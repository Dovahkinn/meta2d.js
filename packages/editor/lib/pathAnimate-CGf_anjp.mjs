var qo = Object.defineProperty;
var Yo = (t, e, i) => e in t ? qo(t, e, { enumerable: !0, configurable: !0, writable: !0, value: i }) : t[e] = i;
var O = (t, e, i) => Yo(t, typeof e != "symbol" ? e + "" : e, i);
import { inject as Ca, ref as Ve, useAttrs as $o, reactive as Gi, defineComponent as Ra, computed as Xo, resolveComponent as dt, withDirectives as _s, createBlock as Ji, openBlock as ei, normalizeStyle as Ko, withCtx as $e, createVNode as Ye, createElementBlock as Pa, Fragment as Ea, renderList as Go, createTextVNode as _a, toDisplayString as Jo, vShow as Ls, onMounted as Qo, onUnmounted as Zo, createElementVNode as er, normalizeClass as tr, mergeProps as ir, unref as Je, createCommentVNode as sr } from "vue";
import { p as ar, N as Ms } from "./index-B0jrlxAg.mjs";
/*!
  * vue-router v4.5.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
var Ns;
(function(t) {
  t.pop = "pop", t.push = "push";
})(Ns || (Ns = {}));
var Os;
(function(t) {
  t.back = "back", t.forward = "forward", t.unknown = "";
})(Os || (Os = {}));
Symbol(process.env.NODE_ENV !== "production" ? "navigation failure" : "");
var Ds;
(function(t) {
  t[t.aborted = 4] = "aborted", t[t.cancelled = 8] = "cancelled", t[t.duplicated = 16] = "duplicated";
})(Ds || (Ds = {}));
Symbol(process.env.NODE_ENV !== "production" ? "router view location matched" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view depth" : "");
const or = Symbol(process.env.NODE_ENV !== "production" ? "router" : ""), rr = Symbol(process.env.NODE_ENV !== "production" ? "route location" : "");
Symbol(process.env.NODE_ENV !== "production" ? "router view location" : "");
function pf() {
  return Ca(or);
}
function bf(t) {
  return Ca(rr);
}
function Tt(t, e) {
  const i = e || new Path2D();
  let s = t.calculative.borderRadius || 0, a = s;
  const { x: o, y: r, width: l, height: n, ex: h, ey: c } = t.calculative.worldRect;
  s < 1 && (s = l * s, a = n * a);
  let d = s < a ? s : a;
  if (l < 2 * d && (d = l / 2), n < 2 * d && (d = n / 2), i.moveTo(o + d, r), i.arcTo(h, r, h, c, d), i.arcTo(h, c, o, c, d), i.arcTo(o, c, o, r, d), i.arcTo(o, r, h, r, d), i.closePath(), i instanceof Path2D)
    return i;
}
const nr = Tt;
function lr(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.ellipse(
    s + o / 2,
    a + r / 2,
    o / 2,
    r / 2,
    0,
    0,
    Math.PI * 2
  ), i instanceof Path2D)
    return i;
}
var fe = /* @__PURE__ */ ((t) => (t[t.Node = 0] = "Node", t[t.Line = 1] = "Line", t))(fe || {}), he = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.DisableEdit = 1] = "DisableEdit", t[t.DisableMove = 2] = "DisableMove", t[t.DisableScale = 3] = "DisableScale", t[t.DisableMoveScale = 4] = "DisableMoveScale", t[t.Disable = 10] = "Disable", t))(he || {}), oi = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.Linear = 1] = "Linear", t[t.Radial = 2] = "Radial", t))(oi || {}), de = /* @__PURE__ */ ((t) => (t[t.CanvasTemplate = 1] = "CanvasTemplate", t[t.CanvasImageBottom = 2] = "CanvasImageBottom", t[t.CanvasMain = 3] = "CanvasMain", t[t.CanvasImage = 4] = "CanvasImage", t))(de || {});
const cr = [
  "text",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "fontFamily",
  "fontSize",
  "lineHeight",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "whiteSpace",
  "ellipsis",
  "keepDecimal"
], hr = ["x", "y", "width", "height", "flipX", "flipY"], dr = [
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "flipX",
  "flipY",
  "visible",
  "showChild"
], ur = ["iconLeft", "iconTop", "iconRotate"];
var He = /* @__PURE__ */ ((t) => (t[t.Normal = 0] = "Normal", t[t.Beads = 1] = "Beads", t[t.Dot = 2] = "Dot", t[t.Arrow = 3] = "Arrow", t[t.WaterDrop = 4] = "WaterDrop", t))(He || {});
const fr = [
  "gif",
  "iframe",
  "video",
  "echarts",
  "highcharts",
  "lightningCharts"
], Oi = [
  "radio",
  "checkbox",
  "button",
  "inputDom",
  "slider",
  "echarts"
], qt = /* @__PURE__ */ new Set([
  "borderRadius",
  // 'rotate',
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  "paddingBottom",
  "progress",
  "progressColor",
  "verticalProgress",
  "reverseProgress",
  // 'flip',
  "flipX",
  "flipY",
  "input",
  "lineDash",
  "lineCap",
  "lineJoin",
  "strokeType",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "color",
  "hoverColor",
  "activeColor",
  "lineWidth",
  "bkType",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "hoverBackground",
  "activeBackground",
  "globalAlpha",
  "anchorColor",
  "anchorRadius",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "textHasShadow",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "ellipsis",
  "hiddenText",
  "keepDecimal",
  "borderWidth",
  "borderColor",
  "animateLineWidth",
  "lineAnimateType",
  "frames",
  "animateColor",
  "animateType",
  "animateReverse",
  "background",
  "gradientColors",
  "lineGradientColors",
  "animateLineWidth",
  "gradientSmooth",
  "lineSmooth",
  "animations"
]);
function gr(t) {
  t.onAdd = void 0, t.onValue = void 0, t.onBeforeValue = void 0, t.onDestroy = void 0, t.onMove = void 0, t.onResize = void 0, t.onRotate = void 0, t.onClick = void 0, t.onMouseEnter = void 0, t.onMouseLeave = void 0, t.onMouseDown = void 0, t.onMouseMove = void 0, t.onMouseUp = void 0, t.onShowInput = void 0, t.onInput = void 0, t.onChangeId = void 0, t.onBinds = void 0, t.onStartVideo = void 0, t.onPauseVideo = void 0, t.onStopVideo = void 0, t.onRenderPenRaw = void 0, t.onKeyDown = void 0, t.onContextmenu = void 0, t.onScale = void 0, t.onWheel = void 0, t.onConnectLine = void 0;
}
var se = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.LineAnchor = 1] = "LineAnchor", t[t.NodeAnchor = 2] = "NodeAnchor", t[t.Line = 3] = "Line", t[t.Node = 4] = "Node", t[t.Resize = 5] = "Resize", t[t.Rotate = 6] = "Rotate", t[t.LineAnchorPrev = 7] = "LineAnchorPrev", t[t.LineAnchorNext = 8] = "LineAnchorNext", t))(se || {}), ge = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.Translate = 1] = "Translate", t[t.Select = 2] = "Select", t[t.Resize = 3] = "Resize", t[t.AddAnchor = 4] = "AddAnchor", t))(ge || {}), ot = /* @__PURE__ */ ((t) => (t[t.None = 0] = "None", t[t.Down = 1] = "Down", t[t.Translate = 2] = "Translate", t))(ot || {}), ce = /* @__PURE__ */ ((t) => (t[t.None = -1] = "None", t[t.Up = 0] = "Up", t[t.Right = 1] = "Right", t[t.Bottom = 2] = "Bottom", t[t.Left = 3] = "Left", t))(ce || {});
const Bs = [
  "nw-resize",
  "ne-resize",
  "se-resize",
  "sw-resize"
], zs = [
  "n-resize",
  "e-resize",
  "s-resize",
  "w-resize"
], vr = ["curve", "polyline", "line"], La = [
  "dash",
  "lineWidth",
  "lineCap",
  "lineJoin",
  "strokeType",
  "color",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "globalAlpha",
  "bkType",
  "background",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textLeft",
  "textTop",
  "flipX",
  "flipY",
  "lineDash",
  "visible",
  "iconColor"
];
var Ft = /* @__PURE__ */ ((t) => (t[t.Mirror = 0] = "Mirror", t[t.Bilateral = 1] = "Bilateral", t[t.Free = 2] = "Free", t))(Ft || {}), Re = /* @__PURE__ */ ((t) => (t[t.Default = 0] = "Default", t[t.In = 1] = "In", t[t.Out = 2] = "Out", t[t.DisableConnected = 3] = "DisableConnected", t[t.DisableConnectTo = 4] = "DisableConnectTo", t[t.Disable = 10] = "Disable", t))(Re || {}), pt = /* @__PURE__ */ ((t) => (t[t.Default = 0] = "Default", t[t.Line = 1] = "Line", t))(pt || {});
function ve(t, e, i) {
  if (!e || e % 360 === 0)
    return;
  const s = e * Math.PI / 180, a = (t.x - i.x) * Math.cos(s) - (t.y - i.y) * Math.sin(s) + i.x, o = (t.x - i.x) * Math.sin(s) + (t.y - i.y) * Math.cos(s) + i.y;
  t.x = a, t.y = o, t.prev && ve(t.prev, e, i), t.next && ve(t.next, e, i);
}
function Nt(t, e, i = 5, s) {
  if (e.type === 1) {
    let a = s.rotate;
    s.flipX && (a *= -1), s.flipY && (a *= -1);
    let o = e.rotate + a;
    return s.flipX && (o *= -1), s.flipY && (o *= -1), nt(t, {
      x: e.x - e.length * s.calculative.canvas.store.data.scale / 2,
      y: e.y - i,
      width: e.length * s.calculative.canvas.store.data.scale,
      height: i * 2,
      rotate: o
    });
  } else
    return t.x > e.x - i && t.x < e.x + i && t.y > e.y - i && t.y < e.y + i;
}
function Si(t, e, i) {
  t.x = i.x - (i.x - t.x) * e, t.y = i.y - (i.y - t.y) * e;
}
function ze(t, e) {
  if (t.x === e.x)
    return t.y <= e.y ? 0 : 180;
  if (t.y === e.y)
    return t.x < e.x ? 270 : 90;
  const i = t.x - e.x, s = t.y - e.y;
  let a = Math.atan(Math.abs(i / s)) / (2 * Math.PI) * 360;
  return i > 0 && s > 0 ? a = 180 - a : i < 0 && s > 0 ? a += 180 : i < 0 && s < 0 && (a = 360 - a), a;
}
function Li(t, e) {
  const i = t.x - e.x, s = t.y - e.y;
  return Math.sqrt(i * i + s * s);
}
function yr(t, e) {
  let i = ce.None;
  if (!e)
    return i;
  const s = t.x - e.x, a = t.y - e.y;
  return Math.abs(s) > Math.abs(a) ? s > 0 ? i = ce.Right : i = ce.Left : a > 0 ? i = ce.Bottom : i = ce.Up, i;
}
function ti(t, e, i) {
  t && (t.x += e, t.y += i, t.next && (t.next.x += e, t.next.y += i), t.prev && (t.prev.x += e, t.prev.y += i));
}
function Hs(t, e) {
  return t.anchorId === e.anchorId && t.connectTo === e.connectTo;
}
function di(t, e, i) {
  let s = Math.sqrt(
    (t.x - e.x) * (t.x - e.x) + (t.y - e.y) * (t.y - e.y)
  ) / i.data.scale;
  e.rotate === 0 ? t.x < e.x ? i.pens[e.penId].flipX || (s *= -1) : i.pens[e.penId].flipX && (s *= -1) : t.y < e.y ? i.pens[e.penId].flipY || (s *= -1) : i.pens[e.penId].flipY && (s *= -1), t.distance = s;
}
const mr = "1.0.42", Ma = {
  version: mr
}, re = {
  version: Ma.version,
  path2dDraws: {},
  canvasDraws: {},
  anchors: {},
  htmlElements: {}
};
function xt(t) {
  Object.assign(re.path2dDraws, t);
}
function Ot(t) {
  Object.assign(re.canvasDraws, t);
}
function Qi(t) {
  Object.assign(re.anchors, t);
}
function pr(t) {
  return { all: t = t || /* @__PURE__ */ new Map(), on: function(e, i) {
    var s = t.get(e);
    s && s.push(i) || t.set(e, [i]);
  }, off: function(e, i) {
    var s = t.get(e);
    s && s.splice(s.indexOf(i) >>> 0, 1);
  }, emit: function(e, i) {
    (t.get(e) || []).slice().map(function(s) {
      s(i);
    }), (t.get("*") || []).slice().map(function(s) {
      s(e, i);
    });
  } };
}
var Xt = /* @__PURE__ */ ((t) => (t[t.None = -1] = "None", t[t.Document = 0] = "Document", t[t.Canvas = 1] = "Canvas", t))(Xt || {});
const br = {
  fontFamily: '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial',
  fontSize: 12,
  lineHeight: 1.5,
  textAlign: "center",
  textBaseline: "middle",
  color: "#222222",
  activeColor: "#278df8",
  hoverColor: "rgba(39,141,248,0.50)",
  anchorColor: "#278DF8",
  hoverAnchorColor: "#FF4101",
  anchorRadius: 4,
  anchorBackground: "#fff",
  dockColor: "rgba(39,141,248,0.50)",
  dockPenColor: "#1890FF",
  dragColor: "#1890ff",
  rotateCursor: "rotate.cur",
  rightCursor: "right.cur",
  downCursor: "down.cur",
  hoverCursor: "pointer",
  minScale: 0.1,
  maxScale: 10,
  keydown: 0,
  gridSize: 20,
  gridColor: "#e2e2e2",
  ruleColor: "#888888",
  drawingLineName: "curve",
  interval: 30,
  animateInterval: 30,
  autoPolyline: !0,
  autoAnchor: !0,
  autoAlignGrid: !1,
  animateColor: "#30EEDC",
  ruleLineColor: "#FF4101",
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowBlur: 64,
  shadowColor: "#00000014",
  globalAlpha: 1,
  defaultAnchors: [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ],
  measureTextWidth: !0,
  moveConnectedLine: !0,
  mouseRightActive: !0,
  disableClipboard: !1,
  drawingLineLength: 0,
  disableTouchPadScale: !1,
  cdn: "",
  polylineSpace: 10,
  domShapes: [],
  containerShapes: ["tablePlus"],
  textFlip: !0,
  textRotate: !0,
  unavailableKeys: [],
  diagramOptions: {},
  svgPathStroke: !0
}, wr = {
  dark: {
    color: "#bdc7db",
    background: "#1e2430",
    parentBackground: "#080b0f",
    ruleColor: "#222E47",
    ruleOptions: {
      background: "#121924",
      textColor: "#6E7B91"
    }
  },
  light: {
    color: "#222222",
    background: "#FFFFFF",
    parentBackground: "#F0F1F2",
    ruleColor: "#C8D0E1",
    ruleOptions: {
      background: "#F7F8FA",
      textColor: "#C8D0E1"
    }
  }
};
var ie = /* @__PURE__ */ ((t) => (t[t.Add = 0] = "Add", t[t.Update = 1] = "Update", t[t.Delete = 2] = "Delete", t[t.Replace = 3] = "Replace", t))(ie || {});
const xr = () => ({
  data: {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: { x: 0, y: 0 },
    center: { x: 0, y: 0 },
    paths: {},
    theme: "light"
  },
  histories: [],
  pens: {},
  path2dMap: /* @__PURE__ */ new WeakMap(),
  animateMap: /* @__PURE__ */ new WeakMap(),
  active: [],
  animates: /* @__PURE__ */ new Set(),
  options: { ...br },
  theme: { ...wr },
  emitter: pr(),
  bindDatas: {},
  bind: {},
  pensNetwork: {},
  cacheDatas: [],
  messageEvents: {},
  templatePens: {},
  globalTriggers: {}
}), kr = (t = "default") => (re[t] || (re[t] = xr(), re[t].id = t), re[t]), Ir = (t, e) => {
  const i = t.data.template === e;
  if (i)
    for (const s of t.data.pens)
      s.canvasLayer === de.CanvasTemplate && (t.templatePens[s.id] = s);
  t.lastScale = t.data.scale, t.data = {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: { x: 0, y: 0 },
    center: { x: 0, y: 0 },
    paths: {},
    template: i ? e : null
  }, t.sameTemplate = i, t.pens = {}, t.histories = [], t.historyIndex = null, t.path2dMap = /* @__PURE__ */ new WeakMap(), t.animateMap = /* @__PURE__ */ new WeakMap(), t.bindDatas = {}, t.bind = {}, t.pensNetwork = {}, t.active = [], t.hover = void 0, t.lastHover = void 0, t.animates.clear();
};
function Xe(t) {
  const {
    paddingTop: e,
    paddingBottom: i,
    paddingLeft: s,
    paddingRight: a,
    worldRect: o,
    canvas: r
  } = t.calculative;
  let { textLeft: l, textTop: n, textWidth: h, textHeight: c } = t.calculative, d = s, f = e;
  const u = o.width - s - a, g = o.height - e - i;
  h && h < 1 && (h *= o.width), c && c < 1 && (c *= o.height), h < t.calculative.fontSize && (h = t.calculative.fontSize), d += (l || 0) + o.x, f += (n || 0) + o.y;
  const y = t.textAlign || r.store.options.textAlign, v = t.textBaseline || r.store.options.textBaseline;
  switch (y) {
    case "center":
      d += (u - (h || u)) / 2;
      break;
    case "right":
      d += u - (h || u);
      break;
  }
  switch (v) {
    case "middle":
      f += (g - (c || g)) / 2;
      break;
    case "bottom":
      f += g - (c || g);
      break;
  }
  const b = {
    x: d,
    y: f,
    width: h || u,
    height: c || g
  };
  we(b), t.calculative.worldTextRect = b, ci(t), t.calculative.textDrawRect = void 0;
}
function Na(t, e) {
  const i = e.calculative.fontSize * e.calculative.lineHeight, s = e.calculative.textLines.length * i, a = Sr(t, e), o = e.calculative.worldTextRect;
  let r = o.x + (o.width - a) / 2, l = o.y + (o.height - s) / 2;
  const n = e.calculative.canvas.store.options;
  switch (e.textAlign || n.textAlign) {
    case "left":
      r = o.x;
      break;
    case "right":
      r = o.x + o.width - a;
      break;
  }
  switch (e.textBaseline || n.textBaseline) {
    case "top":
      l = o.y;
      break;
    case "bottom":
      l = o.ey - s;
      break;
  }
  e.calculative.textDrawRect = {
    x: r,
    y: l,
    width: a,
    height: s
  }, we(e.calculative.textDrawRect);
}
function ci(t, e = t.calculative.text) {
  if (e == null) {
    t.calculative.textLines = [];
    return;
  }
  e = e.toString();
  let i = [];
  const s = t.calculative.fontSize * t.calculative.lineHeight, a = t.calculative.worldTextRect.height, o = Math.floor(a / s), r = o > 1 ? o : 1;
  switch (t.whiteSpace) {
    case "nowrap":
      if (t.ellipsis !== !1) {
        const c = Fs(e.split(""), t);
        c[0] && (i.push(c[0]), c.length > 1 && Di(i));
      } else
        i.push(e);
      break;
    case "pre-line":
      i = e.split(/[\n]/g), t.ellipsis !== !1 && i.length > r && (i = i.slice(0, r), Di(i));
      break;
    case "break-all":
    default:
      const n = e.split(/[\n]/g);
      let h = 0;
      e: for (const c of n) {
        const d = t.whiteSpace === "break-all" ? c.split("") : Oa(c);
        let f = Fs(d, t);
        if (f.length === 0 && (f = [""]), t.ellipsis != !1)
          for (const u of f)
            if (h++, h > r) {
              Di(i);
              break e;
            } else
              i.push(u);
        else
          i.push(...f);
      }
      break;
  }
  const l = t.calculative.keepDecimal;
  return l != null && i.forEach((n, h) => {
    const c = Number(n);
    isNaN(c) || (i[h] = c.toFixed(l));
  }), t.calculative.textLines = i, i;
}
function Oa(t = "") {
  const e = [];
  let i = "";
  for (let s = 0; s < t.length; ++s) {
    const a = t.charCodeAt(s);
    a < 33 || a > 126 ? (i && (e.push(i), i = ""), e.push(t[s])) : i += t[s];
  }
  return i && e.push(i), e;
}
function Fs(t, e) {
  const i = e.calculative.canvas, s = i.offscreen.getContext("2d"), { fontStyle: a, fontWeight: o, fontSize: r, fontFamily: l, lineHeight: n } = e.calculative;
  s.save();
  const h = [];
  let c = t[0] || "";
  for (let d = 1; d < t.length; ++d) {
    const f = t[d] || "", u = c + f;
    let g = 0;
    if (i.store.options.measureTextWidth)
      s.font = De({
        fontStyle: a,
        fontWeight: o,
        fontFamily: l || i.store.options.fontFamily,
        fontSize: r,
        lineHeight: n
      }), g = s.measureText(u).width;
    else {
      const v = u.match(/[^\x00-\xff]/g) || "", b = v.length * r, x = u.match(/\s/g) || "", p = x.length * r * 0.3, k = (u.length - v.length - x.length) * r * 0.6;
      g = b + p + k;
    }
    const y = e.calculative.worldTextRect.width;
    g <= y + 0.1 ? c += f : (c.length && h.push(c), c = f);
  }
  return c.length && h.push(c), s.restore(), h;
}
function Sr(t, e) {
  let i = 0;
  return e.calculative.textLineWidths = [], e.calculative.textLines.forEach((s) => {
    const a = t.measureText(s).width;
    e.calculative.textLineWidths.push(a), i < a && (i = a);
  }), i;
}
function Di(t) {
  t[t.length - 1] = t[t.length - 1].slice(0, -3) + "...";
}
function Ar(t) {
  let e = t.text.split(`
`);
  const i = t.calculative.canvas, s = i.offscreen.getContext("2d"), { fontStyle: a, fontWeight: o, fontSize: r, fontFamily: l, lineHeight: n } = t.calculative;
  let h = 0, c = 0;
  s.save();
  for (let f = 0; f < e.length; f++) {
    if (i.store.options.measureTextWidth)
      s.font = De({
        fontStyle: a,
        fontWeight: o,
        fontFamily: l || i.store.options.fontFamily,
        fontSize: r,
        lineHeight: n
      }), c = s.measureText(e[f]).width;
    else {
      const u = e[f].match(/[^\x00-\xff]/g) || "", g = u.length * r, y = e[f].match(/\s/g) || "", v = y.length * r * 0.3, b = (e[f].length - u.length - y.length) * r * 0.6;
      c = g + v + b;
    }
    c > h && (h = c);
  }
  s.restore();
  let d = e.length * r * n;
  t.textAlign === "left" || (t.textAlign === "right" ? t.x = t.x - (h - t.width) : t.x = t.x - (h - t.width) / 2), t.textBaseline === "top" || (t.textBaseline === "bottom" ? t.y = t.y - (d - t.height) : t.y = t.y - (d - t.height) / 2), t.height = d + 2, t.width = h + 2, t.calculative.canvas.updatePenRect(t), t.calculative.canvas.calcActiveRect();
}
function G(t, e = !1) {
  if (Array.isArray(t)) {
    const i = [];
    return t.forEach((s) => {
      i.push(G(s, e));
    }), i;
  } else if (typeof t == "object") {
    if (t === null)
      return null;
    if (t.constructor === RegExp)
      return t;
    const i = {};
    for (const s in t)
      if (!(["canvas", "lastFrame"].includes(s) || t[s] instanceof HTMLImageElement || t[s] instanceof HTMLMediaElement)) {
        {
          if (s === "calculative" && !e)
            continue;
          if (s === "singleton") {
            e ? i[s] = {} : i[s] = t[s];
            continue;
          }
        }
        i[s] = G(t[s], e);
      }
    return i;
  }
  return t;
}
function Zi(t, e, i) {
  if (Array.isArray(t)) {
    const s = [];
    return t.forEach((a) => {
      s.push(Zi(a, e, i));
    }), s;
  } else if (typeof t == "object") {
    if (t === null)
      return null;
    for (const s in t)
      if (e.includes(s))
        if (Array.isArray(t[s]))
          t[s].forEach((a, o) => {
            Number.isNaN(Number(a)) || (t[s][o] = Number(a * i));
          });
        else {
          if (Number.isNaN(Number(t[s])))
            continue;
          t[s] = Number(t[s]) * i;
        }
      else
        t[s] = Zi(t[s], e, i);
    return t;
  }
  return t;
}
const Oe = {};
function Da(t, e, i) {
  if (!Oe[e.fromArrow])
    return;
  const s = xe(e), { x: a, y: o } = s, r = { x: a, y: o };
  if (r.step = (e.fromArrowSize || 10) * i.data.scale, s.next)
    r.rotate = ze(s.next, s) + 90;
  else {
    const n = e.calculative.worldAnchors[1];
    if (!n)
      return;
    n.prev ? r.rotate = ze(n.prev, s) + 90 : r.rotate = ze(n, s) + 90;
  }
  t.save(), t.beginPath(), t.setLineDash([]);
  const l = e.fromArrowColor || e.calculative.color;
  l && (t.strokeStyle = l), Oe[e.fromArrow](t, e, i, r), t.restore();
}
function Ba(t, e, i) {
  if (!Oe[e.toArrow] || e.calculative.worldAnchors.length < 2)
    return;
  t.save();
  const s = ue(e), { x: a, y: o } = s, r = { x: a, y: o };
  if (r.step = (e.toArrowSize || 10) * i.data.scale, s.prev)
    r.rotate = ze(s.prev, s) + 90;
  else {
    const n = e.calculative.worldAnchors[e.calculative.worldAnchors.length - 2];
    n.next ? r.rotate = ze(n.next, s) + 90 : r.rotate = ze(n, s) + 90;
  }
  t.beginPath(), t.setLineDash([]);
  const l = e.toArrowColor || e.calculative.color;
  l && (t.strokeStyle = l), Oe[e.toArrow](t, e, i, r), t.restore();
}
Oe.triangleSolid = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step;
  t.moveTo(a, s.y - s.step / 4), t.lineTo(s.x, s.y), t.lineTo(a, s.y + s.step / 4), t.closePath(), t.stroke(), t.fillStyle = t.strokeStyle, t.fill(), t.restore();
};
Oe.triangle = (t, e, i, s) => {
  t.save(), t.lineWidth < 2 && (t.lineWidth = 2), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step;
  t.moveTo(a, s.y - s.step / 4), t.lineTo(s.x, s.y), t.lineTo(a, s.y + s.step / 4), t.closePath(), t.stroke(), t.fillStyle = i.data.background || "#ffffff", t.fill(), t.restore();
};
Oe.circleSolid = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.step / 2;
  t.arc(s.x - a, s.y, a, 0, 2 * Math.PI), t.stroke(), t.fillStyle = t.strokeStyle, t.fill(), t.restore();
};
Oe.circle = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.step / 2;
  t.arc(s.x - a, s.y, a, 0, 2 * Math.PI), t.stroke(), t.fillStyle = i.data.background || "#ffffff", t.fill(), t.restore();
};
Oe.diamondSolid = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step, o = s.step / 2;
  t.moveTo(a, s.y), t.lineTo(a + o, s.y - o / 2), t.lineTo(s.x, s.y), t.lineTo(a + o, s.y + o / 2), t.closePath(), t.stroke(), t.fillStyle = t.strokeStyle, t.fill(), t.restore();
};
Oe.diamond = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step, o = s.step / 2;
  t.moveTo(a, s.y), t.lineTo(a + o, s.y - o / 2), t.lineTo(s.x, s.y), t.lineTo(a + o, s.y + o / 2), t.closePath(), t.stroke(), t.fillStyle = i.data.background || "#ffffff", t.fill(), t.restore();
};
Oe.line = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step;
  t.moveTo(a, s.y - s.step / 3), t.lineTo(s.x, s.y), t.lineTo(a, s.y + s.step / 3), t.stroke(), t.restore();
};
Oe.lineUp = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step;
  t.moveTo(a, s.y - s.step / 3), t.lineTo(s.x, s.y), t.stroke(), t.restore();
};
Oe.lineDown = (t, e, i, s) => {
  t.save(), t.translate(s.x, s.y), t.rotate(s.rotate * Math.PI / 180), t.translate(-s.x, -s.y);
  const a = s.x - s.step;
  t.moveTo(a, s.y + s.step / 3), t.lineTo(s.x, s.y), t.stroke(), t.restore();
};
function es(t) {
  const e = parseInt, i = Math.round;
  let s = t.length, a = {};
  if (s > 9) {
    const [o, r, l, n] = t = t.split(",");
    if (s = t.length, s < 3 || s > 4) return null;
    a.r = e(o[3] == "a" ? o.slice(5) : o.slice(4)), a.g = e(r), a.b = e(l), a.a = n ? parseFloat(n) : -1;
  } else {
    if (s == 8 || s == 6 || s < 4) return null;
    s < 6 && (t = "#" + t[1] + t[1] + t[2] + t[2] + t[3] + t[3] + (s > 4 ? t[4] + t[4] : "")), t = e(t.slice(1), 16), s == 9 || s == 5 ? (a.r = t >> 24 & 255, a.g = t >> 16 & 255, a.b = t >> 8 & 255, a.a = i((t & 255) / 0.255) / 1e3) : (a.r = t >> 16, a.g = t >> 8 & 255, a.b = t & 255, a.a = -1);
  }
  return a;
}
function Te(t, e, i, s) {
  let a, o, r, l, n, h, c, d = Math.round, f = typeof i == "string";
  return typeof t != "number" || t < -1 || t > 1 || typeof e != "string" || e[0] != "r" && e[0] != "#" || i && !f || (c = e.length > 9, c = f ? i.length > 9 ? !0 : i == "c" ? !c : !1 : c, n = es(e), l = t < 0, h = i && i != "c" ? es(i) : l ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 }, t = l ? t * -1 : t, l = 1 - t, !n || !h) ? null : (s ? (a = d(l * n.r + t * h.r), o = d(l * n.g + t * h.g), r = d(l * n.b + t * h.b)) : (a = d((l * n.r ** 2 + t * h.r ** 2) ** 0.5), o = d((l * n.g ** 2 + t * h.g ** 2) ** 0.5), r = d((l * n.b ** 2 + t * h.b ** 2) ** 0.5)), f = n.a, h = h.a, n = f >= 0 || h >= 0, f = n ? f < 0 ? h : h < 0 ? f : f * l + h * t : 0, c ? "rgb" + (n ? "a(" : "(") + a + "," + o + "," + r + (n ? "," + d(f * 1e3) / 1e3 : "") + ")" : "#" + (4294967296 + a * 16777216 + o * 65536 + r * 256 + (n ? d(f * 255) : 0)).toString(16).slice(1, n ? void 0 : -2));
}
globalThis.pSBC = Te;
function Ai(t, e) {
  const i = es(t) || { r: 0, g: 0, b: 0 };
  return i.a < 0 ? `rgba(${i.r},${i.g},${i.b},${e})` : `rgba(${i.r},${i.g},${i.b},${e + i.a})`;
}
function _t(t, e) {
  if (isNaN(t)) {
    console.warn("realValue not number");
    return;
  }
  if (typeof e != "string") {
    console.warn("collection must be string");
    return;
  }
  const [i, s] = [e[0], e[e.length - 1]];
  if (!["[", "("].includes(i)) {
    console.warn('collection must start with "[" or "("');
    return;
  }
  if (!["]", ")"].includes(s)) {
    console.warn('collection must end with "]" or ")"');
    return;
  }
  const a = e.substring(1, e.length - 1).split(",");
  if (a.length !== 2) {
    console.warn("collection must have 2 numbers");
    return;
  }
  const [o, r] = [+a[0], +a[1]];
  if (o >= r) {
    console.warn("startNum must less than endNum");
    return;
  }
  return t > o || i === "[" && t === o ? t < r || s === "]" && t === r : !1;
}
function Lt(t, e) {
  if (typeof e != "string") {
    console.warn("collection must be string");
    return;
  }
  const [i, s] = [e[0], e[e.length - 1]];
  if (i !== "[" || s !== "]") {
    console.warn('collection must start with "[" and end with "]"');
    return;
  }
  const a = e.substring(1, e.length - 1).split(",");
  for (const o of a)
    if (o.includes("..")) {
      const [r, l] = o.split(".."), [n, h] = [+r, +l];
      if (n >= h) {
        console.warn("startNum must less than endNum");
        return;
      }
      if (t >= n && t <= h)
        return !0;
    } else if (t == o)
      return !0;
  return !1;
}
function Tr() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function ne() {
  return ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1);
}
function wf() {
  return Tr() + ne();
}
const Qe = (t) => {
  let e = 0, i = 0, s = 0, a = 0;
  return typeof t == "number" ? e = i = s = a = t : typeof t == "string" ? e = i = s = a = parseInt(t, 10) : Array.isArray(t) && (e = t[0], s = Bi(t[1]) ? t[0] : t[1], a = Bi(t[2]) ? t[0] : t[2], i = Bi(t[3]) ? s : t[3]), [e, s, a, i];
};
function Bi(t) {
  return t == null;
}
async function Cr(t) {
  return new Promise((e, i) => {
    const s = new FileReader();
    s.onload = (a) => {
      e(a.target.result);
    }, s.onerror = (a) => {
      i(a);
    }, s.readAsDataURL(t);
  });
}
async function Rr(t, e, i, s) {
  const a = new FormData();
  if (a.append("file", t), i)
    for (const r in i)
      i.hasOwnProperty(r) && a.append(r, i[r]);
  return (await (await fetch(e, {
    method: "POST",
    headers: s,
    body: a
  })).json()).url;
}
function Pr(t, e, i) {
  var s = document.createElement("link");
  s.href = t, s.rel = "stylesheet", e && (s.onload = e), document.head.appendChild(s);
}
function zi(t) {
  let e = t || window.location.search.split("?")[1];
  const i = new URLSearchParams(e);
  return Object.fromEntries(i.entries());
}
function Bt(t, e) {
  if (e == null)
    return t;
  const i = e.split(".");
  for (; i.length && (t = t[i.shift()]); ) ;
  return t;
}
function ts(t, e, i) {
  e != null && e.split(".").reduce(
    (s, a, o) => s[a] = e.split(".").length === ++o ? i : s[a] || {},
    t
  );
}
function Er(t) {
  const e = ["天", "一", "二", "三", "四", "五", "六"], i = /* @__PURE__ */ new Date(), s = i.getFullYear(), a = i.getMonth() + 1, o = i.getDate(), r = i.getDay(), l = i.getHours(), n = i.getMinutes(), h = i.getSeconds();
  return new Function(
    "year",
    "month",
    "day",
    "week",
    "hours",
    "minutes",
    "seconds",
    `return ${t}`
  )(s, a, o, e[r], l, n, h);
}
function _r(t, e) {
  if (!t || !e)
    return !1;
  let i = Ne(t);
  for (; i; ) {
    if (i.id === e.id)
      return !0;
    i = Ne(i);
  }
  return !1;
}
function Ne(t, e) {
  if (!t || !t.parentId || !t.calculative)
    return;
  const s = t.calculative.canvas.store.pens[t.parentId];
  return e && Ne(s, e) || s;
}
function je(t, e) {
  if (!t || !t.children)
    return [];
  const i = [];
  return t.children.forEach((s) => {
    const a = e.pens[s];
    a && (i.push(a), i.push(...je(a, e)));
  }), i;
}
function ps(t, e) {
  if (!t || !t.followers)
    return [];
  const i = [];
  return t.followers.forEach((s) => {
    const a = e.pens[s];
    a && !a.parentId && (i.push(a), i.push(...ps(a, e)));
  }), i;
}
function Lr(t, e) {
  const { worldRect: i, gradientFromColor: s, gradientToColor: a, gradientAngle: o } = e.calculative;
  return Ha(
    t,
    i,
    s,
    a,
    o
  );
}
function Mr(t, e) {
  const { worldRect: i, gradientFromColor: s, gradientToColor: a, gradientRadius: o } = e.calculative;
  if (!s || !a)
    return;
  const { width: r, height: l, center: n } = i, { x: h, y: c } = n;
  let d = r;
  d < l && (d = l), d *= 0.5;
  const f = t.createRadialGradient(
    h,
    c,
    d * (o || 0),
    h,
    c,
    d
  );
  return f.addColorStop(0, s), f.addColorStop(1, a), f;
}
function Nr(t, e, i, s, a) {
  let o = 0;
  o = Math.PI / 2 - Math.atan2(s - e, i - t);
  const r = (t + i) / 2, l = (e + s) / 2, n = r + a * Math.sin(90 * Math.PI / 180 - o), h = l + a * -Math.cos(90 * Math.PI / 180 - o), c = r + a * Math.sin(270 * Math.PI / 180 - o), d = l + a * -Math.cos(270 * Math.PI / 180 - o);
  return [n, h, c, d];
}
function Or(t, e) {
  const { worldRect: i, gradientColors: s, gradientRadius: a } = e.calculative;
  if (!s)
    return;
  let o = e.calculative.gradientColors;
  e.calculative.checked && (o = e.calculative.onGradientColors);
  const { width: r, height: l, center: n } = i, { x: h, y: c } = n;
  let d = r;
  d < l && (d = l), d *= 0.5;
  const { colors: f } = Et(o), u = t.createRadialGradient(
    h,
    c,
    d * (a || 0),
    h,
    c,
    d
  );
  return f.forEach((g) => {
    u.addColorStop(g.i, g.color);
  }), u;
}
function Dr(t, e) {
  const { x: i, y: s, ex: a, width: o, height: r, center: l } = e.calculative.worldRect;
  let n = [
    { x: a, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ], h = e.calculative.gradientColors;
  e.calculative.checked && (h = e.calculative.onGradientColors);
  const { angle: c, colors: d } = Et(h);
  let f = bs(c, o, r);
  return n.forEach((u) => {
    ve(u, c, l);
  }), Mi(t, n, d, f);
}
function Br(t, e) {
  const { worldRect: i, textGradientColors: s } = e.calculative;
  if (!s)
    return;
  const { width: a, height: o, center: r } = i, { x: l, y: n } = r;
  let h = a;
  h < o && (h = o), h *= 0.5;
  const { colors: c } = Et(s), d = t.createRadialGradient(
    l,
    n,
    0,
    l,
    n,
    h
  );
  return c.forEach((f) => {
    d.addColorStop(f.i, f.color);
  }), d;
}
function zr(t, e) {
  const { x: i, y: s, ex: a, width: o, height: r, center: l } = e.calculative.worldRect;
  let n = [
    { x: a, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ];
  const { angle: h, colors: c } = Et(e.calculative.textGradientColors);
  let d = bs(h, o, r);
  return n.forEach((f) => {
    ve(f, h, l);
  }), Mi(t, n, c, d);
}
function bs(t, e, i) {
  const s = Math.atan(i / e) / Math.PI * 180;
  let a = (t - 90) % 360, o = 0;
  return a > s && a < 180 - s || a > 180 + s && a < 360 - s || a < 0 ? (a > 270 ? a = 360 - a : a > 180 ? a = a - 180 : a > 90 && (a = 180 - a), o = Math.abs(i / Math.sin(a / 180 * Math.PI) / 2)) : (a > 270 ? a = 360 - a : a > 180 ? a = a - 180 : a > 90 && (a = 180 - a), o = Math.abs(e / Math.cos(a / 180 * Math.PI) / 2)), o;
}
function Et(t) {
  if (typeof t == "string" && t.startsWith("linear-gradient")) {
    let e = t.slice(16, -2).split("deg,");
    if (e.length > 1) {
      let i = e[1].split("%,");
      const s = [];
      return i.forEach((a) => {
        if (/rgba?/.test(a)) {
          let o = a.split(") ");
          s.push({
            color: Hr(o[0] + ")"),
            i: parseFloat(o[1]) / 100
          });
        } else {
          let o = a.split(" ");
          o.length > 2 ? s.push({
            color: o[1],
            i: parseFloat(o[2]) / 100
          }) : s.push({
            color: o[0],
            i: parseFloat(o[1]) / 100
          });
        }
      }), {
        angle: parseFloat(e[0]),
        colors: s
      };
    } else
      return {
        angle: parseFloat(e[0]),
        colors: []
      };
  } else
    return {
      angle: 0,
      colors: []
    };
}
function Hr(t) {
  if (/rgba?/.test(t)) {
    let e = t.split(",");
    if (e.length < 3) return "";
    t = "#";
    for (let i = 0, s; s = e[i++]; )
      if (i < 4)
        s = parseInt(s.replace(/[^\d]/gi, ""), 10).toString(16), t += s.length == 1 ? "0" + s : s;
      else {
        s = s.replace(")", "");
        let o = parseInt(s * 255 + "").toString(16);
        o = o.length === 2 ? o : "0" + o, t += o;
      }
    t = t.toUpperCase();
  }
  return t;
}
function Fr(t, e) {
  const { x: i, y: s, ex: a, width: o, height: r, center: l } = e.calculative.worldRect;
  let n = [
    { x: a, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ];
  const { angle: h, colors: c } = Et(e.calculative.lineGradientColors);
  let d = bs(h, o, r);
  return n.forEach((f) => {
    ve(f, h, l);
  }), Mi(t, n, c, d);
}
function Mi(t, e, i, s) {
  let a = Nr(
    e[0].x,
    e[0].y,
    e[1].x,
    e[1].y,
    s
  ), o = t.createLinearGradient(a[0], a[1], a[2], a[3]);
  return i.forEach((r) => {
    o.addColorStop(r.i, r.color);
  }), o;
}
function rt(t, e, i) {
  let s = [];
  e.calculative.gradientColorStop ? s = e.calculative.gradientColorStop : (s = Et(e.calculative.lineGradientColors).colors, e.calculative.gradientColorStop = s), t.strokeStyle = Mi(
    t,
    i,
    s,
    e.calculative.lineWidth / 2
  ), t.beginPath(), t.moveTo(i[0].x, i[0].y), t.lineTo(i[1].x, i[1].y), t.stroke();
}
function za(t, e) {
  const i = e.calculative.worldAnchors;
  let s = e.calculative.lineWidth * (e.calculative.gradientSmooth || e.calculative.lineSmooth || 0);
  for (let a = 0; a < i.length - 1; a++)
    if ((e.lineName === "curve" || e.lineName === "mind") && i[a].curvePoints) {
      if (a > 0) {
        let l = i[a - 1].curvePoints;
        l ? ui(
          t,
          e,
          s,
          l[l.length - 1],
          i[a],
          i[a].curvePoints[0]
        ) : ui(
          t,
          e,
          s,
          i[a - 1],
          i[a],
          i[a].curvePoints[0]
        );
        let n = et(
          s,
          i[a],
          i[a].curvePoints[0]
        );
        rt(t, e, [n, i[a].curvePoints[1]]);
      } else
        rt(t, e, [
          i[a],
          i[a].curvePoints[0]
        ]), rt(t, e, [
          i[a].curvePoints[0],
          i[a].curvePoints[1]
        ]);
      let o = i[a].curvePoints.length - 1;
      for (let l = 1; l < o; l++)
        rt(t, e, [
          i[a].curvePoints[l],
          i[a].curvePoints[l + 1]
        ]);
      let r = et(
        s,
        i[a + 1],
        i[a].curvePoints[o]
      );
      rt(t, e, [i[a].curvePoints[o], r]);
    } else {
      let o = i[a], r = i[a + 1];
      if (a > 0 && a < i.length - 1) {
        let n = i[a - 1].curvePoints;
        n ? ui(
          t,
          e,
          s,
          n[n.length - 1],
          i[a],
          i[a + 1]
        ) : ui(
          t,
          e,
          s,
          i[a - 1],
          i[a],
          i[a + 1]
        );
      }
      a > 0 && a < i.length - 1 && (o = et(s, i[a], i[a + 1])), a < i.length - 2 && (r = et(s, i[a + 1], i[a]));
      let l = !1;
      if (a === 0 && e.fromLineCap && e.fromLineCap !== "butt" && (t.save(), l = !0, t.lineCap = e.fromLineCap), a !== 0 && a === i.length - 2 && e.toLineCap && e.toLineCap !== "butt" && (t.save(), l = !0, t.lineCap = e.toLineCap), rt(t, e, [o, r]), l && t.restore(), i.length === 2 && a === 0) {
        t.save(), l = !0, t.lineCap = e.toLineCap;
        let n = 0.1, h = 0.1;
        o.x - r.x === 0 ? h = 0 : n = (o.y - r.y) / (o.x - r.x) * 0.1, rt(t, e, [
          { x: r.x - h, y: r.y - n },
          r
        ]), t.restore();
      }
    }
}
function et(t, e, i) {
  let s = Math.sqrt(
    (i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y)
  );
  return s === 0 ? {
    x: e.x,
    y: e.y
  } : t < s ? {
    x: e.x + (i.x - e.x) * t / s,
    y: e.y + (i.y - e.y) * t / s
  } : {
    x: e.x + (i.x - e.x) / s / 2,
    y: e.y + (i.y - e.y) / s / 2
  };
}
function ui(t, e, i, s, a, o) {
  let r = et(i, a, s), l = et(i, a, o), n = { x: a.x, y: a.y }, h = Wr(
    e.calculative.canvas.store.data.smoothNum || 20,
    r,
    n,
    l
  );
  for (let c = 0; c < h.length - 1; c++)
    rt(t, e, [
      {
        x: h[c].x,
        y: h[c].y
      },
      {
        x: h[c + 1].x,
        y: h[c + 1].y
      }
    ]);
}
function Ws(t, e, i, s) {
  let a = et(e, i, s), o = { x: i.x, y: i.y };
  t.quadraticCurveTo(o.x, o.y, a.x, a.y);
}
function ws(t) {
  const e = t.calculative.worldAnchors;
  let i = t.calculative.lineWidth * (t.calculative.gradientSmooth || t.calculative.lineSmooth || 0);
  const s = new Path2D();
  for (let a = 0; a < e.length - 1; a++) {
    e[a];
    let o = e[a + 1];
    if (a == 0 && s.moveTo(e[a].x, e[a].y), a > 0 && a < e.length - 1) {
      let r = e[a - 1].curvePoints;
      Ws(s, i, e[a], e[a + 1]);
    }
    a > 0 && a < e.length - 1 && et(i, e[a], e[a + 1]), a < e.length - 2 && (o = et(i, e[a + 1], e[a])), s.lineTo(o.x, o.y);
  }
  return s;
}
function Wr(t = 100, e, i, s, a) {
  let o = null;
  const r = [];
  s ? s && (o = jr) : o = Vr;
  for (let l = 0; l < t; l++)
    r.push(o(l / t, e, i, s, a));
  return s && r.push(s), r;
}
function Vr(t, e, i) {
  const { x: s, y: a } = e, { x: o, y: r } = i;
  let l = s + (o - s) * t, n = a + (r - a) * t;
  return { x: l, y: n };
}
function jr(t, e, i, s) {
  const { x: a, y: o } = e, { x: r, y: l } = i, { x: n, y: h } = s;
  let c = (1 - t) * (1 - t) * a + 2 * t * (1 - t) * r + t * t * n, d = (1 - t) * (1 - t) * o + 2 * t * (1 - t) * l + t * t * h;
  return { x: c, y: d };
}
function Ur(t, e) {
  const {
    worldRect: i,
    lineGradientFromColor: s,
    lineGradientToColor: a,
    lineGradientAngle: o
  } = e.calculative;
  return Ha(
    t,
    i,
    s,
    a,
    o
  );
}
function Ha(t, e, i, s, a) {
  if (!i || !s)
    return;
  const { x: o, y: r, center: l, ex: n, ey: h } = e, c = {
    x: o,
    y: l.y
  }, d = {
    x: n,
    y: l.y
  };
  a % 90 === 0 && a % 180 ? (c.x = l.x, d.x = l.x, a % 270 ? (c.y = r, d.y = h) : (c.y = h, d.y = r)) : a && (ve(c, a, e.center), ve(d, a, e.center));
  const f = t.createLinearGradient(c.x, c.y, d.x, d.y);
  return f.addColorStop(0, i), f.addColorStop(1, s), f;
}
function qr(t) {
  const {
    worldIconRect: e,
    iconWidth: i,
    iconHeight: s,
    imgNaturalWidth: a,
    imgNaturalHeight: o
  } = t.calculative;
  let { x: r, y: l, width: n, height: h } = e;
  if (i && (n = i), s && (h = s), a && o && t.imageRatio) {
    const c = e.width / a, d = e.height / o, f = Math.min(c, d), u = a / o;
    i ? h = i / u : s ? n = s * u : (n = f * a, h = f * o);
  }
  switch (r += (e.width - n) / 2, l += (e.height - h) / 2, t.iconAlign) {
    case "top":
      l = e.y;
      break;
    case "bottom":
      l = e.ey - h;
      break;
    case "left":
      r = e.x;
      break;
    case "right":
      r = e.ex - n;
      break;
    case "left-top":
      r = e.x, l = e.y;
      break;
    case "right-top":
      r = e.ex - n, l = e.y;
      break;
    case "left-bottom":
      r = e.x, l = e.ey - h;
      break;
    case "right-bottom":
      r = e.ex - n, l = e.ey - h;
      break;
  }
  return {
    x: r,
    y: l,
    width: n,
    height: h
  };
}
function Wt(t, e) {
  const { x: i, y: s, width: a, height: o } = qr(e), { worldIconRect: r, iconRotate: l, img: n } = e.calculative;
  if (l) {
    const { x: h, y: c } = r.center;
    t.translate(h, c), t.rotate(l * Math.PI / 180), t.translate(-h, -c);
  }
  if (e.imageRadius) {
    t.save();
    let h = e.calculative.imageRadius || 0, c = h;
    const {
      x: d,
      y: f,
      width: u,
      height: g,
      ex: y,
      ey: v
    } = e.calculative.worldRect;
    h < 1 && (h = u * h, c = g * c);
    let b = h < c ? h : c;
    u < 2 * b && (b = u / 2), g < 2 * b && (b = g / 2), t.beginPath(), t.moveTo(d + b, f), t.arcTo(y, f, y, v, b), t.arcTo(y, v, d, v, b), t.arcTo(d, v, d, f, b), t.arcTo(d, f, y, f, b), t.clip(), t.drawImage(n, i, s, a, o), t.restore();
  } else
    t.drawImage(n, i, s, a, o);
}
function ft(t, e) {
  const { textColor: i, color: s } = t.calculative, { data: a, options: o } = e;
  return i || s || a.textColor || a.color || o.textColor || o.color;
}
function Fa(t, e) {
  const {
    fontStyle: i,
    fontWeight: s,
    fontSize: a,
    fontFamily: o,
    lineHeight: r,
    text: l,
    hiddenText: n,
    canvas: h,
    textHasShadow: c,
    textBackground: d,
    textType: f
  } = e.calculative;
  if (l == null || n)
    return;
  const u = h.store;
  t.save(), c || (t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0);
  let g;
  e.calculative.disabled ? g = e.disabledTextColor || e.disabledColor || Te(0.4, ft(e, u)) : e.calculative.hover ? g = e.hoverTextColor || e.hoverColor || u.options.hoverColor : e.calculative.active && (g = e.activeTextColor || e.activeColor || u.options.activeColor);
  let y;
  f === oi.Linear ? y = zr(t, e) : f === oi.Radial && (y = Br(t, e)), t.fillStyle = g || y || ft(e, u), t.font = De({
    fontStyle: i,
    fontWeight: s,
    fontFamily: o || u.options.fontFamily,
    fontSize: a,
    lineHeight: r
  }), !e.calculative.textDrawRect && Na(t, e);
  const {
    x: v,
    y: b,
    width: x,
    height: p
  } = e.calculative.textDrawRect;
  d && (t.save(), t.fillStyle = d, t.fillRect(v, b, x, p), t.restore());
  const k = 0.55, R = e.textAlign || u.options.textAlign, A = a * r;
  e.calculative.textLines.forEach((P, E) => {
    const D = e.calculative.textLineWidths[E];
    let q = 0;
    R === "center" ? q = (x - D) / 2 : R === "right" && (q = x - D), t.fillText(P, v + q, b + (E + k) * A);
    const { textDecorationColor: I, textDecorationDash: S, textDecoration: T } = e;
    T && Yr(
      t,
      {
        x: v + q,
        y: b + (E + k) * A,
        width: D
      },
      { textDecorationColor: I, textDecorationDash: S, fontSize: a }
    );
    const { textStrickoutColor: _, textStrickoutDash: z, textStrickout: V } = e;
    V && $r(
      t,
      {
        x: v + q,
        y: b + (E + k) * A,
        width: D
      },
      { textStrickoutColor: _, textStrickoutDash: z, fontSize: a }
    );
  }), t.restore();
}
function Yr(t, e, i) {
  const { textDecorationColor: s, textDecorationDash: a, fontSize: o } = i;
  let { x: r, y: l, width: n } = e;
  switch (t.textBaseline) {
    case "top":
      l += o;
      break;
    case "middle":
      l += o / 2;
      break;
  }
  t.save(), t.beginPath(), t.strokeStyle = s || t.fillStyle, t.lineWidth = 1, t.moveTo(r, l), t.setLineDash(a || []), t.lineTo(r + n, l), t.stroke(), t.restore();
}
function $r(t, e, i) {
  const { textStrickoutColor: s, textStrickoutDash: a, fontSize: o } = i;
  let { x: r, y: l, width: n } = e;
  switch (t.textBaseline) {
    case "top":
      l += o / 2;
      break;
    case "bottom":
      l -= o / 2;
      break;
  }
  t.save(), t.beginPath(), t.strokeStyle = s || t.fillStyle, t.lineWidth = 1, t.moveTo(r, l), t.setLineDash(a || []), t.lineTo(r + n, l), t.stroke(), t.restore();
}
function Wa(t, e, i) {
  if (i == null)
    return;
  const { fontStyle: s, fontWeight: a, fontSize: o, fontFamily: r, lineHeight: l, canvas: n } = e.calculative, h = n.store;
  t.save();
  let c;
  e.calculative.hover ? c = e.hoverTextColor || e.hoverColor || h.options.hoverColor : e.calculative.active && (c = e.activeTextColor || e.activeColor || h.options.activeColor), t.fillStyle = c || ft(e, h), t.font = De({
    fontStyle: s,
    fontWeight: a,
    fontFamily: r || h.options.fontFamily,
    fontSize: o,
    lineHeight: l
  });
  const d = t.measureText(i).width;
  let f, u;
  for (const g of e.calculative.worldAnchors) {
    if (!u) {
      u = g;
      continue;
    }
    const y = Li(u, g), v = Math.floor(y / d);
    f = "";
    for (let x = 0; x < v; x++)
      f += i;
    const b = ze(u, g) - 270;
    if (t.save(), b % 360 !== 0) {
      const { x, y: p } = u;
      t.translate(x, p);
      let k = b * Math.PI / 180;
      t.rotate(k), t.translate(-x, -p);
    }
    t.fillText(f, u.x, u.y + l / 2), t.restore(), u = g;
  }
  t.restore();
}
function Va(t, e) {
  const i = e.calculative.canvas.store;
  t.save(), t.shadowColor = "", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.textAlign = "center", t.textBaseline = "middle";
  const s = e.calculative.worldIconRect;
  let a = s.x + s.width / 2, o = s.y + s.height / 2;
  switch (e.iconAlign) {
    case "top":
      o = s.y, t.textBaseline = "top";
      break;
    case "bottom":
      o = s.ey, t.textBaseline = "bottom";
      break;
    case "left":
      a = s.x, t.textAlign = "left";
      break;
    case "right":
      a = s.ex, t.textAlign = "right";
      break;
    case "left-top":
      a = s.x, o = s.y, t.textAlign = "left", t.textBaseline = "top";
      break;
    case "right-top":
      a = s.ex, o = s.y, t.textAlign = "right", t.textBaseline = "top";
      break;
    case "left-bottom":
      a = s.x, o = s.ey, t.textAlign = "left", t.textBaseline = "bottom";
      break;
    case "right-bottom":
      a = s.ex, o = s.ey, t.textAlign = "right", t.textBaseline = "bottom";
      break;
  }
  const r = e.calculative.iconWeight;
  let l;
  const n = e.calculative.iconFamily;
  e.calculative.iconSize > 0 ? l = e.calculative.iconSize : s.width > s.height ? l = s.height : l = s.width, t.font = De({
    fontSize: l,
    fontWeight: r,
    fontFamily: n
  }), t.fillStyle = e.calculative.iconColor || ft(e, i), e.calculative.iconRotate && (t.translate(s.center.x, s.center.y), t.rotate(e.calculative.iconRotate * Math.PI / 180), t.translate(-s.center.x, -s.center.y)), t.beginPath(), t.fillText(e.calculative.icon, a, o), t.restore();
}
function ja(t, e) {
  const i = e.calculative.canvas.store.data.scale, s = e.calculative.canvas.inputDiv.dataset.penId, { x: a, y: o, width: r, height: l } = e.calculative.worldRect;
  t.save(), t.beginPath(), e.id === s ? (t.moveTo(a + r - 20 * i, o + l / 2 + 2 * i), t.lineTo(a + r - 14 * i, o + l / 2 - 4 * i), t.lineTo(a + r - 8 * i, o + l / 2 + 2 * i)) : (t.moveTo(a + r - 20 * i, o + l / 2 - 4 * i), t.lineTo(a + r - 14 * i, o + l / 2 + 2 * i), t.lineTo(a + r - 8 * i, o + l / 2 - 4 * i)), t.stroke(), t.restore();
}
function De({
  fontStyle: t = "normal",
  textDecoration: e = "normal",
  fontWeight: i = "normal",
  fontSize: s = 12,
  fontFamily: a = "Arial",
  lineHeight: o = 1
  // TODO: lineHeight 默认值待测试
} = {}) {
  return `${t} ${e} ${i} ${s}px/${o} ${a}`;
}
function Ct(t, e) {
  const { x: i, ex: s, y: a, ey: o } = e.calculative.worldRect || {};
  e.calculative.flipX && (t.translate(i + s + 0.5, 0.5), t.scale(-1, 1)), e.calculative.flipY && (t.translate(0.5, a + o + 0.5), t.scale(1, -1));
}
function it(t, e, i = !1) {
  const { x: s, y: a } = e.calculative.worldRect.pivot || e.calculative.worldRect.center;
  t.translate(s, a);
  let o = e.calculative.rotate * Math.PI / 180;
  i || (e.calculative.flipX && (o *= -1), e.calculative.flipY && (o *= -1)), t.rotate(o), t.translate(-s, -a);
}
function bt(t, e, i) {
  t.save(), t.translate(0.5, 0.5), t.beginPath();
  const s = e.calculative.canvas.store, a = e.textFlip || s.options.textFlip, o = e.textRotate || s.options.textRotate;
  (!a || !o) && t.save(), Ct(t, e), e.calculative.rotate && e.name !== "line" && it(t, e), (e.calculative.lineWidth > 1 || i) && (t.lineWidth = e.calculative.lineWidth), an(t, s, e);
  let r, l = !1, n;
  e.calculative.disabled ? (n = e.disabledColor || s.options.disabledColor || Te(0.4, e.calculative.color || ii(s)), r = e.disabledBackground || s.options.disabledBackground || Te(0.4, e.calculative.background || s.data.penBackground)) : e.mouseDownValid && e.calculative.mouseDown ? (n = e.mouseDownColor || Te(-0.4, e.calculative.color || ii(s)), r = e.mouseDownBackground || Te(-0.4, e.calculative.background || s.data.penBackground)) : e.switch && e.calculative.checked ? e.calculative.bkType || (r = e.onBackground) : e.calculative.hover ? (n = e.hoverColor || s.options.hoverColor, r = e.hoverBackground || s.options.hoverBackground) : e.calculative.active ? (n = e.activeColor || s.options.activeColor, r = e.activeBackground || s.options.activeBackground) : e.calculative.isDock && (e.type === fe.Line ? n = s.options.dockPenColor : r = Ai(s.options.dockPenColor, 0.2));
  const h = e.calculative.strokeImg;
  if (e.calculative.strokeImage && h)
    t.strokeStyle = n || t.createPattern(h, "repeat");
  else {
    let d;
    e.calculative.strokeType ? e.calculative.lineGradientColors ? e.name === "line" ? l = !0 : e.calculative.lineGradient ? d = e.calculative.lineGradient : (d = Fr(t, e), e.calculative.lineGradient = d) : d = Ur(t, e) : d = e.calculative.color || (e.type ? s.data.lineColor : "") || ii(s), t.strokeStyle = n || d;
  }
  const c = e.calculative.backgroundImg;
  if (e.calculative.backgroundImage && c)
    t.fillStyle = r || t.createPattern(c, "repeat"), r = !0;
  else {
    let d;
    e.calculative.bkType === oi.Linear ? e.calculative.gradientColors ? e.calculative.gradient ? d = e.calculative.gradient : (d = Dr(t, e), e.calculative.gradient = d) : d = Lr(t, e) : e.calculative.bkType === oi.Radial ? e.calculative.gradientColors ? e.calculative.radialGradient ? d = e.calculative.radialGradient : (d = Or(t, e), e.calculative.radialGradient = d) : d = Mr(t, e) : d = e.calculative.background || s.data.penBackground, t.fillStyle = r || d, r = !!d;
  }
  if (Ua(t, e), qa(t, e), Rt(t, e), e.calculative.lineDash && t.setLineDash(
    e.calculative.lineDash.map(
      (d) => d * e.calculative.canvas.store.data.scale
    )
  ), e.calculative.lineDashOffset && (t.lineDashOffset = e.calculative.lineDashOffset), e.calculative.shadowColor && (t.shadowColor = e.calculative.shadowColor, t.shadowOffsetX = e.calculative.shadowOffsetX, t.shadowOffsetY = e.calculative.shadowOffsetY, t.shadowBlur = e.calculative.shadowBlur), l ? (za(t, e), $a(!0, t, e, s)) : (Ya(!0, t, e, s, r), eo(t, e)), !(e.image && e.calculative.img) && e.calculative.icon && Va(t, e), e.dropdownList && ja(t, e), (!a || !o) && t.restore(), a && !o && Ct(t, e), !a && o && e.calculative.rotate && e.name !== "line" && it(t, e, !0), Fa(t, e), e.type === fe.Line && e.fillTexts)
    for (const d of e.fillTexts)
      Wa(t, e, d);
  t.restore();
}
function Ua(t, e) {
  const i = e.lineCap || (e.type ? "round" : "square");
  i ? t.lineCap = i : e.type && (t.lineCap = "round");
}
function qa(t, e) {
  const i = e.lineJoin;
  i ? t.lineJoin = i : e.type && (t.lineJoin = "round");
}
function Ti(t, e, i, s) {
  var h;
  t.save(), i && t.translate(-i.x, -i.y), (h = t.setAttrs) == null || h.call(t, e);
  let a = !1;
  const o = e.calculative.canvas.store, r = e.textFlip || o.options.textFlip, l = e.textRotate || o.options.textRotate;
  t.beginPath(), (!r || !l) && t.save(), e.calculative.flipX && (t.translate(
    e.calculative.worldRect.x + e.calculative.worldRect.ex,
    0
  ), t.scale(-1, 1)), e.calculative.flipY && (t.translate(
    0,
    e.calculative.worldRect.y + e.calculative.worldRect.ey
  ), t.scale(1, -1)), e.calculative.rotate && e.name !== "line" && it(t, e), (e.calculative.lineWidth > 1 || s) && (t.lineWidth = e.calculative.lineWidth);
  let n;
  if (e.calculative.hover)
    t.strokeStyle = e.hoverColor || o.options.hoverColor, t.fillStyle = e.hoverBackground || o.options.hoverBackground, n = e.hoverBackground || o.options.hoverBackground;
  else if (e.calculative.active)
    t.strokeStyle = e.activeColor || o.options.activeColor, t.fillStyle = e.activeBackground || o.options.activeBackground, n = e.activeBackground || o.options.activeBackground;
  else {
    if (e.strokeImage)
      e.calculative.strokeImg && (t.strokeStyle = t.createPattern(
        e.calculative.strokeImg,
        "repeat"
      ), n = !0);
    else {
      let c;
      e.calculative.strokeType && e.calculative.lineGradientColors && e.name === "line" ? a = !0 : c = e.calculative.color || ii(o), t.strokeStyle = c;
    }
    e.backgroundImage ? e.calculative.backgroundImg && (t.fillStyle = t.createPattern(
      e.calculative.backgroundImg,
      "repeat"
    ), n = !0) : (t.fillStyle = e.background, n = !!e.background);
  }
  if (Ua(t, e), qa(t, e), Rt(t, e), e.calculative.lineDash && t.setLineDash(e.calculative.lineDash), e.calculative.lineDashOffset && (t.lineDashOffset = e.calculative.lineDashOffset), e.calculative.shadowColor && (t.shadowColor = e.calculative.shadowColor, t.shadowOffsetX = e.calculative.shadowOffsetX, t.shadowOffsetY = e.calculative.shadowOffsetY, t.shadowBlur = e.calculative.shadowBlur), a ? (za(t, e), $a(!0, t, e, o)) : (Ya(!1, t, e, o, n), eo(t, e)), e.calculative.img ? (t.save(), t.shadowColor = "", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0, Wt(t, e), t.restore()) : e.calculative.icon && Va(t, e), e.dropdownList && ja(t, e), (!r || !l) && t.restore(), r && !l && (e.calculative.flipX && (t.translate(
    e.calculative.worldRect.x + e.calculative.worldRect.ex,
    0
  ), t.scale(-1, 1)), e.calculative.flipY && (t.translate(
    0,
    e.calculative.worldRect.y + e.calculative.worldRect.ey
  ), t.scale(1, -1))), !r && l && e.calculative.rotate && e.name !== "line" && it(t, e, !0), Fa(t, e), e.type === fe.Line && e.fillTexts)
    for (const c of e.fillTexts)
      Wa(t, e, c);
  t.restore();
}
function Ya(t = !0, e, i, s, a) {
  if (i.name === "drawCommand") return;
  const o = t ? s.path2dMap.get(i) : re.path2dDraws[i.name];
  let r = null, l = null;
  if (i.type === fe.Line && (i.fromLineCap && i.fromLineCap !== "butt" && (e.lineCap = "butt", r = new Path2D(), r.moveTo(
    i.calculative.worldAnchors[0].x,
    i.calculative.worldAnchors[0].y
  ), r.lineTo(
    i.calculative.worldAnchors[0].x,
    i.calculative.worldAnchors[0].y
  )), i.toLineCap && i.toLineCap !== "butt" && (e.lineCap = "butt", l = new Path2D(), l.moveTo(
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].x,
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].y
  ), l.lineTo(
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].x,
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].y
  ))), o) {
    if (i.type === fe.Line && i.borderWidth) {
      e.save(), e.beginPath();
      const h = i.calculative.lineWidth + i.calculative.borderWidth;
      e.lineWidth = h, e.strokeStyle = i.borderColor, r && (e.save(), e.lineCap = i.fromLineCap, e.stroke(r), e.restore()), o instanceof Path2D ? (a && e.fill(o), h && e.stroke(o)) : (o(i, e), a && e.fill(), h && e.stroke()), l && (e.save(), e.lineCap = i.toLineCap, e.stroke(l), e.restore()), e.restore();
    }
    o instanceof Path2D ? i.type ? i.close && a && e.fill(o) : a && e.fill(o) : (e.save(), o(i, e), a && e.fill(), e.restore());
    const n = i.calculative.progress;
    if (n != null) {
      e.save();
      const { ex: h, x: c, y: d, width: f, height: u, ey: g } = i.calculative.worldRect;
      let y = null;
      if (i.calculative.verticalProgress ? y = i.reverseProgress ? e.createLinearGradient(c, d, c, d + u * n) : e.createLinearGradient(c, g, c, d + u * (1 - n)) : y = i.reverseProgress ? e.createLinearGradient(h, d, c + f * (1 - n), d) : e.createLinearGradient(c, d, c + f * n, d), i.calculative.progressGradientColors) {
        const { colors: v } = Et(
          i.calculative.progressGradientColors
        );
        v.forEach((b) => {
          y.addColorStop(b.i, b.color);
        });
      } else {
        const v = i.calculative.progressColor || i.calculative.color || s.options.activeColor;
        y.addColorStop(0, v), y.addColorStop(1, v);
      }
      y.addColorStop(1, "transparent"), e.fillStyle = y, o instanceof Path2D ? e.fill(o) : (o(i, e), e.fill()), e.restore();
    }
    if (i.calculative.lineWidth && (o instanceof Path2D ? (s.options.svgPathStroke || i.name !== "svgPath") && (r && (e.save(), e.lineCap = i.fromLineCap, e.stroke(r), e.restore()), e.stroke(o), l && (e.save(), e.lineCap = i.toLineCap, e.stroke(l), e.restore())) : (o(i, e), e.stroke())), i.type) {
      if (i.calculative.animatePos) {
        if (e.save(), Xa(e, i, s), i.lineAnimateType === He.Arrow || i.lineAnimateType === He.WaterDrop) {
          let h = lo(i, e);
          h instanceof Path2D ? (e.stroke(h), e.fill(h)) : (e.stroke(), e.fill());
        } else
          o instanceof Path2D ? (r && !i.lineAnimateType && (e.save(), e.lineCap = i.fromLineCap, e.stroke(r), e.restore()), e.lineCap = i.lineCap, e.stroke(o)) : (o(i, e), e.stroke());
        e.restore();
      }
      i.fromArrow && Da(e, i, s), i.toArrow && Ba(e, i, s), i.calculative.active && !i.calculative.pencil && !s.options.disableAnchor && !s.data.locked && Ka(e, i);
    }
  }
}
function $a(t = !0, e, i, s) {
  const a = t ? s.path2dMap.get(i) : re.path2dDraws[i.name];
  if (a && i.type) {
    if (i.calculative.animatePos) {
      if (e.save(), Xa(e, i, s), e.beginPath(), a instanceof Path2D)
        if (i.lineName === "polyline" || i.lineName === "line")
          if (i.lineAnimateType === He.Arrow || i.lineAnimateType === He.WaterDrop) {
            const o = lo(i);
            e.stroke(o), e.fill(o);
          } else
            i.calculative.gradientSmooth || i.calculative.lineSmooth ? (i.calculative.gradientAnimatePath || (i.calculative.gradientAnimatePath = ws(i)), i.calculative.gradientAnimatePath instanceof Path2D && e.stroke(i.calculative.gradientAnimatePath)) : e.stroke(a);
        else
          e.stroke(a);
      else
        a(i, e), e.stroke();
      e.restore();
    }
    i.fromArrow && Da(e, i, s), i.toArrow && Ba(e, i, s), i.calculative.active && !i.calculative.pencil && !s.options.disableAnchor && !s.data.locked && Ka(e, i);
  }
}
function Xa(t, e, i) {
  t.strokeStyle = e.animateColor || i.options.animateColor, e.animateShadow && (t.shadowBlur = e.animateShadowBlur || e.animateLineWidth || 6, t.shadowColor = e.animateShadowColor || e.animateColor || i.options.animateColor), e.calculative.animateLineWidth && (t.lineWidth = e.calculative.animateLineWidth * i.data.scale);
  let s = 0;
  switch (e.lineAnimateType) {
    case He.Beads:
      e.animateReverse ? t.lineDashOffset = e.calculative.animatePos : t.lineDashOffset = e.length - e.calculative.animatePos, s = e.calculative.lineWidth || 5, s < 5 && (s = 5);
      const a = e.animateLineDash && e.animateLineDash.map((o) => o * s / 5);
      t.setLineDash(a || [s, s * 2]);
      break;
    case He.Dot:
      e.animateReverse ? t.lineDashOffset = e.calculative.animatePos : t.lineDashOffset = e.length - e.calculative.animatePos, s = e.calculative.animateDotSize || e.calculative.lineWidth * 2 || 6, s < 6 && (s = 6), s > 40 && (s = 40), t.lineWidth = (e.calculative.animateLineWidth || s) * i.data.scale, t.setLineDash([0.1, e.length]);
      break;
    case He.Arrow:
      t.fillStyle = e.animateColor || i.options.animateColor, t.lineWidth = 1;
      break;
    case He.WaterDrop:
      t.fillStyle = e.animateColor || i.options.animateColor, t.lineWidth = 1;
      break;
    default:
      e.animateReverse ? (t.lineDashOffset = Number.EPSILON, t.setLineDash([
        0,
        e.length - e.calculative.animatePos + 1,
        e.calculative.animatePos
      ])) : t.setLineDash([
        e.calculative.animatePos,
        e.length + 0.01 - e.calculative.animatePos
        //避免在缩放时，精度问题绘制多余圆点
      ]);
      break;
  }
}
function ii(t) {
  const { data: e, options: i } = t;
  return e.color || i.color;
}
function Ka(t, e) {
  const i = e.calculative.canvas.store;
  t.save(), t.lineWidth = 1, t.fillStyle = e.activeColor || i.options.activeColor, e.calculative.worldAnchors.forEach((s) => {
    !s.hidden && !s.isTemp && Xr(t, s, e);
  }), t.restore();
}
function Xr(t, e, i) {
  if (!e)
    return;
  const s = i.calculative.canvas.store.activeAnchor === i.calculative.activeAnchor && i.calculative.activeAnchor === e;
  let a = 3;
  i.calculative.lineWidth > 3 && (a = i.calculative.lineWidth), i.anchorRadius && (a = i.anchorRadius), e.radius && (a = e.radius), s ? (e.prev && (t.save(), t.strokeStyle = "#4dffff", t.beginPath(), t.moveTo(e.prev.x, e.prev.y), t.lineTo(e.x, e.y), t.stroke(), t.restore(), t.save(), t.fillStyle = "#ffffff", t.beginPath(), t.arc(e.prev.x, e.prev.y, a, 0, Math.PI * 2), t.fill(), t.stroke(), t.restore()), e.next && (t.save(), t.strokeStyle = "#4dffff", t.beginPath(), t.moveTo(e.x, e.y), t.lineTo(e.next.x, e.next.y), t.stroke(), t.restore(), t.save(), t.fillStyle = "#ffffff", t.beginPath(), t.arc(e.next.x, e.next.y, a, 0, Math.PI * 2), t.fill(), t.stroke(), t.restore(), t.beginPath(), t.arc(e.x, e.y, a, 0, Math.PI * 2), t.fill(), t.stroke()), t.beginPath(), t.arc(e.x, e.y, a, 0, Math.PI * 2), t.fill(), t.stroke()) : (t.save(), t.fillStyle = "#ffffff", t.beginPath(), t.arc(e.x, e.y, a, 0, Math.PI * 2), t.fill(), t.stroke(), t.restore());
}
function Ga(t) {
  const e = t.calculative.canvas.store;
  let i = {
    x: t.x,
    y: t.y
  };
  if (!t.parentId || t.parentId && !e.pens[t.parentId])
    t.parentId = void 0, i.width = t.width, i.height = t.height, i.rotate = t.rotate, we(i), pe(i), t.pivot && ss(i, t.pivot);
  else {
    const s = e.pens[t.parentId];
    let a = s.calculative.worldRect;
    a || (a = Ga(s)), i.x = a.x + a.width * t.x, i.y = a.y + a.height * t.y, i.width = a.width * t.width, i.height = a.height * t.height, s.flipX && (i.x = a.width - (i.x - a.x + i.width) + a.x), s.flipY && (i.y = a.height - (i.y - a.y + i.height) + a.y), we(i), i.rotate = a.rotate + t.rotate, pe(i), t.pivot && ss(i, t.pivot);
  }
  return t.calculative.worldRect = i, xs(t, i), i;
}
function xs(t, e) {
  !t.paddingTop && (t.calculative.paddingTop = 0), !t.paddingBottom && (t.calculative.paddingBottom = 0), !t.paddingLeft && (t.calculative.paddingLeft = 0), !t.paddingRight && (t.calculative.paddingRight = 0), Math.abs(t.calculative.paddingTop) < 1 && (t.calculative.paddingTop *= e.height), Math.abs(t.calculative.paddingBottom) < 1 && (t.calculative.paddingBottom *= e.height), Math.abs(t.calculative.paddingLeft) < 1 && (t.calculative.paddingLeft *= e.width), Math.abs(t.calculative.paddingRight) < 1 && (t.calculative.paddingRight *= e.width);
}
function xi(t) {
  const e = G(t.calculative.worldRect);
  if (delete e.pivot, !t.parentId) {
    Object.assign(t, e);
    return;
  }
  const s = t.calculative.canvas.store.pens[t.parentId].calculative.worldRect;
  Object.assign(t, lt(e, s));
}
function Vt(t) {
  const e = t.calculative.canvas.store;
  let i = [];
  if (t.anchors) {
    let s = G(t.anchors);
    t.flipX && s.forEach((a) => {
      a.x = 0.5 - (a.x - 0.5);
    }), t.flipY && s.forEach((a) => {
      a.y = 0.5 - (a.y - 0.5);
    }), s.forEach((a) => {
      i.push(Kr(t, a));
    });
  }
  if (!i.length && !t.type && !t.calculative.canvas.parent.isCombine(t)) {
    const { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
    i = e.options.defaultAnchors.map((l, n) => ({
      id: `${n}`,
      penId: t.id,
      x: s + o * l.x,
      y: a + r * l.y
    }));
  }
  t.calculative.rotate && i.forEach((s) => {
    ve(
      s,
      t.calculative.rotate,
      t.calculative.worldRect.pivot || t.calculative.worldRect.center
    );
  }), (!t.type || t.anchors) && (t.calculative.worldAnchors = i), t.calculative.activeAnchor && i.length && (t.calculative.activeAnchor = i.find((s) => {
    s.id, t.calculative.activeAnchor.id;
  })), t.calculative.gradientAnimatePath = void 0;
}
function Ja(t) {
  var e;
  if ((e = t.children) != null && e.length) {
    let i = t.calculative.worldRect;
    t.children.forEach((s) => {
      const a = t.calculative.canvas.store.pens[s];
      a.calculative.initRect && a.calculative.initRelativeRect && (a.calculative.initRect.x = i.x + i.width * a.calculative.initRelativeRect.x, a.calculative.initRect.y = i.y + i.height * a.calculative.initRelativeRect.y, a.calculative.initRect.ex = a.calculative.initRect.x + i.width * a.calculative.initRelativeRect.width, a.calculative.initRect.ey = a.calculative.initRect.y + i.height + a.calculative.initRelativeRect.height, pe(a.calculative.initRect)), Ja(a);
    });
  }
}
function Kr(t, e) {
  const i = { ...e }, { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  return i.x = s + o * e.x, i.y = a + r * e.y, e.prev && (i.prev = {
    penId: t.id,
    connectTo: e.prev.connectTo,
    x: s + o * e.prev.x,
    y: a + r * e.prev.y
  }), e.next && (i.next = {
    penId: t.id,
    connectTo: e.next.connectTo,
    x: s + o * e.next.x,
    y: a + r * e.next.y
  }), i;
}
function Vs(t, e) {
  const { paddingTop: i, paddingBottom: s, paddingLeft: a, paddingRight: o } = e.calculative;
  let r = a, l = i, n = e.calculative.worldRect.width - a - o, h = e.calculative.worldRect.height - i - s, c = e.calculative.iconLeft, d = e.calculative.iconTop;
  c && Math.abs(c) < 1 && (c = e.calculative.worldRect.width * c), d && Math.abs(d) < 1 && (d = e.calculative.worldRect.height * d), r += c || 0, l += d || 0, n -= c || 0, h -= d || 0;
  let f = e.calculative.iconRotate || 0;
  if (e.parentId) {
    const u = t[e.parentId].calculative;
    u && (f += u.rotate, f %= 360);
  }
  r = e.calculative.worldRect.x + r, l = e.calculative.worldRect.y + l, e.calculative.worldIconRect = {
    x: r,
    y: l,
    width: n,
    height: h,
    rotate: f
  }, we(e.calculative.worldIconRect), pe(e.calculative.worldIconRect);
}
function Mt(t, e, i) {
  ri(t.calculative.worldRect, e, i, t.pivot), t.calculative.initRect && ri(t.calculative.initRect, e, i, t.pivot), Qa(t, e, i), t.calculative.x && Si(t.calculative, e, i), t.type && Vt(t);
}
function Qa(t, e, i) {
  var s;
  t && (s = t.children) != null && s.length && t.children.forEach((a) => {
    const o = t.calculative.canvas.store.pens[a];
    o && (o.calculative.initRect && ri(o.calculative.initRect, e, i), Qa(o, e, i));
  });
}
function Gr(t, e) {
  t.anchors || (t.anchors = []), t.calculative.worldAnchors || (t.calculative.worldAnchors = []);
  const i = {
    id: e.id,
    penId: t.id,
    x: e.x,
    y: e.y
  };
  if (t.calculative.worldAnchors.push(i), t.calculative.worldRect) {
    t.rotate % 360 && ve(e, -t.rotate, t.calculative.worldRect.center);
    const s = {
      id: e.id,
      penId: t.id,
      x: (e.x - t.calculative.worldRect.x) / t.calculative.worldRect.width,
      y: (e.y - t.calculative.worldRect.y) / t.calculative.worldRect.height
    };
    t.anchors.push(s);
  }
  return i;
}
function Jr(t, e, i) {
  t.anchors || (t.anchors = []), t.calculative.worldAnchors || (t.calculative.worldAnchors = []);
  const s = $n(t, e, i);
  return t.calculative.worldAnchors.splice(i + 1, 0, s), t.anchors.splice(
    i + 1,
    0,
    si(s, t.calculative.worldRect)
  ), t.calculative.activeAnchor = s, s;
}
function Qr(t, e) {
  if (!t || !t.calculative.worldAnchors)
    return;
  let i = t.calculative.worldAnchors.findIndex((s) => s.id === e.id);
  i > -1 && t.calculative.worldAnchors.splice(i, 1), i = t.anchors.findIndex((s) => s.id === e.id), i > -1 && t.anchors.splice(i, 1);
}
function jt(t, e) {
  if (!e || !e.calculative || !e.calculative.worldRect.center)
    return ce.None;
  if (t.anchorId) {
    let i = e.anchors.filter((s) => s.id === t.anchorId);
    if (i.length && i[0].direction > -1)
      return i[0].direction;
  }
  return yr(t, e.calculative.worldRect.center);
}
function zt(t, e) {
  let i = 1 / 0, s;
  return t.calculative.worldAnchors.forEach((a) => {
    const o = Li(e, a);
    i > o && (i = o, s = a);
  }), s;
}
function js(t, e, i) {
  t.x += e, t.y += i, t.anchors && t.anchors.forEach((s) => {
    ti(s, e, i);
  }), t.calculative.worldAnchors && t.calculative.worldAnchors.forEach((s) => {
    ti(s, e, i);
  });
}
function ks(t) {
  if (t && t.calculative && t.calculative.worldAnchors.length) {
    let e = ue(t);
    if (!t.anchors || !t.anchors.length)
      for (; t.calculative.worldAnchors.length && e !== t.calculative.activeAnchor; )
        t.calculative.worldAnchors.pop(), e = ue(t);
    else e === t.calculative.activeAnchor ? t.calculative.worldAnchors = [t.calculative.worldAnchors[0]] : t.calculative.worldAnchors[0] === t.calculative.activeAnchor && (t.calculative.worldAnchors = [
      t.calculative.worldAnchors[t.calculative.worldAnchors.length - 1]
    ]);
  }
}
function Ae(t, e, i, s) {
  var l, n, h, c, d, f;
  if (!t || !e || !i || !s || e.twoWay === Re.DisableConnected || e.twoWay === Re.Disable || s.twoWay === Re.DisableConnectTo || s.twoWay === Re.Disable)
    return;
  if (e.twoWay === Re.In) {
    if (i.calculative.worldAnchors.length === 1)
      return;
    const u = ue(i);
    if (s.id !== u.id)
      return;
  }
  if (e.twoWay === Re.Out) {
    const u = xe(i);
    if (s.id !== u.id)
      return;
  }
  if (s.connectTo === t.id && s.anchorId === e.id)
    return;
  if (s.connectTo) {
    const u = t.calculative.canvas.store.pens[s.connectTo];
    Ht(u, wt(u, s.anchorId), i, s);
  }
  t.connectedLines || (t.connectedLines = []), t.connectedLines.findIndex(
    (u) => u.lineId === i.id && u.lineAnchor === s.id && u.anchor === e.id
  ) < 0 && t.connectedLines.push({
    lineId: i.id,
    lineAnchor: s.id,
    anchor: e.id
  }), s.connectTo = t.id, s.anchorId = e.id, t.type && Ae(i, s, t, e), t.calculative.canvas.store.emitter.emit("connectLine", {
    line: i,
    lineAnchor: s,
    pen: t,
    anchor: e
  });
  let o = ((l = i.calculative.worldAnchors) == null ? void 0 : l.length) >= 2 ? (n = i.calculative.worldAnchors) == null ? void 0 : n[0].connectTo : void 0, r = ((h = i.calculative.worldAnchors) == null ? void 0 : h.length) >= 2 ? (d = i.calculative.canvas.store.pens[(c = i.calculative.worldAnchors) == null ? void 0 : c[0].connectTo]) == null ? void 0 : d.anchors.find(
    (u) => {
      var g;
      return u.id === ((g = i.calculative.worldAnchors) == null ? void 0 : g[0].anchorId);
    }
  ) : void 0;
  return (f = t.onConnectLine) == null || f.call(t, t, {
    line: i,
    lineAnchor: s,
    pen: t,
    anchor: e,
    fromPen: o,
    fromAnchor: r
  }), !0;
}
function Ht(t, e, i, s) {
  if (!(!t || !e || !i || !s) && !(!t.connectedLines || !t.connectedLines.length))
    return i.lastConnected || (i.lastConnected = {}), i.lastConnected[t.id] || (i.lastConnected[t.id] = G(t.connectedLines)), t.connectedLines.forEach((a, o, r) => {
      (a.lineId === i.id || a.lineId === i.id) && a.lineAnchor === s.id && a.anchor === e.id && r.splice(o, 1);
    }), s.connectTo = void 0, s.anchorId = void 0, t.type && e.connectTo === i.id && e.anchorId === s.id && Ht(i, s, t, e), t.calculative.canvas.store.emitter.emit("disconnectLine", {
      line: i,
      lineAnchor: s,
      pen: t,
      anchor: e
    }), !0;
}
function wt(t, e) {
  var i;
  if (!(!t || !e))
    return (i = t.calculative.worldAnchors) == null ? void 0 : i.find((s) => s.id === e);
}
function xe(t) {
  if (!(!t || !t.calculative.worldAnchors))
    return t.calculative.worldAnchors[0];
}
function ue(t) {
  if (!(!t || !t.calculative.worldAnchors))
    return t.calculative.worldAnchors[t.calculative.worldAnchors.length - 1];
}
function Zr(t, e) {
  var s, a;
  if (t.calculative.start === 0 || !t.frames || !t.frames.length)
    return t.calculative.start = void 0, 0;
  if (!t.calculative.duration) {
    t.calculative.duration = 0;
    for (const o of t.frames) {
      t.calculative.duration += o.duration;
      for (const r in o)
        r !== "duration" && !t[r] && r === "scale" && (t[r] = 1);
    }
  }
  if (t.animateCycle || (t.animateCycle = 1 / 0), t.calculative.start) {
    let o = 0;
    const r = Math.ceil(
      (e - t.calculative.start) / t.calculative.duration
    );
    if (r > t.animateCycle)
      return t.currentAnimation = void 0, t.calculative.start = void 0, qs(t, 1), 0;
    const l = (e - t.calculative.start) % t.calculative.duration;
    let n = 0;
    for (const d of t.frames)
      if (n += d.duration, l > n)
        ++o;
      else
        break;
    if (!t.frames[o])
      return !0;
    t.calculative.frameDuration = t.frames[o].duration, t.calculative.frameStart = t.calculative.start + t.calculative.duration * (r - 1), t.calculative.frameEnd = t.calculative.frameStart + t.calculative.frameDuration;
    const h = o !== t.calculative.frameIndex, c = r > t.calculative.cycleIndex;
    if (h && (t.calculative.frameIndex = o), c && (t.calculative.cycleIndex = r), h || c)
      if (t.calculative.x = t.calculative.initRect.x, t.calculative.y = t.calculative.initRect.y, (a = t.children) != null && a.length && !t.parentId ? t.calculative.canvas.rotatePen(
        t,
        (t.calculative.initRect.rotate || 0) - (t.calculative.rotate || 0),
        t.calculative.initRect
      ) : t.calculative.rotate = t.calculative.initRect.rotate || 0, o > 0) {
        t.prevFrame = {};
        const d = t.frames[o - 1];
        for (const f in d)
          t.prevFrame[f] = d[f];
        Object.assign(t.prevFrame, {
          rotate: d.rotate || 0,
          x: d.x || 0,
          y: d.y || 0,
          scale: d.scale || 1
        });
      } else
        Us(t);
  } else {
    if (t.calculative.start = e, t.calculative.frameIndex = 0, t.calculative.frameStart = t.calculative.start, t.calculative.frameDuration = t.frames[0].duration, t.calculative.frameEnd = t.calculative.frameStart + t.calculative.frameDuration, t.calculative.cycleIndex = 1, t.calculative.x = t.calculative.worldRect.x, t.calculative.y = t.calculative.worldRect.y, t.calculative.initRect = G(t.calculative.worldRect), t.parentId && (t.calculative.initRelativeRect = {
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    }), (s = t.children) != null && s.length) {
      const o = t.calculative.canvas.store;
      t.calculative.childrenVisible = {}, t.children.forEach((r) => {
        t.calculative.childrenVisible[r] = o.pens[r].visible;
      });
    }
    t.calculative.initRect.rotate = t.calculative.rotate || 0, Us(t);
  }
  const i = (e - t.calculative.frameStart) / t.calculative.frameDuration % 1;
  return qs(t, i), !0;
}
function Us(t) {
  t.prevFrame = {};
  for (const e in t)
    (typeof t[e] != "object" || e === "lineDash") && (t.prevFrame[e] = t[e]);
  t.prevFrame.rotate = 0, t.prevFrame.x = 0, t.prevFrame.y = 0, t.prevFrame.scale = 1;
}
function qs(t, e) {
  var s, a;
  if (e < 0)
    return;
  e > 1 && (e = 1);
  const i = t.frames[t.calculative.frameIndex];
  for (const o in i)
    if (o !== "duration") {
      if (o === "scale") {
        t.calculative.worldRect = G(t.calculative.initRect), ri(
          t.calculative.worldRect,
          t.prevFrame.scale,
          t.calculative.worldRect.center
        );
        const r = t.prevFrame.scale + (i[o] - t.prevFrame.scale) * e;
        ri(
          t.calculative.worldRect,
          r / t.prevFrame.scale,
          t.calculative.worldRect.center
        ), t.calculative.patchFlags = !0;
      } else if (o === "x") {
        const r = Fi(t, o, t.calculative.frameIndex);
        t.calculative.worldRect.x = t.calculative.initRect.x + r, t.calculative.worldRect.ex = t.calculative.initRect.ex + r, It(
          t.calculative.worldRect,
          i[o] * e * t.calculative.canvas.store.data.scale,
          0
        ), t.calculative.patchFlags = !0;
      } else if (o === "y") {
        const r = Fi(t, o, t.calculative.frameIndex);
        t.calculative.worldRect.y = t.calculative.initRect.y + r, t.calculative.worldRect.ey = t.calculative.initRect.ey + r, It(
          t.calculative.worldRect,
          0,
          i[o] * e * t.calculative.canvas.store.data.scale
        ), t.calculative.patchFlags = !0;
      } else if (o === "rotate") {
        t.prevFrame[o] >= 360 && (t.prevFrame[o] %= 360);
        const r = Fi(t, o, t.calculative.frameIndex), l = (t.calculative.initRect.rotate + r + i[o] * e) % 360 - (t.calculative.rotate || 0);
        (s = t.children) != null && s.length ? t.calculative.canvas.rotatePen(
          t,
          l,
          t.calculative.initRect
        ) : t.calculative.rotate = (t.calculative.initRect.rotate + r + i[o] * e) % 360, t.calculative.patchFlags = !0;
      } else if (o === "image")
        t.image = i.image, t.calculative.image = void 0, t.calculative.canvas.loadImage(t), t.canvasLayer === de.CanvasImageBottom ? t.calculative.canvas.canvasImageBottom.init() : t.canvasLayer === de.CanvasImage && t.calculative.canvas.canvasImage.init();
      else if (en(i[o], o, t)) {
        t.prevFrame[o] == null && (o === "globalAlpha" ? t.prevFrame[o] = 1 : t.prevFrame[o] = 0);
        const r = t.prevFrame[o] + (i[o] - t.prevFrame[o]) * e;
        t.calculative[o] = Math.round(r * 100) / 100;
      } else {
        if (o === "visible") {
          if (t.calculative.image)
            t.canvasLayer === de.CanvasImageBottom ? t.calculative.canvas.canvasImageBottom.init() : t.canvasLayer === de.CanvasImage && t.calculative.canvas.canvasImage.init();
          else if ((a = t.children) != null && a.length) {
            const l = je(t, t.calculative.canvas.store);
            t.calculative.canvas.initImageCanvas(l);
          }
        }
        t.calculative[o] = i[o];
        const r = {};
        r[o] = i[o], Is(t, r);
      }
      o === "text" && ci(t);
    }
}
function en(t, e, i) {
  const s = ["strokeType", "bkType", "showChild"];
  return typeof t == "number" && i.linear !== !1 && !s.includes(e);
}
function tn(t, e) {
  if (t.calculative.start === 0)
    return t.calculative.start = void 0, 0;
  if (t.animateCycle || (t.animateCycle = 1 / 0), t.animateSpan || (t.animateSpan = 1), t.calculative.animatePos += t.animateSpan * (t.calculative.canvas.store.data.scale || 1), !t.calculative.start)
    t.calculative.start = Date.now(), t.calculative.animatePos = t.animateSpan * (t.calculative.canvas.store.data.scale || 1), t.calculative.cycleIndex = 1;
  else if (t.calculative.animatePos > t.length) {
    if (++t.calculative.cycleIndex, t.calculative.cycleIndex > t.animateCycle)
      return t.currentAnimation = void 0, t.calculative.start = void 0, 0;
    t.calculative.animatePos = t.animateSpan;
  }
  return !0;
}
function Dt(t, e = !0) {
  if (!t.children || t.childActive === !1)
    return;
  const i = t.calculative.canvas.store;
  t.children.forEach((s) => {
    const a = i.pens[s];
    a && (a.calculative.active = e, Dt(a, e));
  });
}
function Kt(t, e = !0) {
  if (!t)
    return;
  const i = t.calculative.canvas.store;
  t.calculative.hover = e, t.childHover !== !1 && t.children && t.children.forEach((s) => {
    var a, o;
    ((a = i.pens[s]) == null ? void 0 : a.hoverColor) == null && ((o = i.pens[s]) == null ? void 0 : o.hoverBackground) == null && Kt(i.pens[s], e);
  });
}
function Ce(t, e) {
  if (!e)
    return;
  const i = t.calculative.canvas.store, s = t.calculative.worldRect;
  e.style.opacity = t.globalAlpha + "", e.style.position = "absolute", e.style.outline = "none", e.style.left = s.x + i.data.x + "px", e.style.top = s.y + i.data.y + "px", e.style.width = s.width + "px", e.style.height = s.height + "px", e.style.display = t.calculative.inView != !1 ? t.calculative.cssDisplay || "inline" : "none", !t.calculative.rotate && (t.calculative.rotate = 0), e.style.transform = `rotate(${t.calculative.rotate}deg)`, t.calculative.rotate || (t.calculative.flipX && (e.style.transform = "rotateY(180deg)"), t.calculative.flipY && (e.style.transform = "rotateX(180deg)"), t.calculative.flipX && t.calculative.flipY && (e.style.transform = "rotateZ(180deg)")), e.style.zIndex = t.calculative.zIndex !== void 0 ? t.calculative.zIndex + "" : "5", t.calculative.zIndex > t.calculative.canvas.maxZindex && (t.calculative.canvas.maxZindex = t.calculative.zIndex), t.locked === he.DisableEdit || t.locked === he.DisableMove || i.data.locked ? (e.style.userSelect = "initial", e.style.pointerEvents = "initial", t.name === "gif" && (e.style.userSelect = "none", e.style.pointerEvents = "none")) : (e.style.userSelect = "none", e.style.pointerEvents = "none");
}
function Hi(t) {
  return t.every((e) => e.locked);
}
function Ys(t) {
  return t.every((e) => e.disableRotate);
}
function Za(t, e, i) {
  var s;
  t.type ? (t.calculative.worldAnchors.forEach((a) => {
    ve(a, e, i.center);
  }), sn(t), xi(t)) : (t.calculative.rotate ? t.calculative.rotate += e : t.calculative.rotate = e, ve(t.calculative.worldRect.center, e, i.center), t.parentId && (t.calculative.worldRect.x = t.calculative.worldRect.center.x - t.calculative.worldRect.width / 2, t.calculative.worldRect.y = t.calculative.worldRect.center.y - t.calculative.worldRect.height / 2, t.x = (t.calculative.worldRect.x - i.x) / i.width, t.y = (t.calculative.worldRect.y - i.y) / i.height)), (s = t.children) == null || s.forEach((a) => {
    const o = t.calculative.canvas.store.pens[a];
    Za(o, e, i);
  });
}
function sn(t) {
  var a;
  if (!((a = t.calculative.worldAnchors) != null && a.length) || !isFinite(t.x) || !isFinite(t.x) || t.x == null || t.y == null)
    return;
  const e = ns(t);
  t.parentId || Object.assign(t, e);
  const { fontSize: i, lineHeight: s } = t.calculative.canvas.store.options;
  t.fontSize ? t.fontSize < 0 && (t.fontSize = 0, t.calculative.fontSize = 0) : (t.fontSize = i >= 0 ? i : 12, t.calculative.fontSize = t.fontSize * t.calculative.canvas.store.data.scale), t.lineHeight || (t.lineHeight = s, t.calculative.lineHeight = t.lineHeight), pe(e), t.calculative.worldRect = e, xs(t, e), Xe(t), t.calculative.worldAnchors && (t.anchors = t.calculative.worldAnchors.map((o) => si(o, t.calculative.worldRect)));
}
function $s(t) {
  return t.every((e) => e.disableSize || e.pivot);
}
function Fi(t, e, i) {
  if (!t.frames || !e)
    return 0;
  let s = 0;
  for (let a = 0; a < i; a++)
    t.frames[a] && (s += t.frames[a][e] || 0);
  return s;
}
function Ci(t, e) {
  var s;
  let i = t;
  for (; i && i.parentId; ) {
    const a = i;
    i = e.pens[i.parentId];
    const o = (s = i == null ? void 0 : i.calculative) == null ? void 0 : s.showChild;
    if (o != null && i.children[o] !== a.id)
      return !1;
  }
  return !0;
}
function Ze(t, e = !1) {
  var a, o;
  const { store: i, canvasRect: s } = t.calculative.canvas;
  if (e && ((a = t.children) == null || a.forEach((r) => {
    const l = i.pens[r];
    l && Ze(l, !0);
  })), t.calculative.inView = !0, !Ci(t, i) || t.visible == !1 || t.calculative.visible == !1)
    t.calculative.inView = !1;
  else {
    const { x: r, y: l, width: n, height: h, rotate: c } = t.calculative.worldRect, d = {
      x: r + i.data.x,
      y: l + i.data.y,
      width: n,
      height: h,
      rotate: c
    };
    we(d), tt(d, s) || (t.calculative.inView = !1);
  }
  (o = t.calculative.singleton) != null && o.div && Ce(t, t.calculative.singleton.div);
}
function an(t, e, i) {
  if (e.fillWorldTextRect) {
    t.save(), t.fillStyle = "#c3deb7";
    const { x: s, y: a, width: o, height: r } = i.calculative.worldTextRect;
    t.fillRect(s, a, o, r), t.restore();
  }
}
function Rt(t, e) {
  const i = e.calculative.globalAlpha;
  typeof i == "number" && i < 1 && !isNaN(i) && (t.globalAlpha = i);
}
function eo(t, e) {
  const i = on(t, e) || re.canvasDraws[e.name];
  i && (t.save(), i(t, e), t.restore());
}
function on(t, e) {
  const i = e.drawCommand;
  if (!(!i || e.name === "line"))
    return (s, a) => {
      i.forEach((o) => {
        try {
          o.steps = o.steps.flat(1 / 0), o.steps.reduce((r, l) => {
            const n = rn(l, a, r.x, r.y);
            try {
              if (n.c) {
                if (n.c.startsWith("_")) {
                  const c = n.c.split("_")[1];
                  return typeof n.v.value == "number" && (n.v.value *= a.calculative.canvas.store.data.scale), (n.p || s)[c] = n.v.value, { x: r.x, y: r.y };
                }
                let h = [];
                for (const c in n.v)
                  h.push(n.v[c]);
                return (n.p || s)[n.c](...h), { x: n.startX || n.v.x, y: n.startY || n.v.y };
              }
              return { x: r.x, y: r.y };
            } catch {
            }
          }, {});
        } catch {
        }
      }), s.stroke();
    };
}
function rn(t, e, i, s) {
  return {
    visio: ln,
    dxf: nn
  }[e.parseType](t, e, i, s);
}
function nn(t, e, i, s) {
  const { x: a, y: o, width: r, height: l } = e.calculative.worldRect, { originWidth: n, originHeight: h } = e.dxfOrigin;
  switch (t.c) {
    case "beginPath":
      return {
        c: "beginPath",
        v: {}
      };
    case "closePath":
      return {
        c: "closePath",
        v: {}
      };
    case "moveTo":
      return {
        c: "moveTo",
        v: {
          x: t.v.x * (r / n) + a,
          y: t.v.y * (l / h) + o
        }
      };
    case "lineTo":
      return {
        c: "lineTo",
        v: {
          x: t.v.x * (r / n) + a,
          y: t.v.y * (l / h) + o
        }
      };
    case "arc":
      return {
        c: "ellipse",
        v: {
          x: t.v.x * (r / n) + a,
          y: t.v.y * (l / h) + o,
          rx: t.v.xr * (r / n),
          ry: t.v.yr * (l / h),
          rotation: t.v.rotation || 0,
          startAngle: t.v.startAngle,
          endAngle: t.v.endAngle,
          a: t.v.aclockwise ?? !0
        }
      };
    case "ellipse":
      return {
        c: "ellipse",
        v: {
          x: t.v.x * (r / n) + a,
          y: t.v.y * (l / h) + o,
          rx: t.v.xr * (r / n),
          ry: t.v.yr * (l / h),
          rotation: t.v.rotation || 0,
          startAngle: t.v.startAngle,
          endAngle: t.v.endAngle,
          a: t.v.aclockwise ?? !0
        }
      };
    case "_font":
      return {
        c: "_font",
        v: {
          value: t.v.fontSize * e.calculative.canvas.store.data.scale + "px " + (t.v.fontFamily || e.calculative.canvas.store.options.fontFamily)
        }
      };
    case "_fillStyle":
      return {
        c: "_fillStyle",
        v: {
          value: e.color || t.v.value
        }
      };
    default:
      const c = {
        c: t.c,
        v: {
          ...t.v
        }
      };
      return c.v.x !== void 0 && (c.v.x = t.v.x * (r / n) + a), c.v.y !== void 0 && (c.v.y = t.v.y * (l / h) + o), c;
  }
}
function ln(t, e, i, s) {
  const { x: a, y: o, width: r, height: l } = e.calculative.worldRect, { width: n, height: h } = e.origin;
  switch (t.c) {
    case "MoveTo":
      return {
        c: "moveTo",
        v: {
          x: +t.v.X * 100 * (r / n) + a,
          y: +t.v.Y * 100 * (l / h) + o
        }
      };
    case "RelMoveTo":
      return {
        c: "moveTo",
        v: {
          x: +t.v.X * n * (r / n) + a,
          y: +t.v.Y * h * (l / h) + o
        }
      };
    case "LineTo":
      return {
        c: "lineTo",
        v: {
          x: +t.v.X * 100 * (r / n) + a,
          y: +t.v.Y * 100 * (l / h) + o
        }
      };
    case "RelLineTo":
      return {
        c: "lineTo",
        v: {
          x: +t.v.X * n * (r / n) + a,
          y: +t.v.Y * h * (l / h) + o
        }
      };
    case "Ellipse":
      let c = t.v.X, d = t.v.Y, f = Math.abs(t.v.A - t.v.C), u = Math.abs(t.v.B - t.v.D);
      return {
        c: "ellipse",
        v: {
          x: c * 100 * (r / n) + a,
          y: d * 100 * (l / h) + o,
          radiuX: f * 100 * (r / n),
          radiuY: u * 100 * (l / h),
          rotation: 0,
          startAngle: 0,
          endAngle: Math.PI * 2,
          anticlockwise: !0
        }
      };
    case "EllipticalArcTo":
      const g = t.v.X * 100 * (r / n) + a, y = t.v.Y * 100 * (l / h) + o, v = t.v.A * 100 * (r / n) + a, b = t.v.B * 100 * (l / h) + o;
      t.v.C;
      const x = t.v.D * (r / l) * (h / n), p = (g - i) * (b - s) - (y - s) * (v - i) > 0, k = Xs(
        i,
        s,
        g,
        y,
        v,
        b,
        x
      );
      return !t.orign && (t.orign = {}), !t.orign.startA && (t.orign.startA = fi(
        k.x0,
        k.y0,
        i,
        s
      )), !t.orign.endA && (t.orign.endA = fi(
        k.x0,
        k.y0,
        g,
        y
      )), {
        c: "ellipse",
        v: {
          centerX: k.x0,
          centerY: k.y0,
          radiuX: k.a,
          radiuY: k.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: t.orign.startA,
          endAngle: t.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: p
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: g,
        startY: y
      };
    case "RelEllipticalArcTo":
      const R = t.v.X * n * (r / n) + a, A = t.v.Y * h * (l / h) + o, P = t.v.A * n * (r / n) + a, E = t.v.B * h * (l / h) + o;
      t.v.C;
      const D = t.v.D * (r / l) * (h / n), q = (R - i) * (E - s) - (A - s) * (P - i) > 0, I = Xs(
        i,
        s,
        R,
        A,
        P,
        E,
        D
      );
      return !t.orign && (t.orign = {}), !t.orign.startA && (t.orign.startA = fi(
        I.x0,
        I.y0,
        i,
        s
      )), !t.orign.endA && (t.orign.endA = fi(
        I.x0,
        I.y0,
        R,
        A
      )), {
        c: "ellipse",
        v: {
          centerX: I.x0,
          centerY: I.y0,
          radiuX: I.a,
          radiuY: I.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: t.orign.startA,
          endAngle: t.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: q
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: R,
        startY: A
      };
    case "ArcTo":
      let S = t.v.X * 100 * r / n + a, T = t.v.Y * 100 * l / h + o, _ = t.v.A * 100 * (r / l) * (h / n), z = (i + S) / 2, V = (s + T) / 2, X = Math.sqrt((S - i) ** 2 + (T - s) ** 2), H = X ** 2 / (8 * _) + _ / 2, M = -(T - s) / X, B = (S - i) / X, W = z + M * H, N = V + B * H, U = W, Y = N, $ = Math.atan2(s - Y, i - U), Z = Math.atan2(T - Y, S - U);
      return {
        c: "arc",
        v: {
          x: U,
          y: Y,
          radius: H,
          startAngle: $,
          endAngle: Z,
          aclockwise: !0
        }
      };
    default:
      const Q = G(t);
      return Object.entries(Q.v).forEach(([J, m]) => {
        var w, C;
        (w = J.endsWith) != null && w.call(J, "_x") ? typeof m == "number" && (Q.v[J] = m * (r / n) + a) : (C = J.endsWith) != null && C.call(J, "_y") ? typeof m == "number" && (Q.v[J] = m * (l / h) + o) : typeof m == "number" && (Q.v[J] = m);
      }), Q;
  }
}
function Is(t, e) {
  for (const i in e)
    La.includes(i) && (i == "fontSize" && e[i] < 0 && (e[i] = 0), t[i] = e[i], ["fontSize", "lineWidth"].includes(i) ? (t.calculative[i] = e[i] * t.calculative.canvas.store.data.scale, Xe(t)) : t.calculative[i] = e[i]);
  if (t.calculative.canvas.parent.isCombine(t)) {
    const i = t.children;
    i == null || i.forEach((s) => {
      let a = G(e);
      t.calculative.childrenVisible && t.calculative.childrenVisible[s] === !1 && delete a.visible;
      const o = t.calculative.canvas.store.pens[s];
      o && Is(o, a);
    });
  }
}
function Xs(t, e, i, s, a, o, r) {
  let l = (t - i) * (t + i) * (s - o) - (i - a) * (i + a) * (e - s) + r * r * (e - s) * (s - o) * (e - o), n = 2 * ((t - i) * (s - o) - (i - a) * (e - s)), h = l / n, c = (t - i) * (i - a) * (t - a) + r * r * ((i - a) * (e - s) * (e + s) - (t - i) * (s - o) * (s + o)), d = 2 * r * r * ((i - a) * (e - s) - (t - i) * (s - o)), f = c / d, u = Math.sqrt(Math.pow(t - h, 2) + Math.pow(r * (e - f), 2)), g = u / r;
  return { x0: h, y0: f, a: u, b: g };
}
function fi(t, e, i, s) {
  let a = i - t, o = s - e, r = Math.atan2(o, a);
  return r < 0 && (r += 2 * Math.PI), r;
}
function Ks(t, e, i) {
  let s, a, o = 1 / 0, r = 1 / 0;
  const l = 8;
  for (const n of t.data.pens) {
    if (n.calculative.inView === !1)
      continue;
    Ss(n).forEach((c) => {
      if (c === e || c === i)
        return;
      let d = (n.calculative.worldRect.center.x - e.x) * (n.calculative.worldRect.center.x - e.x) + (n.calculative.worldRect.center.y - e.y) * (n.calculative.worldRect.center.y - e.y);
      const f = Math.abs(c.x - e.x);
      f > 0 && f < l && d < o && (s = {
        x: Math.round(c.x) + 0.5,
        y: Math.round(c.y) + 0.5,
        prev: {
          x: Math.round(e.x) + 0.5,
          y: Math.round(e.y) + 0.5
        },
        step: c.x - e.x
      }, o = d);
      const u = Math.abs(c.y - e.y);
      u > 0 && u < l && d < r && (a = {
        x: Math.round(c.x) + 0.5,
        y: Math.round(c.y) + 0.5,
        prev: {
          x: Math.round(e.x) + 0.5,
          y: Math.round(e.y) + 0.5
        },
        step: c.y - e.y
      }, r = d);
    });
  }
  return {
    xDock: s,
    yDock: a
  };
}
function cn(t, e, i, s) {
  let a = [];
  return i.length === 1 ? (a = G(Ss(i[0])), a.forEach((o) => {
    o.x += s.x, o.y += s.y;
  })) : (pe(e), a = [e.center, ...st(e)]), to(t, a, e, !0);
}
function Ss(t) {
  if (t.type) {
    if (t.type === fe.Line)
      return t.calculative.worldAnchors;
  } else {
    const e = st(t.calculative.worldRect);
    return pe(t.calculative.worldRect), [
      ...t.calculative.worldAnchors,
      ...e,
      t.calculative.worldRect.center
    ];
  }
}
function hn(t, e, i, s) {
  const a = st(e);
  return to(t, a, e);
}
function to(t, e, i, s = !1) {
  let a, o, r = 1 / 0, l = 1 / 0;
  const n = 10, h = yn(i, n);
  return t.data.pens.forEach((c) => {
    const { inView: d, worldRect: f, active: u } = c.calculative;
    if (d === !1 || !s && u || // 如果不计算活动层，则过滤掉活动层
    vn(h, f) || // 水平和垂直方向 无重合
    c.type && t.active.some((y) => io(t, y, c)))
      return;
    const g = Ss(c);
    if (g)
      for (const y of g)
        for (const v of e) {
          const b = y.x - v.x, x = y.y - v.y, p = Math.abs(b), k = Math.abs(x);
          i.center || (i.center = {
            x: i.x + i.width / 2,
            y: i.y + i.height / 2
          }), p < n && p < r && (a = {
            x: Math.round(y.x) + 0.5,
            y: Math.round(y.y) + 0.5,
            step: b,
            prev: {
              x: Math.round(v.x) + 0.5,
              y: Math.round(v.y) + 0.5
            },
            penId: c.id,
            anchorId: v.id,
            dockAnchorId: y.id
          }, r = p), k < n && k < l && (o = {
            x: Math.round(y.x) + 0.5,
            y: Math.round(y.y) + 0.5,
            step: x,
            prev: {
              x: Math.round(v.x) + 0.5,
              y: Math.round(v.y) + 0.5
            },
            penId: c.id,
            anchorId: v.id,
            dockAnchorId: y.id
          }, l = k);
        }
  }), {
    xDock: a,
    yDock: o
  };
}
function io(t, e, i) {
  if (!i.type)
    return !1;
  if (Array.isArray(e == null ? void 0 : e.connectedLines)) {
    for (const s of e == null ? void 0 : e.connectedLines)
      if (s.lineId === i.id)
        return !0;
  }
  if (Array.isArray(e == null ? void 0 : e.children))
    for (const s of e.children) {
      const a = t.pens[s];
      if (io(t, a, i))
        return !0;
    }
  return !1;
}
function is(t, e) {
  return t.toFixed(12) == e;
}
function Gs(t) {
  if (t.id = ne(), Array.isArray(t.anchors))
    for (const e of t.anchors)
      t.type && (e.id = ne()), e.penId = t.id, e.prev && (t.type && (e.prev.id = ne()), e.prev.penId = t.id), e.next && (t.type && (e.next.id = ne()), e.next.penId = t.id);
}
function dn() {
  let t = null, e = /* @__PURE__ */ new Map();
  return (i, s, a, o = !1) => {
    if (e.has(i) && e.get(i) ? t = e.get(i) : e.set(i, t = /* @__PURE__ */ new Map()), typeof a != "function") return () => {
      console.warn("[rewritePenLifeCycle] warn: not a function ");
    };
    let r = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
    t.has(s) && t.get(s) ? r = t.get(s) : (l.set(s, i[s]), t.set(s, r)), o ? r.delete(a) : r.add(a);
    let n = l.get(s), h = (...c) => {
      n == null || n(...c), r.forEach((d) => {
        d(...c);
      });
    };
    i[s] = h;
  };
}
let un = dn();
function fn(t) {
  return !t.name && !t.install ? (console.error("installPenPlugin Error: Validation Failed"), !1) : !0;
}
function nt(t, e) {
  if (!e)
    return;
  if (e.ex == null && we(e), !e.rotate || // rect.width < 20 ||
  // rect.height < 20 ||
  e.rotate % 360 === 0)
    return t.x > e.x && t.x < e.ex && t.y > e.y && t.y < e.ey;
  e.center || pe(e);
  const i = [
    { x: e.x, y: e.y },
    { x: e.ex, y: e.y },
    { x: e.ex, y: e.ey },
    { x: e.x, y: e.ey }
  ];
  return i.forEach((s) => {
    ve(s, e.rotate, e.pivot || e.center);
  }), gn(t, i);
}
function Pt(t, e, i = 0) {
  const { x: s, y: a, ex: o, ey: r } = e;
  return t.x >= s - i && t.x <= o + i && t.y >= a - i && t.y <= r + i;
}
function pe(t) {
  t.center || (t.center = {}), t.center.x = t.x + t.width / 2, t.center.y = t.y + t.height / 2;
}
function we(t) {
  t.ex = t.x + t.width, t.ey = t.y + t.height;
}
function ss(t, e) {
  t.pivot || (t.pivot = {}), t.pivot.x = t.x + t.width * e.x, t.pivot.y = t.y + t.height * e.y;
}
function gn(t, e) {
  if (e.length < 3)
    return !1;
  let i = !1, s = e[e.length - 1];
  for (const a of e)
    s.y > t.y != a.y > t.y && a.x + (t.y - a.y) * (s.x - a.x) / (s.y - a.y) > t.x && (i = !i), s = a;
  return i;
}
function Ue(t) {
  const e = [];
  t.forEach((s) => {
    if (s.isRuleLine)
      return;
    const a = s.calculative.worldRect;
    if (a) {
      const o = st(a);
      e.push(...o);
    }
  });
  const i = Ut(e);
  return pe(i), i;
}
function st(t) {
  const e = [
    { x: t.x, y: t.y },
    { x: t.ex, y: t.y },
    { x: t.ex, y: t.ey },
    { x: t.x, y: t.ey }
  ];
  return t.rotate && (t.center || pe(t), e.forEach((i) => {
    ve(i, t.rotate, t.pivot || t.center);
  })), e;
}
function Ut(t) {
  let e = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
  return t == null || t.forEach((o) => {
    !isFinite(o.x) || !isFinite(o.y) || (e = Math.min(e, o.x), i = Math.min(i, o.y), s = Math.max(s, o.x), a = Math.max(a, o.y));
  }), { x: e, y: i, ex: s, ey: a, width: s - e, height: a - i };
}
function tt(t, e, i) {
  return t.rotate && (t = Ut(st(t))), i ? t.x > e.x && t.ex < e.ex && t.y > e.y && t.ey < e.ey : !(t.x > e.ex || t.ex < e.x || t.ey < e.y || t.y > e.ey);
}
function vn(t, e) {
  return (e.x > t.ex || e.ex < t.x) && (e.y > t.ey || e.ey < t.y);
}
function yn(t, e) {
  const i = Qe(e), s = {
    x: t.x - i[3],
    y: t.y - i[0],
    width: t.width + i[1] + i[3],
    height: t.height + i[0] + i[2]
  };
  return we(s), s;
}
function It(t, e, i) {
  t.x += e, t.y += i, t.ex += e, t.ey += i, t.center && (t.center.x += e, t.center.y += i), t.pivot && (t.pivot.x += e, t.pivot.y += i);
}
function mn(t, e) {
  const i = (t.to.y - t.from.y) / (t.to.x - t.from.x), s = (e.to.y - e.from.y) / (e.to.x - e.from.x);
  return as(
    {
      k: i,
      point: t.from
    },
    {
      k: s,
      point: e.from
    }
  );
}
function as(t, e) {
  if (is(t.k, 0))
    return {
      x: e.point.x,
      y: t.point.y
    };
  if (is(e.k, 0))
    return {
      x: t.point.x,
      y: e.point.y
    };
  const i = t.point.y - t.k * t.point.x, a = (e.point.y - e.k * e.point.x - i) / (t.k - e.k), o = t.k * a + i;
  return {
    x: a,
    y: o
  };
}
function pn(t, e) {
  const i = mn(
    {
      from: t[0],
      to: t[2]
    },
    {
      from: t[1],
      to: t[3]
    }
  );
  for (const s of t)
    ve(s, -e, i);
  return Ut(t);
}
function Js(t, e, i, s) {
  let a = t.rotate ? t.rotate % 360 : 0;
  if (a) {
    const o = st(t), r = (o[0].y - o[1].y) / (o[0].x - o[1].x), l = (o[1].y - o[2].y) / (o[1].x - o[2].x);
    if (s < 4) {
      if (o[s].x += e, t.ratio)
        if (s === 0 || s === 2) {
          let c = e * Math.tan((90 - (360 - a) - Math.atan(t.width / t.height) / Math.PI * 180) / 180 * Math.PI);
          o[s].y += c;
        } else {
          let c = e * Math.tan((90 - (360 - a) + Math.atan(t.width / t.height) / Math.PI * 180) / 180 * Math.PI);
          o[s].y += c;
        }
      else
        o[s].y += i;
      const h = o[(s + 2) % 4];
      o[(s + 1) % 4] = as(
        { k: s % 2 ? l : r, point: o[s] },
        { k: s % 2 ? r : l, point: h }
      ), o[(s + 4 - 1) % 4] = as(
        { k: s % 2 ? r : l, point: o[s] },
        { k: s % 2 ? l : r, point: h }
      );
    } else {
      const h = [4, 6].includes(s) ? l : r;
      is(h, 0) ? (o[s % 4].x += e, o[(s + 1) % 4].x += e) : (o[s % 4].y += i, o[s % 4].x += i / h, o[(s + 1) % 4].y += i, o[(s + 1) % 4].x += i / h);
    }
    if ((o[0].x - o[1].x) ** 2 + (o[0].y - o[1].y) ** 2 < 25 || (o[1].x - o[2].x) ** 2 + (o[1].y - o[2].y) ** 2 < 25)
      return;
    const n = pn(o, t.rotate);
    pe(n), Object.assign(t, n);
    return;
  }
  switch (s) {
    case 0:
      if (t.width - e < 5 || t.height - i < 5)
        break;
      t.x += e, t.y += i, t.width -= e, t.height -= i;
      break;
    case 1:
      if (t.width + e < 5 || t.height - i < 5)
        break;
      t.ex += e, t.y += i, t.width += e, t.height -= i;
      break;
    case 2:
      if (t.width + e < 5 || t.height + i < 5)
        break;
      t.ex += e, t.ey += i, t.width += e, t.height += i;
      break;
    case 3:
      if (t.width - e < 5 || t.height + i < 5)
        break;
      t.x += e, t.ey += i, t.width -= e, t.height += i;
      break;
    case 4:
      if (t.height - i < 5)
        break;
      t.y += i, t.height -= i;
      break;
    case 5:
      if (t.width + e < 5)
        break;
      t.ex += e, t.width += e;
      break;
    case 6:
      if (t.height + i < 5)
        break;
      t.ey += i, t.height += i;
      break;
    case 7:
      if (t.width - e < 5)
        break;
      t.x += e, t.width -= e;
      break;
  }
}
function ri(t, e, i, s) {
  t && (t.width *= e, t.height *= e, Si(t, e, i), we(t), pe(t), s && ss(t, s));
}
function lt(t, e) {
  const i = {
    x: (t.x - e.x) / e.width,
    y: (t.y - e.y) / e.height,
    width: t.width / e.width,
    height: t.height / e.height
  };
  return we(i), i;
}
function si(t, e) {
  const { x: i, y: s, width: a, height: o } = e, { penId: r, connectTo: l } = t, n = Object.assign({}, t, {
    x: a ? (t.x - i) / a : 0,
    y: o ? (t.y - s) / o : 0
  });
  return t.prev && (n.prev = {
    penId: r,
    connectTo: l,
    x: a ? (t.prev.x - i) / a : 0,
    y: o ? (t.prev.y - s) / o : 0
  }), t.next && (n.next = {
    penId: r,
    connectTo: l,
    x: a ? (t.next.x - i) / a : 0,
    y: o ? (t.next.y - s) / o : 0
  }), n;
}
function bn(t, e) {
  let i = !1;
  for (let s = 0, a = e.length - 1; s < e.length; a = s++) {
    let o = e[s].x, r = e[s].y, l = e[a].x, n = e[a].y;
    r > t.y != n > t.y && t.x < (l - o) * (t.y - r) / (n - r) + o && (i = !i);
  }
  return i;
}
const wn = /^[\t\n\f\r ]*([MLHVZCSQTAmlhvzcsqta])[\t\n\f\r ]*/, Qs = /^[01]/, ye = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, xn = /^(([\t\n\f\r ]+,?[\t\n\f\r ]*)|(,[\t\n\f\r ]*))/, kn = {
  M: [ye, ye],
  L: [ye, ye],
  H: [ye],
  V: [ye],
  Z: [],
  C: [
    ye,
    ye,
    ye,
    ye,
    ye,
    ye
  ],
  S: [ye, ye, ye, ye],
  Q: [ye, ye, ye, ye],
  T: [ye, ye],
  A: [
    ye,
    ye,
    ye,
    Qs,
    Qs,
    ye,
    ye
  ]
};
function so(t) {
  let e = 0;
  const i = [];
  for (; e < t.length; ) {
    const s = t.slice(e).match(wn);
    if (s !== null) {
      const a = s[1];
      e += s[0].length;
      const o = Tn(a, t, e);
      e = o.cursor, i.push(...o.commands);
    } else
      throw new Error("malformed path (first error at " + e + ")");
  }
  return { commands: i };
}
function os(t) {
  let e = 1 / 0, i = 1 / 0, s = -1 / 0, a = -1 / 0;
  return Rn(t), t.commands.forEach((o) => {
    o.worldPoints.forEach((r, l) => {
      l % 2 === 0 ? (r < e && (e = r), r > s && (s = r)) : (r < i && (i = r), r > a && (a = r));
    });
  }), --e, --i, {
    x: e,
    y: i,
    ex: s,
    ey: a,
    width: s - e + 1,
    height: a - i + 1
  };
}
function In(t, e, i) {
  i == null && (i = e), t.commands.forEach((s, a) => {
    if (!(s.relative && a))
      switch (s.key) {
        case "A":
        case "a":
          s.values[5] += e, s.values[6] += i;
          break;
        case "V":
        case "v":
          s.values[0] += i;
          break;
        default:
          s.values.forEach((o, r) => {
            s.values[r] = o + (r % 2 === 0 ? e : i);
          });
          break;
      }
  });
}
function Sn(t, e, i) {
  i == null && (i = e), t.commands.forEach((s) => {
    switch (s.key) {
      case "A":
      case "a":
        const a = s.values[0], o = s.values[1], r = Math.PI * s.values[2] / 180, l = Math.cos(r), n = Math.sin(r), h = o * o * i * i * l * l + a * a * i * i * n * n, c = 2 * e * i * l * n * (o * o - a * a), d = a * a * e * e * l * l + o * o * e * e * n * n, f = -(a * a * o * o * e * e * i * i), u = c * c - 4 * h * d, g = Math.sqrt((h - d) * (h - d) + c * c);
        s.values[2] = c !== 0 ? Math.atan((d - h - g) / c) * 180 / Math.PI : h < d ? 0 : 90, s.values[0] = -Math.sqrt(2 * u * f * (h + d + g)) / u, s.values[1] = -Math.sqrt(2 * u * f * (h + d - g)) / u, s.values[5] *= e, s.values[6] *= i, s.values[4] = e * i >= 0 ? s.values[4] : 1 - s.values[4];
        break;
      case "V":
      case "v":
        s.values[0] *= i;
        break;
      default:
        s.values.forEach((y, v) => {
          s.values[v] = y * (v % 2 === 0 ? e : i);
        });
        break;
    }
  });
}
function An(t) {
  let e = "";
  return t.commands.forEach((i) => {
    e += i.key + " ", i.values.forEach((s) => {
      e += s + " ";
    });
  }), e;
}
function Tn(t, e, i) {
  const s = kn[t.toUpperCase()], a = [];
  for (; i <= e.length; ) {
    const o = { key: t, values: [] };
    for (const r of s) {
      const l = e.slice(i).match(r);
      if (l !== null) {
        o.values.push(+l[0]), i += l[0].length;
        const n = e.slice(i).match(xn);
        n !== null && (i += n[0].length);
      } else {
        if (o.values.length === 0)
          return { cursor: i, commands: a };
        throw new Error("malformed path (first error at " + i + ")");
      }
    }
    if (o.relative = o.key.toUpperCase() !== o.key, a.push(o), s.length === 0)
      return { cursor: i, commands: a };
    t === "m" && (t = "l"), t === "M" && (t = "L");
  }
  throw new Error("malformed path (first error at " + i + ")");
}
function Cn(t, e) {
  const i = [];
  let s = t.relative && e ? {
    x: e.worldPoints[e.worldPoints.length - 2],
    y: e.worldPoints[e.worldPoints.length - 1]
  } : { x: 0, y: 0 };
  for (let a = 0; a < t.values.length - 1; a += 2)
    i.push(s.x + t.values[a]), i.push(s.y + t.values[a + 1]);
  t.worldPoints = i;
}
function Rn(t) {
  let e, i = 0, s = 0;
  t.commands.forEach((a) => {
    switch (a.key) {
      case "Z":
      case "z":
        a.worldPoints = [i, s];
        break;
      case "H":
        a.worldPoints = [
          a.values[0],
          e.worldPoints[e.worldPoints.length - 1]
        ];
        break;
      case "h":
        a.worldPoints = [
          a.values[0] + e.worldPoints[e.worldPoints.length - 2],
          e.worldPoints[e.worldPoints.length - 1]
        ];
        break;
      case "V":
        a.worldPoints = [
          e.worldPoints[e.worldPoints.length - 2],
          a.values[0]
        ];
        break;
      case "v":
        a.worldPoints = [
          e.worldPoints[e.worldPoints.length - 2],
          a.values[0] + e.worldPoints[e.worldPoints.length - 1]
        ];
        break;
      case "A":
        a.worldPoints = [
          e.worldPoints[e.worldPoints.length - 2],
          a.values[0] + e.worldPoints[e.worldPoints.length - 1]
        ];
        break;
      default:
        Cn(a, e);
        break;
    }
    (a.key === "M" || a.key === "m" || a.key === "Z" || a.key === "z") && (i = a.worldPoints[a.worldPoints.length - 2], s = a.worldPoints[a.worldPoints.length - 1]), e = a;
  });
}
function Pn(t, e) {
  var n;
  const s = t.calculative.canvas.store.data.paths[t.pathId];
  if (!s)
    return new Path2D();
  const a = so(s);
  t.calculative.svgRect = os(a), pe(t.calculative.svgRect), (t.calculative.svgRect.width !== t.calculative.worldRect.width || t.calculative.svgRect.height !== t.calculative.worldRect.height) && (t.calculative.worldRect.width / t.calculative.svgRect.width, t.calculative.worldRect.height / t.calculative.svgRect.height, Sn(
    a,
    t.calculative.worldRect.width / t.calculative.svgRect.width,
    t.calculative.worldRect.height / t.calculative.svgRect.height
  ));
  const o = os(a);
  pe(o), In(
    a,
    t.calculative.worldRect.x - o.x,
    t.calculative.worldRect.y - o.y
  );
  const r = An(a);
  if (e) {
    (n = e.svgPath) == null || n.call(e, r);
    return;
  }
  return new Path2D(r);
}
function En(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s + o / 2, a), i.lineTo(s + o, a + r / 2), i.lineTo(s + o / 2, a + r), i.lineTo(s, a + r / 2), i.lineTo(s + o / 2, a), i.closePath(), i instanceof Path2D) return i;
}
function _n(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s + o / 2, a), i.lineTo(s + o, a + r), i.lineTo(s, a + r), i.lineTo(s + o / 2, a), i.closePath(), i instanceof Path2D) return i;
}
function Ln(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.75,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.25,
      y: 0.5
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function Mn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s + o / 2, a), i.lineTo(s + o, a + r * 2 / 5), i.lineTo(s + o * 4 / 5, a + r), i.lineTo(s + o / 5, a + r), i.lineTo(s, a + r * 2 / 5), i.closePath(), i instanceof Path2D) return i;
}
function Nn(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.4
    },
    {
      x: 0.8,
      y: 1
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0,
      y: 0.4
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function On(t, e) {
  t.onResize || (t.onResize = Dn);
  const i = e || new Path2D(), { width: s, height: a, center: o } = t.calculative.worldRect, r = s > a ? a : s, l = o.x, n = o.y, h = n - r / 2, c = n - r / 4, d = -(c - n) * Math.sin(Math.PI / 180 * 324) + l, f = (c - n) * Math.cos(Math.PI / 180 * 324) + n;
  i.moveTo(d, f);
  for (let u = 0; u < 5; ++u)
    i.lineTo(
      -(h - n) * Math.sin(Math.PI / 180 * 72 * u) + l,
      (h - n) * Math.cos(Math.PI / 180 * 72 * u) + n
    ), i.lineTo(
      (d - l) * Math.cos(Math.PI / 180 * 72 * (u + 1)) - (f - n) * Math.sin(Math.PI / 180 * 72 * (u + 1)) + l,
      (d - l) * Math.sin(Math.PI / 180 * 72 * (u + 1)) + (f - n) * Math.cos(Math.PI / 180 * 72 * (u + 1)) + n
    );
  if (i.closePath(), i instanceof Path2D) return i;
}
function ao(t) {
  const { width: e, height: i } = t, s = e > i ? i : e, a = [];
  for (let o = 0; o < 5; ++o)
    a.push({
      flag: 1,
      // 默认锚点
      id: String(o),
      penId: t.id,
      x: 0.5 + s / 2 * Math.sin(Math.PI / 180 * 72 * o) / e,
      y: -s / 2 * Math.cos(Math.PI / 180 * 72 * o) / i + 0.5
    });
  t.anchors = a;
}
function Dn(t) {
  const e = t.anchors.filter((i) => i.flag !== 1);
  ao(t), t.anchors = t.anchors.concat(...e);
}
function Bn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s + o / 4, a), i.lineTo(s + o * 3 / 4, a), i.lineTo(s + o, a + r / 2), i.lineTo(s + o * 3 / 4, a + r), i.lineTo(s + o * 1 / 4, a + r), i.lineTo(s, a + r / 2), i.lineTo(s + o / 4, a), i.closePath(), i instanceof Path2D) return i;
}
function zn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s, a + r / 2), i.lineTo(s + r / 2, a), i.lineTo(s + r / 2, a + r / 3), i.lineTo(s + o, a + r / 3), i.lineTo(s + o, a + r * 2 / 3), i.lineTo(s + r / 2, a + r * 2 / 3), i.lineTo(s + r / 2, a + r * 2 / 3), i.lineTo(s + r / 2, a + r), i.closePath(), i instanceof Path2D) return i;
}
function Hn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s, a + r / 3), i.lineTo(s + (o - r / 2), a + r / 3), i.lineTo(s + (o - r / 2), a), i.lineTo(s + o, a + r / 2), i.lineTo(s + (o - r / 2), a + r), i.lineTo(s + (o - r / 2), a + r * 2 / 3), i.lineTo(s, a + r * 2 / 3), i.closePath(), i instanceof Path2D) return i;
}
function Fn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s, a + r / 2), i.lineTo(s + r / 2, a), i.lineTo(s + r / 2, a + r / 3), i.lineTo(s + (o - r / 2), a + r / 3), i.lineTo(s + (o - r / 2), a), i.lineTo(s + o, a + r / 2), i.lineTo(s + (o - r / 2), a + r), i.lineTo(s + (o - r / 2), a + r * 2 / 3), i.lineTo(s + r / 2, a + r * 2 / 3), i.lineTo(s + r / 2, a + r), i.closePath(), i instanceof Path2D) return i;
}
function Wn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ey: l } = t.calculative.worldRect;
  if (i.moveTo(s, a), i.lineTo(s + o, a), i.lineTo(s + o, a + r * 3 / 4), i.lineTo(s + o * 8 / 16, a + r * 3 / 4), i.lineTo(s + o / 4, l), i.lineTo(s + o * 5 / 16, a + r * 3 / 4), i.lineTo(s, a + r * 3 / 4), i.closePath(), i instanceof Path2D) return i;
}
function Vn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s + o / 5, a + r * 13 / 16), i.bezierCurveTo(
    s - o / 15,
    a + r * 13 / 16,
    s - o / 15,
    a + r * 7 / 16,
    s + o / 5,
    a + r * 7 / 16
  ), i.bezierCurveTo(
    s + o / 5,
    a,
    s + o * 4 / 5,
    a,
    s + o * 4 / 5,
    a + r * 7 / 16
  ), i.bezierCurveTo(
    s + o * 16 / 15,
    a + r * 7 / 16,
    s + o * 16 / 15,
    a + r * 13 / 16,
    s + o * 4 / 5,
    a + r * 13 / 16
  ), i.closePath(), i instanceof Path2D) return i;
}
function jn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 6;
  if (i.moveTo(s, a), i.lineTo(r - n, a), i.lineTo(r, a + n), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i.moveTo(r - n, a), i.lineTo(r - n, a + n), i.lineTo(r, a + n), i.closePath(), i instanceof Path2D) return i;
}
function Un(t, e) {
  const { x: i, y: s, width: a, ex: o, ey: r } = e.calculative.worldRect;
  let l = a * 0.25;
  const n = e.z;
  n > 1 ? l = n : n > 0 && (l = a * n);
  const h = {
    x: i,
    y: s + l
  }, c = {
    x: o - l,
    y: s + l
  }, d = {
    x: o - l,
    y: r
  };
  Wi(
    t,
    [h, c, d, {
      x: i,
      y: r
    }],
    e.backgroundFront || e.background,
    e.color
  ), Wi(
    t,
    [
      h,
      {
        x: i + l,
        y: s
      },
      { x: o, y: s },
      c
    ],
    e.backgroundUp || e.background,
    e.color
  ), Wi(
    t,
    [
      c,
      { x: o, y: s },
      {
        x: o,
        y: r - l
      },
      d
    ],
    e.backgroundRight || e.background,
    e.color
  );
}
function Wi(t, e, i = "", s = "") {
  t.save(), i && (t.fillStyle = i), s && (t.strokeStyle = s), t.beginPath();
  for (let a = 0; a < e.length; ++a)
    a ? t.lineTo(e[a].x, e[a].y) : t.moveTo(e[a].x, e[a].y);
  t.closePath(), i && t.fill(), t.stroke(), t.restore();
}
function qn(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 4, h = s + o / 2;
  if (i.arc(h, a + n, n, 0, Math.PI * 2), i.moveTo(s, a + n * 3), i.lineTo(r, a + n * 3), i.moveTo(h, a + n * 2), i.lineTo(h, a + n * 4), i.moveTo(h, a + n * 4), i.lineTo(s, l), i.moveTo(h, a + n * 4), i.lineTo(r, l), i.closePath(), i instanceof Path2D) return i;
}
function Yn(t, e, i) {
  if (e.calculative.worldAnchors || (e.calculative.worldAnchors = []), i)
    e.calculative.activeAnchor && (e.calculative.activeAnchor.next = {
      penId: e.id,
      x: i.x,
      y: i.y
    }, Li(
      e.calculative.activeAnchor.next,
      e.calculative.activeAnchor
    ) < 5 ? e.calculative.activeAnchor.next = void 0 : (e.calculative.activeAnchor.prev = {
      ...e.calculative.activeAnchor.next
    }, ve(
      e.calculative.activeAnchor.prev,
      180,
      e.calculative.activeAnchor
    )));
  else {
    const s = e.calculative.worldAnchors[0];
    if (!s.next) {
      const o = jt(s, t.pens[s.connectTo]);
      Zs(s, o, 50), s.prev = void 0;
    }
    const a = e.calculative.worldAnchors[e.calculative.worldAnchors.length - 1];
    if (a && a !== s && !a.prev) {
      const o = jt(a, t.pens[a.connectTo]);
      Zs(a, o, -50), a.next = void 0;
    }
  }
}
function Zs(t, e, i) {
  switch (e) {
    case ce.Up:
      t.prev = {
        penId: t.penId,
        x: t.x,
        y: t.y + i
      }, t.next = {
        penId: t.penId,
        x: t.x,
        y: t.y - i
      };
      break;
    case ce.Right:
      t.prev = {
        penId: t.penId,
        x: t.x - i,
        y: t.y
      }, t.next = {
        penId: t.penId,
        x: t.x + i,
        y: t.y
      };
      break;
    case ce.Bottom:
      t.prev = {
        penId: t.penId,
        x: t.x,
        y: t.y - i
      }, t.next = {
        penId: t.penId,
        x: t.x,
        y: t.y + i
      };
      break;
    case ce.Left:
      t.prev = {
        penId: t.penId,
        x: t.x + i,
        y: t.y
      }, t.next = {
        penId: t.penId,
        x: t.x - i,
        y: t.y
      };
      break;
  }
}
function rs(t, e, i, s) {
  const a = 1 - t, o = a * a * e.x + 2 * a * t * i.x + t * t * s.x, r = a * a * e.y + 2 * a * t * i.y + t * t * s.y;
  return { x: o, y: r, step: t };
}
function oo(t, e, i, s, a) {
  const { x: o, y: r } = e, { x: l, y: n } = a, { x: h, y: c } = i, { x: d, y: f } = s, u = 1 - t, g = o * u * u * u + 3 * h * t * u * u + 3 * d * t * t * u + l * t * t * t, y = r * u * u * u + 3 * c * t * u * u + 3 * f * t * t * u + n * t * t * t;
  return { x: g, y, step: t };
}
function at(t, e, i) {
  return {
    x: t.x + i * (e.x - t.x),
    y: t.y + i * (e.y - t.y)
  };
}
function $n(t, e, i) {
  let s = t.calculative.worldAnchors[i], a = t.calculative.worldAnchors[i + 1];
  !a && t.close && (a = t.calculative.worldAnchors[0]);
  const o = e.step;
  let r;
  if (s.next && a.prev) {
    const l = s, n = s.next, h = a.prev, c = a, d = at(l, n, o), f = at(n, h, o), u = at(h, c, o), g = at(d, f, o), y = at(f, u, o);
    r = at(g, y, o), g.penId = t.id, r.prev = g, y.penId = t.id, r.next = y, s.next.x = d.x, s.next.y = d.y, a.prev.x = u.x, a.prev.y = u.y;
  } else if (s.next || a.prev) {
    const l = s, n = s.next || a.prev, h = a, c = at(l, n, o), d = at(n, h, o);
    r = e, c.penId = t.id, d.penId = t.id, r.prev = c, r.next = d, s.next = void 0, a.prev = void 0;
  } else
    r = e;
  return r.penId = t.id, r.id = ne(), r.prevNextType = Ft.Bilateral, r;
}
function Xn(t, e, i) {
  if (e.calculative.worldAnchors || (e.calculative.worldAnchors = []), e.calculative.worldAnchors.length < 2)
    return;
  let s = e.calculative.activeAnchor, a = i || ue(e);
  if (!s || !a)
    return;
  const o = 20, r = t.pens[s.connectTo];
  let l = jt(s, r);
  switch (l === ce.None && (a.x > s.x ? l = ce.Right : l = ce.Left), s.next = {
    id: ne(),
    penId: e.id,
    x: s.x,
    y: s.y,
    prevNextType: 2
  }, a.prev = { id: ne(), penId: e.id, x: a.x, y: a.y, prevNextType: 2 }, l) {
    case ce.Up:
      s.next.y -= o, a.prev.y = s.y;
      break;
    case ce.Bottom:
      s.next.y += o, a.prev.y = s.y;
      break;
    case ce.Left:
      s.next.x -= o, a.prev.x = s.x;
      break;
    default:
      s.next.x += o, a.prev.x = s.x;
      break;
  }
}
function Kn(t, e) {
  const i = e || new Path2D();
  if ((t.lineName === "line" || t.lineName === "polyline") && t.calculative.lineSmooth) {
    let a = ws(t);
    if (i.addPath(a), i instanceof Path2D) return i;
  }
  const s = t.calculative.worldAnchors;
  if (s.length > 1) {
    let a;
    s.forEach((o) => {
      a ? ea(i, a, o) : o.start = !0, a = o;
    }), t.close && (t.lineName === "curve" ? ea(i, a, s[0]) : i.closePath());
  }
  if (i instanceof Path2D) return i;
}
function Gn(t, e, i) {
  var o;
  if (e.calculative.worldAnchors || (e.calculative.worldAnchors = []), e.calculative.worldAnchors.length < 2 || ((o = e.anchors) == null ? void 0 : o.length) > 1)
    return;
  const s = xe(e), a = ue(e);
  !s || !a || !a.id || s === a || (s.next = void 0, ks(e), a.prev = void 0, e.calculative.worldAnchors.push(a));
}
function ea(t, e, i) {
  !i || i.isTemp || (e.start && t.moveTo(e.x, e.y), e.next ? i.prev ? t.bezierCurveTo(
    e.next.x,
    e.next.y,
    i.prev.x,
    i.prev.y,
    i.x,
    i.y
  ) : t.quadraticCurveTo(e.next.x, e.next.y, i.x, i.y) : i.prev ? t.quadraticCurveTo(i.prev.x, i.prev.y, i.x, i.y) : t.lineTo(i.x, i.y));
}
function ns(t) {
  return ls(t), Ut(ro(t));
}
function ro(t) {
  const e = [];
  let i;
  return t.calculative.worldAnchors.forEach((s) => {
    e.push(s), i && e.push(...ta(i, s, t)), i = s;
  }), t.close && t.calculative.worldAnchors.length > 1 && e.push(...ta(i, t.calculative.worldAnchors[0], t)), e;
}
function Ri(t) {
  return t != null && t.lineWidth ? t.lineWidth / 2 + 4 : 4;
}
function ta(t, e, i) {
  const s = [];
  if (!e)
    return s;
  let a = 0.02;
  if (t.lineLength && (a = Ri(i) / t.lineLength), t.next)
    if (e.prev)
      for (let o = a; o < 1; o += a)
        s.push(oo(o, t, t.next, e.prev, e));
    else
      for (let o = a; o < 1; o += a)
        s.push(rs(o, t, t.next, e));
  else if (e.prev)
    for (let o = a; o < 1; o += a)
      s.push(rs(o, t, e.prev, e));
  else
    s.push({ x: e.x, y: e.y });
  return s.length > 1 && (t.curvePoints = s), s;
}
function Jn(t, e) {
  const i = Ri(e);
  let s = 0, a, o;
  for (const r of e.calculative.worldAnchors) {
    if (a) {
      if (o = ia(t, a, r, i), o)
        return {
          i: s,
          point: o
        };
      ++s;
    }
    a = r;
  }
  if (e.close && e.calculative.worldAnchors.length > 1 && (o = ia(t, a, e.calculative.worldAnchors[0], i)))
    return {
      i: s,
      point: o
    };
}
function ia(t, e, i, s = 4) {
  if (!e.next && !i.prev) {
    const { x: a, y: o } = e, { x: r, y: l } = i, n = Math.min(a, r), h = Math.max(a, r), c = Math.min(o, l), d = Math.max(o, l);
    return t.x >= n - s && t.x <= h + s && t.y >= c - s && t.y <= d + s ? Qn(t, e, i, s) : void 0;
  } else if (e.curvePoints) {
    for (const a of e.curvePoints)
      if (Nt(t, a, s))
        return a;
  }
}
function Qn(t, e, i, s = 4) {
  if (e.x === i.x) {
    if (Math.abs(t.x - e.x) <= s)
      return {
        x: e.x,
        y: t.y
      };
  } else {
    const a = (e.y - i.y) / (e.x - i.x), o = e.y - a * e.x;
    if (Math.abs((a * t.x + o - t.y) / Math.sqrt(a * a + 1)) <= s) {
      const n = (t.x + a * t.y - a * o) / (a * a + 1);
      return {
        x: n,
        y: a * n + o
      };
    }
  }
}
function sa(t, e, i, s) {
  if (!e && !i)
    return Math.sqrt(
      Math.pow(Math.abs(t.x - s.x), 2) + Math.pow(Math.abs(t.y - s.y), 2)
    ) || 0;
  const a = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return e && i ? a.setAttribute(
    "d",
    `M${t.x} ${t.y} C${e.x} ${e.y} ${i.x} ${i.y} ${s.x} ${s.y}`
  ) : e ? a.setAttribute(
    "d",
    `M${t.x} ${t.y} Q${e.x} ${e.y} ${s.x} ${s.y}`
  ) : a.setAttribute(
    "d",
    `M${t.x} ${t.y} Q${i.x} ${i.y} ${s.x} ${s.y}`
  ), a.getTotalLength() || 0;
}
function ls(t) {
  if (t.calculative.worldAnchors.length < 2)
    return 0;
  let e = 0, i;
  if (t.calculative.worldAnchors.forEach((s) => {
    i && (i.lineLength = sa(i, i.next, s.prev, s), e += i.lineLength), i = s;
  }), t.close) {
    const s = xe(t);
    i.lineLength = sa(i, i.next, s.prev, s), e += i.lineLength;
  }
  return t.calculative.animatePos && (t.calculative.animatePos = e / t.length * t.calculative.animatePos), t.length = e, e;
}
function Vi(t, e) {
  const i = t.calculative.worldAnchors;
  for (let s = 0; s < i.length - 1; s++) {
    const a = i[s], o = i[s + 1];
    if (!a.next && !o.prev) {
      if (no(a, o, e))
        return !0;
    } else if (Zn(a, o, e))
      return !0;
  }
  return !1;
}
function no(t, e, i) {
  if (Pt(t, i) || Pt(e, i))
    return !0;
  const s = t.x, a = t.y, o = e.x, r = e.y;
  let l = i.x, n = i.y, h = i.ex, c = i.ey;
  const d = a - r, f = o - s, u = s * r - o * a;
  if (d * l + f * n + u >= 0 && d * h + f * c + u <= 0 || d * l + f * n + u <= 0 && d * h + f * c + u >= 0 || d * l + f * c + u >= 0 && d * h + f * n + u <= 0 || d * l + f * c + u <= 0 && d * h + f * n + u >= 0) {
    if (l > h) {
      const g = l;
      l = h, h = g;
    }
    if (n < c) {
      const g = n;
      n = c, c = g;
    }
    return !(s < l && o < l || s > h && o > h || a > n && r > n || a < c && r < c);
  } else
    return !1;
}
function Zn(t, e, i) {
  if (!t.next && !e.prev)
    return no(t, e, i);
  if (t.next && e.prev)
    for (let a = 0.02; a < 1; a += 0.02) {
      const o = oo(a, t, t.next, e.prev, e);
      if (Pt(o, i))
        return !0;
    }
  else if (t.next || e.prev)
    for (let a = 0.02; a < 1; a += 0.02) {
      const o = rs(a, t, t.next || e.prev, e);
      if (Pt(o, i))
        return !0;
    }
  return !1;
}
let _e = 10;
function el(t, e, i) {
  var y;
  if (e.calculative.worldAnchors || (e.calculative.worldAnchors = []), _e = t.options.polylineSpace || 10, e.calculative.worldAnchors.length < 2)
    return;
  let s = xe(e), a = ue(e);
  if (!s || !a)
    return;
  let o;
  if ((y = e.anchors) != null && y.length && s === e.calculative.activeAnchor ? (o = !0, s = a, a = xe(e)) : (!e.anchors || !e.anchors.length) && s !== e.calculative.activeAnchor && (s = e.calculative.activeAnchor), !s || !a)
    return;
  s.next = void 0, a.prev = void 0;
  const r = a.connectTo;
  ks(e);
  const l = [], n = t.pens[s.connectTo], h = t.pens[a.connectTo], c = jt(s, n), d = jt(a, h);
  let f = aa(s, c, _e);
  f && (s = f, l.push(f)), f = aa(a, d, _e);
  const u = a;
  let g;
  if (f && (a = f, u.connectTo && (f.y > u.y && s.y < u.y || f.y < u.y && s.y > u.y))) {
    g = f;
    let v = _e;
    s.x < f.x && (v = -v), Math.abs(s.x - f.x) < v && (v = -v), a = { x: f.x + v, y: f.y, id: ne() };
  }
  switch (c) {
    case ce.Up:
      l.push(...tl(s, a, d));
      break;
    case ce.Right:
      l.push(...il(s, a, d));
      break;
    case ce.Bottom:
      l.push(...sl(s, a, d));
      break;
    case ce.Left:
      l.push(...al(s, a, d));
      break;
    default:
      l.push(...ol(e, s, a));
      break;
  }
  if (l.forEach((v) => {
    v.id = ne(), v.penId = e.id, e.calculative.worldAnchors.push(v);
  }), e.calculative.worldAnchors.push(a), g && e.calculative.worldAnchors.push(g), f && e.calculative.worldAnchors.push(u), o && e.calculative.worldAnchors.reverse(), r) {
    const v = e.calculative.worldAnchors.length - 2;
    e.calculative.worldAnchors[v].isTemp = !1, e.calculative.worldAnchors[1].isTemp = !1;
  }
}
function aa(t, e, i) {
  const s = { x: t.x, y: t.y, id: ne() };
  switch (e) {
    case ce.Up:
      s.y -= i;
      break;
    case ce.Right:
      s.x += i;
      break;
    case ce.Bottom:
      s.y += i;
      break;
    case ce.Left:
      s.x -= i;
      break;
    default:
      return;
  }
  return s;
}
function tl(t, e, i) {
  if (t.x === e.x || t.y === e.y)
    return [];
  const s = [];
  let a, o;
  switch (i) {
    case ce.Up:
      t.y < e.y ? (a = e.x, o = t.y) : (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    case ce.Bottom:
      if (a = e.x, o = t.y, e.y > t.y)
        a = t.x + (e.x - t.x) / 2, s.push({ x: a, y: t.y }, { x: a, y: e.y });
      else {
        const r = (t.y + e.y) / 2;
        s.push({ x: t.x, y: r }, { x: e.x, y: r });
      }
      break;
    case ce.Right:
      a = e.x, o = t.y, e.x < t.x && e.y < t.y && (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    case ce.Left:
      a = e.x, o = t.y, e.x > t.x && e.y < t.y && (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    default:
      if (e.y > t.y - _e)
        a = t.x + (e.x - t.x) / 2, s.push({ x: a, y: t.y }, { x: a, y: e.y });
      else {
        const r = (t.y + e.y + _e) / 2;
        s.push({ x: t.x, y: r }, { x: e.x, y: r });
      }
      break;
  }
  return s;
}
function il(t, e, i) {
  if (t.x === e.x || t.y === e.y)
    return [];
  const s = [];
  let a, o;
  switch (i) {
    case ce.Up:
      a = t.x, o = e.y, e.x > t.x && e.y > t.y && (a = e.x, o = t.y), s.push({ x: a, y: o });
      break;
    case ce.Bottom:
      a = t.x, o = e.y, e.x > t.x && e.y < t.y && (a = e.x, o = t.y), s.push({ x: a, y: o });
      break;
    case ce.Left:
      if (a = e.x, o = t.y, e.x < t.x)
        o = t.y + (e.y - t.y) / 2, s.push({ x: t.x, y: o }, { x: e.x, y: o });
      else {
        const r = (t.x + e.x) / 2;
        s.push({ x: r, y: o }, { x: r, y: e.y });
      }
      break;
    case ce.Right:
      e.x < t.x ? s.push({ x: t.x, y: e.y }) : s.push({ x: e.x, y: t.y });
      break;
    default:
      if (a = e.x, o = e.y, e.x < t.x + _e)
        s.push({ x: t.x, y: o });
      else {
        const r = (t.x + e.x - _e) / 2;
        s.push({ x: r, y: t.y }, { x: r, y: o });
      }
      break;
  }
  return s;
}
function sl(t, e, i) {
  if (t.x === e.x || t.y === e.y)
    return [];
  const s = [];
  let a, o;
  switch (i) {
    case ce.Up:
      if (a = t.x, o = e.y, e.y < t.y)
        a = t.x + (e.x - t.x) / 2, s.push({ x: a, y: t.y }, { x: a, y: e.y });
      else {
        const r = (t.y + e.y) / 2;
        s.push({ x: a, y: r }, { x: e.x, y: r });
      }
      break;
    case ce.Right:
      a = e.x, o = t.y, e.x < t.x && e.y > t.y && (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    case ce.Bottom:
      t.y > e.y ? (a = e.x, o = t.y) : (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    case ce.Left:
      a = e.x, o = t.y, e.x > t.x && e.y > t.y && (a = t.x, o = e.y), s.push({ x: a, y: o });
      break;
    default:
      if (a = t.x, e.y < t.y + _e)
        a = t.x + (e.x - t.x) / 2, s.push({ x: a, y: t.y }, { x: a, y: e.y });
      else {
        const r = (t.y + e.y - _e) / 2;
        s.push({ x: a, y: r }, { x: e.x, y: r });
      }
      break;
  }
  return s;
}
function al(t, e, i) {
  if (t.x === e.x || t.y === e.y)
    return [];
  const s = [];
  let a, o;
  switch (i) {
    case ce.Up:
      a = t.x, o = e.y, e.x < t.x && e.y > t.y && (a = e.x, o = t.y), s.push({ x: a, y: o });
      break;
    case ce.Bottom:
      a = t.x, o = e.y, e.x < t.x && e.y < t.y && (a = e.x, o = t.y), s.push({ x: a, y: o });
      break;
    case ce.Right:
      if (a = t.x, o = e.y, e.x > t.x)
        a = e.x, o = t.y + (e.y - t.y) / 2, s.push({ x: t.x, y: o }, { x: e.x, y: o });
      else {
        const r = (t.x + e.x) / 2;
        s.push({ x: r, y: t.y }, { x: r, y: e.y });
      }
      break;
    case ce.Left:
      e.x > t.x ? s.push({ x: t.x, y: e.y }) : s.push({ x: e.x, y: t.y });
      break;
    default:
      if (a = t.x, o = e.y, e.x < t.x - _e) {
        const r = (t.x + e.x + _e) / 2;
        s.push({ x: r, y: t.y }, { x: r, y: o });
      } else
        s.push({ x: t.x, y: o });
      break;
  }
  return s;
}
function ol(t, e, i) {
  const s = [];
  t.calculative.drawlineH == null && (t.calculative.drawlineH = Math.abs(i.x - e.x) > Math.abs(i.y - e.y));
  let a = t.calculative.worldAnchors.findIndex(
    (o) => o.id == e.id
  );
  if (a > 1) {
    let o = t.calculative.worldAnchors[a - 1];
    if (o.x === e.x && o.y !== e.y)
      return s.push({ x: i.x, y: e.y }), s;
    if (o.y === e.y && o.x !== e.x)
      return s.push({ x: e.x, y: i.y }), s;
  }
  return t.calculative.worldAnchors.length && (i.isTemp = void 0, t.calculative.drawlineH ? (s.push({ x: i.x, y: e.y }), Math.abs(i.y - e.y) < _e && (i.isTemp = !0)) : (s.push({ x: e.x, y: i.y }), Math.abs(i.x - e.x) < _e && (i.isTemp = !0))), s;
}
function gi(t, e, i = !0) {
  var a, o;
  let s = t.calculative.worldAnchors;
  i || (s = [], t.calculative.worldAnchors.forEach((r) => {
    s.unshift(r);
  }));
  for (let r = 0; r < s.length && s[r].id !== e.id; r++)
    if (s[r].y !== e.y || s[r].x === ((a = s[r + 1]) == null ? void 0 : a.x) && s[r].y !== ((o = s[r + 1]) == null ? void 0 : o.y))
      return !1;
  return !0;
}
function vi(t, e, i = !0) {
  var a, o;
  let s = t.calculative.worldAnchors;
  i || (s = [], t.calculative.worldAnchors.forEach((r) => {
    s.unshift(r);
  }));
  for (let r = 0; r < s.length && s[r].id !== e.id; r++)
    if (s[r].x !== e.x || s[r].y === ((a = s[r + 1]) == null ? void 0 : a.y) && s[r].x !== ((o = s[r + 1]) == null ? void 0 : o.x))
      return !1;
  return !0;
}
function rl(t, e, i) {
  if (!t.calculative.worldAnchors)
    return;
  const s = t.calculative.worldAnchors.findIndex(
    (n) => n.id === e.id
  ), a = xe(t), o = ue(t);
  let r = t.calculative.worldAnchors[s - 1], l = t.calculative.worldAnchors[s + 1];
  if (t.calculative.h == null && (a.connectTo && (gi(t, e, !0) ? t.calculative.h = !0 : vi(t, e, !0) && (t.calculative.h = !1)), t.calculative.h == null && o.connectTo && (gi(t, e, !1) ? t.calculative.h = !0 : vi(t, e, !1) && (t.calculative.h = !1)), t.calculative.h == null && (r ? t.calculative.h = r.y === e.y : l && (t.calculative.h = l.y === e.y))), t.calculative.h) {
    if (e.x = i.x, a.connectTo && gi(t, e, !0)) {
      l && l.y !== e.y && (l.x = e.x);
      return;
    }
    if (o.connectTo && gi(t, e, !1)) {
      r && r.y !== e.y && (r.x = e.x);
      return;
    }
    const n = t.anchors[s];
    let h;
    for (let c = s - 1; c > -1; c--)
      if (r = t.anchors[c], h == null && (h = r.y === n.y), h === !0)
        if (r.y === n.y)
          t.calculative.worldAnchors[c].y = i.y;
        else
          break;
      else if (r.x === n.x)
        t.calculative.worldAnchors[c].x = i.x;
      else
        break;
    h = void 0;
    for (let c = s + 1; c < t.calculative.worldAnchors.length && (l = t.anchors[c], l); c++)
      if (h == null && (h = l.y === n.y), h === !0)
        if (l.y === n.y)
          t.calculative.worldAnchors[c].y = i.y;
        else
          break;
      else if (l.x === n.x)
        t.calculative.worldAnchors[c].x = i.x;
      else
        break;
    e.y = i.y;
  } else {
    if (e.y = i.y, a.connectTo && vi(t, e, !0)) {
      l && l.x !== e.x && (l.y = e.y);
      return;
    }
    if (o.connectTo && vi(t, e, !1)) {
      r && r.x !== e.x && (r.y = e.y);
      return;
    }
    const n = t.anchors[s];
    let h;
    for (let c = s - 1; c > -1; c--)
      if (r = t.anchors[c], h == null && (h = r.x === n.x), h === !0)
        if (r.x === n.x)
          t.calculative.worldAnchors[c].x = i.x;
        else
          break;
      else if (r.y === n.y)
        t.calculative.worldAnchors[c].y = i.y;
      else
        break;
    h = void 0;
    for (let c = s + 1; c < t.calculative.worldAnchors.length && (l = t.anchors[c], l); c++)
      if (h == null && (h = l.x === n.x), h === !0)
        if (l.x === n.x)
          t.calculative.worldAnchors[c].x = i.x;
        else
          break;
      else if (l.y === n.y)
        t.calculative.worldAnchors[c].y = i.y;
      else
        break;
    e.x = i.x;
  }
}
function cs(t, e, i, s) {
  const a = [];
  let o, r, l, n, h, c, d, f, u, g, y, v, b, x;
  u = t[i], g = t[s], l = u.x, n = u.y, d = g.x - l, f = g.y - n, x = d * d + f * f, o = e;
  for (let p = i + 1; p < s; p++)
    y = t[p], d !== 0 || f !== 0 ? (v = ((y.x - l) * d + (y.y - n) * f) / x, v > 1 ? (h = y.x - g.x, c = y.y - g.y) : v > 0 ? (h = y.x - (l + d * v), c = y.y - (n + f * v)) : (h = y.x - l, c = y.y - n)) : (h = y.x - l, c = y.y - n), b = h * h + c * c, b > o && (r = p, o = b);
  return o > e && (r - i > 1 && a.push(...cs(t, e, i, r)), a.push({
    id: t[r].id,
    penId: t[r].penId,
    x: t[r].x,
    y: t[r].y
  }), s - r > 1 && a.push(...cs(t, e, r, s))), a;
}
function nl(t, e = 0.8, i = !1) {
  if (t.length < 3)
    return t;
  let s, a, o, r, l, n, h, c, d, f, u, g, y, v, b;
  const x = (p, k, R, A) => (r = Math.sqrt(p * p + k * k), r > 0 ? (g = p / r, v = k / r) : (g = 1, v = 0), l = Math.sqrt(R * R + A * A), l > 0 ? (y = R / l, b = A / l) : (y = 1, b = 0), Math.acos(g * y + v * b));
  f = [], u = t.length, s = t[0], t[u - 1], f.push({ ...t[0] });
  for (let p = 0; p < u - 1; p++) {
    if (a = t[p], o = t[p + 1], d = Math.abs(x(a.x - s.x, a.y - s.y, o.x - a.x, o.y - a.y)), r)
      if (d < e * 3.14)
        if (i && (r = Math.min(r, l), l = r), n = (g + y) / 2, h = (v + b) / 2, c = Math.sqrt(n * n + h * h), c === 0)
          f.push({ ...a });
        else {
          n /= c, h /= c;
          const k = { ...a };
          k.prevNextType = Ft.Bilateral, k.prev = {
            penId: k.penId,
            x: a.x - n * r * 0.25,
            y: a.y - h * r * 0.25
          }, k.next = {
            penId: k.penId,
            x: a.x + n * l * 0.25,
            y: a.y + h * l * 0.25
          }, f.push(k);
        }
      else
        f.push({ ...a });
    s = a;
  }
  return f.push({ ...t[t.length - 1] }), f;
}
function lo(t, e) {
  const i = e || new Path2D(), s = t.calculative.worldAnchors;
  let a = t.calculative.canvas.store.data.scale, o = (t.calculative.animateLineWidth || 6) * a, r = (t.animateLineWidth * 2 || 12) * a;
  t.lineAnimateType === He.WaterDrop && (r = (t.animateLineWidth * 4 || 24) * a);
  let l = (t.animateInterval || 100) * a, n = t.calculative.lineWidth * (t.calculative.lineSmooth || 0), h = (t.calculative.animateLineWidth / 2 || 3) * a;
  if (t.animateReverse && (r = -r, o = -o), s.length > 1) {
    let c, d = 0;
    for (let f = 0; f < s.length; f++) {
      let u = s[f];
      if (c) {
        let g = ll(c, u), y = {
          x: c.x + (t.calculative.animatePos - d) % l * Math.cos(g * Math.PI / 180),
          y: c.y - (t.calculative.animatePos - d) % l * Math.sin(g * Math.PI / 180)
        };
        t.animateReverse && (y = {
          x: c.x + (t.length - (t.calculative.animatePos + d)) % l * Math.cos(g * Math.PI / 180),
          y: c.y - (t.length - (t.calculative.animatePos + d)) % l * Math.sin(g * Math.PI / 180)
        });
        let v = Math.sqrt(
          (y.x - c.x) ** 2 + (y.y - c.y) ** 2
        ), b = Math.sqrt((u.x - c.x) ** 2 + (u.y - c.y) ** 2);
        for (; v < b; )
          (t.animateReverse && v - r < b || //不允许超出连线绘制
          !t.animateReverse && v > r) && v > n + r && b - v > n && (t.lineAnimateType === He.Arrow ? cl(i, y, o, g, h, r) : t.lineAnimateType === He.WaterDrop && hl(i, y, t.animateReverse, g, h, r)), y.x += l * Math.cos(g * Math.PI / 180), y.y -= l * Math.sin(g * Math.PI / 180), v = Math.sqrt(
            (y.x - c.x) ** 2 + (y.y - c.y) ** 2
          );
      }
      c = u;
    }
  }
  if (i instanceof Path2D) return i;
}
function ll(t, e) {
  let i = e.x - t.x, s = e.y - t.y, a = Math.atan(s / i) * 180 / Math.PI;
  return e.x >= t.x ? a = -a : a = 180 - a, a;
}
function ht(t, e, i) {
  let s = (180 - i) * Math.PI / 180;
  return {
    x: (t.x - e.x) * Math.cos(s) - (t.y - e.y) * Math.sin(s) + e.x,
    y: (t.x - e.x) * Math.sin(s) + (t.y - e.y) * Math.cos(s) + e.y
  };
}
function cl(t, e, i, s, a, o) {
  let r = ht(
    { x: e.x + i, y: e.y + 0.57 * i },
    { x: e.x, y: e.y },
    s
  ), l = ht(
    { x: e.x + i, y: e.y - 0.57 * i },
    { x: e.x, y: e.y },
    s
  ), n = ht(
    { x: e.x + i, y: e.y + a / 2 },
    { x: e.x, y: e.y },
    s
  ), h = ht(
    { x: e.x + o, y: e.y + a / 2 },
    { x: e.x, y: e.y },
    s
  ), c = ht(
    { x: e.x + i, y: e.y - a / 2 },
    { x: e.x, y: e.y },
    s
  ), d = ht(
    { x: e.x + o, y: e.y - a / 2 },
    { x: e.x, y: e.y },
    s
  );
  t.moveTo(r.x, r.y), t.lineTo(e.x, e.y), t.lineTo(l.x, l.y), t.lineTo(c.x, c.y), t.lineTo(d.x, d.y), t.lineTo(h.x, h.y), t.lineTo(n.x, n.y), t.lineTo(r.x, r.y);
}
function hl(t, e, i, s, a, o) {
  let r = a / 2;
  i && (r = -a / 2);
  let l = ht(
    { x: e.x, y: e.y + r },
    { x: e.x, y: e.y },
    s
  ), n = ht(
    { x: e.x + o, y: e.y },
    { x: e.x, y: e.y },
    s
  ), h = Math.PI / 2;
  i && (h = -Math.PI / 2), t.moveTo(e.x, e.y), t.arc(e.x, e.y, a / 2, -h - s / 180 * Math.PI, h - s / 180 * Math.PI, !1), t.lineTo(n.x, n.y), t.lineTo(l.x, l.y);
}
function dl(t) {
  var i;
  t.onDestroy || (t.onDestroy = ul, t.onMove = yi, t.onResize = yi, t.onRotate = yi, t.onValue = yi, t.onMouseMove = gl, t.onBeforeValue = fl, t.onRenderPenRaw = vl), t.calculative.singleton || (t.calculative.singleton = {});
  const e = t.calculative.worldRect;
  if (!t.calculative.singleton.div) {
    const s = document.createElement("div");
    s.style.position = "absolute", s.style.outline = "none", s.style.left = "-9999px", s.style.top = "-9999px", s.style.width = e.width + "px", s.style.height = e.height + "px", document.body.appendChild(s), (i = t.calculative.canvas.externalElements) == null || i.parentElement.appendChild(s), Ce(t, s), t.calculative.singleton.div = s;
    const a = document.createElement("iframe");
    a.style.width = "100%", a.style.height = "100%", a.scrolling = t.scrolling || "no", a.frameBorder = "0", a.style.border = "none", a.src = t.iframe, t.calculative.iframe = t.iframe, s.appendChild(a), ho(t), a.onload = () => {
      a.setAttribute("document.domain", "");
    };
  }
  return t.calculative.patchFlags && Ce(t, t.calculative.singleton.div), t.onRenderPenRaw(t), new Path2D();
}
function ul(t) {
  uo(t), t.calculative.singleton && t.calculative.singleton.div && (t.calculative.singleton.div.remove(), delete t.calculative.singleton.div);
}
function yi(t) {
  t.calculative.singleton.div && Ce(t, t.calculative.singleton.div);
}
function fl(t, e) {
  if (e.iframe && t.calculative.singleton.div && (t.calculative.singleton.div.children[0].src = e.iframe, t.calculative.iframe = e.iframe), e.operationalRect || e["operationalRect.x"] !== void 0 || e["operationalRect.y"] !== void 0 || e["operationalRect.width"] !== void 0 || e["operationalRect.height"] !== void 0) {
    t.operationalRect || (t.operationalRect = {});
    let i = G(e);
    i.operationalRect || (i.operationalRect = {}), i["operationalRect.x"] !== void 0 && (i.operationalRect.x = i["operationalRect.x"]), i["operationalRect.y"] !== void 0 && (i.operationalRect.y = i["operationalRect.y"]), i["operationalRect.width"] !== void 0 && (i.operationalRect.width = i["operationalRect.width"]), i["operationalRect.height"] !== void 0 && (i.operationalRect.height = i["operationalRect.height"]), Object.assign(t.operationalRect, i.operationalRect), t.calculative.singleton.div && (t.calculative.singleton.div.children.length === 1 ? ho(t) : (t.calculative.singleton.div.children[1].style.height = t.operationalRect.y * 100 + "%", t.calculative.singleton.div.children[1].style.left = t.operationalRect.x * 100 + "%", t.calculative.singleton.div.children[1].style.width = t.operationalRect.width * 100 + "%", t.calculative.singleton.div.children[2].style.width = (1 - t.operationalRect.x - t.operationalRect.width) * 100 + "%", t.calculative.singleton.div.children[3].style.height = (1 - t.operationalRect.y - t.operationalRect.height) * 100 + "%", t.calculative.singleton.div.children[3].style.left = t.operationalRect.x * 100 + "%", t.calculative.singleton.div.children[3].style.width = t.operationalRect.width * 100 + "%", t.calculative.singleton.div.children[4].style.width = t.operationalRect.x * 100 + "%"));
  }
  if (e.blur !== void 0)
    for (let i = 1; i < 5; i++)
      t.calculative.singleton.div.children[i].style["backdrop-filter"] = `blur(${e.blur || 2}px)`;
  if (e.blurBackground !== void 0)
    for (let i = 1; i < 5; i++)
      t.calculative.singleton.div.children[i].style.backgroundColor = e.blurBackground;
  return e;
}
function gl(t, e) {
  if (!(!t.calculative.canvas.store.data.locked && !t.locked) && co(t.operationalRect) && t.calculative.zIndex < 5 && e.x > t.x + t.width * t.operationalRect.x && e.x < t.x + t.width * (t.operationalRect.x + t.operationalRect.width) && e.y > t.y + t.height * t.operationalRect.y && e.y < t.y + t.height * (t.operationalRect.y + t.operationalRect.height) && t.calculative.singleton.div) {
    let i = t.calculative.singleton.div.parentNode.children;
    for (let s = 0; s < 6; s++)
      i[s].style.pointerEvents = "none";
  }
}
function co(t) {
  return t ? !t.width || !t.height ? !1 : (t.x === void 0 && (t.x = (1 - t.width) / 2), t.y === void 0 && (t.y = (1 - t.height) / 2), !0) : !1;
}
function ho(t) {
  if (!co(t.operationalRect))
    return;
  const e = t.calculative.singleton.div;
  if (!e)
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = t.operationalRect.x * 100 + "%", i.style.top = "0px", i.style.width = t.operationalRect.width * 100 + "%", i.style.height = t.operationalRect.y * 100 + "%", i.style["backdrop-filter"] = `blur(${t.blur || 2}px)`, i.style.backgroundColor = t.blurBackground, e.appendChild(i);
  const s = document.createElement("div");
  s.style.position = "absolute", s.style.right = "0px", s.style.top = "0px", s.style.width = (1 - t.operationalRect.x - t.operationalRect.width) * 100 + "%", s.style.height = "100%", s.style["backdrop-filter"] = `blur(${t.blur || 2}px)`, s.style.backgroundColor = t.blurBackground, e.appendChild(s);
  const a = document.createElement("div");
  a.style.position = "absolute", a.style.left = t.operationalRect.x * 100 + "%", a.style.bottom = "0px", a.style.width = t.operationalRect.width * 100 + "%", a.style.height = (1 - t.operationalRect.y - t.operationalRect.height) * 100 + "%", a.style["backdrop-filter"] = `blur(${t.blur || 2}px)`, a.style.backgroundColor = t.blurBackground, e.appendChild(a);
  const o = document.createElement("div");
  o.style.position = "absolute", o.style.left = "0px", o.style.top = "0px", o.style.width = t.operationalRect.x * 100 + "%", o.style.height = "100%", o.style["backdrop-filter"] = `blur(${t.blur || 2}px)`, o.style.backgroundColor = t.blurBackground, e.appendChild(o);
  let r = () => {
    uo(t);
  };
  i.onmouseenter = r, a.onmouseenter = r, s.onmouseenter = r, o.onmouseenter = r, e.onmouseleave = r;
}
function uo(t) {
  if (!(!t.calculative.canvas.store.data.locked && !t.locked) && t.calculative.zIndex < 5) {
    let e = t.calculative.singleton.div.parentNode.children;
    for (let i = 1; i < 6; i++)
      e[i].style.pointerEvents = "initial";
  }
}
function vl(t) {
  if (t.thumbImg && !t.calculative.img) {
    const e = new Image();
    e.crossOrigin = t.crossOrigin === "undefined" ? void 0 : t.crossOrigin || "anonymous", t.calculative.canvas.store.options.cdn && !(t.thumbImg.startsWith("http") || t.thumbImg.startsWith("//") || t.thumbImg.startsWith("data:image")) ? e.src = t.calculative.canvas.store.options.cdn + t.thumbImg : e.src = t.thumbImg, e.onerror = (i) => {
      e.remove(), t.calculative.img = void 0;
    }, t.calculative.img = e;
  }
}
const Le = {}, ki = ['<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M473.088 125.44L256 256H52.224C23.552 256 0 279.552 0 308.224V716.8c0 28.16 23.04 51.2 51.2 51.2h204.8l217.088 130.56c16.896 10.24 38.912-2.048 38.912-22.016V147.456c0-19.968-21.504-32.256-38.912-22.016zM699.904 320.512c-20.992-18.944-53.248-17.408-72.192 3.584-18.944 20.992-17.408 53.248 3.584 72.192 0.512 0.512 58.368 54.784 58.368 121.344 0 37.888-19.456 74.752-58.368 110.08-20.992 18.944-22.528 51.2-3.584 72.192 10.24 11.264 24.064 16.896 37.888 16.896 12.288 0 24.576-4.608 34.304-13.312 61.44-55.296 92.16-117.76 92.16-185.856 0-112.64-88.576-193.536-92.16-197.12z" fill="" p-id="2434"></path><path d="M853.504 166.4c-20.992-18.944-53.248-16.896-72.192 4.096-18.944 20.992-16.896 53.248 4.096 72.192 1.536 1.024 135.68 122.88 135.68 280.576 0 90.624-45.568 177.152-135.68 257.536-20.992 18.944-23.04 51.2-4.096 72.192 10.24 11.264 24.064 16.896 38.4 16.896 12.288 0 24.576-4.096 34.304-12.8 112.64-100.864 169.984-212.992 169.984-333.824-1.024-202.752-163.84-350.208-170.496-356.864z"></path></svg>', '<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M256 768H51.2c-28.16 0-51.2-23.04-51.2-51.2V308.224C0 279.552 23.552 256 52.224 256H256v512zM512 147.456v728.576c0 19.968-21.504 32.256-38.912 22.016L256 768V256l217.088-130.56c17.408-10.24 38.912 2.048 38.912 22.016zM623.104 656.896c-19.968-19.968-19.968-52.224 0-72.192l217.088-217.088c19.968-19.968 52.224-19.968 72.192 0 19.968 19.968 19.968 52.224 0 72.192l-217.088 217.088c-19.456 19.968-52.224 19.968-72.192 0z" fill="" p-id="2582"></path><path d="M623.104 367.104c19.968-19.968 52.224-19.968 72.192 0l217.088 217.088c19.968 19.968 19.968 52.224 0 72.192-19.968 19.968-52.224 19.968-72.192 0l-217.088-217.088c-19.968-19.456-19.968-52.224 0-72.192z"></path></svg>'];
function yl(t) {
  var e;
  if (t.onDestroy || (t.onDestroy = ml, t.onMove = ji, t.onResize = ji, t.onRotate = ji, t.onClick = oa, t.onValue = bl, t.onChangeId = pl), Le[t.id])
    t.video && t.calculative.media && t.video !== t.calculative.video ? (console.warn("video 更改, 此处是否执行？"), t.calculative.media.src = t.video, t.autoPlay && (t.calculative.media.muted = !0, t.calculative.media.autoplay = !0), t.calculative.media.loop = t.playLoop, t.calculative.video = t.video) : t.audio && t.calculative.media && t.audio !== t.calculative.audio && (t.calculative.media.src = t.audio, t.autoPlay && (t.calculative.media.muted = !0, t.calculative.media.autoplay = !0), t.calculative.media.loop = t.playLoop, t.calculative.audio = t.audio);
  else {
    const i = document.createElement("div"), s = document.createElement("div");
    s.style.position = "absolute", s.style.outline = "none", s.style.left = "0", s.style.bottom = "0", s.style.width = "0", s.style.height = "2px", s.style.background = "#52c41a", s.style.zIndex = "1", t.hideProgress && (s.style.display = "none");
    const a = document.createElement("div");
    a.innerHTML = ki[1], a.style.position = "absolute", a.style.right = "0", a.style.bottom = "0", a.style.width = "20px", a.style.height = "20px", a.style.fill = "hsla(0, 0%, 100%, .8)", a.style.zIndex = "1", a.style.display = "none", i.appendChild(s), i.appendChild(a), a.onclick = (r) => {
      r.stopPropagation(), t.calculative.media.muted ? (a.innerHTML = ki[0], t.calculative.media.muted = !1) : (a.innerHTML = ki[1], t.calculative.media.muted = !0);
    }, t.calculative.singleton || (t.calculative.singleton = {}), t.calculative.singleton.muted = a, i.onmouseenter = (r) => {
      a.style.display = "block";
    }, i.onmouseleave = (r) => {
      a.style.display = "none";
    }, i.onclick = (r) => {
      r.stopPropagation(), oa(t);
    };
    let o;
    t.video ? (o = document.createElement("video"), o.src = t.video) : t.audio && (o = document.createElement("audio"), o.src = t.audio), o.loop = t.playLoop, o.ontimeupdate = () => {
      fo(s, o, t.calculative.worldRect.width);
    }, o.onended = () => {
      t.calculative.onended && t.calculative.onended(t);
    }, t.calculative.media = o, o.style.position = "absolute", o.style.outline = "none", o.style.left = "0", o.style.top = "0", o.style.width = "100%", o.style.height = "100%", i.appendChild(o), Le[t.id] = i, (e = t.calculative.canvas.externalElements) == null || e.parentElement.appendChild(i), Ce(t, i), t.autoPlay && (o.autoplay = !0, o.muted = !0);
  }
  return t.calculative.patchFlags && Ce(t, Le[t.id]), new Path2D();
}
function ml(t) {
  Le[t.id].onclick = null, Le[t.id].remove(), Le[t.id] = void 0;
}
function ji(t) {
  Ce(t, Le[t.id]);
  const e = Le[t.id].children[0], i = Le[t.id].children[1];
  fo(
    e,
    i,
    t.calculative.worldRect.width
  );
}
function oa(t) {
  t.calculative.media && (t.calculative.media.muted = !1, t.calculative.singleton.muted.innerHTML = ki[0], t.calculative.media.paused ? t.calculative.media.play() : t.calculative.media.pause());
}
function fo(t, e, i) {
  t.style.width = e.currentTime / e.duration * i + "px";
}
function pl(t, e, i) {
  Le[e] && (Le[i] = Le[e], delete Le[e]);
}
function bl(t) {
  const e = Le[t.id];
  if (!e)
    return;
  Ce(t, e);
  const i = t.calculative.media.getAttribute("src");
  t.video ? i !== t.video && (t.calculative.media.src = t.video) : t.audio && i !== t.audio && (t.calculative.media.src = t.audio), t.autoPlay && (t.calculative.media.muted = !0, t.calculative.media.autoplay = !0), t.calculative.media.loop = t.playLoop;
}
function Ke() {
  try {
    const t = new OffscreenCanvas(0, 0), e = t.getContext("2d");
    return e && e.arc ? t : document.createElement("canvas");
  } catch {
    return document.createElement("canvas");
  }
}
class ai {
  // 本次 tooltip 在哪个画笔上
  constructor(e, i) {
    O(this, "box");
    O(this, "text");
    O(this, "arrowUp");
    O(this, "arrowDown");
    O(this, "x");
    O(this, "y");
    O(this, "currentPen");
    this.parentElement = e, this.store = i, this.box = document.createElement("div"), this.text = document.createElement("div"), this.arrowUp = document.createElement("div"), this.arrowDown = document.createElement("div"), this.box.className = "meta2d-tooltip", this.text.className = "text", this.arrowUp.className = "arrow", this.arrowDown.className = "arrow down", this.box.appendChild(this.text), this.box.appendChild(this.arrowUp), this.box.appendChild(this.arrowDown), e.appendChild(this.box), this.box.onmouseleave = () => {
      this.hide(), this.store.lastHover = void 0;
    };
    let s;
    for (let a = 0; a < document.styleSheets.length; a++)
      document.styleSheets[a].title === "le5le.com/tooltip" && (s = document.styleSheets[a]);
    if (!s) {
      let a = document.createElement("style");
      a.type = "text/css", a.title = "le5le.com/tooltip", document.head.appendChild(a), a = document.createElement("style"), a.type = "text/css", document.head.appendChild(a), s = a.sheet, s.insertRule(
        ".meta2d-tooltip{position:absolute;padding:8px 0;z-index:10;left: -9999px;top: -9999px;}"
      ), s.insertRule(
        ".meta2d-tooltip .text{max-width:320px;min-height:30px;max-height:400px;outline:none;padding:8px 16px;border-radius:4px;background:#777777;color:#ffffff;line-height:1.8;overflow-y:auto;}"
      ), s.insertRule(
        ".meta2d-tooltip .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-5px;left:50%;transform:translateX(-50%)}"
      ), s.insertRule(
        ".meta2d-tooltip .arrow.down{top:initial;bottom: -1px;}"
      );
    }
  }
  /**
   * 通过 pen 的 titleFn titleFnJs title 来获取 title
   * @returns 此次应该展示的 title
   */
  static getTitle(e) {
    if (e.titleFnJs && !e.titleFn)
      try {
        e.titleFn = new Function("pen", e.titleFnJs);
      } catch (i) {
        console.log("titleFnJs", i);
      }
    return e.titleFn ? e.titleFn(e) : String(e.title);
  }
  /**
   * 更改 tooltip dom 的文本
   * @returns 返回设置前的 rect
   */
  setText(e) {
    const i = this.box.getBoundingClientRect();
    let s = globalThis.marked;
    const a = ai.getTitle(e);
    if (s) {
      this.text.innerHTML = s(a);
      const o = this.text.getElementsByTagName("A");
      for (let r = 0; r < o.length; ++r)
        o[r].setAttribute("target", "_blank");
    } else
      this.text.innerHTML = a;
    return i;
  }
  /**
   * 更新文字
   */
  updateText(e) {
    var a;
    if (((a = this.currentPen) == null ? void 0 : a.id) !== e.id || ai.titleEmpty(e))
      return;
    const i = this.setText(e), s = this.box.getBoundingClientRect();
    this.changePositionByText(i, s);
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByText(e, i) {
    this.x -= (i.width - e.width) / 2, this.y -= i.height - e.height, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  static titleEmpty(e) {
    return !e.title && !e.titleFn && !e.titleFnJs;
  }
  show(e, i) {
    if (this.currentPen = e, ai.titleEmpty(e)) {
      let l = Ne(e, !0);
      l && this.show(l, i);
      return;
    }
    this.setText(e);
    const s = this.box.getBoundingClientRect(), a = e.calculative.worldRect;
    let o = e.calculative.canvas.store.data.x + i.x - s.width / 2, r = e.calculative.canvas.store.data.y + i.y - s.height;
    e.type || (o = e.calculative.canvas.store.data.x + a.x - (s.width - a.width) / 2, r = e.calculative.canvas.store.data.y + a.ey - s.height - a.height), r > 0 ? (this.arrowUp.style.borderBottomColor = "transparent", this.arrowDown.style.borderTopColor = "#777777") : (r += s.height + a.height + 5, this.arrowUp.style.borderBottomColor = "#777777", this.arrowDown.style.borderTopColor = "transparent"), this.x = o, this.y = r, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  hide() {
    this.currentPen = null, this.x = -9999, this.box.style.left = "-9999px";
  }
  translate(e, i) {
    this.x < -1e3 || (this.x += e, this.y += i, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px");
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
class go {
  //页面模式
  constructor(e) {
    O(this, "h");
    O(this, "v");
    O(this, "isDownH");
    O(this, "isDownV");
    O(this, "x");
    O(this, "y");
    O(this, "hSize");
    O(this, "vSize");
    O(this, "scrollX");
    O(this, "scrollY");
    O(this, "lastScrollX");
    O(this, "lastScrollY");
    O(this, "rect");
    O(this, "isShow");
    O(this, "pageMode");
    O(this, "onMouseDownH", (e) => {
      e.preventDefault(), e.stopPropagation(), this.isDownH = e.x, this.x = this.parent.store.data.x || 0, this.lastScrollX = this.scrollX;
    });
    O(this, "onMouseDownV", (e) => {
      e.preventDefault(), e.stopPropagation(), this.isDownV = e.y, this.y = this.parent.store.data.y || 0, this.lastScrollY = this.scrollY;
    });
    O(this, "onMouseMove", (e) => {
      if (this.isDownH) {
        const i = e.x - this.isDownH;
        this.scrollX = this.lastScrollX + i, this.h.style.left = `${this.scrollX}px`, this.parent.store.data.x = this.x - i * this.rect.width / this.parent.parentElement.clientWidth;
      }
      if (this.isDownV) {
        const i = e.y - this.isDownV;
        if (this.pageMode && this.canMouseMove(i))
          return;
        this.scrollY = this.lastScrollY + i, this.v.style.top = `${this.scrollY}px`, this.parent.store.data.y = this.y - i * this.rect.height / this.parent.parentElement.clientHeight;
      }
      (this.isDownH || this.isDownV) && (this.parent.onMovePens(), this.parent.canvasTemplate.init(), this.parent.canvasImage.init(), this.parent.canvasImageBottom.init(), this.parent.render());
    });
    O(this, "onMouseUp", (e) => {
      !this.isDownH && !this.isDownV || (this.isDownH = void 0, this.isDownV = void 0, this.scrollX < 20 ? (this.scrollX = 20, this.h.style.left = `${this.scrollX}px`) : this.scrollX > this.parent.parentElement.clientWidth - this.hSize - 20 && (this.scrollX = this.parent.parentElement.clientWidth - this.hSize - 20, this.h.style.left = `${this.scrollX}px`), this.scrollY < 20 ? (this.scrollY = 20, this.v.style.top = `${this.scrollY}px`) : this.scrollY > this.parent.parentElement.clientHeight - this.vSize - 20 && (this.scrollY = this.parent.parentElement.clientHeight - this.vSize - 20, this.v.style.top = `${this.scrollY}px`), this.resize());
    });
    this.parent = e, this.h = document.createElement("div"), this.v = document.createElement("div"), this.parent.externalElements.appendChild(this.h), this.parent.externalElements.appendChild(this.v), this.h.className = "meta2d-scroll h", this.h.onmousedown = this.onMouseDownH, this.v.className = "meta2d-scroll v", this.v.onmousedown = this.onMouseDownV, document.addEventListener("mousemove", this.onMouseMove), document.addEventListener("mouseup", this.onMouseUp);
    let i;
    for (let s = 0; s < document.styleSheets.length; s++)
      document.styleSheets[s].title === "le5le/scroll" && (i = document.styleSheets[s]);
    if (!i) {
      let s = document.createElement("style");
      s.type = "text/css", s.title = "le5le.com/scroll", document.head.appendChild(s), s = document.createElement("style"), s.type = "text/css", document.head.appendChild(s), i = s.sheet, i.insertRule(
        ".meta2d-scroll{position:absolute;width:8px;height:200px;background:#dddddd;border-radius:10px;z-index:20;cursor:default;}"
      ), i.insertRule(
        ".meta2d-scroll:hover{background:#cccccc;cursor:pointer}"
      ), i.insertRule(".meta2d-scroll.v{right:0;top:calc(50% - 100px);}"), i.insertRule(
        ".meta2d-scroll.h{bottom:2px;left:calc(50% - 100px);width:200px;height:8px;}"
      );
    }
    this.init();
  }
  init() {
    this.isShow = !0, this.resize(), this.initPos();
  }
  canMouseMove(e) {
    const i = this.parent.parent.getRect();
    return e < 0 && i.y + this.parent.store.data.y >= 0 || e > 0 && i.ey - this.parent.height + this.parent.store.data.y <= 0;
  }
  changeMode() {
    this.pageMode = !0, this.h.style.display = "none", this.parent.parent.getRect().height < this.parent.height && (this.v.style.display = "none");
  }
  initPos() {
    this.scrollX = (this.parent.parentElement.clientWidth - this.hSize) / 2, this.scrollY = (this.parent.parentElement.clientHeight - this.vSize) / 2, this.h.style.left = `${this.scrollX}px`, this.v.style.top = `${this.scrollY}px`;
  }
  resize() {
    this.rect = Ue(this.parent.store.data.pens), this.rect.width < 1400 && (this.rect.width = 1400), this.rect.height < 900 && (this.rect.height = 900), this.parent.store.data.x > 0 ? this.rect.width += this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x) : this.rect.width -= this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x), this.parent.store.data.y > 0 ? this.rect.height += this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y) : this.rect.height -= this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y), this.rect.width < 1400 && (this.rect.width = 1400), this.rect.height < 900 && (this.rect.height = 900), this.hSize = 1e3 * this.parent.parentElement.clientWidth / this.rect.width / 3, this.vSize = 1e3 * this.parent.parentElement.clientHeight / this.rect.height / 3, this.h.style.width = this.hSize + "px", this.v.style.height = this.vSize + "px";
  }
  show() {
    this.isShow = !0, this.h.style.display = "block", this.v.style.display = "block", document.addEventListener("mousemove", this.onMouseMove), document.addEventListener("mouseup", this.onMouseUp);
  }
  hide() {
    this.isShow = !1, this.h.style.display = "none", this.v.style.display = "none", this.destroy();
  }
  translate(e, i) {
    e && (this.scrollX -= e * this.parent.parentElement.clientWidth / this.rect.width, this.h.style.left = `${this.scrollX}px`), i && (this.scrollY -= i * this.parent.parentElement.clientHeight / this.rect.height, this.v.style.top = `${this.scrollY}px`);
  }
  wheel(e) {
    let i = 10;
    e && (i = -10), !(this.pageMode && this.canMouseMove(i)) && (this.scrollY += i, this.v.style.top = `${this.scrollY}px`, this.parent.store.data.y -= i * this.rect.height / this.parent.parentElement.clientHeight, this.parent.onMovePens(), this.parent.canvasTemplate.init(), this.parent.canvasImage.init(), this.parent.canvasImageBottom.init(), this.parent.render());
  }
  destroy() {
    document.removeEventListener("mousemove", this.onMouseMove), document.removeEventListener("mouseup", this.onMouseUp);
  }
}
class ra {
  constructor(e, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    /**
     * 非图片的绘制
     * isBottom true 指背景颜色，背景网格
     * isBottom false 指 标尺
     */
    O(this, "otherOffsreen", Ke());
    // 非图片的
    O(this, "offscreen", Ke());
    O(this, "animateOffsScreen", Ke());
    O(this, "fitOffscreen", Ke());
    O(this, "fitFlag", !1);
    //开启自定义填充
    O(this, "currentFit");
    O(this, "activeFit");
    this.parentElement = e, this.store = i, this.isBottom = s, e.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(e, i) {
    this.canvas.style.width = e + "px", this.canvas.style.height = i + "px", e = e * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = e, this.canvas.height = i, this.otherOffsreen.width = e, this.otherOffsreen.height = i, this.offscreen.width = e, this.offscreen.height = i, this.animateOffsScreen.width = e, this.animateOffsScreen.height = i, this.fitOffscreen.width = e, this.fitOffscreen.height = i, this.otherOffsreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.otherOffsreen.getContext("2d").textBaseline = "middle", this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.animateOffsScreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.animateOffsScreen.getContext("2d").textBaseline = "middle", this.fitOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.fitOffscreen.getContext("2d").textBaseline = "middle", this.init();
  }
  init() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const e of this.store.data.pens)
      this.hasImage(e) && (e.calculative.imageDrawed = !1);
    this.isBottom ? this.store.patchFlagsBackground = !0 : this.store.patchFlagsTop = !0;
  }
  clear() {
    this.otherOffsreen.getContext("2d").clearRect(0, 0, this.otherOffsreen.width, this.otherOffsreen.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  hasImage(e) {
    return e.calculative.hasImage = e.calculative && e.calculative.inView && // !pen.isBottom == !this.isBottom && // undefined == false 结果 false
    (this.isBottom && e.canvasLayer === de.CanvasImageBottom || !this.isBottom && e.canvasLayer === de.CanvasImage) && e.image && e.calculative.img && e.name !== "gif", e.calculative.hasImage;
  }
  render() {
    var r;
    let e = !1, i = !1;
    for (const l of this.store.data.pens)
      this.hasImage(l) && (this.store.animates.has(l) ? i = !0 : l.calculative.imageDrawed || (e = !0), l.parentId && this.store.animates.has(Ne(l, !0)) && (i = !0));
    const s = this.store.patchFlagsBackground, a = this.store.patchFlagsTop;
    if (a && !this.isBottom) {
      const l = this.otherOffsreen.getContext("2d");
      l.clearRect(0, 0, this.canvas.width, this.canvas.height), this.renderRule(l);
    }
    if (this.store.patchFlagsLast && this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), e) {
      const l = this.offscreen.getContext("2d");
      l.save(), l.clearRect(0, 0, this.canvas.width, this.canvas.height), l.translate(this.store.data.x, this.store.data.y);
      for (const n of this.store.data.pens)
        !n.calculative.hasImage || this.store.animates.has(n) || this.store.animates.has(Ne(n, !0)) || n.canvasLayer !== de.CanvasTemplate && (n.name === "combine" && !n.draw || (n.calculative.imageDrawed = !0, l.save(), Ct(l, n), n.calculative.rotate && it(l, n), Rt(l, n), Wt(l, n), l.restore()));
      l.restore();
    }
    if (i) {
      const l = this.animateOffsScreen.getContext("2d");
      l.save(), l.clearRect(0, 0, this.canvas.width, this.canvas.height), l.translate(this.store.data.x, this.store.data.y);
      for (const n of this.store.animates)
        n.calculative.hasImage && n.canvasLayer !== de.CanvasTemplate && (n.calculative.imageDrawed = !0, l.save(), Ct(l, n), n.calculative.rotate && it(l, n), Rt(l, n), Wt(l, n), l.restore());
      for (const n of this.store.data.pens)
        !n.calculative.hasImage || !n.parentId || n.canvasLayer !== de.CanvasTemplate && this.store.animates.has(Ne(n, !0)) && (n.calculative.imageDrawed = !0, l.save(), Ct(l, n), n.calculative.rotate && it(l, n), Rt(l, n), Wt(l, n), l.restore());
      l.restore();
    }
    if (!this.isBottom && !this.store.data.locked && this.fitFlag) {
      const l = (this.store.data.width || this.store.options.width) * this.store.data.scale, n = (this.store.data.height || this.store.options.height) * this.store.data.scale, h = this.store.data.origin.x + this.store.data.x || this.store.options.x || 0, c = this.store.data.origin.y + this.store.data.y || this.store.options.y || 0, d = this.fitOffscreen.getContext("2d");
      d.save(), d.clearRect(0, 0, this.canvas.width, this.canvas.height), d.fillStyle = "#ffffff66", d.strokeStyle = this.store.options.activeColor, (r = this.store.data.fits) == null || r.forEach((f, u) => {
        d.fillRect(
          h + l * f.x,
          c + n * f.y,
          l * f.width,
          n * f.height
        ), f.active && d.strokeRect(
          h + l * f.x,
          c + n * f.y,
          l * f.width,
          n * f.height
        );
      }), d.restore();
    }
    if (e || i || s && this.isBottom || // this.isBottom ||
    a && !this.isBottom) {
      const l = this.canvas.getContext("2d");
      l.clearRect(0, 0, this.canvas.width, this.canvas.height), this.isBottom && (this.store.patchFlagsBackground = !1), l.drawImage(
        this.offscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), l.drawImage(
        this.animateOffsScreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.isBottom || (l.drawImage(
        this.otherOffsreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.store.patchFlagsTop = !1, !this.store.data.locked && this.fitFlag && l.drawImage(
        this.fitOffscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ));
    }
  }
  // renderGrid(
  //   ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  // ) {
  //   const { data, options } = this.store;
  //   const { grid, gridRotate, gridColor, gridSize, scale } = data;
  //   if (!(grid ?? options.grid)) {
  //     // grid false 时不绘制, undefined 时看 options.grid
  //     return;
  //   }
  //   ctx.save();
  //   const { width, height } = this.canvas;
  //   if (gridRotate) {
  //     ctx.translate(width / 2, height / 2);
  //     ctx.rotate((gridRotate * Math.PI) / 180);
  //     ctx.translate(-width / 2, -height / 2);
  //   }
  //   ctx.lineWidth = 1;
  //   ctx.strokeStyle = gridColor || options.gridColor;
  //   ctx.beginPath();
  //   const size = (gridSize || options.gridSize) * scale;
  //   const longSide = Math.max(width, height);
  //   const count = Math.ceil(longSide / size);
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(i, -longSide);
  //     ctx.lineTo(i, longSide * 2);
  //   }
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(-longSide, i);
  //     ctx.lineTo(longSide * 2, i);
  //   }
  //   ctx.stroke();
  //   ctx.restore();
  // }
  renderRule(e) {
    var p, k, R, A, P, E, D, q;
    const { data: i, options: s } = this.store, { rule: a, ruleColor: o, scale: r, origin: l } = i;
    if (!(a ?? s.rule))
      return;
    const n = r * 10;
    e.save();
    const h = o || s.ruleColor;
    e.strokeStyle = Ai(h, 0.7);
    const c = l.x + i.x, d = l.y + i.y, { width: f, height: u } = this.canvas;
    let g = ((p = s.ruleOptions) == null ? void 0 : p.height) || 20;
    (k = s.ruleOptions) != null && k.background && (e.beginPath(), e.fillStyle = (R = s.ruleOptions) == null ? void 0 : R.background, e.rect(0, 0, f, g), e.fill(), e.rect(0, 0, g, u), e.fill()), (A = s.ruleOptions) != null && A.underline && (e.beginPath(), e.fillStyle = Ai(h, 0.7), e.moveTo(0, g), e.lineTo(f, g), e.stroke(), e.moveTo(g, 0), e.lineTo(g, u), e.stroke());
    let y = g / 4;
    ((P = s.ruleOptions) == null ? void 0 : P.baseline) === "bottom" && (y = g * 3 / 4), e.beginPath(), e.lineWidth = g / 2, e.lineDashOffset = -c % n, e.setLineDash([1, n - 1]), e.moveTo(0, y), e.lineTo(f, y), e.stroke(), e.beginPath(), e.lineDashOffset = -d % n, e.moveTo(y, 0), e.lineTo(y, u), e.stroke(), e.strokeStyle = h, e.beginPath(), e.lineWidth = g, e.lineDashOffset = -c % (n * 10), e.setLineDash([1, n * 10 - 1]), e.moveTo(0, g / 2), e.lineTo(f, g / 2), e.stroke(), e.beginPath(), e.lineDashOffset = -d % (n * 10), e.moveTo(g / 2, 0), e.lineTo(g / 2, u), e.stroke(), e.beginPath(), e.fillStyle = ((E = s.ruleOptions) == null ? void 0 : E.textColor) || e.strokeStyle;
    let v = 0 - Math.floor(c / n / 10) * 100, b = ((D = s.ruleOptions) == null ? void 0 : D.textTop) || 16, x = ((q = s.ruleOptions) == null ? void 0 : q.textLeft) || 4;
    c < 0 && (v -= 100);
    for (let I = c % (n * 10); I < f; I += 10 * n, v += 100)
      n < 3 && v % 500 || e.fillText(v.toString(), I + x, b);
    v = 0 - Math.floor(d / n / 10) * 100, d < 0 && (v -= 100);
    for (let I = d % (n * 10); I < u; I += 10 * n, v += 100)
      n < 3 && v % 500 || (e.save(), e.beginPath(), e.translate(b, I - x), e.rotate(270 * Math.PI / 180), e.fillText(v.toString(), 0, 0), e.restore());
    e.restore();
  }
}
class wl {
  constructor(e, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "magnifierScreen", Ke());
    O(this, "offscreen", Ke());
    O(this, "domOffscreen", Ke());
    O(this, "magnifierSize", 300);
    O(this, "magnifier");
    this.parentCanvas = e, this.parentElement = i, this.store = s, i.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(e, i) {
    this.canvas.style.width = e + "px", this.canvas.style.height = i + "px", e = e * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = e, this.canvas.height = i, this.offscreen.width = e, this.offscreen.height = i, this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.domOffscreen.width = e, this.domOffscreen.height = i, this.domOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.domOffscreen.getContext("2d").textBaseline = "middle", this.magnifierScreen.width = this.magnifierSize + 5, this.magnifierScreen.height = this.magnifierSize + 5;
  }
  /**
   * 绘制到 该画布的 离屏层
   */
  renderMagnifier() {
    if (!this.magnifier)
      return;
    const e = this.magnifierSize / 2, i = this.magnifierSize + 5, s = this.magnifierScreen.getContext(
      "2d"
    );
    s.clearRect(0, 0, i, i), s.lineWidth = 5, s.save(), s.translate(2.5, 2.5), s.save(), s.arc(e, e, e, 0, Math.PI * 2, !1), s.clip(), s.translate(-e, -e), s.scale(2, 2);
    const a = {
      x: (this.parentCanvas.mousePos.x + this.store.data.x) * this.store.dpiRatio,
      y: (this.parentCanvas.mousePos.y + this.store.data.y) * this.store.dpiRatio
    };
    [
      this.parentCanvas.canvasTemplate.bgOffscreen,
      this.parentCanvas.canvasTemplate.offscreen,
      this.parentCanvas.canvasImageBottom.offscreen,
      this.parentCanvas.canvasImageBottom.animateOffsScreen,
      this.parentCanvas.offscreen,
      this.parentCanvas.canvasImage.offscreen,
      this.parentCanvas.canvasImage.animateOffsScreen,
      this.domOffscreen
      //dom元素的绘制层
    ].forEach((n) => {
      s.drawImage(
        n,
        a.x - e,
        a.y - e,
        this.magnifierSize,
        this.magnifierSize,
        0,
        0,
        this.magnifierSize,
        this.magnifierSize
      );
    }), s.restore(), s.beginPath();
    const r = s.createRadialGradient(e, e, e - 5, e, e, e);
    r.addColorStop(0, "rgba(0,0,0,0.2)"), r.addColorStop(0.8, "rgb(200,200,200)"), r.addColorStop(0.9, "rgb(200,200,200)"), r.addColorStop(1, "rgba(200,200,200,0.9)"), s.strokeStyle = r, s.arc(e, e, e, 0, Math.PI * 2, !1), s.stroke(), s.restore(), this.offscreen.getContext("2d").drawImage(
      this.magnifierScreen,
      0,
      0,
      this.magnifierSize + 5,
      this.magnifierSize + 5,
      (a.x - e - 2.5) / this.store.dpiRatio,
      (a.y - e - 2.5) / this.store.dpiRatio,
      (this.magnifierSize + 5) / this.store.dpiRatio,
      (this.magnifierSize + 5) / this.store.dpiRatio
    );
  }
  updateDomOffscreen() {
    const e = this.domOffscreen.getContext("2d");
    e.clearRect(0, 0, this.domOffscreen.width, this.domOffscreen.height);
    for (const i of this.store.data.pens)
      if ((i.externElement || i.name === "gif") && i.calculative.img) {
        e.save(), e.translate(this.store.data.x, this.store.data.y);
        const { x: s, y: a, width: o, height: r } = i.calculative.worldRect;
        e.drawImage(i.calculative.img, s, a, o, r), e.restore();
      }
  }
  render() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.renderMagnifier();
    const e = this.canvas.getContext("2d");
    e.clearRect(0, 0, this.canvas.width, this.canvas.height), e.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
  }
}
function vo(t) {
  if (t.data.locked)
    throw new Error("canvas is locked");
}
class xl {
  constructor(e) {
    O(this, "box");
    O(this, "iframe");
    O(this, "dialog");
    O(this, "close");
    O(this, "title");
    O(this, "body");
    O(this, "x");
    O(this, "y");
    O(this, "url");
    this.parentElement = e, this.box = document.createElement("div"), this.dialog = document.createElement("div");
    let i = document.createElement("div");
    this.title = document.createElement("div"), this.close = document.createElement("span"), this.close.innerHTML = `
      <svg fill="none" viewBox="0 0 16 16" width="1em" height="1em">
      <path
        fill="currentColor"
        d="M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z"
        fill-opacity="0.9"
      ></path>
    </svg>`, this.body = document.createElement("div"), this.iframe = document.createElement("iframe"), this.iframe.setAttribute("frameborder", "0"), this.box.className = "meta2d-dialog_mask", this.dialog.className = "meta2d-dialog", this.body.className = "meta2d-dialog_body", i.className = "meta2d-dialog_header", this.title.className = "meta2d-dialog-content", this.close.className = "meta2d-dialog-close", i.appendChild(this.title), i.appendChild(this.close), this.body.appendChild(this.iframe), this.dialog.appendChild(i), this.dialog.appendChild(this.body), this.box.appendChild(this.dialog), e.appendChild(this.box), this.dialog.onclick = (a) => {
      a.stopPropagation();
    }, this.box.onclick = () => {
      this.hide();
    }, this.close.onclick = () => {
      this.hide();
    };
    let s;
    for (let a = 0; a < document.styleSheets.length; a++)
      document.styleSheets[a].title === "le5le.com/dialog" && (s = document.styleSheets[a]);
    if (!s) {
      let a = document.createElement("style");
      a.type = "text/css", a.title = "le5le.com/dialog", document.head.appendChild(a), a = document.createElement("style"), a.type = "text/css", document.head.appendChild(a), s = a.sheet, s.insertRule(
        `.meta2d-dialog_mask {
        display: none;
        position: absolute;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: #0000006f;
        z-index: 9999;`
      ), s.insertRule(
        `.meta2d-dialog_mask .meta2d-dialog {
            position: absolute;
            top: 15vh;
            left: 10%;
            width: 80%;
            height:420px;
            padding: 16px 20px;
            border-radius: 9px;
            background-color: #1e2430;
            z-index: 19999;
            overflow: auto;
        }`
      ), s.insertRule(
        `.meta2d-dialog_header {
            display: flex;
        }`
      ), s.insertRule(
        `.meta2d-dialog-content {
            width: calc(100% - 20px);
            font-weight: 600;
            font-size: 14px;
            color: #bdc7db;
            padding-bottom:8px;
        }`
      ), s.insertRule(
        `.meta2d-dialog-close {
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            color: #617b91;
            position: absolute;
            right:20px;
            top:18px;
        }`
      ), s.insertRule(
        `.meta2d-dialog-close :hover{
            cursor: pointer;
        }`
      ), s.insertRule(
        `.meta2d-dialog_body{
            // margin-top: 4px;
        } `
      ), s.insertRule(
        `.meta2d-dialog_body iframe{
            width: 100%;
            height: 100%;
        }`
      );
    }
  }
  show(e, i, s) {
    i && (i !== this.url && (this.iframe.setAttribute("src", i), this.url = i), e && (this.title.innerText = e), e ? (this.dialog.style.padding = "16px 20px", this.title.style.display = "block", this.body.style.height = "calc(100% - 26px)") : (this.dialog.style.padding = "0px", this.title.style.display = "none", this.body.style.height = "100%", this.body.style.overflow = "hidden"), s && (this.dialog.style.width = s.width ? s.width + "px" : "80%", this.dialog.style.height = s.height ? s.height + "px" : "420px", this.dialog.style.top = s.y ? s.y + "px" : "15vh", this.dialog.style.left = s.x ? s.x + "px" : `calc( 50% - ${s.width ? s.width / 2 + "px" : "40%"} )`), this.box.style.display = "block");
  }
  hide() {
    this.box.style.display = "none";
  }
  destroy() {
    this.dialog.onclick = void 0, this.box.onclick = void 0, this.close.onclick = void 0;
  }
}
class Pi {
  // 本次 tooltip 在哪个画笔上
  constructor(e) {
    O(this, "box");
    O(this, "currentAnchor");
    this.parentElement = e, this.box = document.createElement("div"), this.box.className = "meta2d-title", e.appendChild(this.box);
    let i;
    for (let s = 0; s < document.styleSheets.length; s++)
      document.styleSheets[s].title === "le5le.com/title" && (i = document.styleSheets[s]);
    if (!i) {
      let s = document.createElement("style");
      s.type = "text/css", s.title = "le5le.com/title", document.head.appendChild(s), s = document.createElement("style"), s.type = "text/css", document.head.appendChild(s), i = s.sheet, i.insertRule(
        ".meta2d-title{position:absolute;padding:0;z-index:10;left: -9999px;top: -9999px;background:#fff;color:#000; cursor: crosshair;border: 1px solid black;}"
      );
    }
  }
  /**
   * @returns 此次应该展示的 title
   */
  static getTitle(e) {
  }
  /**
   * @returns 返回设置前的 rect
   */
  setText(e) {
    this.box.innerText = e.title;
  }
  /**
   * 更新文字
   */
  updateText(e) {
    var i;
    ((i = this.currentAnchor) == null ? void 0 : i.id) === e.id && (Pi.titleEmpty(e) || (this.setText(e), this.changePositionByAnchor(e)));
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByAnchor(e) {
    this.box.style.left = e.x + 10 + "px", this.box.style.top = e.y + 10 + "px";
  }
  static titleEmpty(e) {
    return !e.title;
  }
  show(e, i) {
    if (Pi.titleEmpty(e))
      return;
    this.currentAnchor = e, this.setText(e);
    let s = {
      x: i.calculative.canvas.store.data.x + e.x,
      y: i.calculative.canvas.store.data.y + e.y
    };
    this.changePositionByAnchor(s);
  }
  hide() {
    this.box.style.left = "-9999px", this.box.innerText = "", this.currentAnchor = null;
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
class kl {
  constructor(e, i) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "offscreen", Ke());
    O(this, "bgOffscreen", Ke());
    O(this, "patchFlags");
    O(this, "bgPatchFlags");
    this.parentElement = e, this.store = i, e.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(e, i) {
    this.canvas.style.width = e + "px", this.canvas.style.height = i + "px", e = e * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = e, this.canvas.height = i, this.bgOffscreen.width = e, this.bgOffscreen.height = i, this.offscreen.width = e, this.offscreen.height = i, this.bgOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.bgOffscreen.getContext("2d").textBaseline = "middle", this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.init();
  }
  init() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.patchFlags = !0, this.bgPatchFlags = !0;
  }
  hidden() {
    this.canvas.style.display = "none";
  }
  show() {
    this.canvas.style.display = "block";
  }
  clear() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.bgPatchFlags = !0, this.patchFlags = !0;
  }
  render() {
    if (this.bgPatchFlags) {
      const e = this.bgOffscreen.getContext("2d");
      e.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height, a = this.store.data.x || this.store.options.x || 0, o = this.store.data.y || this.store.options.y || 0, r = this.store.data.background || this.store.options.background;
      r && (e.save(), e.fillStyle = r, e.globalAlpha = this.store.data.globalAlpha ?? this.store.options.globalAlpha, i && s ? (e.shadowOffsetX = this.store.options.shadowOffsetX, e.shadowOffsetY = this.store.options.shadowOffsetY, e.shadowBlur = this.store.options.shadowBlur, e.shadowColor = this.store.options.shadowColor, e.fillRect(
        this.store.data.origin.x + a,
        this.store.data.origin.y + o,
        i * this.store.data.scale,
        s * this.store.data.scale
      )) : e.fillRect(0, 0, this.canvas.width, this.canvas.height), e.restore()), i && s && this.store.bkImg && (e.save(), e.drawImage(
        this.store.bkImg,
        this.store.data.origin.x + a,
        this.store.data.origin.y + o,
        i * this.store.data.scale,
        s * this.store.data.scale
      ), e.restore()), this.renderGrid(e);
    }
    if (this.patchFlags) {
      const e = this.offscreen.getContext("2d");
      e.save(), e.clearRect(0, 0, this.canvas.width, this.canvas.height), e.translate(this.store.data.x, this.store.data.y);
      for (const i of this.store.data.pens)
        if (isFinite(i.x) && // pen.template 
        i.canvasLayer === de.CanvasTemplate && i.calculative.inView) {
          if (i.name === "combine" && !i.draw)
            continue;
          bt(e, i), i.image && i.name !== "gif" && i.calculative.img && (e.save(), Ct(e, i), i.calculative.rotate && it(e, i), Rt(e, i), Wt(e, i), e.restore());
        }
      e.restore();
    }
    if (this.patchFlags || this.bgPatchFlags) {
      const e = this.canvas.getContext("2d");
      e.clearRect(0, 0, this.canvas.width, this.canvas.height), e.drawImage(
        this.bgOffscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), e.drawImage(
        this.offscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.patchFlags = !1, this.bgPatchFlags = !1;
    }
  }
  renderGrid(e) {
    const { data: i, options: s } = this.store, { grid: a, gridRotate: o, gridColor: r, gridSize: l, scale: n, origin: h } = i;
    if (!(a ?? s.grid))
      return;
    e.save();
    const c = (i.width || s.width) * n, d = (i.height || s.height) * n, f = (i.x || s.x || 0) + h.x, u = (i.y || s.y || 0) + h.y;
    o && (e.translate(c / 2, d / 2), e.rotate(o * Math.PI / 180), e.translate(-c / 2, -d / 2)), e.lineWidth = 1, e.strokeStyle = r || s.gridColor, e.beginPath();
    let g = (l || s.gridSize) * n;
    if (g = g < 0 ? 0 : g, !c || !d) {
      const y = this.store.dpiRatio, v = this.canvas.width / y, b = this.canvas.height / y, x = f / g, p = u / g, k = g * 10, R = f - Math.ceil(x) * g, A = u - Math.ceil(p) * g, P = v + R + k, E = b + A + k;
      for (let D = R; D <= P; D += g)
        e.moveTo(D, A), e.lineTo(D, b + A + k);
      for (let D = A; D <= E; D += g)
        e.moveTo(R, D), e.lineTo(v + R + k, D);
    } else {
      const y = c + f, v = d + u;
      for (let b = f; b <= y; b += g)
        e.moveTo(b, u), e.lineTo(b, d + u);
      for (let b = u; b <= v; b += g)
        e.moveTo(f, b), e.lineTo(c + f, b);
    }
    e.stroke(), e.restore();
  }
}
const Il = {
  info: {
    icon: '<svg fill="none" viewBox="0 0 24 24"><path fill="#0052d9" d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  }
};
class Sl {
  constructor(e, i) {
    O(this, "box");
    O(this, "text");
    O(this, "arrowUp");
    O(this, "arrowDown");
    O(this, "icon");
    O(this, "confirm");
    O(this, "cancel");
    O(this, "x");
    O(this, "y");
    this.parentElement = e, this.store = i, this.box = document.createElement("div"), this.text = document.createElement("div"), this.arrowUp = document.createElement("div"), this.arrowDown = document.createElement("div"), this.icon = document.createElement("div"), this.confirm = document.createElement("button"), this.cancel = document.createElement("button"), this.box.className = "meta2d-popconfirm", this.text.className = "text", this.arrowUp.className = "arrow", this.arrowDown.className = "arrow down", this.icon.className = "icon", this.confirm.className = "confirm", this.cancel.className = "cancel", this.confirm.innerHTML = "确定", this.cancel.innerHTML = "取消", this.icon.innerHTML = Il.info.icon, this.box.appendChild(this.text), this.box.appendChild(this.arrowUp), this.box.appendChild(this.arrowDown), this.box.appendChild(this.confirm), this.box.appendChild(this.cancel), this.box.appendChild(this.icon), e.appendChild(this.box);
    let s;
    for (let a = 0; a < document.styleSheets.length; a++)
      document.styleSheets[a].title === "le5le.com/popconfirm" && (s = document.styleSheets[a]);
    if (!s) {
      let a = document.createElement("style");
      a.type = "text/css", a.title = "le5le.com/popconfirm", document.head.appendChild(a), a = document.createElement("style"), a.type = "text/css", document.head.appendChild(a), s = a.sheet, s.insertRule(
        ".meta2d-popconfirm{position:absolute;z-index:999;left: -9999px;top: -9999px;padding:16px;max-width:400px;background:#fff;border-radius:6px;box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);}"
      ), s.insertRule(
        ".meta2d-popconfirm .text{outline:none;padding:0px 0px 40px 28px;border-radius:4px;color:rgba(0, 0, 0, 0.9);overflow-y:auto;line-height:22px;font-size:13px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-18px;left:50%;transform:translateX(-50%)}"
      ), s.insertRule(
        ".meta2d-popconfirm .arrow.down{top:initial;bottom: -18px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .icon{position:absolute;width:22px;height:22px;left:16px;top:16px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .confirm{position:absolute;right:16px;bottom:16px;width:40px;height:24px;text-align:center;background:#4582e6;color:#fff;border-radius:3px;border-color:transparent}"
      ), s.insertRule(
        ".meta2d-popconfirm .confirm:hover{background:#003cab;}"
      ), s.insertRule(
        ".meta2d-popconfirm .cancel{position:absolute;right:64px;bottom:16px;width:40px;height:24px;text-align:center;background:#dcdcdc;color:rgba(0, 0, 0, 0.9);border-radius:3px;border-color:transparent}"
      ), s.insertRule(
        ".meta2d-popconfirm .cancel:hover{background:#a6a6a6;}"
      );
    }
  }
  show(e, i) {
    if (!e)
      return;
    const s = this.box.getBoundingClientRect(), a = e.calculative.worldRect;
    let o = e.calculative.canvas.store.data.x + i.x - s.width / 2, r = e.calculative.canvas.store.data.y + i.y - s.height - 20;
    e.type || (o = e.calculative.canvas.store.data.x + a.x - (s.width - a.width) / 2, r = e.calculative.canvas.store.data.y + a.ey - s.height - a.height), r > 0 ? (this.arrowUp.style.borderBottomColor = "transparent", this.arrowDown.style.borderTopColor = "#fff", r -= 10) : (r += s.height + a.height + 5, r += 10, this.arrowUp.style.borderBottomColor = "#fff", this.arrowDown.style.borderTopColor = "transparent"), this.x = o, this.y = r, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  hide() {
    this.x = -9999, this.box.style.left = "-9999px";
  }
  showModal(e, i, s) {
    return new Promise((a) => {
      this.text.innerHTML = s || "确认执行操作吗？", this.show(e, i), this.confirm.onclick = () => {
        a(!0), this.hide();
      }, this.cancel.onclick = () => {
        a(!1), this.hide();
      };
    });
  }
  destroy() {
    this.box = null;
  }
}
const Ee = "-moving";
class na {
  constructor(e, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "offscreen", Ke());
    O(this, "width");
    O(this, "height");
    O(this, "externalElements", document.createElement("div"));
    O(this, "clientRect");
    O(this, "canvasRect");
    O(this, "activeRect");
    O(this, "initActiveRect");
    O(this, "dragRect");
    O(this, "lastRotate", 0);
    O(this, "sizeCPs");
    O(this, "activeInitPos");
    O(this, "hoverType", se.None);
    O(this, "resizeIndex", 0);
    O(this, "mouseDown");
    O(this, "hotkeyType");
    O(this, "mouseRight");
    O(this, "addCaches");
    O(this, "touchCenter");
    O(this, "initTouchDis");
    O(this, "initScale");
    O(this, "touchScaling");
    O(this, "touchMoving");
    O(this, "startTouches");
    O(this, "lastOffsetX", 0);
    O(this, "lastOffsetY", 0);
    O(this, "drawingLineName");
    O(this, "drawLineFns", [...vr]);
    O(this, "drawingLine");
    O(this, "pencil");
    O(this, "pencilLine");
    O(this, "movingPens");
    O(this, "patchFlagsLines", /* @__PURE__ */ new Set());
    O(this, "dock");
    O(this, "prevAnchor");
    O(this, "nextAnchor");
    O(this, "lastMouseTime", 0);
    O(this, "hoverTimer", 0);
    O(this, "fitTimer", 0);
    // 即将取消活动状态的画笔，用于Ctrl选中/取消选中画笔
    O(this, "willInactivePen");
    O(this, "patchFlags", !1);
    O(this, "lastRender", 0);
    O(this, "touchStart", 0);
    O(this, "touchStartTimer");
    O(this, "timer");
    O(this, "lastAnimateRender", 0);
    O(this, "animateRendering", !1);
    O(this, "renderTimer");
    O(this, "initPens");
    O(this, "pointSize", 8);
    O(this, "pasteOffset", !0);
    O(this, "opening", !1);
    O(this, "maxZindex", 5);
    O(this, "canMoveLine", !1);
    //moveConnectedLine=false
    O(this, "randomIdObj");
    //记录拖拽前后id变化
    O(this, "keyOptions");
    /**
     * @deprecated 改用 beforeAddPens
     */
    O(this, "beforeAddPen");
    O(this, "beforeAddPens");
    O(this, "beforeAddAnchor");
    O(this, "beforeRemovePens");
    O(this, "beforeRemoveAnchor");
    O(this, "customResizeDock");
    O(this, "customMoveDock");
    O(this, "inputParent", document.createElement("div"));
    // input = document.createElement('textarea');
    O(this, "inputDiv", document.createElement("div"));
    // inputRight = document.createElement('div');
    O(this, "dropdown", document.createElement("ul"));
    O(this, "tooltip");
    O(this, "popconfirm");
    O(this, "title");
    O(this, "mousePos", { x: 0, y: 0 });
    O(this, "scroll");
    O(this, "movingAnchor");
    // 正在移动中的瞄点
    O(this, "canvasTemplate");
    O(this, "canvasImage");
    O(this, "canvasImageBottom");
    O(this, "magnifierCanvas");
    O(this, "dialog");
    O(this, "autoPolylineFlag", !1);
    //标记open不自动计算
    O(this, "stopPropagation", (e) => {
      e.stopPropagation();
    });
    O(this, "curve", Yn);
    O(this, "polyline", el);
    O(this, "mind", Xn);
    O(this, "line", Gn);
    O(this, "onCopy", (e) => {
      this.store.options.disableClipboard || e.target !== this.externalElements && e.target !== document.body && e.target.offsetParent !== this.externalElements || this.copy();
    });
    O(this, "onCut", (e) => {
      this.store.options.disableClipboard || e.target !== this.externalElements && e.target !== document.body && e.target.offsetParent !== this.externalElements || this.cut();
    });
    O(this, "onPaste", (e) => {
      if (this.store.data.locked || this.store.options.disableClipboard || e.target !== this.externalElements && e.target !== document.body && e.target.offsetParent !== this.externalElements)
        return;
      let i;
      if (navigator.clipboard && e.clipboardData) {
        const s = e.clipboardData.items;
        if (s) {
          for (let a = 0; a < s.length; a++)
            if (s[a].type.indexOf("image") !== -1 && s[a].getAsFile()) {
              i = !0;
              break;
            }
        }
      }
      if (i) {
        const s = e.clipboardData.items;
        if (s) {
          for (let a = 0; a < s.length; a++)
            if (s[a].type.indexOf("image") !== -1 && s[a].getAsFile()) {
              const { x: o, y: r } = this.mousePos, l = s[a].getAsFile();
              let n = s[a].type.slice(6) === "gif" ? "gif" : "image";
              if (l !== null) {
                let h;
                const c = new FileReader();
                c.onload = (d) => {
                  h = d.target.result;
                  const f = new Image();
                  f.src = h, f.onload = () => {
                    const { width: u, height: g } = f, y = {
                      name: n,
                      x: o - 50 / 2,
                      y: r - g / u * 50,
                      externElement: n === "gif",
                      width: 100,
                      height: g / u * 100,
                      image: h
                    };
                    this.addPens([y]), this.active([y]), this.copy([y]);
                  };
                }, c.readAsDataURL(l);
              }
            }
        }
      } else
        this.paste();
    });
    O(this, "onMessage", (e) => {
      if (typeof e.data != "string" || !e.data || e.data.startsWith("setImmediate"))
        return;
      let i = JSON.parse(e.data);
      typeof i == "object" ? this.parent.doMessageEvent(i.name, i.value) : this.parent.doMessageEvent(i);
    });
    O(this, "onwheel", (e) => {
      if (this.inputDiv.contentEditable === "true" || this.drawingLine || this.pencil)
        return;
      if (this.store.hover && this.store.hover.onWheel) {
        this.store.hover.onWheel(this.store.hover, e);
        return;
      }
      if (this.store.data.disableScale || this.store.options.disableScale || (e.preventDefault(), e.stopPropagation(), this.mouseDown && (this.hoverType === se.Node || this.hoverType === se.Line)) || this.store.data.locked === he.Disable || this.store.data.locked === he.DisableScale || this.store.data.locked === he.DisableMoveScale) return;
      if (!e.ctrlKey && Math.abs(e.wheelDelta) < 100 && e.deltaY.toString().indexOf(".") === -1) {
        if (this.store.options.scroll && !e.metaKey && this.scroll) {
          this.scroll.wheel(e.deltaY < 0);
          return;
        }
        const o = this.store.data.scale || 1;
        this.translate(-e.deltaX / o, -e.deltaY / o);
        return;
      }
      if (Math.abs(e.wheelDelta) > 100 && this.store.options.scroll && this.scroll && !this.store.options.scrollButScale && !(e.ctrlKey || e.metaKey)) {
        this.scroll.wheel(e.deltaY < 0);
        return;
      }
      if (this.store.options.disableTouchPadScale)
        return;
      let i = 0.015;
      if (this.store.options.scaleOff)
        i = this.store.options.scaleOff, e.deltaY > 0 && (i = -this.store.options.scaleOff);
      else if (/mac os /i.test(navigator.userAgent))
        e.ctrlKey ? e.deltaY > 0 && (i *= -1) : i *= e.wheelDeltaY / 240;
      else {
        let r = 0.2;
        e.deltaY.toString().indexOf(".") !== -1 && (r = 0.01), e.deltaY > 0 ? i = -r : i = r;
      }
      let { offsetX: s, offsetY: a } = e;
      this.scale(this.store.data.scale + i, { x: s, y: a }), this.externalElements.focus();
    });
    O(this, "onkeydown", (e) => {
      var o, r, l;
      if (this.store.data.locked >= he.DisableEdit && e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA" && !e.target.dataset.meta2dIgnore && this.store.active.forEach((n) => {
        var h;
        (h = n.onKeyDown) == null || h.call(n, n, e.key);
      }), this.store.data.locked >= he.DisableEdit || e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA" || e.target.dataset.meta2dIgnore || this.store.options.unavailableKeys.includes(e.key))
        return;
      this.keyOptions || (this.keyOptions = {}), this.keyOptions.altKey = e.altKey, this.keyOptions.shiftKey = e.shiftKey, this.keyOptions.ctrlKey = e.ctrlKey, this.keyOptions.metaKey = e.metaKey;
      let i = 10, s = 10, a = null;
      if (this.store.options.strictScope) {
        const n = this.store.data.width || this.store.options.width, h = this.store.data.height || this.store.options.height;
        n && h && (a = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: n * this.store.data.scale,
          height: h * this.store.data.scale
        });
      }
      switch (e.key) {
        case " ":
          this.hotkeyType = ge.Translate;
          break;
        case "Control":
          this.drawingLine ? this.drawingLine.calculative.drawlineH = !this.drawingLine.calculative.drawlineH : this.hotkeyType || (this.patchFlags = !0, this.hotkeyType = ge.Select);
          break;
        case "Meta":
          break;
        case "Shift":
          this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor ? this.toggleAnchorHand() : this.hotkeyType || (this.patchFlags = !0, this.store.options.resizeMode || (this.hotkeyType = ge.Resize));
          break;
        case "Alt":
          if (!e.ctrlKey && !e.shiftKey && this.drawingLine) {
            const n = ue(this.drawingLine);
            n !== this.drawingLine.calculative.activeAnchor ? (ks(this.drawingLine), this.drawingLine.calculative.worldAnchors.push(n)) : this.drawingLine.calculative.worldAnchors.push({
              x: n.x,
              y: n.y
            });
            const h = this.drawLineFns.indexOf(this.drawingLineName);
            this.drawingLineName = this.drawLineFns[(h + 1) % this.drawLineFns.length], this.drawingLine.lineName = this.drawingLineName, this.drawline(), this.patchFlags = !0;
          }
          e.preventDefault();
          break;
        case "a":
        case "A":
          e.ctrlKey || e.metaKey ? (this.active(
            this.store.data.pens.filter(
              (n) => !n.parentId && n.locked !== he.Disable
            )
          ), e.preventDefault()) : this.toggleAnchorMode();
          break;
        case "Delete":
        case "Backspace":
          if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
            this.deleteFit();
            break;
          }
          !this.store.data.locked && this.delete();
          break;
        case "ArrowLeft":
          if (this.movingAnchor) {
            this.translateAnchor(-1, 0);
            break;
          }
          if (i = -1, e.shiftKey && (i = -5), (e.ctrlKey || e.metaKey) && (i = -10), i = i * this.store.data.scale, this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x + i, y: this.store.activeAnchor.y },
              {}
            );
            break;
          }
          a && this.activeRect.x + i < a.x && (i = a.x - this.activeRect.x), this.translatePens(this.store.active, i, 0);
          break;
        case "ArrowUp":
          if (this.movingAnchor) {
            this.translateAnchor(0, -1);
            break;
          }
          if (s = -1, e.shiftKey && (s = -5), (e.ctrlKey || e.metaKey) && (s = -10), s = s * this.store.data.scale, a && this.activeRect.y + s < a.y && (s = a.y - this.activeRect.y), this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + s },
              {}
            );
            break;
          }
          this.translatePens(this.store.active, 0, s);
          break;
        case "ArrowRight":
          if (this.movingAnchor) {
            this.translateAnchor(1, 0);
            break;
          }
          if (i = 1, e.shiftKey && (i = 5), (e.ctrlKey || e.metaKey) && (i = 10), i = i * this.store.data.scale, this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x + i, y: this.store.activeAnchor.y },
              {}
            );
            break;
          }
          a && this.activeRect.x + this.activeRect.width + i > a.x + a.width && (i = a.x + a.width - (this.activeRect.x + this.activeRect.width)), this.translatePens(this.store.active, i, 0);
          break;
        case "ArrowDown":
          if (this.movingAnchor) {
            this.translateAnchor(0, 1);
            break;
          }
          if (s = 1, e.shiftKey && (s = 5), (e.ctrlKey || e.metaKey) && (s = 10), s = s * this.store.data.scale, a && this.activeRect.y + this.activeRect.height + s > a.y + a.height && (s = a.y + a.height - (this.activeRect.y + this.activeRect.height)), this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + s },
              {}
            );
            break;
          }
          this.translatePens(this.store.active, 0, s);
          break;
        case "d":
        case "D":
          (o = this.store.active[0]) != null && o.locked || this.removeAnchorHand();
          break;
        case "h":
        case "H":
          (r = this.store.active[0]) != null && r.locked || this.addAnchorHand();
          break;
        case "m":
        case "M":
          this.toggleMagnifier();
          break;
        case "g":
        case "G":
          this.hoverType === se.NodeAnchor && (this.movingAnchor = this.store.hoverAnchor, this.externalElements.style.cursor = "move");
          break;
        case "s":
        case "S":
          !this.store.data.locked && this.hoverType === se.LineAnchor && this.store.hover === this.store.active[0] && this.splitLine(this.store.active[0], this.store.hoverAnchor), (e.ctrlKey || e.metaKey) && this.store.emitter.emit("save", { event: e });
          break;
        case "c":
        case "C":
          (e.ctrlKey || e.metaKey) && this.store.options.disableClipboard && this.copy();
          break;
        case "x":
        case "X":
          (e.ctrlKey || e.metaKey) && this.store.options.disableClipboard && this.cut();
          break;
        case "√":
        case "v":
        case "V":
          !e.ctrlKey && !e.metaKey && (this.pencil && this.stopPencil(), this.drawingLineName ? (this.finishDrawline(), this.drawingLineName = "") : this.drawingLineName = this.store.options.drawingLineName), !this.store.data.locked && (e.ctrlKey || e.metaKey) && (this.store.options.disableClipboard || !this.store.options.disableClipboard && e.altKey) && this.paste();
          break;
        case "b":
        case "B":
          this.drawingLineName && (this.finishDrawline(), this.drawingLineName = ""), this.pencil ? this.stopPencil() : this.drawingPencil();
          break;
        case "y":
        case "Y":
          (e.ctrlKey || e.metaKey) && this.redo();
          break;
        case "z":
        case "Z":
          e.ctrlKey || e.metaKey ? this.undo() : e.shiftKey && this.redo();
          break;
        case "Enter":
          this.drawingLineName && (this.finishDrawline(!0), this.store.active[0].anchors[0].connectTo ? this.drawingLineName = "" : this.drawingLineName = this.store.options.drawingLineName), this.store.active && (this.store.active.forEach((n) => {
            n.type ? (n.close = !n.close, n.close && ro(n), this.store.path2dMap.set(n, re.path2dDraws.line(n)), ls(n)) : n.calculative.focus = !0;
          }), this.render());
          break;
        case "Escape":
          this.drawingLineName && this.finishDrawline(), this.drawingLineName = void 0, this.stopPencil(), this.store.active && this.store.active.forEach((n) => {
            n.type || (n.calculative.focus = !1);
          }), this.movingPens && (this.getAllByPens(this.movingPens).forEach((n) => {
            this.store.pens[n.id] = void 0;
          }), this.movingPens = void 0, this.mouseDown = void 0, this.clearDock(), (l = this.store.active) == null || l.forEach((n) => {
            this.updateLines(n);
          }), this.calcActiveRect(), this.patchFlags = !0), this.hotkeyType = ge.None, this.movingAnchor = void 0, this.magnifierCanvas.magnifier && (this.magnifierCanvas.magnifier = !1, this.patchFlags = !0);
          break;
        case "E":
        case "e":
          this.store.options.disableAnchor = !this.store.options.disableAnchor, this.store.emitter.emit(
            "disableAnchor",
            this.store.options.disableAnchor
          );
          break;
        case "=":
          (e.ctrlKey || e.metaKey) && (this.scale(this.store.data.scale + 0.1), e.preventDefault(), e.stopPropagation());
          break;
        case "-":
          (e.ctrlKey || e.metaKey) && (this.scale(this.store.data.scale - 0.1), e.preventDefault(), e.stopPropagation());
          break;
        case "l":
        case "L":
          this.canMoveLine = !0;
          break;
        case "[":
          this.parent.down();
          break;
        case "]":
          this.parent.up();
          break;
        case "{":
          this.parent.bottom();
          break;
        case "}":
          this.parent.top();
          break;
        case "F":
        case "f":
          this.setFollowers();
          break;
      }
      this.render(!1);
    });
    O(this, "onkeyup", (e) => {
      switch (e.key) {
        case "l":
        case "L":
          this.canMoveLine = !1;
          break;
      }
      this.hotkeyType && this.render(), this.hotkeyType < ge.AddAnchor && (this.hotkeyType = ge.None);
    });
    O(this, "ondrop", async (e) => {
      if (this.store.data.locked) {
        console.warn("canvas is locked, can not drop");
        return;
      }
      e.preventDefault(), e.stopPropagation();
      const i = e.dataTransfer.getData("Meta2d") || e.dataTransfer.getData("Text");
      let s = null;
      try {
        i && (s = JSON.parse(i));
      } catch {
      }
      if (!s) {
        const { files: a } = e.dataTransfer;
        if (a.length && a[0].type.match("image.*") && !(this.addCaches && this.addCaches.length)) {
          const o = a[0].type === "image/gif";
          s = await this.fileToPen(a[0], o);
        } else if (this.addCaches && this.addCaches.length)
          s = this.addCaches, this.addCaches = [];
        else {
          this.store.emitter.emit("drop", void 0);
          return;
        }
      }
      if (s = Array.isArray(s) ? s : [s], s[0] && s[0].draggable !== !1) {
        const a = { x: e.offsetX, y: e.offsetY };
        this.calibrateMouse(a), this.dropPens(s, a), this.addCaches = [], this.getContainerHover(a), this.mousePos.x = a.x, this.mousePos.y = a.y, this.store.emitter.emit("mouseup", {
          x: a.x,
          y: a.y,
          pen: this.store.hoverContainer
        });
      }
      this.store.emitter.emit("drop", s || i);
    });
    O(this, "ontouchstart", (e) => {
      this.store.data.locked !== he.Disable && (this.touchStartTimer && clearTimeout(this.touchStartTimer), this.touchStartTimer = setTimeout(() => {
        this.touchStart = performance.now();
        const i = e.touches[0].pageX - this.clientRect.x, s = e.touches[0].pageY - this.clientRect.y, a = { x: i, y: s };
        if (this.calibrateMouse(a), this.getHover(a), this.onMouseDown({
          x: i,
          y: s,
          clientX: e.touches[0].clientX,
          clientY: e.touches[0].clientY,
          pageX: e.touches[0].pageX,
          pageY: e.touches[0].pageY,
          ctrlKey: e.ctrlKey || e.metaKey,
          shiftKey: e.shiftKey,
          altKey: e.altKey,
          buttons: 1
        }), e.touches.length === 2) {
          this.initTouchDis = Math.hypot(
            e.touches[0].pageX - e.touches[1].pageX,
            e.touches[0].pageY - e.touches[1].pageY
          ), this.initScale = this.store.data.scale, this.startTouches = e.touches, this.touchCenter = {
            x: e.touches[0].pageX + (e.touches[1].pageX - e.touches[0].pageX) / 2 - this.clientRect.x,
            y: e.touches[0].pageY + (e.touches[1].pageY - e.touches[0].pageY) / 2 - this.clientRect.y
          };
          return;
        } else e.touches.length === 3 && (this.store.emitter.emit("contextmenu", {
          e: {
            x: i,
            y: s,
            clientX: e.touches[0].clientX,
            clientY: e.touches[0].clientY,
            pageX: e.touches[0].pageX,
            pageY: e.touches[0].pageY
          },
          clientRect: this.clientRect
        }), e.preventDefault(), e.stopPropagation());
        this.touchStartTimer = void 0;
      }, 50));
    });
    O(this, "ontouchmove", (e) => {
      var l;
      if (this.store.data.locked === he.Disable)
        return;
      e.stopPropagation(), e.preventDefault();
      const i = performance.now();
      if (i - this.touchStart < 50)
        return;
      this.touchStart = i;
      const s = e.touches, a = s.length, o = e.touches[0].pageX - this.clientRect.x, r = e.touches[0].pageY - this.clientRect.y;
      if (a === 1)
        this.onMouseMove({
          x: o,
          y: r,
          clientX: e.changedTouches[0].clientX,
          clientY: e.changedTouches[0].clientY,
          pageX: e.changedTouches[0].pageX,
          pageY: e.changedTouches[0].pageY,
          ctrlKey: e.ctrlKey || e.metaKey,
          shiftKey: e.shiftKey,
          altKey: e.altKey,
          buttons: 1
        });
      else if (a === 2 && ((l = this.startTouches) == null ? void 0 : l.length) === 2) {
        if (!this.touchMoving && !this.touchScaling) {
          const n = this.startTouches[0].pageX - s[0].pageX, h = this.startTouches[1].pageX - s[1].pageX, c = this.startTouches[0].pageY - s[0].pageY, d = this.startTouches[1].pageY - s[1].pageY;
          (n >= 0 && h < 0 || n <= 0 && h > 0) && (c >= 0 && d < 0 || c <= 0 && d > 0) ? this.touchScaling = !0 : this.touchMoving = !0;
        }
        if (this.touchScaling) {
          if (this.store.data.disableScale || this.store.options.disableScale)
            return;
          const n = Math.hypot(
            s[0].pageX - s[1].pageX,
            s[0].pageY - s[1].pageY
          ) / this.initTouchDis;
          this.scale(this.initScale * n, G(this.touchCenter));
        }
        if (this.touchMoving) {
          if (this.store.data.locked >= he.DisableMove && this.store.data.locked !== he.DisableScale || this.store.data.disableScale || this.store.options.disableScale)
            return;
          if (this.lastOffsetX) {
            const { scale: n } = this.store.data;
            this.translate(
              (o - this.lastOffsetX) / n,
              (r - this.lastOffsetY) / n
            );
          }
          this.lastOffsetX = o, this.lastOffsetY = r;
        }
      }
    });
    O(this, "ontouchend", (e) => {
      if (this.store.data.locked === he.Disable)
        return;
      this.touchCenter = void 0, this.touchScaling = void 0, this.touchMoving = void 0, this.startTouches = void 0, this.lastOffsetX = 0, this.lastOffsetY = 0;
      const i = e.changedTouches[0].pageX - this.clientRect.x, s = e.changedTouches[0].pageY - this.clientRect.y;
      this.onMouseUp({
        x: i,
        y: s,
        clientX: e.changedTouches[0].clientX,
        clientY: e.changedTouches[0].clientY,
        pageX: e.changedTouches[0].pageX,
        pageY: e.changedTouches[0].pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: 1
      }), setTimeout(() => {
        this.render();
      }, 20);
    });
    O(this, "onGesturestart", (e) => {
      e.preventDefault();
    });
    O(this, "onMouseDown", (e) => {
      var i, s, a, o, r;
      if (e.buttons === 2 && !this.drawingLine && (this.mouseRight = ot.Down), this.hideInput(), this.popconfirm.hide(), this.store.data.locked === he.Disable || e.buttons !== 1 && e.buttons !== 2) {
        this.hoverType = se.None;
        return;
      }
      if (!this.magnifierCanvas.magnifier) {
        if (this.calibrateMouse(e), this.mousePos.x = e.x, this.mousePos.y = e.y, this.mouseDown = e, this.lastMouseTime = performance.now(), this.canvasImage.fitFlag) {
          this.canvasImage.currentFit || this.calcuActiveFit();
          return;
        }
        if (this.hotkeyType === ge.AddAnchor) {
          this.setAnchor(this.store.pointAt);
          return;
        }
        if (!this.store.options.autoAnchor && !this.drawingLine && e.shiftKey && e.ctrlKey && e.altKey) {
          this.setAnchor(this.store.pointAt), this.drawingLineName = this.store.options.drawingLineName;
          const l = this.store.activeAnchor;
          if (!l)
            return;
          const n = {
            id: ne(),
            x: l.x,
            y: l.y
          };
          this.drawingLine = this.createDrawingLine(n);
          let h = xe(this.drawingLine);
          this.drawingLine.calculative.activeAnchor = h, Ae(this.store.hover, l, this.drawingLine, n), this.drawline();
          return;
        }
        if (!(this.hotkeyType === ge.Translate || this.mouseRight === ot.Down && !this.store.options.mouseRightActive)) {
          if (this.drawingLine) {
            if (this.store.hoverAnchor) {
              const n = ue(this.drawingLine);
              this.store.hoverAnchor.type === pt.Line ? di(n, this.store.hoverAnchor, this.store) : (n.x = this.store.hoverAnchor.x, n.y = this.store.hoverAnchor.y), Ae(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                n
              ), this.drawline(), this.finishDrawline(!0);
              return;
            }
            if (!this.store.options.autoAnchor && e.shiftKey && e.altKey && e.ctrlKey) {
              this.setAnchor(this.store.pointAt);
              const n = ue(this.drawingLine), h = this.store.activeAnchor;
              if (!h)
                return;
              n.x = h.x, n.y = h.y, Ae(this.store.hover, h, this.drawingLine, n), this.drawline(), this.finishDrawline(!0);
              return;
            }
            if (e.buttons === 2 || this.drawingLineName === "mind" && ((i = this.drawingLine) == null ? void 0 : i.calculative.worldAnchors.length) > 1 || this.store.options.drawingLineLength && ((s = this.drawingLine) == null ? void 0 : s.calculative.worldAnchors.length) > this.store.options.drawingLineLength) {
              this.finishDrawline(!0), (a = this.store.active[0]) != null && a.anchors[0].connectTo || this.store.active.length == 0 ? this.drawingLineName = "" : this.drawingLineName = this.store.options.drawingLineName;
              return;
            }
            if (this.store.options.autoAnchor && this.hoverType === se.Node) {
              const n = ue(this.drawingLine), h = zt(this.store.hover, e);
              n.x = h.x, n.y = h.y, this.drawingLine.autoTo = !0, Ae(this.store.hover, h, this.drawingLine, n), this.drawline(), this.finishDrawline(!0);
              return;
            }
            const l = ue(this.drawingLine);
            l.isTemp ? (this.drawingLine.calculative.activeAnchor = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2], l.isTemp = void 0) : (this.drawingLine.calculative.activeAnchor = l, this.drawingLine.calculative.worldAnchors.push({
              x: l.x,
              y: l.y,
              penId: l.penId
            })), this.drawingLine.calculative.drawlineH = void 0, this.drawingLineName !== "polyline" && this.drawline();
          }
          if (this.drawingLineName) {
            if (this.hoverType === se.Node)
              if (this.store.options.autoAnchor) {
                this.inactive(!0);
                const l = zt(this.store.hover, e);
                this.store.hoverAnchor = l;
                const n = { id: ne(), x: l.x, y: l.y };
                this.drawingLine = this.createDrawingLine(n), this.drawingLine.autoFrom = !0, Ae(this.store.hover, l, this.drawingLine, n);
              } else
                this.inactive(), this.hoverType = se.None;
            else if (this.hoverType === se.NodeAnchor) {
              this.drawingLineName = this.store.options.drawingLineName;
              const l = {
                id: ne(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(l), this.drawingLine.calculative.activeAnchor = l, Ae(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                l
              );
            } else if (!this.drawingLine && this.drawingLineName !== "curve") {
              this.inactive(!0);
              const l = { id: ne(), x: e.x, y: e.y };
              this.drawingLine = this.createDrawingLine(l), this.drawingLine.calculative.activeAnchor = l;
            }
          } else if (this.pencil) {
            this.inactive(!0);
            const l = ne(), n = { x: e.x, y: e.y, id: ne(), penId: l };
            this.pencilLine = this.getInitPencilLine(n);
          } else {
            switch (this.hoverType) {
              case se.None:
                (this.store.data.rule || this.store.options.rule) && !this.store.options.disableRuleLine && this.addRuleLine(e), this.store.options.resizeMode && (this.hotkeyType = ge.None), this.inactive();
                break;
              case se.Node:
              case se.Line:
                if (this.store.hover) {
                  if ((o = this.store.active) != null && o.length && this.store.active.length === 1 && this.store.hover.id === this.store.active[0].id) {
                    this.calcActiveRect();
                    break;
                  }
                  const l = Ne(this.store.hover, !0);
                  let n = l || this.store.hover;
                  l && (l.container || (r = this.store.options.containerShapes) != null && r.includes(l.name)) && (n = this.store.hover), e.ctrlKey && !e.shiftKey ? (n.calculative.active ? this.willInactivePen = n : this.store.active.length > 0 && (n.calculative.active = !0, Dt(n), this.store.active.push(n), this.store.emitter.emit("active", this.store.active)), this.patchFlags = !0) : e.ctrlKey && e.shiftKey && this.store.hover.parentId ? this.active([this.store.hover]) : (!(this.activeRect && nt({ x: e.x, y: e.y }, this.activeRect)) || this.store.active.length == 1) && (n.calculative.active || (this.active([n]), this.store.options.resizeMode && (this.hotkeyType = ge.Resize))), this.calcActiveRect();
                }
                break;
              case se.LineAnchor:
                this.store.activeAnchor = this.store.hoverAnchor, this.store.hover.calculative.activeAnchor = this.store.hoverAnchor, this.active([this.store.hover]);
                break;
              case se.LineAnchorPrev:
              case se.LineAnchorNext:
                this.store.activeAnchor && (this.prevAnchor = { ...this.store.activeAnchor.prev }, this.nextAnchor = { ...this.store.activeAnchor.next });
                break;
              case se.Resize:
                this.activeInitPos = [], this.store.active.forEach((l) => {
                  this.activeInitPos.push({
                    x: (l.calculative.worldRect.x - this.activeRect.x) / this.activeRect.width,
                    y: (l.calculative.worldRect.y - this.activeRect.y) / this.activeRect.height
                  });
                });
                break;
            }
            this.store.hover && (this.store.hover.calculative.mouseDown = !0), this.store.emitter.emit("mousedown", {
              x: e.x,
              y: e.y,
              pen: this.store.hover
            });
          }
          this.render();
        }
      }
    });
    O(this, "onMouseMove", (e) => {
      var s, a, o, r, l, n, h, c;
      if (this.store.data.locked === he.Disable) {
        this.hoverType = se.None;
        return;
      }
      if (this.mouseDown && !this.mouseDown.restore && e.buttons !== 1 && e.buttons !== 2) {
        this.onMouseUp(e);
        return;
      }
      if (this.lastMouseTime) {
        if (performance.now() - this.lastMouseTime < 50) {
          this.lastMouseTime = 0;
          return;
        }
        this.lastMouseTime = 0;
      }
      if (this.calibrateMouse(e), this.mousePos.x = e.x, this.mousePos.y = e.y, this.magnifierCanvas.magnifier) {
        this.render();
        return;
      }
      if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
        const d = performance.now();
        d - this.fitTimer > 100 && (this.mouseDown ? this.updateFit(e) : this.inFitBorder(this.mousePos), this.fitTimer = d);
        return;
      }
      if (this.mouseDown && !this.store.options.disableTranslate && !this.store.data.disableTranslate) {
        if (this.mouseRight === ot.Down && (this.mouseRight = ot.Translate), this.store.data.locked === he.DisableEdit || this.store.data.locked === he.DisableScale || this.hotkeyType === ge.Translate || this.mouseRight === ot.Translate) {
          const { scale: d } = this.store.data;
          let f = (e.x - this.mouseDown.x) / d, u = (e.y - this.mouseDown.y) / d;
          e.shiftKey && !e.ctrlKey && (u = 0), e.ctrlKey && (f = 0), this.translate(f, u);
          return;
        }
        if (this.store.data.locked)
          return;
        if (!this.drawingLine && !this.pencil) {
          if (!this.drawingLineName && !this.movingAnchor) {
            if (this.hoverType === se.NodeAnchor) {
              if (!this.store.hoverAnchor)
                return;
              this.drawingLineName = this.store.options.drawingLineName;
              const d = {
                id: ne(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(d), this.drawingLine.calculative.activeAnchor = d, Ae(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                d
              ), this.drawline();
              return;
            }
          } else if (this.drawingLineName && this.hoverType === se.None) {
            const d = { id: ne(), x: e.x, y: e.y };
            this.drawingLine = this.createDrawingLine(d), this.drawingLine.calculative.activeAnchor = d, this.drawline();
            return;
          }
          if (e.buttons === 1 && (e.ctrlKey || !this.hoverType && !this.hotkeyType) && !(e.ctrlKey && (this.store.activeAnchor || (s = this.store.active) != null && s.length))) {
            this.dragRect = {
              x: Math.min(this.mouseDown.x, e.x),
              y: Math.min(this.mouseDown.y, e.y),
              ex: Math.max(this.mouseDown.x, e.x),
              ey: Math.max(this.mouseDown.y, e.y),
              width: Math.abs(e.x - this.mouseDown.x),
              height: Math.abs(e.y - this.mouseDown.y)
            }, this.render();
            return;
          }
          if (this.movingAnchor) {
            const d = e.x - this.movingAnchor.x, f = e.y - this.movingAnchor.y;
            this.translateAnchor(d, f), this.render();
            return;
          } else if (!((a = this.store.active[0]) != null && a.locked)) {
            const d = { x: e.x, y: e.y };
            if (this.hoverType === se.LineAnchor) {
              (this.dockInAnchor(e) || ((o = this.store.active[0]) == null ? void 0 : o.lineName) === "line") && !this.store.options.disableDock && !this.store.options.disableLineDock && (this.clearDock(), this.dock = Ks(
                this.store,
                d,
                this.store.activeAnchor
              ), (r = this.dock) != null && r.xDock && (d.x += this.dock.xDock.step), (l = this.dock) != null && l.yDock && (d.y += this.dock.yDock.step)), this.moveLineAnchor(d, e);
              return;
            }
            if (this.hoverType === se.LineAnchorPrev) {
              this.moveLineAnchorPrev(e);
              return;
            }
            if (this.hoverType === se.LineAnchorNext) {
              this.moveLineAnchorNext(e);
              return;
            }
          }
          if (this.hoverType === se.Rotate) {
            this.rotatePens({ x: e.x, y: e.y });
            return;
          }
          if (this.hoverType === se.Resize) {
            this.resizePens(e);
            return;
          }
          if (this.hoverType === se.Node || this.hoverType === se.Line) {
            const d = e.x - this.mouseDown.x, f = e.y - this.mouseDown.y, u = 20;
            if (e.ctrlKey && !e.shiftKey && (Math.abs(d) >= u || Math.abs(f) >= u) && (this.willInactivePen = void 0), this.store.active.length === 1) {
              const g = this.store.active[0];
              if ((g.locked === void 0 || g.locked < he.DisableMove) && ((n = g == null ? void 0 : g.onMouseMove) == null || n.call(g, g, this.mousePos)), g.calculative.focus)
                return;
            }
            this.movePens(e), this.getContainerHover(e);
            return;
          }
        } else if (this.pencil) {
          const { x: d, y: f } = e, u = { x: d, y: f };
          u.id = ne(), u.penId = this.pencilLine.id, this.pencilLine.calculative.worldAnchors.push(u), this.store.path2dMap.set(
            this.pencilLine,
            re.path2dDraws[this.pencilLine.name](this.pencilLine)
          ), this.patchFlags = !0;
        }
      }
      if (this.drawingLine) {
        const { x: d, y: f } = e, u = { x: d, y: f };
        if (u.id = ne(), u.penId = this.drawingLine.id, !this.store.options.disableDock && !this.store.options.disableLineDock && (this.clearDock(), this.dock = Ks(this.store, u), (h = this.dock) != null && h.xDock && (u.x += this.dock.xDock.step), (c = this.dock) != null && c.yDock && (u.y += this.dock.yDock.step)), this.mouseDown && this.drawingLineName === "curve" && !this.drawingLine.calculative.worldAnchors[0].connectTo)
          this.drawline(u);
        else {
          let g;
          if (this.drawingLine.calculative.worldAnchors.length > 1 && (g = ue(this.drawingLine)), g ? (g.prev = void 0, g.next = void 0, g.id || (g.id = ne()), g.x = u.x, g.y = u.y, g.connectTo = void 0) : (g = { ...u }, this.drawingLine.calculative.worldAnchors.push(g)), (this.hoverType === se.NodeAnchor || this.hoverType === se.LineAnchor) && (this.store.hoverAnchor.type !== pt.Line && (g.x = this.store.hoverAnchor.x, g.y = this.store.hoverAnchor.y), g.connectTo = this.store.hoverAnchor.penId, this.drawingLineName === "polyline" && (g.isTemp = !1)), this.drawingLineName === "line") {
            if (e.ctrlKey && !e.shiftKey)
              g.x = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].x;
            else if (e.shiftKey && !e.ctrlKey)
              g.y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].y;
            else if (e.shiftKey && e.ctrlKey) {
              let y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
              this.getSpecialAngle(g, y);
            }
          }
          this.drawline();
        }
      }
      globalThis.debug && console.time("hover");
      const i = performance.now();
      i - this.hoverTimer > 50 && (this.hoverTimer = i, this.getHover(e)), globalThis.debug && console.timeEnd("hover"), this.hotkeyType === ge.AddAnchor && (this.patchFlags = !0), this.render(!1);
    });
    O(this, "onMouseUp", (e) => {
      if (this.store.data.locked === he.Disable) {
        this.hoverType = se.None;
        return;
      }
      if (this.mouseDown) {
        if (this.mouseRight === ot.Down && (this.store.hover && this.store.hover.onContextmenu ? this.store.hover.onContextmenu(this.store.hover, e) : this.store.emitter.emit("contextmenu", {
          e,
          clientRect: this.clientRect,
          pen: this.store.hover
        })), this.mouseRight = ot.None, this.calibrateMouse(e), this.mousePos.x = e.x, this.mousePos.y = e.y, this.pencil && this.finishPencil(), this.drawingLine) {
          if (this.store.hoverAnchor) {
            const i = ue(this.drawingLine);
            this.store.hoverAnchor.type === pt.Line ? di(i, this.store.hoverAnchor, this.store) : (i.x = this.store.hoverAnchor.x, i.y = this.store.hoverAnchor.y), Ae(
              this.store.hover,
              this.store.hoverAnchor,
              this.drawingLine,
              i
            ), this.drawline(), this.finishDrawline(!0);
            return;
          }
          if (this.store.options.autoAnchor && this.hoverType === se.Node) {
            const i = ue(this.drawingLine), s = zt(this.store.hover, e);
            i.x = s.x, i.y = s.y, this.drawingLine.autoTo = !0, Ae(this.store.hover, s, this.drawingLine, i), this.drawline(), this.finishDrawline(!0);
            return;
          }
        }
        if (this.hoverType === se.LineAnchor && this.store.hover && this.store.active[0] && this.store.active[0].name === "line" && this.store.active[0] !== this.store.hover) {
          const i = this.store.active[0], s = xe(i), a = ue(i);
          if (this.store.hoverAnchor) {
            const o = this.store.hover, r = xe(o) === this.store.hoverAnchor, l = ue(o) === this.store.hoverAnchor, n = s === this.store.activeAnchor, h = a === this.store.activeAnchor;
            if ((e.ctrlKey || e.altKey) && o.type === fe.Line && (r || l) && (n || h)) {
              const c = o.calculative.worldAnchors.map(
                (d) => ({
                  ...d,
                  penId: i.id
                })
              );
              r ? c.shift() : l && c.pop(), (r && n || l && h) && c.reverse(), n ? (i.calculative.worldAnchors[0].connectTo = void 0, i.calculative.worldAnchors.unshift(...c)) : h && (i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].connectTo = void 0, i.calculative.worldAnchors.push(...c)), this.delete([o]), this.render();
            } else
              this.store.activeAnchor && (this.store.hoverAnchor.type === pt.Line ? di(
                this.store.activeAnchor,
                this.store.hoverAnchor,
                this.store
              ) : (this.store.activeAnchor.x = this.store.hoverAnchor.x, this.store.activeAnchor.y = this.store.hoverAnchor.y), Ae(
                this.store.hover,
                this.store.hoverAnchor,
                i,
                this.store.activeAnchor
              ));
            this[i.lineName] && i.lineName !== "polyline" && this[i.lineName](this.store, i), this.store.path2dMap.set(i, re.path2dDraws.line(i)), this.initLineRect(i);
          } else
            s === this.store.activeAnchor && i.autoFrom ? this.calcAutoAnchor(i, s, this.store.hover) : a === this.store.activeAnchor && i.autoTo && this.calcAutoAnchor(i, a, this.store.hover);
        }
        if (this.addCaches && this.addCaches.length) {
          if (!this.store.data.locked) {
            if (this.dragRect && this.addCaches.length === 1) {
              const i = this.addCaches[0];
              i.width = this.dragRect.width / this.store.data.scale, i.height = this.dragRect.height / this.store.data.scale, e.x = (this.dragRect.x + this.dragRect.ex) / 2, e.y = (this.dragRect.y + this.dragRect.ey) / 2;
            }
            this.dropPens(this.addCaches, e);
          }
          this.addCaches = void 0;
        }
        if (this.hoverType === se.Rotate && (this.getSizeCPs(), this.store.active.forEach((i) => {
          i.rotate = i.calculative.rotate;
        })), this.patchFlagsLines.forEach((i) => {
          i.type && this.initLineRect(i);
        }), this.patchFlagsLines.clear(), this.dragRect)
          if (this.canvasImage.fitFlag)
            this.makeFit();
          else {
            const i = this.store.data.pens.filter((s) => {
              if (s.visible === !1 || s.locked >= he.DisableMove || s.parentId || s.isRuleLine)
                return !1;
              if (tt(
                s.calculative.worldRect,
                this.dragRect,
                e.ctrlKey || this.store.options.dragAllIn
              ))
                return s.type === fe.Line && !this.store.options.dragAllIn ? Vi(s, this.dragRect) : !0;
            });
            this.active(i);
          }
        if (e.button !== 2 && (Li(this.mouseDown, e) < 2 && (this.store.hover && this.store.hover.input && this.showInput(this.store.hover), this.store.emitter.emit("click", {
          x: e.x,
          y: e.y,
          pen: this.store.hover
        })), this.store.hover && (this.store.hover.calculative.mouseDown = !1), this.store.hover != this.store.hoverContainer && this.store.emitter.emit("mouseup", {
          x: e.x,
          y: e.y,
          pen: this.store.hover
        }), this.store.emitter.emit("mouseup", {
          x: e.x,
          y: e.y,
          pen: this.store.hoverContainer
        })), this.willInactivePen) {
          this.willInactivePen.calculative.active = void 0, Dt(this.willInactivePen, !1);
          const i = this.store.active.findIndex((s) => s === this.willInactivePen);
          i >= 0 && this.store.active.splice(i, 1), this.calcActiveRect(), this.willInactivePen = void 0, this.store.emitter.emit("inactive", [this.willInactivePen]), this.render();
        }
        this.movingPens && (e.altKey && !e.shiftKey ? this.copyMovedPens() : this.movedActivePens(e.ctrlKey && e.shiftKey), this.getAllByPens(this.movingPens).forEach((i) => {
          this.store.pens[i.id] = void 0;
        }), this.movingPens = void 0), this.store.active && this.store.active[0] && (this.store.active[0].calculative.h = void 0), this.mouseDown = void 0, this.lastOffsetX = 0, this.lastOffsetY = 0, this.clearDock(), this.dragRect = void 0, this.initActiveRect = void 0, this.render();
      }
    });
    O(this, "clearDock", () => {
      var o, r, l, n;
      const e = (r = (o = this.dock) == null ? void 0 : o.xDock) == null ? void 0 : r.penId, i = (n = (l = this.dock) == null ? void 0 : l.yDock) == null ? void 0 : n.penId, s = this.store.pens[e];
      s && (s.calculative.isDock = !1);
      const a = this.store.pens[i];
      a && (a.calculative.isDock = !1), this.dock = void 0;
    });
    O(this, "onResize", () => {
      this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
        this.resize(), this.timer = void 0;
      }, 100);
    });
    O(this, "onScroll", () => {
      this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
        this.clientRect = this.canvas.getBoundingClientRect(), this.timer = void 0;
      }, 100);
    });
    O(this, "calibrateMouse", (e) => (e.x -= this.store.data.x, e.y -= this.store.data.y, e));
    O(this, "getContainerHover", (e) => {
      var s;
      if (this.dragRect)
        return;
      this.store.hoverContainer = void 0;
      const i = this.store.data.pens.filter((a) => {
        var o;
        return a.container || ((o = this.store.options.containerShapes) == null ? void 0 : o.includes(a.name));
      });
      if (i.length)
        for (let a = i.length - 1; a >= 0; --a) {
          const o = i[a];
          if (!(o.visible == !1 || o.calculative.inView == !1 || o.locked === he.Disable)) {
            if (nt(e, o.calculative.worldRect))
              this.store.hoverContainer = o, (s = o == null ? void 0 : o.onMouseMove) == null || s.call(o, o, e), this.store.lastHoverContainer !== this.store.hoverContainer && (this.patchFlags = !0, this.store.lastHoverContainer && (this.store.lastHoverContainer.calculative.containerHover = !1, this.store.emitter.emit("leave", this.store.lastHoverContainer)), this.store.hoverContainer && (this.store.hoverContainer.calculative.containerHover = !0, this.store.emitter.emit("enter", this.store.hoverContainer)), this.store.lastHoverContainer = this.store.hoverContainer);
            else if (o === this.store.hoverContainer && (this.store.hoverContainer = void 0, this.store.lastHoverContainer !== this.store.hoverContainer)) {
              this.patchFlags = !0;
              const r = this.store.lastHoverContainer.calculative.canvas.store.pens[this.store.lastHoverContainer.id + Ee];
              this.store.lastHoverContainer && !r && (this.store.lastHoverContainer.calculative.containerHover = !1, this.store.emitter.emit("leave", this.store.lastHoverContainer)), this.store.lastHoverContainer = this.store.hoverContainer;
            }
          }
        }
    });
    O(this, "getHover", (e) => {
      var a, o;
      if (this.dragRect || this.canvasImage.fitFlag)
        return;
      let i = se.None;
      this.store.hover = void 0, this.store.hoverAnchor = void 0, this.title.hide(), this.store.pointAt = void 0, this.store.pointAtIndex = void 0;
      const s = this.store.active.length === 1 && this.store.active[0].type;
      if (!this.drawingLineName && this.hotkeyType !== ge.AddAnchor && this.activeRect && !s && !this.store.data.locked) {
        const r = Hi(this.store.active), l = Ys(this.store.active) || this.store.options.disableRotate, n = $s(this.store.active) || this.store.options.disableSize;
        if (!r && !l) {
          const h = {
            x: this.activeRect.center.x,
            y: this.activeRect.y - 30
          };
          this.activeRect.rotate && ve(h, this.activeRect.rotate, this.activeRect.pivot || this.activeRect.center), !this.hotkeyType && Nt(e, h, this.pointSize) && (i = se.Rotate, this.externalElements.style.cursor = `url("${this.store.options.rotateCursor}"), auto`);
        }
        if (!r && !n)
          for (let h = 0; h < 8; h++) {
            const c = h < 4;
            if ((this.hotkeyType === ge.Resize || c && !this.hotkeyType) && Nt(e, this.sizeCPs[h], this.pointSize)) {
              let f = c ? Bs : zs, u = 0;
              Math.abs(this.activeRect.rotate % 90 - 45) < 25 ? (f = c ? zs : Bs, u = Math.round((this.activeRect.rotate - 45) / 90) + (c ? 0 : 1)) : u = Math.round(this.activeRect.rotate / 90), i = se.Resize, this.resizeIndex = h, this.externalElements.style.cursor = f[(h + u) % 4];
              break;
            }
          }
      }
      i === se.None && (i = this.inPens(e, this.store.data.pens)), !i && !s && nt(e, this.activeRect) && (i = se.Node, this.externalElements.style.cursor = "move"), this.hoverType = i, i === se.None && (this.drawingLineName || this.pencil ? this.externalElements.style.cursor = "crosshair" : this.mouseDown || (this.externalElements.style.cursor = "default"), this.store.hover = void 0), this.store.lastHover !== this.store.hover && (this.patchFlags = !0, this.store.lastHover && (this.store.lastHover.calculative.hover = !1, Kt(
        Ne(this.store.lastHover, !0) || this.store.lastHover,
        !1
      ), this.store.emitter.emit("leave", this.store.lastHover), this.tooltip.hide()), this.store.hover && (this.store.hover.calculative.hover = !0, Kt(Ne(this.store.hover, !0) || this.store.hover), this.store.emitter.emit("enter", this.store.hover), this.tooltip.show(this.store.hover, e)), this.store.lastHover = this.store.hover), (o = (a = this.store.hover) == null ? void 0 : a.onMouseMove) == null || o.call(a, this.store.hover, this.mousePos);
    });
    O(this, "inPens", (e, i) => {
      var a;
      let s = se.None;
      e: for (let o = i.length - 1; o >= 0; --o) {
        const r = i[o];
        if (r.visible == !1 || r.calculative.inView == !1 || r.locked === he.Disable)
          continue;
        const l = Ri(r);
        if (!(!r.calculative.active && !Pt(e, r.calculative.worldRect, l) && !nt(e, r.calculative.worldRect))) {
          if (!this.store.data.locked && this.hotkeyType !== ge.Resize && r.calculative.worldAnchors) {
            for (const n of r.calculative.worldAnchors)
              if (s = this.inAnchor(e, r, n), s) {
                let h = G(n);
                Object.assign(h, e), this.title.show(h, r);
                break e;
              }
          }
          if (r.type) {
            if (r.isRuleLine) {
              let h = ((a = this.store.options.ruleOptions) == null ? void 0 : a.height) || 20;
              if (e.x + this.store.data.x > h && e.y + this.store.data.y > h)
                break;
            }
            const n = Jn(e, r);
            if (n) {
              !this.store.data.locked && !r.locked ? this.hotkeyType === ge.AddAnchor ? this.externalElements.style.cursor = "pointer" : this.externalElements.style.cursor = "move" : this.externalElements.style.cursor = this.store.options.hoverCursor, r.calculative.disabled && (this.externalElements.style.cursor = "not-allowed"), this.store.hover = r, this.store.pointAt = n.point, this.store.pointAtIndex = n.i, this.initTemplateCanvas([this.store.hover]), s = se.Line;
              break;
            }
          } else {
            if (r.children) {
              const h = [];
              if (r.children.forEach((c) => {
                this.store.pens[c] && h.push(this.store.pens[c]);
              }), s = this.inPens(e, h), s)
                break;
            }
            let n = !1;
            if (r.name === "line" ? n = Pt(
              e,
              r.calculative.worldRect,
              r.lineWidth
            ) : n = nt(e, r.calculative.worldRect), n) {
              if (r.type === fe.Node && r.name === "line" && !bn(e, r.calculative.worldAnchors))
                continue;
              if (!this.store.data.locked && !r.locked ? this.hotkeyType === ge.AddAnchor ? this.externalElements.style.cursor = "pointer" : this.externalElements.style.cursor = "move" : this.externalElements.style.cursor = this.store.options.hoverCursor, r.calculative.disabled && (this.externalElements.style.cursor = "not-allowed"), this.store.hover = r, this.initTemplateCanvas([this.store.hover]), s = se.Node, this.store.pointAt = e, !e.ctrlKey) {
                let { x: h, y: c, ex: d, ey: f, rotate: u, center: g } = this.store.hover.calculative.worldRect;
                if (u) {
                  const y = [
                    { x: h, y: c },
                    { x: d, y: c },
                    { x: d, y: f },
                    { x: h, y: f }
                  ];
                  y.forEach((b) => {
                    ve(b, u, g);
                  });
                  let v = y[y.length - 1];
                  for (const b of y) {
                    if (v.y > e.y != b.y > e.y) {
                      const x = b.x + (e.y - b.y) * (v.x - b.x) / (v.y - b.y);
                      Math.abs(x - this.store.pointAt.x) < 10 && (this.store.pointAt.x = x);
                    }
                    v = b;
                  }
                } else
                  this.store.pointAt.x - 10 < h ? this.store.pointAt.x = h : this.store.pointAt.x + 10 > d && (this.store.pointAt.x = d), this.store.pointAt.y - 10 < c ? this.store.pointAt.y = c : this.store.pointAt.y + 10 > f && (this.store.pointAt.y = f);
              }
              break;
            }
          }
        }
      }
      return s;
    });
    O(this, "dockInAnchor", (e) => {
      var i, s;
      this.store.hover = void 0;
      for (let a = this.store.data.pens.length - 1; a >= 0; --a) {
        const o = this.store.data.pens[a];
        if (o.visible == !1 || o.locked === he.Disable || o === this.store.active[0])
          continue;
        let r = Ri(o);
        if (r += 2 * this.store.options.anchorRadius, !!Pt(e, o.calculative.worldRect, r) && (this.store.hover = o, this.hotkeyType !== ge.Resize && o.calculative.worldAnchors))
          for (const l of o.calculative.worldAnchors) {
            if (l.twoWay === Re.In) {
              const n = ue(this.store.active[0]);
              if (this.store.activeAnchor.id !== n.id)
                continue;
            }
            if (l.twoWay === Re.Out) {
              const n = xe(this.store.active[0]);
              if (this.store.activeAnchor.id !== n.id)
                continue;
            }
            if (!(l.twoWay === Re.DisableConnected || l.twoWay === Re.Disable || ((i = this.store.activeAnchor) == null ? void 0 : i.twoWay) === Re.DisableConnectTo || ((s = this.store.activeAnchor) == null ? void 0 : s.twoWay) === Re.Disable) && (this.title.hide(), this.inAnchor(e, o, l))) {
              let n = G(l);
              return Object.assign(n, e), this.title.show(n, o), !0;
            }
          }
      }
    });
    O(this, "imageTimer");
    O(this, "templateImageTimer");
    O(this, "render", (e) => {
      if (e && (this.opening = !1), this.opening)
        return;
      let i;
      if (e == null || e === !0 || e === 1 / 0 ? (i = performance.now(), this.patchFlags = !0) : e > 1 ? i = e : i = performance.now(), !this.patchFlags)
        return;
      if (i - this.lastRender < this.store.options.interval) {
        this.renderTimer && cancelAnimationFrame(this.renderTimer), this.renderTimer = requestAnimationFrame(this.render);
        return;
      }
      this.renderTimer = void 0, this.lastRender = i;
      const s = this.offscreen.getContext("2d");
      s.clearRect(0, 0, this.offscreen.width, this.offscreen.height), s.save(), s.translate(this.store.data.x, this.store.data.y), globalThis.debugRender && console.time("renderPens"), this.renderPens(), globalThis.debugRender && console.timeEnd("renderPens"), this.renderBorder(), this.renderHoverPoint(), s.restore(), this.magnifierCanvas.render();
      const a = this.canvas.getContext("2d");
      a.clearRect(0, 0, this.canvas.width, this.canvas.height), a.drawImage(this.offscreen, 0, 0, this.width, this.height), this.canvasTemplate.render(), this.canvasImageBottom.render(), this.canvasImage.render(), this.patchFlags = !1;
    });
    O(this, "renderPens", () => {
      const e = this.offscreen.getContext("2d");
      e.strokeStyle = ii(this.store);
      for (const i of this.store.data.pens)
        isFinite(i.x) && i.canvasLayer !== de.CanvasTemplate && (i.name === "combine" && !i.draw || i.calculative.inView && (i.canvasLayer === de.CanvasMain && i.name !== "gif" && i.image && i.calculative.img && (e.save(), Ct(e, i), i.calculative.rotate && it(e, i), Rt(e, i), Wt(e, i), e.restore()), bt(e, i)));
      this.drawingLine && bt(e, this.drawingLine), this.pencilLine && bt(e, this.pencilLine), this.movingPens && this.movingPens.forEach((i) => {
        this.renderPenContainChild(e, i);
      });
    });
    O(this, "renderPenContainChild", (e, i) => {
      var s;
      i.calculative.inView && bt(e, i), (s = i.children) == null || s.forEach((a) => {
        const o = this.store.pens[a];
        o && this.renderPenContainChild(e, o);
      });
    });
    O(this, "renderBorder", () => {
      if (!this.store.data.locked && this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !this.movingPens) {
        const e = this.offscreen.getContext("2d");
        e.save(), e.translate(0.5, 0.5);
        const i = this.activeRect.pivot || this.activeRect.center;
        if (this.activeRect.rotate && (e.translate(i.x, i.y), e.rotate(this.activeRect.rotate * Math.PI / 180), e.translate(-i.x, -i.y)), e.strokeStyle = this.store.options.activeColor, e.globalAlpha = this.store.options.activeGlobalAlpha === void 0 ? 0.3 : this.store.options.activeGlobalAlpha, e.beginPath(), e.lineWidth = this.store.options.activeLineWidth || 1, e.setLineDash(this.store.options.activeLineDash || []), e.strokeRect(
          this.activeRect.x,
          this.activeRect.y,
          this.activeRect.width,
          this.activeRect.height
        ), e.setLineDash([]), e.lineWidth = 1, e.globalAlpha = 1, Hi(this.store.active) || Ys(this.store.active) || this.store.options.disableRotate) {
          e.restore();
          return;
        }
        e.beginPath(), e.moveTo(this.activeRect.center.x, this.activeRect.y), e.lineTo(this.activeRect.center.x, this.activeRect.y - 30), e.stroke(), e.beginPath(), e.strokeStyle = this.store.options.activeColor, e.fillStyle = "#ffffff", e.arc(
          this.activeRect.center.x,
          this.activeRect.y - 30,
          5,
          0,
          Math.PI * 2
        ), e.fill(), e.stroke(), e.restore();
      }
    });
    O(this, "renderHoverPoint", () => {
      if (this.store.data.locked)
        return;
      const e = this.offscreen.getContext("2d");
      if (e.save(), e.translate(0.5, 0.5), !this.store.options.disableAnchor && this.store.hover && !this.store.hover.disableAnchor && (this.hotkeyType !== ge.Resize || this.store.active.length !== 1 || this.store.active[0] !== this.store.hover)) {
        const i = [...this.store.hover.calculative.worldAnchors];
        this.store.pointAt && this.hotkeyType === ge.AddAnchor && i.push(this.store.pointAt), i && (e.strokeStyle = this.store.hover.anchorColor || this.store.options.anchorColor, e.fillStyle = this.store.hover.anchorBackground || this.store.options.anchorBackground, i.forEach((s) => {
          if (s.hidden && s.locked > he.DisableEdit)
            return;
          if (s === this.store.hoverAnchor) {
            e.save();
            const o = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
            e.strokeStyle = o, e.fillStyle = o;
          }
          e.beginPath();
          let a = s.radius || this.store.hover.anchorRadius || this.store.options.anchorRadius;
          if (this.store.hover.type && !s.radius && !this.store.hover.anchorRadius && (a = 3, this.store.hover.calculative.lineWidth > 3 && (a = this.store.hover.calculative.lineWidth)), s.type === pt.Line) {
            let o = this.store.pens[s.penId].rotate || 0;
            this.store.pens[s.penId].calculative.flipX && (o *= -1), this.store.pens[s.penId].calculative.flipY && (o *= -1);
            let r = s.rotate + o;
            this.store.pens[s.penId].calculative.flipX && (r *= -1), this.store.pens[s.penId].calculative.flipY && (r *= -1), e.save(), e.translate(s.x, s.y), e.rotate(r * Math.PI / 180), e.translate(-s.x, -s.y), e.rect(
              s.x - s.length * this.store.data.scale / 2,
              s.y - a,
              s.length * this.store.data.scale,
              a * 2
            ), e.restore();
          } else
            e.arc(s.x, s.y, a, 0, Math.PI * 2);
          if (this.store.hover.type && this.store.hoverAnchor === s ? (e.save(), e.strokeStyle = this.store.hover.activeColor || this.store.options.activeColor, e.fillStyle = e.strokeStyle) : (s.color || s.background) && (e.save(), e.strokeStyle = s.color, e.fillStyle = s.background), e.fill(), e.stroke(), s === this.store.hoverAnchor && e.restore(), (this.store.hover.type && this.store.hoverAnchor === s || s.color || s.background) && e.restore(), !this.store.hover.parentId && this.store.hover.children && this.store.hover.children.length > 0 && s === this.store.hoverAnchor) {
            e.save(), e.beginPath(), e.lineWidth = 3;
            const o = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
            globalThis.pSBC && (e.strokeStyle = globalThis.pSBC(
              0.5,
              o
            )), e.arc(s.x, s.y, a + 1.5, 0, Math.PI * 2), e.stroke(), e.restore();
          }
        }));
      }
      this.hotkeyType !== ge.AddAnchor && !this.movingPens && // 不在移动中
      this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !Hi(this.store.active) && !$s(this.store.active) && !this.store.options.disableSize && (e.strokeStyle = this.store.options.activeColor, e.fillStyle = "#ffffff", this.sizeCPs.forEach((i, s) => {
        this.activeRect.rotate && (e.save(), e.translate(i.x, i.y), e.rotate(this.activeRect.rotate * Math.PI / 180), e.translate(-i.x, -i.y)), (s < 4 || this.hotkeyType === ge.Resize) && (e.beginPath(), e.fillRect(i.x - 4.5, i.y - 4.5, 8, 8), e.strokeRect(i.x - 5.5, i.y - 5.5, 10, 10)), this.activeRect.rotate && e.restore();
      })), !this.store.data.locked && this.dragRect && (e.save(), e.fillStyle = Ai(this.store.options.dragColor, 0.2), e.strokeStyle = this.store.options.dragColor, e.beginPath(), e.strokeRect(
        this.dragRect.x,
        this.dragRect.y,
        this.dragRect.width,
        this.dragRect.height
      ), e.fillRect(
        this.dragRect.x,
        this.dragRect.y,
        this.dragRect.width,
        this.dragRect.height
      ), e.restore()), this.dock && (e.strokeStyle = this.store.options.dockColor, this.dock.xDock && (e.beginPath(), e.moveTo(this.dock.xDock.x, this.dock.xDock.y), e.lineTo(this.dock.xDock.x, this.dock.xDock.prev.y), e.stroke()), this.dock.yDock && (e.beginPath(), e.moveTo(this.dock.yDock.x, this.dock.yDock.y), e.lineTo(this.dock.yDock.prev.x, this.dock.yDock.y), e.stroke())), e.restore();
    });
    /**
     *
     * @param pen 当前复制的画笔
     * @param parentId 父节点 id
     * @param clipboard 本次复制的全部画笔，包含子节点, 以及 origin 和 scale
     * @returns 复制后的画笔
     */
    O(this, "pastePen", (e, i) => {
      const s = e.id;
      if (Gs(e), e.parentId = i, e.type === fe.Line ? this.changeNodeConnectedLine(s, e, this.store.clipboard.pens) : this.changeLineAnchors(s, e, this.store.clipboard.pens), !e.parentId) {
        const o = this.getPenRect(
          e,
          this.store.clipboard.origin,
          this.store.clipboard.scale
        ), r = this.getPenRect(
          this.store.clipboard.initRect,
          this.store.clipboard.origin,
          this.store.clipboard.scale
        ), { origin: l, scale: n } = this.store.data;
        e.x = l.x + o.x * n, e.y = l.y + o.y * n, e.width = o.width * n, e.height = o.height * n, r.x = l.x + r.x * n, r.y = l.y + r.y * n, pe(r), this.store.clipboard.pos && (e.x -= r.center.x - this.store.clipboard.pos.x, e.y -= r.center.y - this.store.clipboard.pos.y), this.keyOptions && this.keyOptions.altKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey) ? (e.x = -this.store.data.x + this.width / 2 - e.width / 2, e.y = -this.store.data.y + this.height / 2 - e.height / 2) : this.keyOptions && this.keyOptions.shiftKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey) || (e.x += this.store.clipboard.offset * this.store.data.scale, e.y += this.store.clipboard.offset * this.store.data.scale);
      }
      this.makePen(e);
      const a = [];
      if (Array.isArray(e.children))
        for (const o of e.children) {
          const r = this.store.clipboard.pens.find(
            (l) => l.id === o
          );
          r && a.push(this.pastePen(r, e.id).id);
        }
      return e.children = a, Ze(e, !0), e;
    });
    O(this, "ondblclick", (e) => {
      var i;
      this.store.hover && (!this.store.data.locked || this.store.hover.dbInput) && !this.store.options.disableInput && (this.store.hover.onShowInput ? this.store.hover.onShowInput(this.store.hover, e) : this.store.hover && this.store.hover.parentId ? ((i = this.store.active) == null ? void 0 : i.length) === 1 && this.store.active[0].id === this.store.hover.id ? this.showInput(this.store.hover) : (this.store.pens[this.store.hover.parentId].children.forEach((s) => {
        this.store.pens[s].calculative.active = !1, this.store.pens[s].calculative.hover = !1;
      }), this.active([this.store.hover])) : this.showInput(this.store.hover)), this.store.emitter.emit("dblclick", {
        x: e.x,
        y: e.y,
        pen: this.store.hover
      });
    });
    O(this, "showInput", (e, i, s = "transparent") => {
      if (!window || !this.store.hover || this.store.hover.locked || this.store.hover.externElement || this.store.hover.disableInput || this.store.hover.disabled)
        return;
      if (this.inputDiv.dataset.penId === e.id) {
        this.inputDiv.dataset.isInput = "true", this.inputDiv.contentEditable = "true", this.inputDiv.focus();
        const c = window.getSelection();
        c.selectAllChildren(this.inputDiv), c.collapseToEnd(), this.inputDiv.scrollTop = this.inputDiv.scrollHeight, this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
        return;
      }
      !i && !e.dbInput ? this.setInputStyle(e) : (this.inputDiv.style.width = "100%", this.inputDiv.style.height = "100%");
      const a = i || e.calculative.worldTextRect, l = `${(e.calculative.tempText === void 0 ? e.text + "" || "" : e.calculative.tempText).replace(/\x20/g, "&nbsp;").split(/[\s\n]/).join("</div><div>")}</div>`.replace("</div>", "").replace(/\<div\>\<\/div\>/g, "<div><br></div>");
      this.inputDiv.innerHTML = l, this.inputParent.style.left = a.x + this.store.data.x - (e.textLeft || 0) + "px", this.inputParent.style.top = a.y + this.store.data.y - (e.textTop || 0) + "px";
      let n = a.width;
      this.inputParent.style.width = (n < 0 ? 12 : n) + "px", this.inputParent.style.height = a.height + (e.textTop || 0) + "px", this.inputParent.style.zIndex = "9999", this.inputParent.style.background = s, e.rotate % 360 ? this.inputParent.style.transform = `rotate(${e.rotate}deg)` : this.inputParent.style.transform = null, this.inputParent.style.display = "flex", this.inputDiv.dataset.penId = e.id, this.inputDiv.contentEditable = e.disableInput == null ? "true" : e.disableInput.toString(), e.dropdownList && this.dropdown.style.display !== "block" && (this.dropdown.style.background = e.dropdownBackground || "#fff", this.dropdown.style.color = e.dropdownColor || "#bdc7db", this.setDropdownList()), this.inputDiv.contentEditable = "true", this.inputDiv.focus();
      const h = window.getSelection();
      h.selectAllChildren(this.inputDiv), h.collapseToEnd(), this.inputDiv.scrollTop = this.inputDiv.scrollHeight, this.inputDiv.scrollLeft = this.inputDiv.scrollWidth, e.calculative.text = void 0, this.initTemplateCanvas([e]), this.render();
    });
    O(this, "setInputStyle", (e) => {
      e.text || (e.text = "");
      let i;
      for (let n = 0; n < document.styleSheets.length; n++)
        document.styleSheets[n].title === "le5le.com" && (i = document.styleSheets[n]);
      let s = "overflow: scroll;", a = "", o = 1;
      const { scale: r } = this.store.data;
      if (e.fontSize < 12 && (o = 12 / e.fontSize), e.textAlign ? s += `text-align: ${e.textAlign};` : s += "text-align: center;", e.textAlign && e.whiteSpace === "pre-line" && (s += `align-items: ${{
        left: "start",
        center: "center",
        right: "end"
      }[e.textAlign]};`), e.textBaseline ? s += `justify-content: ${{
        top: "start",
        middle: "center",
        bottom: "end"
      }[e.textBaseline]};` : s += "justify-content: center;", e.fontFamily && (s += `font-family: ${e.fontFamily};`), e.fontSize && (e.fontSize * r < 12 ? (s += `font-size:${e.fontSize}px;`, s += `zoom:${e.fontSize / 12 * r};`) : s += `font-size:${e.fontSize * r}px;`), s += `color:${ft(e, this.store)};`, e.fontStyle && (s += `font-style: ${e.fontStyle};`), e.fontWeight && (s += `font-weight: ${e.fontWeight};`), e.textLeft && (s += `margin-left:${r > 1 ? e.textLeft * o : e.textLeft * o / r}px;`), e.textTop && (s += `margin-top:${r > 1 ? e.textTop * o : e.textTop * o / r}px;`), e.lineHeight && (s += `line-height:${r > 1 ? e.fontSize * e.lineHeight * r : e.fontSize * e.lineHeight * o}px;`), e.textHeight)
        s += `height:${r > 1 ? e.textHeight * o * r : e.textHeight * o}px;`;
      else {
        let n = e.calculative.worldRect.height / r;
        n < 0 && (n = 0);
        let h = e.fontSize * r < 12 ? n * o : n * r * o;
        h < e.fontSize * e.lineHeight * r && (h = e.fontSize * e.lineHeight * r, s += `top:-${h / 2}px;`), s += `height:${h}px;`;
      }
      let l = null;
      if (e.textWidth)
        l = e.textWidth < 1 && e.textWidth > -1 ? e.textWidth * e.calculative.worldRect.width : e.textWidth, e.whiteSpace !== "pre-line" && (l < e.fontSize ? s += `width:${e.fontSize * 1.2 * o}px;` : s += `width:${r > 1 ? l * o * r : l * o}px;`);
      else if (e.whiteSpace === void 0 || e.whiteSpace === "break-all") {
        let n = (e.calculative.worldTextRect.width || 12) / r;
        n < 0 && (n = 0), s += `width:${e.fontSize * r < 12 ? n * o : n * r}px;`;
      }
      if (e.whiteSpace && (e.whiteSpace === "pre-line" ? s += "white-space:pre;" : (s += `white-space:${e.whiteSpace};`, e.whiteSpace === "nowrap" && (a += "display:contents;"))), e.whiteSpace !== "nowrap") {
        let n = e.fontSize * 1.2 * e.text.length, h = (l || e.calculative.worldRect.width / r) * Math.floor(
          e.calculative.worldRect.height / r / (e.lineHeight * e.fontSize)
        );
        n > h && (s += "justify-content: start;");
      }
      i.deleteRule(0), i.deleteRule(0), i.insertRule(
        `.meta2d-input
      .input-div{
        resize:none;border:none;outline:none;background:transparent;position:absolute;flex-grow:1;height:100%;width: 100%;position:absolute;left:0;top:0;display:flex;flex-direction: column;cursor: text;${s}}`
      ), i.insertRule(`.input-div div{${a}}`);
    });
    O(this, "hideInput", () => {
      if (this.inputParent.style.display === "flex") {
        this.inputParent.style.display = "none";
        const e = this.store.pens[this.inputDiv.dataset.penId];
        if (!e)
          return;
        if (e.calculative.text = e.text, this.inputDiv.dataset.value = this.inputDiv.innerHTML.replace(/\<div\>/g, `
`).replace(/\<\/div\>/g, "").replace(/\<br\>/g, "").replace(/&nbsp;/g, " ").replace(/(<([^>]+)>)/gi, ""), this.inputDiv.dataset.value = this.convertSpecialCharacter(
          this.inputDiv.dataset.value
        ), e.onInput)
          e.onInput(e, this.inputDiv.dataset.value);
        else if (e.text !== this.inputDiv.dataset.value) {
          const i = [G(e, !0)];
          e.text = this.inputDiv.dataset.value, e.calculative.text = e.text, this.inputDiv.dataset.penId = void 0, e.text && e.textAutoAdjust && Ar(e), Xe(e), this.patchFlags = !0, this.pushHistory({
            type: ie.Update,
            pens: [G(e, !0)],
            initPens: i
          }), this.store.emitter.emit("change", e), this.store.emitter.emit("valueUpdate", e);
        } else e.text === this.inputDiv.dataset.value && e.calculative.textLines.length == 0 && Xe(e);
        this.initTemplateCanvas([e]);
      }
      this.inputDiv.dataset.penId = void 0, this.dropdown.style.display = "none", this.inputDiv.dataset.isInput = "false", this.inputDiv.contentEditable = "false", this.render();
    });
    O(this, "setDropdownList", (e) => {
      this.clearDropdownList();
      const i = this.store.pens[this.inputDiv.dataset.penId];
      if (!this.store.data.locked && !["tablePlus"].includes(i.name))
        return;
      if (this.dropdown.style.display = "block", !i || !i.dropdownList) {
        this.dropdown.style.display = "none";
        return;
      }
      if (!i.dropdownList.length) {
        const o = document.createElement("div");
        o.innerText = "None", o.style.padding = "5px 12px", o.style.color = "#ddd", this.dropdown.appendChild(o);
        return;
      }
      const s = this.inputDiv.innerHTML.replace(/\<div\>/g, `
`).replace(/\<\/div\>/g, "").replace(/\<br\>/g, "");
      let a = 0;
      for (const o of i.dropdownList) {
        const r = typeof o == "string" ? o : o.text;
        e && s ? r.includes(s) && this.dropdownAppendOption(r, a) : this.dropdownAppendOption(r, a), ++a;
      }
      if (!this.dropdown.hasChildNodes()) {
        const o = document.createElement("div");
        o.innerText = "None", o.style.padding = "5px 12px", o.style.color = "#ddd", this.dropdown.appendChild(o);
      }
    });
    O(this, "selectDropdown", (e) => {
      const i = e.target, s = this.store.pens[this.inputDiv.dataset.penId];
      if (!i || !s || !s.dropdownList)
        return;
      const a = +i.dataset.i, o = s.dropdownList[a];
      if (!o)
        return;
      const r = [G(s, !0)];
      typeof o == "object" ? (this.updateValue(s, { ...o }), s.calculative.text = void 0, this.calcActiveRect()) : s.text = o + "", this.inputDiv.innerText = s.text, this.hideInput(), this.pushHistory({
        type: ie.Update,
        pens: [G(s, !0)],
        initPens: r
      }), this.render(), this.store.emitter.emit("change", s), this.store.emitter.emit("valueUpdate", s);
    });
    O(this, "inFitBorder", (e) => {
      let i;
      const s = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
      let o = {
        x: (e.x - this.store.data.origin.x) / this.store.data.scale,
        y: (e.y - this.store.data.origin.y) / this.store.data.scale
      };
      const r = this.canvasImage.activeFit;
      this.externalElements.style.cursor = "default", o.y > a * r.y - 10 && o.y < a * r.y + 10 && (i = "top", this.externalElements.style.cursor = "row-resize"), o.y > a * (r.y + r.height) - 10 && o.y < a * (r.y + r.height) + 10 && (i = "bottom", this.externalElements.style.cursor = "row-resize"), o.x > s * r.x - 10 && o.x < s * r.x && (i = "left", this.externalElements.style.cursor = "col-resize"), o.x > s * (r.x + r.width) - 10 && o.x < s * (r.x + r.width) + 10 && (i = "right", this.externalElements.style.cursor = "col-resize"), this.canvasImage.currentFit = i;
    });
    this.parent = e, this.parentElement = i, this.store = s, this.canvasTemplate = new kl(i, s), this.canvasTemplate.canvas.style.zIndex = "1", this.canvasImageBottom = new ra(i, s, !0), this.canvasImageBottom.canvas.style.zIndex = "2", i.appendChild(this.canvas), this.canvas.style.position = "absolute", this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.zIndex = "3", this.canvasImage = new ra(i, s), this.canvasImage.canvas.style.zIndex = "4", this.magnifierCanvas = new wl(this, i, s), this.magnifierCanvas.canvas.style.zIndex = "5", this.externalElements.style.position = "absolute", this.externalElements.style.left = "0", this.externalElements.style.top = "0", this.externalElements.style.outline = "none", this.externalElements.style.background = "transparent", this.externalElements.style.zIndex = "5", i.style.position = "relative", i.appendChild(this.externalElements), this.createInput(), this.tooltip = new ai(i, s), this.tooltip.box.onmouseleave = (a) => {
      this.patchFlags = !0, this.store.lastHover && (this.store.lastHover.calculative.hover = !1);
      let o = this.store.data.pens.find(
        (r) => r.calculative.hover === !0
      );
      Kt(o, !1);
    }, this.popconfirm = new Sl(i, s), this.dialog = new xl(i), this.title = new Pi(i), this.store.options.scroll && (this.scroll = new go(this)), this.store.dpiRatio = globalThis.devicePixelRatio || 1, this.store.dpiRatio < 1 ? this.store.dpiRatio = 1 : this.store.dpiRatio > 1 && this.store.dpiRatio < 1.5 && (this.store.dpiRatio = 1.5), this.clientRect = this.externalElements.getBoundingClientRect(), this.listen(), window == null || window.addEventListener("resize", this.onResize), window == null || window.addEventListener("scroll", this.onScroll), window == null || window.addEventListener("message", this.onMessage);
  }
  listen() {
    switch (this.externalElements.addEventListener("gesturestart", this.onGesturestart), this.externalElements.ondragover = (e) => e.preventDefault(), this.externalElements.ondrop = this.ondrop, this.externalElements.oncontextmenu = (e) => e.preventDefault(), this.store.options.interval = 50, this.externalElements.ontouchstart = this.ontouchstart, this.externalElements.ontouchmove = this.ontouchmove, this.externalElements.ontouchend = this.ontouchend, this.externalElements.onmousedown = (e) => {
      this.onMouseDown({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    }, this.externalElements.onmousemove = (e) => {
      e.target === this.externalElements && this.onMouseMove({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons
      });
    }, this.externalElements.onmouseup = (e) => {
      this.onMouseUp({
        x: e.offsetX,
        y: e.offsetY,
        clientX: e.clientX,
        clientY: e.clientY,
        pageX: e.pageX,
        pageY: e.pageY,
        ctrlKey: e.ctrlKey || e.metaKey,
        shiftKey: e.shiftKey,
        altKey: e.altKey,
        buttons: e.buttons,
        button: e.button
      });
    }, this.externalElements.onmouseleave = (e) => {
      this.store.data.pens.forEach((i) => {
        i.calculative.hover && (i.calculative.hover = !1);
      }), this.store.hover && (this.store.hover.calculative.hover = !1, this.store.hover = void 0), this.render(), e.toElement !== this.tooltip.box && e.toElement !== this.tooltip.arrowUp && e.toElement !== this.tooltip.arrowDown && (this.tooltip.hide(), this.store.lastHover = void 0);
    }, this.externalElements.ondblclick = this.ondblclick, this.externalElements.tabIndex = 0, this.externalElements.onblur = () => {
      this.mouseDown = void 0;
    }, this.externalElements.onwheel = this.onwheel, document.addEventListener("copy", this.onCopy), document.addEventListener("cut", this.onCut), document.addEventListener("paste", this.onPaste), this.store.options.keydown) {
      case Xt.Document:
        document.addEventListener("keydown", this.onkeydown), document.addEventListener("keyup", this.onkeyup);
        break;
      case Xt.Canvas:
        this.externalElements.addEventListener("keydown", this.onkeydown), this.externalElements.addEventListener("keyup", this.onkeyup);
        break;
    }
  }
  /**
   * 分割连线的锚点，变成两条线
   * @param line 连线
   * @param anchor 锚点，连线的某个锚点，引用相同
   */
  splitLine(e, i) {
    const s = e.calculative.worldAnchors, a = s.findIndex((c) => c === i);
    if ([-1, 0, s.length - 1].includes(a))
      return;
    const o = G(e, !0), r = G(e, !0), l = ne();
    r.id = l, r.calculative.canvas = this, r.calculative.active = !1, r.calculative.hover = !1;
    const n = G(s.slice(0, a + 1)), h = G(s.slice(a)).map((c) => (c.penId = l, c));
    e.calculative.worldAnchors = n, r.calculative.worldAnchors = h, this.initLineRect(e), this.initLineRect(r), this.store.data.pens.push(r), this.store.pens[l] = r, this.pushHistory({
      type: ie.Add,
      pens: [G(r, !0)],
      step: 2
    }), this.pushHistory({
      type: ie.Update,
      initPens: [o],
      pens: [G(e, !0)],
      step: 2
    });
  }
  translateAnchor(e, i) {
    this.movingAnchor.x += e, this.movingAnchor.y += i;
    const s = this.movingAnchor.penId;
    if (s) {
      const a = this.store.pens[s], o = a.calculative.worldRect;
      this.movingAnchor.x < o.x ? this.movingAnchor.x = o.x : this.movingAnchor.x > o.ex && (this.movingAnchor.x = o.ex), this.movingAnchor.y < o.y ? this.movingAnchor.y = o.y : this.movingAnchor.y > o.ey && (this.movingAnchor.y = o.ey);
      const r = si(this.movingAnchor, o), l = a.anchors.findIndex(
        (n) => n.id === this.movingAnchor.id
      );
      a.anchors[l] = r, this.patchFlags = !0;
    }
  }
  async fileToPen(e, i) {
    let s = "";
    return this.store.options.uploadFn ? s = await this.store.options.uploadFn(e) : this.store.options.uploadUrl ? s = await Rr(
      e,
      this.store.options.uploadUrl,
      this.store.options.uploadParams,
      this.store.options.uploadHeaders
    ) : s = await Cr(e), new Promise((a, o) => {
      const r = new Image();
      r.onload = () => {
        re.htmlElements[s] = r, a({
          width: r.width,
          height: r.height,
          name: i ? "gif" : "image",
          image: s
        });
      }, r.onerror = (l) => {
        o(l);
      }, r.crossOrigin = "anonymous", r.src = s;
    });
  }
  async dropPens(e, i) {
    var n;
    this.randomIdObj = {};
    for (const h of e)
      !h.parentId && this.randomCombineId(h, e);
    if (Object.keys(this.randomIdObj).length !== 0)
      for (const h of e)
        h.type ? (h.anchors[0].connectTo = this.randomIdObj[h.anchors[0].connectTo], h.anchors[h.anchors.length - 1].connectTo = this.randomIdObj[h.anchors[h.anchors.length - 1].connectTo]) : (n = h.connectedLines) == null || n.forEach((c) => {
          c.lineAnchor = this.randomIdObj[c.lineAnchor], c.lineId = this.randomIdObj[c.lineId];
        });
    for (const h of e)
      h.id || (h.id = ne()), !h.calculative && (h.calculative = { canvas: this }), this.store.pens[h.id] = h;
    let s = 0, a = 0, o = 0;
    for (const h of e)
      h.parentId || (h.width *= this.store.data.scale, h.height *= this.store.data.scale, h.x = i.x - h.width / 2 + o, h.y = i.y - h.height / 2 + a, h.tags && h.tags.includes("meta3d") && (h.x = this.store.data.origin.x, h.y = this.store.data.origin.y), h.dataset && (s % 2 === 0 ? o = h.width - 40 * this.store.data.scale : o = 0, s++, s % 2 === 0 && (a += h.height + 10 * this.store.data.scale)));
    const r = this.store.data.width || this.store.options.width, l = this.store.data.height || this.store.options.height;
    if (r && l) {
      let h = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: r * this.store.data.scale,
        height: l * this.store.data.scale
      }, c = !0;
      for (const d of e)
        if (!d.parentId) {
          let f = [
            { x: d.x, y: d.y },
            { x: d.x + d.width, y: d.y },
            { x: d.x, y: d.y + d.height },
            { x: d.x + d.width, y: d.y + d.height },
            { x: d.x + d.width / 2, y: d.y + d.height / 2 }
          ];
          if (d.x === h.x && d.y === h.y && d.width === h.width && d.height === h.height || f.some((u) => nt(u, h))) {
            c = !1, this.store.options.strictScope && (d.x < h.x && (d.x = h.x), d.y < h.y && (d.y = h.y), d.x + d.width > h.x + h.width && (d.x = h.x + h.width - d.width), d.y + d.height > h.y + h.height && (d.y = h.y + h.height - d.height));
            break;
          }
        }
      if (c) {
        console.info("画笔在大屏范围外");
        return;
      }
    }
    await this.addPens(e, !0), this.active(e.filter((h) => !h.parentId)), this.render(), this.externalElements.focus();
  }
  randomCombineId(e, i, s) {
    let a = null;
    e.type ? (e.anchors[0].connectTo || e.anchors[e.anchors.length - 1].connectTo) && (a = [
      e.id,
      e.anchors[0].id,
      e.anchors[e.anchors.length - 1].id
    ]) : e.connectedLines && e.connectedLines.length && (a = [e.id]), Gs(e), a && (a.length === 1 ? this.randomIdObj[a[0]] = e.id : (this.randomIdObj[a[0]] = e.id, this.randomIdObj[a[1]] = e.anchors[0].id, this.randomIdObj[a[2]] = e.anchors[e.anchors.length - 1].id)), e.parentId = s;
    const o = [];
    if (Array.isArray(e.children))
      for (const r of e.children) {
        const l = i.find((n) => n.id === r);
        l && o.push(this.randomCombineId(l, i, e.id).id);
      }
    return e.children = o, e;
  }
  async addPens(e, i, s) {
    if (this.beforeAddPens && await this.beforeAddPens(e) != !0)
      return [];
    const a = [];
    for (const o of e)
      this.beforeAddPen && this.beforeAddPen(o) != !0 || (s && (o.x = o.x * this.store.data.scale + this.store.data.origin.x, o.y = o.y * this.store.data.scale + this.store.data.origin.y, o.width = o.width * this.store.data.scale, o.height = o.height * this.store.data.scale), this.makePen(o), a.push(o));
    return this.render(), this.store.emitter.emit("add", a), i && this.pushHistory({ type: ie.Add, pens: G(a, !0) }), a;
  }
  /**
   * 获取初始化的 pencilLine
   * @param pt 需包含 penId
   */
  getInitPencilLine(e) {
    const { data: i, options: s } = this.store, a = i.scale, o = i.lineWidth || 1;
    return {
      id: e.penId,
      name: "line",
      x: e.x,
      y: e.y,
      type: fe.Line,
      calculative: {
        canvas: this,
        pencil: !0,
        active: !0,
        worldAnchors: [e],
        lineWidth: o * a
      },
      fromArrow: i.fromArrow || s.fromArrow,
      toArrow: i.toArrow || s.toArrow,
      lineWidth: o
    };
  }
  /**
   * 获取初始化的 drawingLine
   * @param pt 需包含 penId
   */
  createDrawingLine(e) {
    this.inactive();
    const { data: i, options: s } = this.store, a = i.scale, o = i.lineWidth || 1;
    return e.penId = ne(), {
      id: e.penId,
      name: "line",
      lineName: this.drawingLineName,
      x: e.x,
      y: e.y,
      type: fe.Line,
      calculative: {
        canvas: this,
        active: !0,
        worldAnchors: [e],
        lineWidth: o * a
      },
      fromArrow: i.fromArrow || s.fromArrow,
      toArrow: i.toArrow || s.toArrow,
      lineWidth: o
    };
  }
  addRuleLine(e) {
    const { x: i, y: s, scale: a, origin: o } = this.store.data, r = e.x + i, l = e.y + s;
    let n = e.x, h = e.y, c = 0, d = 0, f = 0, u = 0;
    if (r <= l && r < 20)
      n = -i, c = this.width, f = 1, e.ctrlKey || (h = Math.round((h - o.y) / (a * 10)) * (a * 10) + o.y);
    else if (l < r && l < 20)
      h = -s, d = this.height, u = 1, e.ctrlKey || (n = Math.round((n - o.x) / (a * 10)) * (a * 10) + o.x);
    else
      return;
    this.addPen({
      isRuleLine: !0,
      // locked: LockState.DisableMove,
      type: fe.Line,
      name: "line",
      lineName: "line",
      x: n,
      y: h,
      width: c,
      height: d,
      color: this.store.options.ruleLineColor,
      anchors: [
        {
          x: 0,
          y: 0
        },
        {
          x: f,
          y: u
        }
      ]
    });
  }
  clearRuleLines() {
    this.delete(this.ruleLines);
  }
  get ruleLines() {
    return this.store.data.pens.filter((e) => e.isRuleLine);
  }
  /**
   * @description 调整pen的坐标，让pen按照网格自动对齐
   * @author Joseph Ho
   * @date 14/11/2023
   * @memberof Canvas
   */
  alignPenToGrid(e) {
    var s;
    if (this.store.options.autoAlignGrid && this.store.data.grid && !e.type) {
      const a = this.store.data.gridSize || this.store.options.gridSize, { origin: o, scale: r } = this.store.data, { x: l, y: n } = e, h = { x: l, y: n }, c = this.getPenRect(e), d = parseInt((c.x / a).toFixed()), f = parseInt((c.y / a).toFixed()), u = d * a, g = f * a;
      h.x = o.x + u * r, h.y = o.y + g * r, Object.assign(e, h), (s = e.onMove) == null || s.call(e, e), this.updatePenRect(e), this.calcActiveRect(), this.getSizeCPs();
    }
  }
  /**
   * 拖拽结束，数据更新到 active.pens
   */
  movedActivePens(e) {
    let i = this.getAllFollowersByPens(this.store.active, !1);
    const s = G(i, !0), a = this.store.data.gridSize || this.store.options.gridSize, { origin: o, scale: r } = this.store.data, l = this.store.options.autoAlignGrid && this.store.data.grid;
    if (i.forEach((f) => {
      var b;
      const u = this.movingPens.findIndex((x) => x.id === f.id + Ee);
      if (u < 0)
        return;
      const { x: g, y } = this.movingPens[u], v = { x: g, y };
      if (l && !this.movingPens[u].type) {
        const x = this.getPenRect(this.movingPens[u]), p = parseInt((x.x / a).toFixed()), k = parseInt((x.y / a).toFixed()), R = p * a, A = k * a;
        v.x = o.x + R * r, v.y = o.y + A * r;
      }
      Object.assign(f, v), (b = f.onMove) == null || b.call(f, f), this.updatePenRect(f), this.updateLines(f), this.store.emitter.emit("updateLines", f), this.patchFlagsLines.forEach((x) => {
        x.type && this.initLineRect(x);
      }), this.patchFlagsLines.clear(), f.calculative.x = f.x, f.calculative.y = f.y, f.calculative.initRect && (f.calculative.initRect.x = f.calculative.x, f.calculative.initRect.y = f.calculative.y, f.calculative.initRect.ex = f.calculative.x + f.calculative.width, f.calculative.initRect.ey = f.calculative.y + f.calculative.height), Ja(f), f.parentId && this.parent.updateRectbyChild(f.calculative.worldRect, f, this.store.pens[f.parentId]);
    }), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), !this.dock) return;
    const { xDock: n, yDock: h } = this.dock;
    let c;
    n && (c = this.store.pens[n.penId]), !c && h && (c = this.store.pens[h.penId]);
    const d = G(this.store.active, !0);
    if (e && this.store.active.length === 1 && (c == null ? void 0 : c.type) === 1 && (n != null && n.anchorId || h != null && h.anchorId)) {
      const f = xe(c), u = ue(c);
      if (n != null && n.anchorId) {
        const g = this.store.pens[this.store.active[0].id + Ee].calculative.worldAnchors.find((y) => y.id === n.anchorId);
        g.x === f.x && g.y === f.y ? (s.push(G(c, !0)), Ae(this.store.active[0], g, c, f), d.push(G(c, !0))) : g.x === u.x && g.y === u.y && (s.push(G(c, !0)), Ae(this.store.active[0], g, c, u), d.push(G(c, !0)));
      } else if (h != null && h.anchorId) {
        const g = this.store.pens[this.store.active[0].id + Ee].calculative.worldAnchors.find((y) => y.id === h.anchorId);
        g.x === f.x && g.y === f.y ? (s.push(G(c, !0)), Ae(this.store.active[0], g, c, f), d.push(G(c, !0))) : g.x === u.x && g.y === u.y && (s.push(G(c, !0)), Ae(this.store.active[0], g, c, u), d.push(G(c, !0)));
      }
    }
    l && (this.calcActiveRect(), this.getSizeCPs()), this.pushHistory({
      type: ie.Update,
      pens: d,
      initPens: s
    }), this.store.emitter.emit("translatePens", d);
  }
  /**
   * 复制移动后的笔
   */
  copyMovedPens() {
    this.copy(
      this.store.active.map((e, i) => {
        const { x: s, y: a } = this.movingPens[i];
        return this.updateLines(e), {
          ...e,
          x: s,
          y: a
        };
      })
    ), this.pasteOffset = !1, this.paste();
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(e) {
    e.some((i) => this.hasImage(i, !1)) && this.canvasImage.init(), e.some((i) => this.hasImage(i, !0)) && this.canvasImageBottom.init();
  }
  initTemplateCanvas(e) {
    e.some((i) => i.canvasLayer === de.CanvasTemplate) && this.canvasTemplate.init();
  }
  hasImage(e, i) {
    var s;
    return e.image && e.name !== "gif" ? i ? e.canvasLayer === de.CanvasImageBottom : e.canvasLayer === de.CanvasImage : (s = e.children) == null ? void 0 : s.some((a) => {
      const o = this.store.pens[a];
      return o && this.hasImage(o, i);
    });
  }
  inactive(e) {
    this.store.active.length && (this.initTemplateCanvas(this.store.active), this.store.active.forEach((i) => {
      i.calculative.active = void 0, i.calculative.activeAnchor = void 0, i.calculative.hover = !1, Dt(i, !1);
    }), !e && this.store.emitter.emit("inactive", this.store.active), this.store.active = [], this.activeRect = void 0, this.sizeCPs = void 0, this.store.activeAnchor = void 0, this.patchFlags = !0);
  }
  active(e, i = !0) {
    if (this.store.active) {
      i && this.store.emitter.emit("inactive", this.store.active);
      for (const s of this.store.active)
        s.calculative.active = void 0, s.calculative.hover = !1, Dt(s, !1);
    }
    this.store.active = [], e.forEach((s) => {
      s.calculative.active = !0, Dt(s);
    }), this.store.active.push(...e), this.activeRect = void 0, this.calcActiveRect(), this.initTemplateCanvas(e), this.patchFlags = !0, i && this.store.emitter.emit("active", this.store.active);
  }
  getSizeCPs() {
    this.sizeCPs = st(this.activeRect);
    const e = [
      { x: 0.5, y: 0 },
      { x: 1, y: 0.5 },
      { x: 0.5, y: 1 },
      { x: 0, y: 0.5 }
    ], { x: i, y: s, width: a, height: o, rotate: r, center: l } = this.activeRect;
    e.forEach((n) => {
      const h = {
        x: n.x * a + i,
        y: n.y * o + s
      };
      ve(h, r, l), this.sizeCPs.push(h);
    });
  }
  getSpecialAngle(e, i) {
    let s = 0;
    e.x - i.x !== 0 ? (s = Math.atan((i.y - e.y) / (e.x - i.x)) * 180 / Math.PI, e.x < i.x && (s > 0 ? s -= 180 : s += 180)) : i.y > e.y ? s = 90 : i.y < e.y && (s = -90), s = Math.round(s / 15) * 15;
    let a = Math.sqrt(
      (i.x - e.x) * (i.x - e.x) + (i.y - e.y) * (i.y - e.y)
    );
    e.x = i.x + Math.cos(s / 180 * Math.PI) * a, e.y = i.y - Math.sin(s / 180 * Math.PI) * a;
  }
  clearHover() {
    this.hoverType = se.None, this.store.hover = null, this.store.hoverAnchor = null;
  }
  inAnchor(e, i, s) {
    var a;
    if (this.store.hoverAnchor = void 0, this.movingAnchor = void 0, !s || s.locked > he.DisableEdit || !(i.type && i.calculative.active) && this.store.options.disableAnchor || i.disableAnchor)
      return se.None;
    if ((this.mouseDown || this.drawingLine) && i.name === "line" && s.connectTo) {
      const o = this.findOne(s.connectTo);
      if (o != null && o.calculative && !(o != null && o.calculative.active)) {
        i = o;
        const r = o.calculative.worldAnchors.find(
          (l) => l.id === s.anchorId
        );
        r && (s = r);
      }
    }
    if (s.twoWay === Re.Disable && i.name !== "line")
      return se.None;
    if (i.name === "line" && s.connectTo) {
      let o = (a = this.findOne(s.connectTo)) == null ? void 0 : a.anchors.find(
        (r) => r.id === s.anchorId
      );
      if (o && o.twoWay)
        return se.None;
    }
    if (this.drawingLine) {
      if (s.twoWay === Re.Out)
        return se.None;
    } else if (!(this.mouseDown && this.hoverType === se.LineAnchor)) {
      if (s.twoWay === Re.In)
        return se.None;
    }
    if (Nt(
      e,
      s,
      this.pointSize,
      s.penId ? this.store.pens[s.penId] : void 0
    ))
      return s !== this.store.hoverAnchor && (this.patchFlags = !0), this.store.hoverAnchor = s, this.store.hover = i, i.type ? s.connectTo && !i.calculative.active && (this.store.hover = this.store.pens[s.connectTo], this.store.hover) ? (this.store.hoverAnchor = this.store.hover.calculative.worldAnchors.find(
        (o) => o.id === s.anchorId
      ), this.store.hoverAnchor ? (this.externalElements.style.cursor = "crosshair", se.NodeAnchor) : se.None) : (this.hotkeyType === ge.AddAnchor ? this.externalElements.style.cursor = "vertical-text" : this.externalElements.style.cursor = "pointer", se.LineAnchor) : (this.hotkeyType === ge.AddAnchor ? this.externalElements.style.cursor = "vertical-text" : this.externalElements.style.cursor = "crosshair", se.NodeAnchor);
    if (!this.mouseDown && i.type) {
      if (i.calculative.active && s.prev && Nt(e, s.prev, this.pointSize))
        return this.store.hoverAnchor = s, this.store.hover = i, this.externalElements.style.cursor = "pointer", se.LineAnchorPrev;
      if (i.calculative.active && s.next && Nt(e, s.next, this.pointSize))
        return this.store.hoverAnchor = s, this.store.hover = i, this.externalElements.style.cursor = "pointer", se.LineAnchorNext;
    }
    return se.None;
  }
  resize(e, i) {
    e = e || this.parentElement.clientWidth, i = i || this.parentElement.clientHeight, this.width = e, this.height = i, this.canvasRect = {
      x: 0,
      y: 0,
      width: e,
      height: i
    }, we(this.canvasRect), this.canvas.style.width = e + "px", this.canvas.style.height = i + "px", this.externalElements.style.width = e + "px", this.externalElements.style.height = i + "px", this.canvasTemplate.resize(e, i), this.canvasImage.resize(e, i), this.canvasImageBottom.resize(e, i), this.magnifierCanvas.resize(e, i), e = e * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = e, this.canvas.height = i, this.offscreen.width = e, this.offscreen.height = i, this.clientRect = this.externalElements.getBoundingClientRect(), this.canvas.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle";
    for (const s of this.store.data.pens)
      s.isRuleLine && (s.width ? s.height || (s.width = this.width) : s.height = this.height), Ze(s);
    this.render();
  }
  clearCanvas() {
    this.activeRect = void 0, this.sizeCPs = void 0, this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.offscreen.width, this.offscreen.height), this.store.data.template || this.canvasTemplate.clear(), this.canvasImage.clear(), this.canvasImageBottom.clear();
  }
  async addPen(e, i, s, a) {
    if (!(this.beforeAddPens && await this.beforeAddPens([e]) != !0) && !(this.beforeAddPen && this.beforeAddPen(e) != !0))
      return a && (e.x = e.x * this.store.data.scale + this.store.data.origin.x, e.y = e.y * this.store.data.scale + this.store.data.origin.y, e.width = e.width * this.store.data.scale, e.height = e.height * this.store.data.scale), this.makePen(e), this.active([e]), this.render(), s && this.store.emitter.emit("add", [e]), i && this.pushHistory({ type: ie.Add, pens: [e] }), e;
  }
  pushHistory(e) {
    var a;
    if (this.store.data.locked)
      return;
    const { origin: i, scale: s } = this.store.data;
    e.origin = G(i), e.scale = s, e.type !== ie.Update && e.pens && e.pens.forEach((o) => {
      o.calculative && (o.calculative.layer = this.store.data.pens.findIndex(
        (r) => r.id === o.id
      ));
    }), this.store.historyIndex < this.store.histories.length - 1 && this.store.histories.splice(
      this.store.historyIndex + 1,
      this.store.histories.length - this.store.historyIndex - 1
    ), (a = e.pens) == null || a.forEach((o) => {
      let r;
      if (e.initPens)
        for (const l of e.initPens)
          l.id === o.id && (r = l);
      if (r)
        for (const l in o)
          r[l] == null && (r[l] = void 0);
    }), this.store.histories.push(e), this.store.historyIndex = this.store.histories.length - 1, this.store.emitter.emit("update", {
      previous: e.initPens,
      current: e.pens
    });
  }
  undo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex < 0)
      return;
    const e = this.store.histories[this.store.historyIndex--];
    this.doEditAction(e, !0);
    let i = e.step;
    for (; i > 1; ) {
      const s = this.store.histories[this.store.historyIndex--];
      this.doEditAction(s, !0), i--;
    }
    (e.type == ie.Add || e.type == ie.Delete || e.type == ie.Update) && this.activeHistory();
  }
  redo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex > this.store.histories.length - 2)
      return;
    const e = this.store.histories[++this.store.historyIndex];
    this.doEditAction(e, !1);
    let i = e.step;
    for (; i > 1; ) {
      const s = this.store.histories[++this.store.historyIndex];
      this.doEditAction(s, !1), i--;
    }
    (e.type == ie.Add || e.type == ie.Delete || e.type == ie.Update) && this.activeHistory();
  }
  activeHistory() {
    let e = this.store.histories[this.store.historyIndex + 1];
    const i = [];
    if (e && e.type === ie.Update) {
      e.pens.forEach((a) => {
        i.push(this.store.pens[a.id]);
      }), this.active(i);
      return;
    }
    let s = this.store.histories[this.store.historyIndex];
    s && (s.type === ie.Add || s.type === ie.Delete) && (s.pens.forEach((a) => {
      i.push(this.store.pens[a.id]);
    }), this.active(i));
  }
  doEditAction(e, i) {
    switch (this.inactive(), this.store.hoverAnchor = void 0, this.store.hover = void 0, e.type) {
      case ie.Add:
        e.pens.forEach((o) => {
          var n;
          const r = G(o, !0), l = this.store.data.pens.findIndex(
            (h) => h.id === r.id
          );
          l > -1 && ((n = r.onDestroy) == null || n.call(r, this.store.pens[r.id]), this.store.data.pens.splice(l, 1), this.store.pens[r.id] = void 0, r.calculative || (r.calculative = {}), r.calculative.canvas = this, this.store.animates.delete(r), this.store.animateMap.delete(r));
        }), e.type = ie.Delete;
        break;
      case ie.Update:
        const s = i ? e.initPens : e.pens, a = i ? e.pens : e.initPens;
        s.forEach((o) => {
          const r = G(o, !0), l = this.store.data.pens.findIndex(
            (n) => n.id === r.id
          );
          if (l > -1) {
            if (r.calculative = this.store.data.pens[l].calculative, this.store.data.pens[l].type && this.store.data.pens[l].lastConnected) {
              for (let h in this.store.data.pens[l].lastConnected)
                if (this.store.pens[h]) {
                  let c = G(this.store.data.pens[l].lastConnected[h]);
                  this.store.pens[h].connectedLines = c, r.anchors.forEach((d) => {
                    c.forEach((f) => {
                      d.id === f.lineAnchor && (d.connectTo = h);
                    });
                  });
                }
            }
            this.store.data.pens[l] = r, this.store.pens[r.id] = r;
            for (const h in r)
              (typeof r[h] != "object" || h === "lineDash") && (r.calculative[h] = r[h]);
            r.calculative.image = void 0;
            const n = this.getPenRect(r, e.origin, e.scale);
            if (this.setPenRect(r, n, !1), this.updateLines(r, !0), r.calculative.canvas.parent.isCombine(r)) {
              let h = a.find((c) => c.id === r.id);
              La.forEach((c) => {
                r[c] !== h[c] && this.parent.setValue(
                  { id: r.id, [c]: r[c] },
                  { render: !0, doEvent: !1 }
                );
              });
            }
          }
        });
        break;
      case ie.Delete:
        e.pens.reverse().forEach((o) => {
          var l, n;
          const r = G(o, !0);
          if (r.calculative || (r.calculative = {}), this.store.data.pens.splice(
            ((l = r.calculative) == null ? void 0 : l.layer) !== -1 ? (n = r.calculative) == null ? void 0 : n.layer : this.store.data.pens.length,
            0,
            r
          ), this.store.pens[r.id] = r, r.type && r.lastConnected)
            for (let h in r.lastConnected)
              this.store.pens[h] && (this.store.pens[h].connectedLines = r.lastConnected[h]);
          r.calculative.canvas = this;
        }), e.pens.reverse().forEach((o) => {
          const r = this.store.pens[o.id], l = this.getPenRect(r, e.origin, e.scale);
          this.setPenRect(r, l, !1), r.calculative.image = void 0, r.calculative.backgroundImage = void 0, r.calculative.strokeImage = void 0, this.loadImage(r);
        }), e.type = ie.Add;
        break;
      case ie.Replace: {
        const o = i ? e.initPens : e.pens;
        (i ? e.pens : e.initPens).forEach((l) => {
          var c;
          const n = G(l, !0);
          if (this.store.data.pens.findIndex(
            (d) => d.id === n.id
          ) > -1) {
            (c = n.onDestroy) == null || c.call(n, this.store.data.pens.find((f) => f.id === n.id));
            const d = this.store.data.pens.findIndex(
              (f) => f.id === n.id
            );
            this.store.data.pens.splice(d, 1), this.store.pens[n.id] = void 0, n.calculative || (n.calculative = {}), n.calculative.canvas = this, this.store.animates.delete(n), this.store.animateMap.delete(n);
          }
        }), o.reverse().forEach((l) => {
          var h, c;
          const n = G(l, !0);
          if (n.calculative || (n.calculative = {}), this.store.data.pens.splice(
            ((h = n.calculative) == null ? void 0 : h.layer) !== -1 ? (c = n.calculative) == null ? void 0 : c.layer : this.store.data.pens.length,
            0,
            n
          ), this.store.pens[n.id] = n, n.type && n.lastConnected)
            for (let d in n.lastConnected)
              this.store.pens[d] && (this.store.pens[d].connectedLines = n.lastConnected[d]);
          n.calculative.canvas = this;
        }), o.reverse().forEach((l) => {
          const n = this.store.data.pens.find((c) => c.id === l.id), h = this.getPenRect(n, e.origin, e.scale);
          this.setPenRect(n, h, !1), n.calculative.image = void 0, n.calculative.backgroundImage = void 0, n.calculative.strokeImage = void 0, this.loadImage(n);
        }), e.type = ie.Replace;
        break;
      }
    }
    if (e.type === ie.Update) {
      let s = [...e.pens, ...e.initPens];
      this.initImageCanvas(s), this.initTemplateCanvas(s);
    } else
      this.initImageCanvas(e.pens), this.initTemplateCanvas(e.pens);
    this.parent.onSizeUpdate(), this.render(), this.store.emitter.emit(i ? "undo" : "redo", e);
  }
  makePen(e) {
    var a;
    if (e.id || (e.id = ne()), Math.abs(this.store.lastScale - this.store.data.scale) < 1e-4 && this.store.sameTemplate && this.store.templatePens[e.id] && // pen.template
    e.canvasLayer === de.CanvasTemplate) {
      e = this.store.templatePens[e.id], this.store.data.pens.push(e), this.updatePenRect(e);
      return;
    }
    if (this.store.data.pens.push(e), this.store.pens[e.id] = e, e.path) {
      !e.pathId && (e.pathId = ne());
      const o = this.store.data.paths;
      !o[e.pathId] && (o[e.pathId] = e.path), e.path = void 0;
    }
    e.lineWidth == null && (e.lineWidth = 1);
    const { fontSize: i, lineHeight: s } = this.store.options;
    e.fontSize ? e.fontSize < 0 && (e.fontSize = 0) : e.fontSize = i >= 0 ? i : 12, e.lineHeight || (e.lineHeight = s), e.image && e.name !== "gif" && e.canvasLayer === void 0 && (e.isBottom ? e.canvasLayer = de.CanvasImageBottom : e.canvasLayer = de.CanvasImage, delete e.isBottom), e.template && (e.canvasLayer = de.CanvasTemplate), e.calculative = { canvas: this, singleton: (a = e.calculative) == null ? void 0 : a.singleton }, (e.video || e.audio) && (e.calculative.onended = (o) => {
      this.nextAnimate(o);
    });
    for (const o in e)
      (typeof e[o] != "object" || o === "lineDash") && (e.calculative[o] = e[o]);
    if (e.calculative.image = void 0, e.calculative.backgroundImage = void 0, e.calculative.strokeImage = void 0, !e.anchors && re.anchors[e.name] && (e.anchors || (e.anchors = []), re.anchors[e.name](e)), !e.anchors) {
      const o = G(this.store.options.defaultAnchors);
      o.forEach((r, l) => {
        r.id = `${l}`, r.penId = e.id;
      }), e.anchors = o;
    }
    this.updatePenRect(e), !e.anchors && e.calculative.worldAnchors && (e.anchors = e.calculative.worldAnchors.map((o) => si(o, e.calculative.worldRect))), !e.rotate && (e.rotate = 0), this.loadImage(e), this.parent.penNetwork(e);
  }
  drawline(e) {
    var i;
    this.drawingLine && ((i = this[this.drawingLineName]) == null || i.call(this, this.store, this.drawingLine, e), this.store.path2dMap.set(
      this.drawingLine,
      re.path2dDraws.line(this.drawingLine)
    ), this.patchFlags = !0);
  }
  initLineRect(e) {
    var o;
    if (!e)
      return;
    if (!((o = e.calculative.worldAnchors) != null && o.length)) {
      this._del([e]);
      return;
    }
    if (!isFinite(e.x) || !isFinite(e.x) || e.x == null || e.y == null)
      return;
    const i = ns(e);
    e.parentId || Object.assign(e, i);
    const { fontSize: s, lineHeight: a } = this.store.options;
    e.fontSize || (e.fontSize = s >= 0 ? s : 12, e.calculative.fontSize = e.fontSize * this.store.data.scale), e.lineHeight || (e.lineHeight = a, e.calculative.lineHeight = e.lineHeight), pe(i), e.calculative.worldRect = i, xs(e, i), Xe(e), Ze(e), e.calculative && (e.calculative.gradientAnimatePath = void 0), this.store.path2dMap.set(e, re.path2dDraws[e.name](e)), e.calculative.worldAnchors && (e.anchors = e.calculative.worldAnchors.map((r) => si(r, e.calculative.worldRect)));
  }
  drawingPencil() {
    vo(this.store), this.pencil = !0, this.externalElements.style.cursor = "crosshair";
  }
  stopPencil() {
    this.pencil = !1, this.pencilLine = void 0, this.externalElements.style.cursor = "default";
  }
  async finishDrawline(e) {
    if (!this.drawingLine)
      return;
    const i = xe(this.drawingLine);
    let s = ue(this.drawingLine);
    if (s.isTemp && (this.drawingLine.calculative.worldAnchors.pop(), s = ue(this.drawingLine)), !e && (!s.connectTo && this.drawingLine.calculative.worldAnchors.pop(), xe(this.drawingLine) === this.drawingLine.calculative.activeAnchor)) {
      this.drawingLine = void 0, this.render();
      return;
    }
    if (!i.connectTo || !s.connectTo) {
      if (this.store.options.disableEmptyLine) {
        i.connectTo && (this.store.pens[i.connectTo].connectedLines = this.store.pens[i.connectTo].connectedLines.filter((r) => r.lineId !== this.drawingLine.id)), this.drawingLine = void 0, this.render();
        return;
      }
    } else if (this.store.options.disableRepeatLine && this.store.data.pens.find((l) => {
      if (l.type) {
        const n = xe(l), h = ue(l);
        return Hs(n, i) && Hs(h, s);
      }
    })) {
      this.drawingLine = void 0, this.render();
      return;
    }
    const a = ns(this.drawingLine);
    Object.assign(this.drawingLine, a), this.drawingLine.calculative.worldRect = a, this.drawingLine.calculative.activeAnchor = ue(this.drawingLine), this.store.activeAnchor = this.drawingLine.calculative.activeAnchor, (!this.beforeAddPens || await this.beforeAddPens([this.drawingLine])) && (!this.beforeAddPen || this.beforeAddPen(this.drawingLine)) && (this.initLineRect(this.drawingLine), this.store.data.pens.push(this.drawingLine), this.store.pens[this.drawingLine.id] = this.drawingLine, this.store.emitter.emit("add", [this.drawingLine]), this.active([this.drawingLine]), this.pushHistory({
      type: ie.Add,
      pens: G([this.drawingLine], !0)
    })), this.store.path2dMap.set(
      this.drawingLine,
      re.path2dDraws[this.drawingLine.name](this.drawingLine)
    ), this.drawingLine = void 0, this.drawingLineName = void 0, this.render();
  }
  async finishPencil() {
    if (this.pencilLine) {
      const e = cs(
        this.pencilLine.calculative.worldAnchors,
        10,
        0,
        this.pencilLine.calculative.worldAnchors.length - 1
      );
      let i = xe(this.pencilLine);
      e.unshift({ id: i.id, penId: i.penId, x: i.x, y: i.y }), i = ue(this.pencilLine), e.push({ id: i.id, penId: i.penId, x: i.x, y: i.y }), this.pencilLine.calculative.worldAnchors = nl(e), this.pencilLine.calculative.worldAnchors.length > 1 && (this.pencilLine.calculative.pencil = !1, this.store.path2dMap.set(
        this.pencilLine,
        re.path2dDraws[this.pencilLine.name](this.pencilLine)
      ), (!this.beforeAddPens || await this.beforeAddPens([this.pencilLine])) && (!this.beforeAddPen || this.beforeAddPen(this.pencilLine)) && (this.initLineRect(this.pencilLine), this.store.data.pens.push(this.pencilLine), this.store.pens[this.pencilLine.id] = this.pencilLine, this.store.emitter.emit("add", [this.pencilLine]), this.active([this.pencilLine]), this.pushHistory({
        type: ie.Add,
        pens: G([this.pencilLine], !0)
      }))), this.pencilLine = void 0, this.render();
    }
  }
  /**
   * 火狐浏览器无法绘制 svg 不存在 width height 的问题
   * 此方法手动添加 width 和 height 解决火狐浏览器绘制 svg
   * @param pen
   */
  firefoxLoadSvg(e) {
    const i = new Image(), s = new XMLHttpRequest();
    s.open("GET", e.image, !0), s.onload = () => {
      const r = new DOMParser().parseFromString(s.responseText, "text/xml").getElementsByTagName("svg")[0], { width: l, height: n } = e.calculative.worldRect;
      r.setAttribute("width", `${l}px`), r.setAttribute("height", `${n}px`);
      const c = "data:image/svg+xml;base64," + btoa(
        unescape(
          encodeURIComponent(new XMLSerializer().serializeToString(r))
        )
      );
      i.src = c, i.onload = () => {
        e.calculative.img = i, e.calculative.imgNaturalWidth = i.naturalWidth || e.iconWidth, e.calculative.imgNaturalHeight = i.naturalHeight || e.iconHeight, re.htmlElements[e.image] = i, this.imageLoaded(), e.canvasLayer === de.CanvasTemplate && this.templateImageLoaded();
      };
    }, s.send();
  }
  loadImage(e) {
    if (e.image !== e.calculative.image || !e.calculative.img) {
      if (e.calculative.img = void 0, e.image)
        if (re.htmlElements[e.image]) {
          const i = re.htmlElements[e.image];
          e.calculative.img = i, e.calculative.imgNaturalWidth = i.naturalWidth || e.iconWidth, e.calculative.imgNaturalHeight = i.naturalHeight || e.iconHeight, this.imageLoaded(), e.canvasLayer === de.CanvasTemplate && this.templateImageLoaded();
        } else if (navigator.userAgent.includes("Firefox") && e.image.endsWith(".svg"))
          this.firefoxLoadSvg(e);
        else {
          const i = new Image();
          i.crossOrigin = e.crossOrigin === "undefined" ? void 0 : e.crossOrigin || "anonymous", i.src = e.image, this.store.options.cdn && !(e.image.startsWith("http") || e.image.startsWith("//") || e.image.startsWith("data:image")) && (i.src = this.store.options.cdn + e.image), i.onload = () => {
            e.calculative.img = i, e.calculative.imgNaturalWidth = i.naturalWidth || e.iconWidth, e.calculative.imgNaturalHeight = i.naturalHeight || e.iconHeight, re.htmlElements[e.image] = i, this.imageLoaded(), e.canvasLayer === de.CanvasTemplate && this.templateImageLoaded();
          };
        }
      e.calculative.image = e.image;
    }
    if (e.backgroundImage !== e.calculative.backgroundImage) {
      if (e.calculative.backgroundImg = void 0, e.backgroundImage)
        if (re.htmlElements[e.backgroundImage]) {
          const i = re.htmlElements[e.backgroundImage];
          e.calculative.backgroundImg = i;
        } else {
          const i = new Image();
          i.crossOrigin = "anonymous", i.src = e.backgroundImage, this.store.options.cdn && !(e.backgroundImage.startsWith("http") || e.backgroundImage.startsWith("//") || e.backgroundImage.startsWith("data:image")) && (i.src = this.store.options.cdn + e.backgroundImage), i.onload = () => {
            e.calculative.backgroundImg = i, re.htmlElements[e.backgroundImage] = i, this.imageLoaded(), e.canvasLayer === de.CanvasTemplate && this.templateImageLoaded();
          };
        }
      e.calculative.backgroundImage = e.backgroundImage;
    }
    if (e.strokeImage !== e.calculative.strokeImage) {
      if (e.calculative.strokeImg = void 0, e.strokeImage)
        if (re.htmlElements[e.strokeImage]) {
          const i = re.htmlElements[e.strokeImage];
          e.calculative.strokeImg = i;
        } else {
          const i = new Image();
          i.crossOrigin = "anonymous", i.src = e.strokeImage, this.store.options.cdn && !(e.strokeImage.startsWith("http") || e.strokeImage.startsWith("//") || e.strokeImage.startsWith("data:image")) && (i.src = this.store.options.cdn + e.strokeImage), i.onload = () => {
            e.calculative.strokeImg = i, re.htmlElements[e.strokeImage] = i, this.imageLoaded(), // pen.template
            e.canvasLayer === de.CanvasTemplate && e.name !== "gif" && this.templateImageLoaded();
          };
        }
      e.calculative.strokeImage = e.strokeImage;
    }
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  imageLoaded() {
    this.imageTimer && clearTimeout(this.imageTimer), this.imageTimer = setTimeout(() => {
      this.canvasImage.init(), this.canvasImageBottom.init(), this.render();
    }, 100);
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  templateImageLoaded() {
    this.templateImageTimer && clearTimeout(this.templateImageTimer), this.templateImageTimer = setTimeout(() => {
      this.canvasTemplate.init(), this.render();
    }, 100);
  }
  setCalculativeByScale(e) {
    const i = this.store.data.scale;
    e.calculative.lineWidth = e.lineWidth * i, e.calculative.fontSize = e.fontSize * i, e.fontSize < 1 && e.fontSize > 0 && (e.calculative.fontSize = e.fontSize * e.calculative.worldRect.height), e.calculative.iconSize = e.iconSize * i, e.calculative.iconWidth = e.iconWidth * i, e.calculative.iconHeight = e.iconHeight * i, e.calculative.iconLeft = e.iconLeft < 1 && e.iconLeft > -1 ? e.iconLeft : e.iconLeft * i, e.calculative.iconTop = e.iconTop < 1 && e.iconTop > -1 ? e.iconTop : e.iconTop * i, e.calculative.textWidth = e.textWidth < 1 && e.textWidth > -1 ? e.textWidth : e.textWidth * i, e.calculative.textHeight = e.textHeight < 1 && e.textHeight > -1 ? e.textHeight : e.textHeight * i, e.calculative.textLeft = e.textLeft < 1 && e.textLeft > -1 ? e.textLeft * e.calculative.worldRect.width : e.textLeft * i, e.calculative.textTop = e.textTop < 1 && e.textTop > -1 ? e.textTop * e.calculative.worldRect.height : e.textTop * i, e.type === fe.Line && e.borderWidth && (e.calculative.borderWidth = e.borderWidth * i);
  }
  updatePenRect(e, {
    worldRectIsReady: i,
    playingAnimate: s
  } = {}) {
    i ? xi(e) : Ga(e), s || this.setCalculativeByScale(e), Vt(e), Vs(this.store.pens, e), Xe(e), Ze(e), re.path2dDraws[e.name] && this.store.path2dMap.set(e, re.path2dDraws[e.name](e)), e.calculative.patchFlags = !0, this.patchFlags = !0, e.children && e.children.forEach((a) => {
      const o = this.store.pens[a];
      o && this.updatePenRect(o, { worldRectIsReady: !1 });
    }), e.type && this.initLineRect(e), e.calculative.gradientTimer && clearTimeout(e.calculative.gradientTimer), e.calculative.gradientTimer = setTimeout(() => {
      e.calculative.lineGradient && (e.calculative.lineGradient = null), e.calculative.gradient && (e.calculative.gradient = null), e.calculative.radialGradient && (e.calculative.radialGradient = null), this.patchFlags = !0, e.calculative.gradientTimer = void 0;
    }, 50);
  }
  translate(e = 0, i = 0) {
    if (this.store.data.x += e * this.store.data.scale, this.store.data.y += i * this.store.data.scale, this.store.data.x = Math.round(this.store.data.x), this.store.data.y = Math.round(this.store.data.y), this.store.options.padding) {
      let s = Qe(this.store.options.padding);
      const a = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
      this.width < (a + s[1] + s[3]) * this.store.data.scale && (this.store.data.x + this.store.data.origin.x > s[3] * this.store.data.scale && (this.store.data.x = s[3] * this.store.data.scale - this.store.data.origin.x), this.store.data.x + this.store.data.origin.x + a * this.store.data.scale < this.width - s[1] * this.store.data.scale && (this.store.data.x = this.width - s[1] * this.store.data.scale - (this.store.data.origin.x + a * this.store.data.scale))), this.height < (o + s[0] + s[2]) * this.store.data.scale && (this.store.data.y + this.store.data.origin.y > s[0] * this.store.data.scale && (this.store.data.y = s[0] * this.store.data.scale - this.store.data.origin.y), this.store.data.y + this.store.data.origin.y + o * this.store.data.scale < this.height - s[2] * this.store.data.scale && (this.store.data.y = this.height - s[2] * this.store.data.scale - (this.store.data.origin.y + o * this.store.data.scale)));
    }
    this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init(), this.render(), this.store.emitter.emit("translate", {
      x: this.store.data.x,
      y: this.store.data.y
    }), this.tooltip.translate(e, i), this.scroll && this.scroll.isShow && this.scroll.translate(e, i), this.onMovePens();
  }
  onMovePens() {
    var i;
    const e = this.parent.map;
    e && e.isShow && e.setView();
    for (const s of this.store.data.pens)
      Ze(s), (i = s.onMove) == null || i.call(s, s), s.isRuleLine && (s.width ? s.height || (s.x = -this.store.data.x) : s.y = -this.store.data.y, this.updatePenRect(s));
  }
  /**
   * 缩放整个画布
   * @param scale 缩放比例，最终的 data.scale
   * @param center 中心点，引用类型，存在副作用，会更改原值
   */
  scale(e, i = { x: 0, y: 0 }) {
    var l;
    const s = this.store.data.minScale || this.store.options.minScale, a = this.store.data.maxScale || this.store.options.maxScale;
    if (!(e >= s && e <= a))
      return;
    this.calibrateMouse(i);
    const o = e / this.store.data.scale;
    this.store.data.scale = e, this.store.data.center = i, (l = this.store.clipboard) != null && l.pos && Si(this.store.clipboard.pos, o, i), Si(this.store.data.origin, o, i), this.store.data.pens.forEach((n) => {
      if (!n.parentId) {
        if (Mt(n, o, i), n.onScale && n.onScale(n), n.isRuleLine) {
          const h = 1 / o, c = n.calculative.worldRect.center;
          n.width && n.height || Mt(n, h, c);
        }
        this.updatePenRect(n, { worldRectIsReady: !0 }), this.execPenResize(n);
      }
    }), this.onMovePens(), this.calcActiveRect(), this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init();
    const r = this.parent.map;
    r && r.isShow && r.setView(), this.render(), this.store.emitter.emit("scale", this.store.data.scale);
  }
  templateScale(e, i = { x: 0, y: 0 }) {
    const { minScale: s, maxScale: a } = this.store.options;
    if (!(e >= s && e <= a))
      return;
    const o = e / this.store.data.scale;
    this.store.data.scale = e, this.store.data.center = { x: 0, y: 0 }, this.store.data.origin = { x: 0, y: 0 }, this.store.data.pens.forEach((r) => {
      if (!r.parentId) {
        if (Mt(r, o, i), r.onScale && r.onScale(r), r.isRuleLine) {
          const l = o > 1 ? 1 : 1 / o / o, n = r.calculative.worldRect.center;
          r.width && r.height || Mt(r, l, n);
        }
        this.execPenResize(r);
      }
    }), this.calcActiveRect();
  }
  rotatePens(e) {
    this.initPens || (this.initPens = G(this.getAllByPens(this.store.active))), this.activeRect.rotate = ze(e, this.activeRect.center), this.activeRect.rotate % 90 < 10 && (this.activeRect.rotate -= this.activeRect.rotate % 90), this.activeRect.rotate % 90 > 80 && (this.activeRect.rotate += 90 - this.activeRect.rotate % 90), this.store.active.length === 1 && (this.lastRotate = this.store.active[0].rotate || 0);
    const i = this.activeRect.rotate - this.lastRotate;
    for (const s of this.store.active) {
      if (s.parentId)
        return;
      this.rotatePen(s, i, this.activeRect), s.onRotate && s.onRotate(s), this.updateLines(s);
    }
    this.lastRotate = this.activeRect.rotate, this.getSizeCPs(), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), this.render(), this.store.emitter.emit("rotatePens", this.store.active), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: ie.Update,
        pens: G(this.getAllByPens(this.store.active)),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  resizePens(e) {
    if (this.initPens || (this.initPens = G(this.store.active, !0)), !this.initActiveRect) {
      this.initActiveRect = G(this.activeRect);
      return;
    }
    const i = { x: this.mouseDown.x, y: this.mouseDown.y }, s = { x: e.x, y: e.y };
    let a = s.x - i.x, o = s.y - i.y;
    const r = G(this.initActiveRect);
    if (Js(r, a, o, this.resizeIndex), pe(r), !this.store.options.disableDock) {
      this.clearDock();
      const u = this.customResizeDock || hn;
      this.dock = u(
        this.store,
        r,
        this.store.active,
        this.resizeIndex
      );
      const { xDock: g, yDock: y } = this.dock;
      if (g) {
        a += g.step;
        const v = this.store.pens[g.penId];
        v.calculative.isDock = !0;
      }
      if (y) {
        o += y.step;
        const v = this.store.pens[y.penId];
        v.calculative.isDock = !0;
      }
    }
    const l = this.activeRect.width, n = this.activeRect.height;
    let h = a - this.lastOffsetX, c = o - this.lastOffsetY;
    if (this.lastOffsetX = a, this.lastOffsetY = o, (e.ctrlKey || this.initPens.length === 1 && this.initPens[0].ratio) && (c = ([1, 3].includes(this.resizeIndex) ? -1 : 1) * (h * n) / l), this.activeRect.ratio = this.initPens[0].ratio, Js(this.activeRect, h, c, this.resizeIndex), this.store.options.strictScope) {
      const u = this.store.data.width || this.store.options.width, g = this.store.data.height || this.store.options.height;
      if (u && g) {
        let y = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: u * this.store.data.scale,
          height: g * this.store.data.scale
        };
        this.activeRect.x < y.x && (this.activeRect.width = this.activeRect.width - (y.x - this.activeRect.x), this.activeRect.x = y.x), this.activeRect.y < y.y && (this.activeRect.height = this.activeRect.height - (y.y - this.activeRect.y), this.activeRect.y = y.y), this.activeRect.x + this.activeRect.width > y.x + y.width && (this.activeRect.width = this.activeRect.width - (this.activeRect.x + this.activeRect.width - (y.x + y.width)), this.activeRect.x = y.x + y.width - this.activeRect.width, this.activeRect.ex = this.activeRect.x + this.activeRect.width), this.activeRect.y + this.activeRect.height > y.y + y.height && (this.activeRect.height = this.activeRect.height - (this.activeRect.y + this.activeRect.height - (y.y + y.height)), this.activeRect.y = y.y + y.height - this.activeRect.height, this.activeRect.ey = this.activeRect.y + this.activeRect.height);
      }
    }
    pe(this.activeRect);
    const d = this.activeRect.width / l, f = this.activeRect.height / n;
    this.store.active.forEach((u, g) => {
      u.calculative.worldRect.x = this.activeInitPos[g].x * this.activeRect.width + this.activeRect.x, u.calculative.worldRect.y = this.activeInitPos[g].y * this.activeRect.height + this.activeRect.y, u.calculative.worldRect.width *= d, u.calculative.iconWidth && (u.calculative.iconWidth *= d), u.calculative.worldRect.height *= f, u.calculative.iconHeight && (u.calculative.iconHeight *= f), we(u.calculative.worldRect), pe(u.calculative.worldRect), this.updatePenRect(u, { worldRectIsReady: !0 }), this.execPenResize(u), this.updateLines(u);
    }), this.getSizeCPs(), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), this.render(), this.store.emitter.emit("resizePens", this.store.active), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: ie.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  movePens(e) {
    var l, n;
    if (!this.activeRect || this.store.data.locked)
      return;
    if (!this.initActiveRect) {
      this.initActiveRect = G(this.activeRect);
      return;
    }
    if (!this.store.options.moveConnectedLine && !this.canMoveLine && this.store.active.length === 1 && ((l = this.store.active[0].anchors[0]) != null && l.connectTo || (n = this.store.active[0].anchors[this.store.active[0].anchors.length - 1]) != null && n.connectTo) || (this.movingPens || (this.initMovingPens(), this.store.active.forEach((h) => {
      Kt(h, !1);
    }), this.store.hover = void 0), !this.mouseDown))
      return;
    let i = e.x - this.mouseDown.x, s = e.y - this.mouseDown.y;
    e.shiftKey && !e.ctrlKey && (s = 0), e.ctrlKey && (i = 0);
    const a = G(this.initActiveRect);
    It(a, i, s);
    let o = !1;
    if (this.store.options.strictScope) {
      const h = this.store.data.width || this.store.options.width, c = this.store.data.height || this.store.options.height;
      if (h && c) {
        let d = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: h * this.store.data.scale,
          height: c * this.store.data.scale
        };
        a.x < d.x && (a.x = d.x, o = !0), a.y < d.y && (a.y = d.y, o = !0), a.x + a.width > d.x + d.width && (a.x = d.x + d.width - a.width, o = !0), a.y + a.height > d.y + d.height && (a.y = d.y + d.height - a.height, o = !0);
      }
    }
    const r = {
      x: a.x - this.activeRect.x,
      y: a.y - this.activeRect.y
    };
    if (!this.store.options.disableDock && !o) {
      this.clearDock();
      const h = this.customMoveDock || cn;
      this.dock = h(this.store, a, this.movingPens, r);
      const { xDock: c, yDock: d } = this.dock;
      let f;
      c && (r.x += c.step, f = this.store.pens[c.penId], f.calculative.isDock = !0), d && (r.y += d.step, f = this.store.pens[d.penId], f.calculative.isDock = !0);
    }
    this.translatePens(this.movingPens, r.x, r.y, !0);
  }
  /**
   * 初始化移动，更改画笔的 id parentId 等关联关系
   * @param pen 要修改的画笔
   * @param pens 本次操作的画笔们，包含子画笔
   */
  changeIdsByMoving(e, i) {
    e.id += Ee, e.parentId && i.find((s) => s.id === e.parentId) && (e.parentId += Ee), e.children && (e.children = e.children.map((s) => s + Ee)), e.connectedLines && (e.connectedLines = e.connectedLines.map((s) => (i.find((a) => a.id === s.lineId) && (s.lineId += Ee), s))), e.type && e.calculative.worldAnchors && (e.calculative.worldAnchors = e.calculative.worldAnchors.map(
      (s) => (s.connectTo && i.find((a) => a.id === s.connectTo) && (s.connectTo += Ee), s)
    ));
  }
  /**
   * 初始化 this.movingPens
   * 修改 ids （id parentId children 等）
   * 半透明，去图片
   */
  initMovingPens() {
    var s, a;
    if (!this.store.options.moveConnectedLine && !this.canMoveLine)
      for (let o = 0; o < this.store.active.length; o++) {
        const r = this.store.active[o];
        ((s = r.anchors[0]) != null && s.connectTo || (a = r.anchors[r.anchors.length - 1]) != null && a.connectTo) && (this.store.active.splice(o, 1), r.calculative.active = void 0, --o);
      }
    this.movingPens = G(this.store.active, !0), this.movingPens = this.getAllFollowersByPens(this.movingPens);
    const e = this.getAllByPens(this.movingPens), i = G(e, !0);
    e.forEach((o) => {
      this.changeIdsByMoving(o, i), this.store.pens[o.id] = o, o.calculative.canvas = this;
      const r = {
        globalAlpha: 0.5
      };
      o.lineWidth === 0 && (r.lineWidth = 1), (o.name.endsWith("Dom") || fr.includes(o.name) || this.store.options.domShapes.includes(o.name) || o.image) && (r.name = "rectangle", r.onDestroy = void 0), this.updateValue(o, r), o.calculative.image = void 0;
    });
  }
  moveLineAnchor(e, i) {
    var l, n, h, c, d;
    if (!this.activeRect || this.store.data.locked)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), (l = this.store.activeAnchor) != null && l.connectTo) {
      const f = this.store.pens[this.store.activeAnchor.connectTo];
      Ht(
        f,
        wt(f, this.store.activeAnchor.anchorId),
        this.store.pens[this.store.activeAnchor.penId],
        this.store.activeAnchor
      );
    }
    let s = (n = this.store.activeAnchor) == null ? void 0 : n.id, a = (c = (h = this.store.pens[this.store.activeAnchor.penId]) == null ? void 0 : h.connectedLines) == null ? void 0 : c.filter((f) => f.anchor === s);
    a && a.length > 0 && a.forEach((f) => {
      const u = this.store.pens[f.lineId];
      Ht(
        this.store.pens[this.store.activeAnchor.penId],
        this.store.activeAnchor,
        u,
        wt(u, f.lineAnchor)
      );
    });
    const o = this.store.active[0];
    xe(o);
    const r = ue(o);
    if (o.lineName === "polyline" && !i.shiftKey)
      rl(o, this.store.activeAnchor, e);
    else {
      let f = 0, u = 0;
      if (o.lineName === "line") {
        let g = o.calculative.worldAnchors.findIndex(
          (v) => v.id === this.store.activeAnchor.id
        );
        g === 0 && (g = 2);
        let y = o.calculative.worldAnchors[g - 1];
        if (i.ctrlKey && i.shiftKey) {
          let v = G(e);
          this.getSpecialAngle(
            v,
            y
          ), f = v.x - this.store.activeAnchor.x, u = v.y - this.store.activeAnchor.y;
        } else if (!i.ctrlKey && i.shiftKey) {
          let v = {
            x: e.x,
            y: y.y
          };
          f = v.x - this.store.activeAnchor.x, u = v.y - this.store.activeAnchor.y;
        } else if (i.ctrlKey && !i.shiftKey) {
          let v = {
            x: y.x,
            y: e.y
          };
          f = v.x - this.store.activeAnchor.x, u = v.y - this.store.activeAnchor.y;
        } else
          f = e.x - this.store.activeAnchor.x, u = e.y - this.store.activeAnchor.y;
      } else
        !i.ctrlKey && i.shiftKey ? (f = e.x - this.store.activeAnchor.x, u = 0) : i.ctrlKey && !i.shiftKey ? (f = 0, u = e.y - this.store.activeAnchor.y) : (f = e.x - this.store.activeAnchor.x, u = e.y - this.store.activeAnchor.y);
      ti(this.store.activeAnchor, f, u), this.store.hover && this.store.hoverAnchor && this.store.hoverAnchor.penId !== this.store.activeAnchor.penId && (this.store.hoverAnchor.type === pt.Line ? (f = e.x - this.store.activeAnchor.x, u = e.y - this.store.activeAnchor.y, di(
        this.store.activeAnchor,
        this.store.hoverAnchor,
        this.store
      )) : (f = this.store.hoverAnchor.x - this.store.activeAnchor.x, u = this.store.hoverAnchor.y - this.store.activeAnchor.y), ti(this.store.activeAnchor, f, u), r.prev = void 0, o.lineName !== "polyline" && ((d = this[o.lineName]) == null || d.call(this, this.store, o)));
    }
    this.patchFlagsLines.add(o), this.store.path2dMap.set(o, re.path2dDraws[o.name](o)), this.render(), this.store.active[0].calculative && (this.store.active[0].calculative.gradientAnimatePath = void 0), this.store.emitter.emit("moveLineAnchor", {
      pen: this.store.active[0],
      anchor: this.store.activeAnchor
    }), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: ie.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 500);
  }
  moveLineAnchorPrev(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), this.store.activeAnchor.prev.x = e.x, this.store.activeAnchor.prev.y = e.y, this.store.activeAnchor.next) {
      if (!this.store.activeAnchor.prevNextType)
        this.store.activeAnchor.next.x = e.x, this.store.activeAnchor.next.y = e.y, ve(this.store.activeAnchor.next, 180, this.store.activeAnchor);
      else if (this.store.activeAnchor.prevNextType === Ft.Bilateral && this.prevAnchor) {
        const s = ze(e, this.store.activeAnchor), a = ze(this.prevAnchor, this.store.activeAnchor);
        this.store.activeAnchor.next.x = this.nextAnchor.x, this.store.activeAnchor.next.y = this.nextAnchor.y, ve(
          this.store.activeAnchor.next,
          s - a,
          this.store.activeAnchor
        );
      }
    }
    const i = this.store.active[0];
    this.patchFlagsLines.add(i), this.store.path2dMap.set(i, re.path2dDraws[i.name](i)), this.render(), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: ie.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  moveLineAnchorNext(e) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), this.store.activeAnchor.next.x = e.x, this.store.activeAnchor.next.y = e.y, this.store.activeAnchor.prev) {
      if (!this.store.activeAnchor.prevNextType)
        this.store.activeAnchor.prev.x = e.x, this.store.activeAnchor.prev.y = e.y, ve(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
      else if (this.store.activeAnchor.prevNextType === Ft.Bilateral && this.nextAnchor) {
        const s = ze(e, this.store.activeAnchor), a = ze(this.nextAnchor, this.store.activeAnchor);
        this.store.activeAnchor.prev.x = this.prevAnchor.x, this.store.activeAnchor.prev.y = this.prevAnchor.y, ve(
          this.store.activeAnchor.prev,
          s - a,
          this.store.activeAnchor
        );
      }
    }
    const i = this.store.active[0];
    this.patchFlagsLines.add(i), this.store.path2dMap.set(i, re.path2dDraws[i.name](i)), this.render(), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: ie.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  async setAnchor(e) {
    var a;
    const i = [G(this.store.hover, !0)], s = this.store.hover;
    if (this.store.hoverAnchor) {
      if (this.beforeRemoveAnchor && !await this.beforeRemoveAnchor(s, this.store.hoverAnchor))
        return;
      s.type === fe.Line && ((a = s.calculative.worldAnchors) == null ? void 0 : a.length) <= 2 ? this.delete([s]) : (Qr(s, this.store.hoverAnchor), s.type === fe.Line && this.initLineRect(s)), this.store.hoverAnchor = void 0, this.store.activeAnchor = void 0, this.externalElements.style.cursor = "default";
    } else if (s) {
      if (this.beforeAddAnchor && !await this.beforeAddAnchor(s, this.store.pointAt))
        return;
      if (s.type === fe.Line) {
        this.store.activeAnchor = Jr(
          s,
          this.store.pointAt,
          this.store.pointAtIndex
        ), this.initLineRect(s);
        const o = { x: e.x, y: e.y };
        this.getHover(o);
      } else {
        const o = { id: ne(), x: e.x, y: e.y };
        this.store.activeAnchor = Gr(s, o);
      }
    }
    this.hotkeyType = ge.None, this.render(), s && this.pushHistory({
      type: ie.Update,
      pens: [G(s, !0)],
      initPens: i
    });
  }
  /**
   * 连线允许移动，若与其它图形有连接，但其它图形不在此次移动中，会断开连接
   * @param line 连线
   * @param pens 本次移动的全部图形，包含子节点
   */
  checkDisconnect(e, i) {
    if (e.id.indexOf(Ee) > 0) {
      const s = e.id;
      e = this.store.pens[s.replace(Ee, "")];
    }
    e.anchors.forEach((s) => {
      if (s.connectTo && !i.find(
        (a) => a.id === s.connectTo || a.id === s.connectTo + Ee
      )) {
        const a = this.store.pens[s.connectTo];
        if (!a || a.type)
          return;
        Ht(a, wt(a, s.anchorId), e, s);
      }
    });
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  translatePens(e = this.store.active, i, s, a) {
    if (!e || !e.length || e.some((n) => {
      if (n.locked >= he.DisableMove) return !0;
    }))
      return;
    const r = !a && G(e, !0);
    this.activeRect && It(this.activeRect, i, s);
    const l = this.getAllByPens(e);
    e.forEach((n) => {
      var h, c;
      if (!(n.locked >= he.DisableMove)) {
        if (n.type === fe.Line) {
          if (!this.store.options.moveConnectedLine && !this.canMoveLine || n.isRuleLine)
            return;
          js(n, i, s), this.checkDisconnect(n, l), this.store.path2dMap.set(n, re.path2dDraws[n.name](n)), a || (this.initLineRect(n), (h = n.connectedLines) == null || h.forEach((d) => {
            const f = this.store.pens[d.lineId];
            this.initLineRect(f);
          }));
        } else
          It(n.calculative.worldRect, i, s), this.updatePenRect(n, { worldRectIsReady: !0 }), n.calculative.x = n.x, n.calculative.y = n.y, n.calculative.initRect && (n.calculative.initRect.x = n.calculative.x, n.calculative.initRect.y = n.calculative.y, n.calculative.initRect.ex = n.calculative.x + n.calculative.width, n.calculative.initRect.ey = n.calculative.y + n.calculative.height);
        this.updateLines(n), (c = n.onMove) == null || c.call(n, n);
      }
    }), this.activeRect && this.getSizeCPs(), this.render(), this.tooltip.translate(i, s), a || (this.pushHistory({
      type: ie.Update,
      pens: G(e, !0),
      initPens: r
    }), this.initImageCanvas(e), this.initTemplateCanvas(e), this.store.emitter.emit("translatePens", e)), this.store.emitter.emit("translatingPens", e);
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  templateTranslatePens(e = this.store.active, i, s) {
    if (!e || !e.length)
      return;
    const a = this.getAllByPens(e);
    e.forEach((o) => {
      var r;
      if (o.type === fe.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine)
          return;
        js(o, i, s), this.checkDisconnect(o, a), this.store.path2dMap.set(o, re.path2dDraws[o.name](o));
      } else
        It(o.calculative.worldRect, i, s), this.updatePenRect(o, { worldRectIsReady: !0 }), o.calculative.x = o.x, o.calculative.y = o.y, o.calculative.initRect && (o.calculative.initRect.x = o.calculative.x, o.calculative.initRect.y = o.calculative.y, o.calculative.initRect.ex = o.calculative.x + o.calculative.width, o.calculative.initRect.ey = o.calculative.y + o.calculative.height);
      (r = o.onMove) == null || r.call(o, o);
    });
  }
  calcAutoAnchor(e, i, s, a) {
    const o = xe(e), r = ue(e), l = zt(s, i === o ? r : o);
    l && (i.x = l.x, i.y = l.y, i.prev = void 0, i.next = void 0, a ? a.anchor = l.id : Ae(s, l, e, i), this[e.lineName] && this[e.lineName](this.store, e), this.store.path2dMap.set(e, re.path2dDraws.line(e)), this.initLineRect(e));
  }
  restoreNodeAnimate(e) {
    var i, s;
    if (e.calculative.initRect) {
      if (e.keepAnimateState)
        for (const a in e)
          e.calculative[a] !== void 0 && a !== "x" && a !== "y" && a !== "width" && a !== "height" && a !== "initRect" && (typeof e[a] != "object" || a === "lineDash") && (a === "fontSize" || a === "lineWidth" ? e[a] = e.calculative[a] / e.calculative.canvas.store.data.scale : e[a] = e.calculative[a]);
      else {
        const a = e.calculative.initRect.rotate - e.calculative.rotate;
        for (const r in e)
          r !== "x" && r !== "y" && r !== "width" && r !== "height" && r !== "initRect" && r !== "rotate" && (typeof e[r] != "object" || r === "lineDash") && (e.calculative[r] = e[r]);
        (i = e.children) != null && i.length ? a && Za(e, a, e.calculative.worldRect) : e.calculative.rotate = e.rotate;
        const o = G(this.store.animateMap.get(e));
        o && (o.id = e.id, this.parent.setValue(o, {
          doEvent: !1,
          render: !0,
          history: !1
        })), e.calculative.worldRect = e.calculative.initRect;
      }
      this.updatePenRect(e, { worldRectIsReady: !0 }), this.updateLines(e), e.image && e.name !== "gif" && (this.canvasImage.init(), this.canvasImageBottom.init()), e.calculative.text !== e.text && (e.calculative.text = e.text, ci(e)), (s = this.store.active) != null && s.length && this.calcActiveRect(), e.calculative.initRect = void 0;
    }
  }
  updateLines(e, i) {
    var s;
    (s = e.children) == null || s.forEach((a) => {
      const o = this.store.pens[a];
      o && this.updateLines(o, i);
    }), e.connectedLines && e.connectedLines.forEach((a, o) => {
      const r = this.store.pens[a.lineId];
      if (!r || r.calculative.active)
        return;
      const l = wt(r, a.lineAnchor);
      if (!l)
        return;
      if (!l.connectTo) {
        e.connectedLines.splice(o, 1);
        return;
      }
      if (r.autoFrom) {
        const f = xe(r);
        f.id === l.id && this.calcAutoAnchor(r, f, e, a);
      }
      if (r.autoTo) {
        const f = ue(r);
        f.id === l.id && this.calcAutoAnchor(r, f, e, a);
      }
      const n = wt(e, a.anchor);
      if (!n)
        return;
      let h = e.rotate;
      e.flipX && (h *= -1), e.flipY && (h *= -1);
      let c = l.distance * this.store.data.scale * Math.cos((h + n.rotate) / 180 * Math.PI) || 0, d = l.distance * this.store.data.scale * Math.sin((h + n.rotate) / 180 * Math.PI) || 0;
      if (e.flipX && (c = -c), e.flipY && (d = -d), ti(
        l,
        n.x - l.x + c,
        n.y - l.y + d
      ), this.store.options.autoPolyline && !this.autoPolylineFlag && r.autoPolyline !== !1 && r.lineName === "polyline") {
        let f = xe(r), u = ue(r), g = !1;
        f.id === l.id ? (f = l, g = !0) : u.id === l.id && (u = l, g = !0), g && (r.calculative.worldAnchors = [f, u], r.calculative.activeAnchor = f, this.polyline(this.store, r, u), this.initLineRect(r));
      }
      this.store.path2dMap.set(r, re.path2dDraws[r.name](r)), this.patchFlagsLines.add(r), r.calculative.gradientSmooth && (r.calculative.gradientAnimatePath = ws(r)), i && ls(r);
    });
  }
  calcActiveRect() {
    const e = this.store.active.filter(
      (i) => (!i.locked || i.locked < he.DisableMove) && i.visible != !1
    );
    if (e.length)
      e.length === 1 ? (this.activeRect = G(e[0].calculative.worldRect), this.activeRect.rotate = e[0].calculative.rotate || 0, pe(this.activeRect)) : (this.activeRect = Ue(e), this.activeRect.rotate = 0);
    else return;
    this.lastRotate = 0, this.getSizeCPs();
  }
  /**
   * 旋转当前画笔包括子节点
   * @param pen 旋转的画笔
   * @param angle 本次的旋转值，加到 pen.calculative.rotate 上
   */
  rotatePen(e, i, s) {
    e.type ? (e.calculative.worldAnchors.forEach((a) => {
      ve(a, i, s.center);
    }), this.initLineRect(e), xi(e)) : (e.calculative.rotate ? e.calculative.rotate += i : e.calculative.rotate = i, ve(e.calculative.worldRect.center, i, s.center), e.parentId ? (e.calculative.worldRect.x = e.calculative.worldRect.center.x - e.calculative.worldRect.width / 2, e.calculative.worldRect.y = e.calculative.worldRect.center.y - e.calculative.worldRect.height / 2, e.x = (e.calculative.worldRect.x - s.x) / s.width, e.y = (e.calculative.worldRect.y - s.y) / s.height) : (e.x = e.calculative.worldRect.center.x - e.width / 2, e.y = e.calculative.worldRect.center.y - e.height / 2), e.rotate = e.calculative.rotate, this.updatePenRect(e), e.children && e.children.forEach((a) => {
      const o = this.store.pens[a];
      this.rotatePen(o, i, e.calculative.worldRect);
    }));
  }
  nextAnimate(e) {
    if (!e)
      return;
    this.store.emitter.emit("animateEnd", e);
    let i;
    e.nextAnimate && (i = this.store.data.pens.filter((s) => s.id === e.nextAnimate || s.tags && s.tags.indexOf(e.nextAnimate) > -1)), i && (i.forEach((s) => {
      var a, o, r, l, n;
      if (s.calculative.pause) {
        const h = Date.now() - s.calculative.pause;
        s.calculative.pause = void 0, s.calculative.frameStart += h, s.calculative.frameEnd += h;
      } else if (s.name === "video")
        s.calculative.media.currentTime = 0, (a = s.calculative.media) == null || a.play(), (o = s.onStartVideo) == null || o.call(s, s);
      else if (s.type || (r = s.frames) != null && r.length || s.animations && s.animations.length) {
        if (s.type) {
          if ((n = s.animations) != null && n.length) {
            const h = G(s.animations[0]);
            delete h.name, h.currentAnimation = 0, this.parent.setValue(
              {
                id: s.id,
                ...h
              },
              {
                doEvent: !1,
                history: !1
              }
            );
          }
        } else {
          if (!s.frames && s.animations && s.animations.length) {
            let h = (l = s.animations) == null ? void 0 : l.findIndex((f) => f.autoPlay), c = h === -1 ? 0 : h;
            const d = G(s.animations[c]);
            delete d.name, d.currentAnimation = c, !s.type && d.frames && (d.showDuration = this.parent.calcAnimateDuration(d)), this.parent.setValue(
              {
                id: s.id,
                ...d
              },
              {
                doEvent: !1,
                history: !1
              }
            );
          }
          this.store.animateMap.set(s, this.getFrameProps(s));
        }
        this.store.animates.add(s);
      }
    }), this.animate());
  }
  getFrameProps(e) {
    let i = {};
    return e.frames && e.frames.forEach((s) => {
      for (let a in s)
        !["duration", "x", "y", "width", "height", "rotate"].includes(
          a
        ) && !i[a] && (i[a] = e[a]);
    }), i;
  }
  animate() {
    this.animateRendering || requestAnimationFrame(() => {
      const e = Date.now();
      if (e - this.lastAnimateRender < this.store.options.animateInterval) {
        this.store.animates.size > 0 && this.animate();
        return;
      }
      this.lastAnimateRender = e, this.animateRendering = !0;
      const i = [];
      let s = !1;
      for (const a of this.store.animates)
        if (!a.calculative.pause) {
          if (a.calculative.active && !a.type && !this.movingPens && (s = !0), !a.type)
            Zr(a, e) ? a.calculative.patchFlags && (pe(a.calculative.worldRect), this.updatePenRect(a, {
              worldRectIsReady: !0,
              playingAnimate: !0
            })) : (requestAnimationFrame(() => {
              this.restoreNodeAnimate(a);
            }), i.push(a), this.nextAnimate(a)), this.updateLines(a, !0);
          else if (!tn(a)) {
            if (a.keepAnimateState) {
              for (const o in a)
                a.calculative[o] !== void 0 && o !== "length" && (typeof a[o] != "object" || o === "lineDash") && (o === "lineWidth" ? a[o] = a.calculative[o] / a.calculative.canvas.store.data.scale : a[o] = a.calculative[o]);
              xi(a);
            } else
              for (const o in a)
                (typeof a[o] != "object" || o === "lineDash") && (o === "lineWidth" ? a.calculative[o] = a[o] * a.calculative.canvas.store.data.scale : a.calculative[o] = a[o]);
            i.push(a), this.nextAnimate(a);
          }
          this.patchFlags = !0;
        }
      s && this.calcActiveRect(), i.forEach((a) => {
        this.store.animates.delete(a);
      }), this.render(!1), this.animateRendering = !1, this.animate();
    });
  }
  get clipboardName() {
    return "meta2d-clipboard";
  }
  async copy(e, i = !0) {
    const s = ne(), { origin: a, scale: o } = this.store.data;
    this.store.clipboard = void 0, localStorage.removeItem(this.clipboardName), sessionStorage.setItem("page", s);
    let r = this.getAllByPens(
      G(e || this.store.active, !0)
    );
    r.forEach((n) => {
      n.copyIndex = this.store.data.pens.findIndex(
        (h) => h.id === n.id
      ), n.pathId && (n.path = this.store.data.paths[n.pathId]);
    }), r.sort((n, h) => n.copyIndex - h.copyIndex), r.forEach((n) => {
      delete n.copyIndex;
    });
    const l = {
      meta2d: !0,
      pens: r,
      origin: G(a),
      scale: o,
      page: s,
      initRect: G(this.activeRect),
      offset: 10
    };
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox"))
      try {
        await navigator.clipboard.writeText(JSON.stringify(l));
      } catch {
        localStorage.setItem(this.clipboardName, JSON.stringify(l));
      }
    else
      localStorage.setItem(this.clipboardName, JSON.stringify(l));
    i && this.store.emitter.emit("copy", l.pens);
  }
  cut(e) {
    this.copy(e, !1), this.delete(e), this.store.emitter.emit("cut", e);
  }
  async paste() {
    var l;
    let e, i;
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox"))
      try {
        e = await ((l = navigator.clipboard) == null ? void 0 : l.readText());
      } catch {
        e = localStorage.getItem(this.clipboardName);
      }
    else
      e = localStorage.getItem(this.clipboardName);
    if (e) {
      try {
        i = JSON.parse(e);
      } catch (n) {
        console.warn("剪切板数据不是json", n.message);
        return;
      }
      if (!i || !i.meta2d)
        return;
    } else
      return;
    if (this.beforeAddPens && await this.beforeAddPens(i.pens) != !0)
      return;
    let s, a;
    this.store.clipboard && (s = this.store.clipboard.offset + 10, a = this.store.clipboard.pos), this.store.clipboard = G(i), sessionStorage.getItem("page") !== i.page ? (this.store.clipboard.pos = { x: this.mousePos.x, y: this.mousePos.y }, this.store.clipboard.offset = 0) : this.pasteOffset ? (s && (this.store.clipboard.offset = s), a && (this.store.clipboard.pos = a)) : (this.store.clipboard.offset = 0, this.pasteOffset = !0);
    const r = this.store.clipboard.pens.filter((n) => !n.parentId);
    for (const n of r)
      this.pastePen(n, void 0);
    sessionStorage.setItem("page", i.page), this.active(r), this.pushHistory({ type: ie.Add, pens: this.store.clipboard.pens }), this.render(), this.store.emitter.emit("add", this.store.clipboard.pens), this.store.emitter.emit("paste", this.store.clipboard.pens);
  }
  /**
   * 获取 pens 列表中的所有节点（包含子节点）
   * @param pens 不包含子节点
   */
  getAllByPens(e) {
    const i = [];
    for (const s of e)
      i.push(...G(je(s, this.store), !0));
    return i.concat(e);
  }
  getAllFollowersByPens(e, i = !0) {
    const s = e;
    for (const a of e) {
      let o = ps(a, this.store);
      i && (o = G(o, !0));
      for (const r of o)
        s.find((l) => l.id === r.id) || s.push(r);
    }
    return s;
  }
  setFollowers(e = this.store.active) {
    if (e)
      if (e.length < 2)
        e[0].followers = [];
      else {
        let i = e.map((a) => a.id);
        i.pop();
        const s = e[e.length - 1];
        s.followers ? i.forEach((a) => {
          s.followers.includes(a) || s.followers.push(a);
        }) : s.followers = i;
      }
  }
  /**
   * 修改对应连线的 anchors
   * @param oldId 老 id
   * @param pen 节点
   * @param pastePens 本次复制的 pens 包含子节点
   */
  changeLineAnchors(e, i, s) {
    if (Array.isArray(i.connectedLines))
      for (let a = 0; a < i.connectedLines.length; a++) {
        const { lineId: o } = i.connectedLines[a], r = s.find((l) => l.id === o);
        if (r) {
          const l = r.anchors[0], n = r.anchors[r.anchors.length - 1];
          l.connectTo === e && (l.connectTo = i.id), n.connectTo === e && (n.connectTo = i.id);
        } else
          i.connectedLines.splice(a, 1), a--;
      }
  }
  /**
   * 复制连线的过程，修改 与 此线连接 node 的 connectedLines
   * @param oldId 线原 id
   * @param line 线
   * @param pastePens 此处复制的全部 pens (包含子节点)
   */
  changeNodeConnectedLine(e, i, s) {
    var l;
    const a = i.anchors[0], o = i.anchors[i.anchors.length - 1], r = [a, o];
    for (const n of r) {
      const h = n.connectTo;
      if (h) {
        const c = s.find((d) => d.id === h);
        c ? (l = c.connectedLines) == null || l.forEach((d) => {
          d.lineId === e && (d.lineId = i.id, d.lineAnchor = n.id);
        }) : (n.connectTo = void 0, n.prev && (n.prev.connectTo = void 0), n.next && (n.next.connectTo = void 0));
      }
    }
  }
  async delete(e = this.store.active, i = !1, s = !0) {
    if (!e || !e.length || this.beforeRemovePens && await this.beforeRemovePens(e) != !0 || (i || (e = e.filter((o) => !o.locked)), !e || !e.length))
      return;
    const a = [];
    if (this._del(e, a, i), this.initImageCanvas(a), this.initTemplateCanvas(a), this.inactive(), this.clearHover(), this.render(), s) {
      if (a.length === 0) return;
      this.pushHistory({ type: ie.Delete, pens: a });
    }
    this.store.emitter.emit("delete", e);
  }
  _del(e, i, s) {
    e && e.forEach((a) => {
      if (a.type && (a.lastConnected = {}), a.parentId)
        if (this.getLockedParent(a)) {
          console.warn("父节点锁定");
          return;
        } else {
          const r = Ne(a), l = r.children.indexOf(a.id);
          r.children.splice(l, 1), i && this.getDelPens(a, i), this.delForce(a);
        }
      else {
        if (!s && a.locked)
          return;
        i && this.getDelPens(a, i), this.delForce(a);
      }
    });
  }
  getDelPens(e, i) {
    if (!e)
      return;
    if (this.store.data.pens.findIndex((a) => a.id === e.id) > -1) {
      const a = this.store.pens[e.id];
      a.calculative.active = void 0, i.push(a);
    }
    e.children && e.children.forEach((a) => {
      this.getDelPens(this.store.pens[a], i);
    });
  }
  getLockedParent(e) {
    if (!e.parentId)
      return !1;
    const i = Ne(e);
    if (i.locked)
      return i;
    this.getLockedParent(i);
  }
  delForce(e) {
    var s;
    if (!e)
      return;
    const i = this.store.data.pens.findIndex((a) => a.id === e.id);
    i > -1 && (this.delConnectedLines(this.store.data.pens[i]), this.store.data.pens.splice(i, 1), this.store.pens[e.id] = void 0, delete this.store.pens[e.id], e.pathId && delete this.store.data.paths[e.pathId]), this.store.animates.delete(e), this.store.animateMap.delete(e), e.children && e.children.forEach((a) => {
      this.delForce(this.store.pens[a]);
    }), (s = e.onDestroy) == null || s.call(e, e);
  }
  delConnectedLines(e) {
    var i;
    if (e.connectedLines)
      for (let s = 0; s < e.connectedLines.length; s++) {
        const { lineId: a, lineAnchor: o } = e.connectedLines[s], r = this.store.pens[a];
        if (r) {
          let l = r.anchors.find((n) => n.id === o);
          (l == null ? void 0 : l.connectTo) === e.id && (l.connectTo = void 0, l.anchorId = void 0, l.prev && (l.prev.connectTo = void 0), l.next && (l.next.connectTo = void 0)), l = wt(r, o), l && (l.connectTo = void 0, l.anchorId = void 0, l.prev && (l.prev.connectTo = void 0), l.next && (l.next.connectTo = void 0));
        }
      }
    e.type && ((i = e.calculative.worldAnchors) == null || i.forEach((s, a) => {
      var r;
      if (!s.connectTo)
        return;
      const o = this.store.pens[s.connectTo];
      o && ((r = o.calculative.worldAnchors) == null || r.forEach((l) => {
        Ht(o, l, e, s);
      }));
    }));
  }
  convertSpecialCharacter(e) {
    var i = { lt: "<", gt: ">", nbsp: " ", amp: "&", quot: '"' };
    return e.replace(/&(lt|gt|nbsp|amp|quot);/gi, function(s, a) {
      return i[a];
    });
  }
  createInput() {
    this.inputParent.classList.add("meta2d-input"), this.inputDiv.classList.add("input-div"), this.inputParent.appendChild(this.inputDiv), this.dropdown.onmouseleave = () => {
      this.store.hover = null;
    }, this.inputParent.appendChild(this.dropdown), this.externalElements.appendChild(this.inputParent), this.inputParent.onmousedown = this.stopPropagation, this.inputDiv.onmousedown = this.stopPropagation, this.inputDiv.contentEditable = "false", this.dropdown.onmousedown = this.stopPropagation;
    let e;
    for (let i = 0; i < document.styleSheets.length; i++)
      document.styleSheets[i].title === "le5le.com" && (e = document.styleSheets[i]);
    if (!e) {
      const i = document.createElement("style");
      i.title = "le5le.com", document.head.appendChild(i), e = i.sheet, e.insertRule(
        ".meta2d-input{display:none;position:absolute;outline:none;align-items: center;}"
      ), e.insertRule(
        ".meta2d-input textarea{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;left:0;top:0}"
      ), e.insertRule(
        ".meta2d-input .right{width:10px;height:10px;flex-shrink:0;border-top: 1px solid;border-right: 1px solid;margin-right: 5px;transition: all .3s cubic-bezier(.645,.045,.355,1);position:absolute;right:1px;}"
      ), e.insertRule(
        ".meta2d-input ul{position:absolute;top:100%;left:-5px;width:calc(100% + 10px);min-height:30px;border-radius: 2px;box-shadow: 0 2px 8px #00000026;list-style-type: none;background-color: #fff;padding: 4px 0;max-height: 105px;overflow-y: auto;}"
      ), e.insertRule(
        ".meta2d-input ul li{padding: 5px 12px;line-height: 22px;white-space: nowrap;cursor: pointer;}"
      ), e.insertRule(".meta2d-input ul li:hover{background: #eeeeee;}"), e.insertRule(".input-div::-webkit-scrollbar {display:none}"), e.insertRule(".input-div{scrollbar-width: none;}"), e.insertRule(
        ".meta2d-input .input-div{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;width: 100%;left:0;top:0;display:flex;text-align: center;justify-content: center;flex-direction: column;}"
      ), e.insertRule(".input-div div{}");
    }
    this.inputDiv.onfocus = (i) => {
      if (navigator.userAgent.includes("Firefox")) {
        if (!i.target.innerText) {
          let s = this.inputDiv.offsetWidth / 2;
          window.getComputedStyle(this.inputDiv, null).textAlign !== "center" && (s = 0), this.inputDiv.innerHTML = `<br style="margin-left:${s}px;margin-top:4px;" />`;
        }
      } else if (i.target.innerText)
        this.inputDiv.style.paddingTop = "";
      else {
        let s = window.getComputedStyle(this.inputDiv, null);
        s.justifyContent === "center" && (this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(s.lineHeight) / 2}px`);
      }
    }, this.inputDiv.onblur = () => {
      setTimeout(() => {
        this.hideInput();
      }, 300);
    }, this.inputDiv.oninput = (i) => {
      const s = this.store.pens[this.inputDiv.dataset.penId];
      if (s && s.inputType === "number") {
        const a = i.target.innerText, o = a.replace(/[^0-9]/g, "");
        a !== o && (i.preventDefault(), i.target.innerText = o);
      }
      if (navigator.userAgent.includes("Firefox")) {
        if (!i.target.innerText.trim()) {
          let a = this.inputDiv.offsetWidth / 2;
          window.getComputedStyle(this.inputDiv, null).textAlign !== "center" && (a = 0), this.inputDiv.innerHTML = `<br style="margin-left:${a}px;margin-top:4px;" />`;
        }
      } else if (i.target.innerText)
        this.inputDiv.style.paddingTop = "";
      else {
        let a = window.getComputedStyle(this.inputDiv, null);
        a.justifyContent === "center" && (this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(a.lineHeight) / 2}px`);
      }
      this.store.emitter.emit("input", s);
    }, this.inputDiv.onclick = (i) => {
      i.stopPropagation();
      const s = this.store.pens[this.inputDiv.dataset.penId];
      this.dropdown.style.display === "block" ? this.dropdown.style.display = "none" : s != null && s.dropdownList && this.store.data.locked && (this.dropdown.style.display = "block"), this.store.emitter.emit("clickInput", s);
    }, this.inputDiv.onkeyup = (i) => {
      this.setDropdownList(!0);
      const s = this.store.pens[this.inputDiv.dataset.penId];
      this.store.emitter.emit("input", { pen: s, text: i.key }), i.stopPropagation();
    }, this.inputDiv.onkeydown = (i) => {
      i.stopPropagation();
    }, this.inputDiv.onmousedown = this.stopPropagation, this.inputDiv.onwheel = (i) => {
      i.stopPropagation();
    }, this.inputDiv.onpaste = (i) => {
      i.preventDefault();
      let s = "";
      i.clipboardData && i.clipboardData.getData && (s = i.clipboardData.getData("text/plain")), document.execCommand("insertHTML", !1, s);
    };
  }
  clearDropdownList() {
    if (this.dropdown.hasChildNodes())
      for (let e = 0; e < this.dropdown.childNodes.length; e++)
        this.dropdown.childNodes[e].remove(), --e;
  }
  /**
   * 添加一个选项到 dropdown dom 中
   * @param text 选项文字
   * @param index 选项索引
   */
  dropdownAppendOption(e, i) {
    const s = document.createElement("li");
    s.onwheel = this.stopPropagation, s.innerText = e, s.style.overflow = "hidden", s.style.textOverflow = "ellipsis", s.title = e, s.style.zoom = this.store.data.scale, s.onmousedown = this.stopPropagation, s.dataset.i = i + "", s.onclick = this.selectDropdown;
    const a = this.store.pens[this.inputDiv.dataset.penId];
    s.onmouseenter = () => {
      s.style.background = a.dropdownHoverBackground || "#eee", s.style.color = a.dropdownHoverColor || "#bdc7db";
    }, s.onmouseleave = () => {
      s.style.background = a.dropdownBackground || "#fff", s.style.color = a.dropdownColor || "#bdc7db";
    }, this.dropdown.appendChild(s);
  }
  find(e) {
    return this.store.data.pens.filter((i) => i.id == e || i.tags && i.tags.indexOf(e) > -1);
  }
  findOne(e) {
    return this.store.data.pens.find((i) => i.id == e || i.tags && i.tags.indexOf(e) > -1);
  }
  changePenId(e, i) {
    var a, o, r, l, n, h, c;
    if (e === i)
      return;
    const s = this.store.pens[e];
    if (s && !this.store.pens[i]) {
      if (s.id = i, this.store.pens[i] = this.store.pens[e], (a = s.onChangeId) == null || a.call(s, s, e, i), delete this.store.pens[e], s.parentId) {
        const d = this.store.pens[s.parentId], f = (o = d.children) == null ? void 0 : o.findIndex((u) => u === e);
        f !== -1 && ((r = d.children) == null || r.splice(f, 1, i));
      }
      (l = s.children) == null || l.forEach((d) => {
        const f = this.store.pens[d];
        f.parentId = i;
      }), s.type === fe.Line ? this.changeNodeConnectedLine(e, s, this.store.data.pens) : (this.changeLineAnchors(e, s, this.store.data.pens), (n = s.connectedLines) == null || n.forEach(({ lineId: d }) => {
        const f = this.store.pens[d];
        Vt(f);
      })), (h = s.anchors) == null || h.forEach((d) => d.penId = i), (c = s.calculative.worldAnchors) == null || c.forEach((d) => d.penId = i);
    }
  }
  updateValue(e, i) {
    var g, y;
    const s = this.getPenRect(e), a = e.name;
    Object.assign(e, i);
    const o = a !== e.name;
    i.newId && this.changePenId(e.id, i.newId);
    let r = !1, l = !1, n = !1, h = !1, c = !1, d = !1, f, u = !1;
    for (const v in i)
      v.indexOf(".") === -1 ? (v === "rotate" ? e.disableRotate ? e.rotate = e.calculative.rotate || 0 : f = e.calculative.rotate || 0 : v === "canvasLayer" || v === "isBottom" || v === "showChild" ? d = !0 : v === "image" && (u = !0), (typeof e[v] != "object" || v === "lineDash") && (!e.disableRotate || v !== "rotate") && (e.calculative[v] = i[v]), cr.includes(v) && (l = !0), ["name", "borderRadius", "lineSmooth", "close"].includes(v) && (r = !0), hr.includes(v) && (c = !0), dr.includes(v) && (n = !0), ur.includes(v) && (h = !0), e.image && e.name !== "gif" && ["globalAlpha", "flipY", "flipX", "x", "y", "width", "height", "iconWidth", "iconHeight", "imageRatio", "iconLeft", "iconTop", "iconAlign", "rotate"].includes(v) && (u = !0)) : (delete e[v], ts(e, v, i[v])), v.split(".")[0] === "anchors" && Vt(e);
    if (this.setCalculativeByScale(e), o && ((g = e.onDestroy) == null || g.call(e, e), gr(e)), c) {
      const v = {
        x: i.x ?? s.x,
        y: i.y ?? s.y,
        width: i.width ?? s.width,
        height: i.height ?? s.height
      };
      this.setPenRect(e, v, !1), this.updateLines(e, !0), this.store.active && this.store.active.length && e.id === this.store.active[0].id && this.calcActiveRect();
    } else n ? this.updatePenRect(e) : (l && Xe(e), h && Vs(this.store.pens, e), r && re.path2dDraws[e.name] && this.store.path2dMap.set(e, re.path2dDraws[e.name](e)));
    if (f !== void 0) {
      const v = e.calculative.rotate;
      e.calculative.rotate = f, this.rotatePen(e, v - f, e.calculative.worldRect);
    }
    (i.image || i.backgroundImage || i.strokeImage) && (e.calculative.image = void 0, e.calculative.backgroundImage = void 0, e.calculative.strokeImage = void 0, this.loadImage(e)), i.lineGradientColors && (e.calculative.lineGradient = void 0, e.calculative.gradientColorStop = void 0), i.gradientColors && (e.calculative.gradient = void 0, e.calculative.radialGradient = void 0), i.gradientRadius && (e.calculative.gradient = void 0, e.calculative.radialGradient = void 0), i.animateLineWidth && (e.calculative.gradientAnimatePath = void 0), i.gradientSmooth && (e.calculative.gradientAnimatePath = void 0), d ? (this.canvasImage.init(), this.canvasImageBottom.init()) : u && (e.canvasLayer === void 0 && (e.canvasLayer = de.CanvasImageBottom, e.calculative.canvasLayer = de.CanvasImageBottom), e.canvasLayer === de.CanvasImageBottom ? this.canvasImageBottom.init() : e.canvasLayer === de.CanvasImage && this.canvasImage.init()), (i.canvasLayer !== void 0 || e.canvasLayer === de.CanvasTemplate) && this.initTemplateCanvas([e]), i.zIndex !== void 0 && (y = e.calculative.singleton) != null && y.div && Ce(e, e.calculative.singleton.div);
  }
  /**
   * 执行 pen ，以及 pen 的子孙节点的 onResize 生命周期函数
   */
  execPenResize(e) {
    var i, s;
    (i = e.onResize) == null || i.call(e, e), (s = e.children) == null || s.forEach((a) => {
      const o = this.store.pens[a];
      o && this.execPenResize(o);
    });
  }
  setPenRect(e, i, s = !0) {
    if (e.parentId)
      Object.assign(e, i);
    else {
      const { origin: a, scale: o } = this.store.data;
      e.x = a.x + i.x * o, e.y = a.y + i.y * o, e.width = i.width * o, e.height = i.height * o;
    }
    this.updatePenRect(e), this.execPenResize(e), s && this.render();
  }
  getPenRect(e, i = this.store.data.origin, s = this.store.data.scale) {
    if (e)
      return e.parentId ? {
        x: e.x,
        y: e.y,
        width: e.width,
        height: e.height
      } : {
        x: (e.x - i.x) / s,
        y: (e.y - i.y) / s,
        width: e.width / s,
        height: e.height / s
      };
  }
  toPng(e = 2, i, s = !1, a) {
    const o = Ue(this.store.data.pens), r = this.store.data.scale;
    if (!isFinite(o.width))
      throw new Error("can not to png, because width is not finite");
    const l = G(o), n = this.store.data, h = s && !n.background && this.store.bkImg;
    let c = !1, d = !1;
    if (h) {
      if (o.x += n.x, o.y += n.y, we(o), tt(o, this.canvasRect, !0))
        Object.assign(o, this.canvasRect);
      else {
        const R = Ut([
          ...st(o),
          ...st(this.canvasRect)
        ]);
        Object.assign(o, R);
      }
      c = o.x === 0, d = o.y === 0;
    }
    const f = this.store.data.width || this.store.options.width, u = this.store.data.height || this.store.options.height;
    let g = !1;
    f && u && !this.store.data.component && (g = !0), g && (o.x = this.store.data.origin.x, o.y = this.store.data.origin.y, o.width = f * this.store.data.scale, o.height = u * this.store.data.scale);
    const y = G(o), v = Qe(e);
    o.x -= v[3] * r, o.y -= v[0] * r, o.width += (v[3] + v[1]) * r, o.height += (v[0] + v[2]) * r;
    const b = (a || 1920) / o.width;
    o.width *= b, o.height *= b, we(o);
    const x = document.createElement("canvas");
    if (x.width = o.width, x.height = o.height, x.width > 32767 || x.height > 32767 || !navigator.userAgent.includes("Firefox") && x.height * x.width > 268435456 || navigator.userAgent.includes("Firefox") && x.height * x.width > 472907776)
      throw new Error(
        "can not to png, because the size exceeds the browser limit"
      );
    const p = x.getContext("2d");
    p.textBaseline = "middle", p.scale(b, b);
    const k = this.store.data.background || this.store.options.background;
    if (k && (p.save(), p.fillStyle = k, g ? p.fillRect(
      0,
      0,
      y.width + (v[1] + v[3]) * r,
      y.height + (v[0] + v[2]) * r
    ) : p.fillRect(
      0,
      0,
      l.width + (v[3] + v[1]) * r,
      l.height + (v[0] + v[2]) * r
    ), p.restore()), h)
      if (g)
        p.drawImage(
          this.store.bkImg,
          v[3] * r || 0,
          v[0] * r || 0,
          y.width,
          y.height
        );
      else {
        const R = o.x < 0 ? -o.x : 0, A = o.y < 0 ? -o.y : 0;
        p.drawImage(
          this.store.bkImg,
          R,
          A,
          this.canvasRect.width,
          this.canvasRect.height
        );
      }
    h ? g ? p.translate(
      -l.x + v[3] * r || 0,
      -l.y + v[0] * r || 0
    ) : p.translate(
      (c ? n.x : -l.x) + v[3] * r || 0,
      (d ? n.y : -l.y) + v[0] * r || 0
    ) : p.translate(-o.x, -o.y);
    for (const R of this.store.data.pens) {
      if (!Ci(R, this.store) || R.visible == !1)
        continue;
      const { active: A } = R.calculative;
      R.calculative.active = !1, R.calculative.img ? Ti(p, R) : bt(p, R, !0), R.calculative.active = A;
    }
    if (i) {
      x.toBlob(i);
      return;
    }
    return x.toDataURL();
  }
  activeToPng(e = 2, i) {
    return this.pensToPng(this.store.active, e, i);
  }
  pensToPng(e = this.store.active, i = 2, s) {
    if (e.length === 0)
      return;
    const a = this.getAllByPens(e);
    let o = a.map((u) => u.id);
    const r = Ue(a);
    if (!isFinite(r.width))
      throw new Error("can not to png, because width is not finite");
    const l = G(r), n = Qe(i);
    r.x -= n[3], r.y -= n[0], r.width += n[3] + n[1], r.height += n[0] + n[2], we(r);
    const h = (s || r.width) / r.width;
    r.width *= h, r.height *= h;
    const c = document.createElement("canvas");
    if (c.width = r.width, c.height = r.height, c.width > 32767 || c.height > 32767 || !navigator.userAgent.includes("Firefox") && c.height * c.width > 268435456 || navigator.userAgent.includes("Firefox") && c.height * c.width > 472907776)
      throw new Error(
        "can not to png, because the size exceeds the browser limit"
      );
    const d = c.getContext("2d");
    d.textBaseline = "middle", d.scale(h, h);
    const f = this.store.data.background || this.store.options.background;
    f && (d.save(), d.fillStyle = f, d.fillRect(
      0,
      0,
      l.width + (n[3] + n[1]),
      l.height + (n[0] + n[2])
    ), d.restore()), d.translate(-l.x + n[3], -l.y + n[0]);
    for (const u of this.store.data.pens)
      if (o.includes(u.id)) {
        if (!Ci(u, this.store) || u.visible == !1)
          continue;
        const { active: g } = u.calculative;
        u.calculative.active = !1, u.calculative.img ? Ti(d, u) : bt(d, u), u.calculative.active = g;
      }
    return c.toDataURL();
  }
  toggleAnchorMode() {
    var e;
    if (this.hotkeyType)
      this.hotkeyType === ge.AddAnchor && (this.hotkeyType = ge.None, this.store.hoverAnchor ? this.externalElements.style.cursor = "vertical-text" : this.store.hover && (this.externalElements.style.cursor = "move"));
    else {
      if (this.store.options.disableAnchor || (e = this.store.hover) != null && e.disableAnchor)
        return;
      this.hotkeyType = ge.AddAnchor, this.store.hover && (this.externalElements.style.cursor = "pointer");
    }
    this.patchFlags = !0;
  }
  addAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const e = [G(this.store.active[0], !0)];
      this.store.activeAnchor.prev ? this.store.activeAnchor.next || (this.store.activeAnchor.next = { ...this.store.activeAnchor.prev }, ve(this.store.activeAnchor.next, 180, this.store.activeAnchor), this.initLineRect(this.store.active[0]), this.patchFlags = !0) : (this.store.activeAnchor.next || (this.store.activeAnchor.next = {
        penId: this.store.activeAnchor.penId,
        x: this.store.activeAnchor.x + 50,
        y: this.store.activeAnchor.y
      }), this.store.activeAnchor.prev = { ...this.store.activeAnchor.next }, ve(this.store.activeAnchor.prev, 180, this.store.activeAnchor), this.initLineRect(this.store.active[0]), this.patchFlags = !0), this.pushHistory({
        type: ie.Update,
        pens: [G(this.store.active[0], !0)],
        initPens: e
      });
    }
  }
  removeAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const e = [G(this.store.active[0], !0)];
      this.hoverType === se.LineAnchorPrev ? (this.store.activeAnchor.prev = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0) : this.hoverType === se.LineAnchorNext ? (this.store.activeAnchor.next = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0) : (this.store.activeAnchor.prev = void 0, this.store.activeAnchor.next = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0), this.pushHistory({
        type: ie.Update,
        pens: [G(this.store.active[0])],
        initPens: e
      });
    }
  }
  toggleAnchorHand() {
    this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor && (this.store.activeAnchor.prevNextType || (this.store.activeAnchor.prevNextType = Ft.Mirror), this.store.activeAnchor.prevNextType = (this.store.activeAnchor.prevNextType + 1) % 3);
  }
  gotoView(e, i) {
    let s = Ue(this.store.data.pens);
    if (!isFinite(s.width))
      throw new Error("can not move view, because width is not finite");
    const a = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
    a && o && (s = {
      x: this.store.data.origin.x,
      y: this.store.data.origin.y,
      width: a * this.store.data.scale,
      height: o * this.store.data.scale
    }), this.store.data.x = this.canvas.clientWidth / 2 - e * s.width - s.x, this.store.data.y = this.canvas.clientHeight / 2 - i * s.height - s.y, this.onMovePens(), this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init(), this.render();
  }
  showMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "100", this.externalElements.style.zIndex = "101", this.magnifierCanvas.magnifier = !0, this.magnifierCanvas.updateDomOffscreen(), this.externalElements.style.cursor = "default", this.render();
  }
  hideMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "5", this.externalElements.style.zIndex = "5", this.magnifierCanvas.magnifier = !1, this.externalElements.style.cursor = "default", this.render();
  }
  showFit() {
    this.store.data.locked = 0, this.canvasImage.fitFlag = !0, this.canvasImage.activeFit = void 0, this.canvasImage.currentFit = void 0, this.store.data.fits || (this.store.data.fits = []), this.store.data.fits.forEach((e) => e.active = !1), this.canvasImage.init(), this.canvasImage.render();
  }
  hideFit() {
    this.canvasImage.fitFlag = !1, this.canvasImage.activeFit = void 0, this.canvasImage.currentFit = void 0, this.canvasImage.init(), this.canvasImage.render();
  }
  makeFit() {
    if (this.dragRect.width < 100 && this.dragRect.height < 100)
      return;
    const e = this.store.data.pens.filter((h) => {
      if (
        // pen.locked >= LockState.DisableMove || 
        h.parentId || h.isRuleLine
      )
        return !1;
      if (tt(
        h.calculative.worldRect,
        this.dragRect,
        !0
      ))
        return h.type === fe.Line && !this.store.options.dragAllIn ? Vi(h, this.dragRect) : !0;
    });
    if (!e.length)
      return;
    const i = this.parent.getRect(e), s = this.store.data.scale, a = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
    let r = (Math.floor(i.x) - this.store.data.origin.x) / s / a, l = (Math.floor(i.y) - this.store.data.origin.y) / s / o, n = {
      x: r,
      y: l,
      width: (Math.ceil(i.width) + 1) / s / a,
      height: (Math.ceil(i.height) + 1) / s / o,
      children: e.map((h) => h.id),
      id: ne(),
      active: !0
    };
    n.x < -0.1 && (n.x = -0.1), n.y < -0.1 && (n.y = -0.1), n.width > 0.5 ? (n.left = !0, n.right = !0, n.leftValue = (n.x - 0) * s * a, n.rightValue = (1 - (n.x + n.width)) * s * a) : n.x < 0.5 ? (n.left = !0, n.leftValue = (n.x - 0) * s * a) : (n.right = !0, n.rightValue = (1 - (n.x + n.width)) * s * a), n.leftValue < 1 && (n.leftValue = 0), n.rightValue < 1 && (n.rightValue = 0), n.height > 0.5 ? (n.top = !0, n.bottom = !0, n.topValue = (n.y - 0) * s * o, n.bottomValue = (1 - (n.y + n.height)) * s * o) : n.y < 0.5 ? (n.top = !0, n.topValue = (n.y - 0) * s * o) : (n.bottom = !0, n.bottomValue = (1 - (n.y + n.height)) * s * o), n.topValue < 1 && (n.topValue = 0), n.bottomValue < 1 && (n.bottomValue = 0), this.store.data.fits || (this.store.data.fits = []), this.store.data.fits.forEach((h) => {
      h.active = !1;
    }), this.store.data.fits.push(n), this.canvasImage.activeFit = n, this.store.emitter.emit("fit", n), this.canvasImage.init(), this.canvasImage.render();
  }
  updateFit(e) {
    const i = this.store.data.scale, s = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
    let o = (e.x - this.store.data.origin.x) / i / s, r = (e.y - this.store.data.origin.y) / i / a;
    if (this.canvasImage.currentFit) {
      const l = this.canvasImage.activeFit;
      if (this.canvasImage.currentFit === "top") {
        r < -0.1 && (r = -0.1);
        let c = r - l.y;
        if (l.height -= c, l.height < 0.01) {
          l.height = 0.01;
          return;
        }
        l.y = r;
      }
      if (this.canvasImage.currentFit === "bottom" && (r > 1.1 && (r = 1.1), l.height = r - l.y, l.height <= 0.01 && (l.height = 0.01)), this.canvasImage.currentFit === "left") {
        o < -0.1 && (o = -0.1);
        let c = o - l.x;
        if (l.width -= c, l.width < 0.01) {
          l.width = 0.01;
          return;
        }
        l.x = o;
      }
      this.canvasImage.currentFit === "right" && (o > 1.1 && (o = 1.1), l.width = o - l.x, l.width <= 0.01 && (l.width = 0.01));
      let n = {
        x: l.x * s * i + this.store.data.origin.x,
        y: l.y * a * i + this.store.data.origin.y,
        width: l.width * s * i,
        height: l.height * a * i
      };
      we(n);
      const h = this.store.data.pens.filter((c) => {
        if (
          // pen.locked >= LockState.DisableMove || 
          c.parentId || c.isRuleLine
        )
          return !1;
        if (tt(
          c.calculative.worldRect,
          n,
          !0
        ))
          return c.type === fe.Line && !this.store.options.dragAllIn ? Vi(c, n) : !0;
      });
      l.left = void 0, l.leftValue = void 0, l.right = void 0, l.rightValue = void 0, l.top = void 0, l.topValue = void 0, l.bottom = void 0, l.bottomValue = void 0, l.width > 0.5 ? (l.left = !0, l.right = !0, l.leftValue = (l.x - 0) * i * s, l.rightValue = (1 - (l.x + l.width)) * i * s) : l.x < 0.5 ? (l.left = !0, l.leftValue = (l.x - 0) * i * s) : (l.right = !0, l.rightValue = (1 - (l.x + l.width)) * i * s), Math.abs(l.leftValue) < 1 && (l.leftValue = 0), Math.abs(l.rightValue) < 1 && (l.rightValue = 0), l.height > 0.5 ? (l.top = !0, l.bottom = !0, l.topValue = (l.y - 0) * i * a, l.bottomValue = (1 - (l.y + l.height)) * i * a) : l.y < 0.5 ? (l.top = !0, l.topValue = (l.y - 0) * i * a) : (l.bottom = !0, l.bottomValue = (1 - (l.y + l.height)) * i * a), Math.abs(l.topValue) < 1 && (l.topValue = 0), Math.abs(l.bottomValue) < 1 && (l.bottomValue = 0), l.children = h.map((c) => c.id), this.store.emitter.emit("fit", l), this.mouseDown.x = e.x, this.mouseDown.y = e.y, this.canvasImage.init(), this.canvasImage.render();
    }
  }
  updateFitRect(e = this.canvasImage.activeFit) {
    const i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height;
    e.left && (e.leftValue ? e.x = Math.abs(e.leftValue) < 1 ? e.leftValue : e.leftValue / i : e.x = 0), e.right && (e.rightValue ? e.width = 1 - (Math.abs(e.rightValue) < 1 ? e.rightValue : e.rightValue / i) - e.x : e.width = 1 - e.x), e.top && (e.topValue ? e.y = Math.abs(e.topValue) < 1 ? e.topValue : e.topValue / s : e.y = 0), e.bottom && (e.bottomValue ? e.height = 1 - (Math.abs(e.bottomValue) < 1 ? e.bottomValue : e.bottomValue / s) - e.y : e.height = 1 - e.y), this.canvasImage.init(), this.canvasImage.render();
  }
  deleteFit(e = this.canvasImage.activeFit) {
    if (!e)
      return;
    const i = this.store.data.fits.findIndex((s) => s.id === e.id);
    this.store.data.fits.splice(i, 1), this.canvasImage.activeFit = void 0, this.canvasImage.init(), this.canvasImage.render(), this.store.emitter.emit("fit", void 0);
  }
  calcuActiveFit() {
    var l;
    const e = this.store.data.width || this.store.options.width, i = this.store.data.height || this.store.options.height;
    let s = (this.mouseDown.x - this.store.data.origin.x) / this.store.data.scale / e, a = (this.mouseDown.y - this.store.data.origin.y) / this.store.data.scale / i, o = -1, r = -1;
    (l = this.store.data.fits) == null || l.forEach((n, h) => {
      n.ex = null, n.ey = null, nt({ x: s, y: a }, n) && (o = h), n.active && (r = h);
    }), o !== -1 && o !== r ? (this.canvasImage.activeFit = this.store.data.fits[o], this.store.data.fits[o].active = !0, r !== -1 && (this.store.data.fits[r].active = !1), this.store.emitter.emit("fit", this.store.data.fits[o])) : o === -1 && r !== -1 && (this.store.data.fits[r].active = !1, this.store.emitter.emit("fit", void 0), this.canvasImage.activeFit = null), this.inactive(), this.canvasImage.init(), this.canvasImage.render();
  }
  toggleMagnifier() {
    this.magnifierCanvas.magnifier = !this.magnifierCanvas.magnifier, this.magnifierCanvas.magnifier && (this.externalElements.style.cursor = "default"), this.render();
  }
  destroy() {
    var e, i, s, a;
    switch (this.scroll && this.scroll.destroy(), (e = this.tooltip) == null || e.destroy(), (i = this.dialog) == null || i.destroy(), (s = this.title) == null || s.destroy(), (a = this.popconfirm) == null || a.destroy(), this.externalElements.removeEventListener(
      "gesturestart",
      this.onGesturestart
    ), this.externalElements.ondragover = (o) => o.preventDefault(), this.externalElements.ondrop = void 0, this.externalElements.ontouchstart = void 0, this.externalElements.ontouchmove = void 0, this.externalElements.ontouchend = void 0, this.externalElements.onmousedown = void 0, this.externalElements.onmousemove = void 0, this.externalElements.onmouseup = void 0, this.externalElements.onmouseleave = void 0, this.externalElements.ondblclick = void 0, this.store.options.keydown) {
      case Xt.Document:
        document.removeEventListener("keydown", this.onkeydown), document.removeEventListener("keyup", this.onkeyup);
        break;
      case Xt.Canvas:
        this.externalElements.removeEventListener("keydown", this.onkeydown), this.externalElements.removeEventListener("keyup", this.onkeyup);
        break;
    }
    document.removeEventListener("copy", this.onCopy), document.removeEventListener("cut", this.onCut), document.removeEventListener("paste", this.onPaste), window && window.removeEventListener("message", this.onMessage), window && window.removeEventListener("resize", this.onResize), window && window.removeEventListener("scroll", this.onScroll), this.parentElement.innerHTML = "";
  }
}
function Al(t, e) {
  const i = e || new Path2D();
  t.onDestroy || (t.onDestroy = Rl, t.onMove = la, t.onRotate = la, t.onMouseEnter = Pl, t.onMouseLeave = El, t.onMouseMove = Ll, t.onMouseUp = _l, t.onInput = Cl);
  let s = t.calculative.borderRadius || 0, a = s;
  const { x: o, y: r, width: l, height: n, ex: h, ey: c } = t.calculative.worldRect, { x: d } = t.calculative.worldTextRect;
  s < 1 && (s = l * s, a = n * a);
  let f = s < a ? s : a;
  l < 2 * f && (f = l / 2), n < 2 * f && (f = n / 2);
  const u = Tl(t.text, t.calculative.fontSize);
  if (i.moveTo(o + f, r), i.lineTo(d - 5, r), i.moveTo(d + u + 5, r), i.lineTo(d + u + 5, r), i.arcTo(h, r, h, c, f), i.arcTo(h, c, o, c, f), i.arcTo(o, c, o, r, f), i.arcTo(o, r, h, r, f), i instanceof Path2D)
    return i;
}
function Tl(t, e) {
  const i = t.match(/[^\x00-\xff]/g) || "", s = i.length * e, a = t.match(/\s/g) || "", o = a.length * e * 0.3, r = (t.length - i.length - a.length) * e * 0.6;
  return s + o + r;
}
function Cl(t, e) {
  t.text = e, t.calculative.text = t.text, t.calculative.canvas.updatePenRect(t);
}
function Rl(t) {
}
function la(t) {
}
function Pl(t) {
}
function El(t) {
  const e = t.calculative.canvas.store.active;
  e && e.length && e.forEach((i) => {
    if (t.followers) {
      let s = t.followers.findIndex((a) => a === i.id);
      if (s !== -1) {
        const a = t.calculative.canvas.store.pens[i.id + Ee];
        a && a.calculative && (tt(
          a.calculative.worldRect,
          t.calculative.worldRect,
          !0
        ) || t.followers.splice(s, 1));
      }
    }
  });
}
function _l(t) {
  const e = t.calculative.canvas.store.active;
  e && e.length && e.forEach((i) => {
    const s = t.calculative.canvas.store.pens[i.id + Ee];
    if (s && s.calculative) {
      let a = G(t.calculative.worldRect);
      a.x -= 1, a.y -= 1, a.width += 2, a.height += 2, tt(s.calculative.worldRect, a, !0) && (t.followers || (t.followers = []), t.followers.includes(i.id) || t.followers.push(i.id));
    }
  });
}
function Ll(t, e) {
}
const Se = {};
function Ml(t) {
  t.onDestroy || (t.onDestroy = Nl, t.onMove = ca, t.onResize = Ol, t.onRotate = ca, t.onValue = Dl, t.onChangeId = Bl);
  const e = new Path2D();
  if (t.image) {
    if (!Se[t.id]) {
      const i = new Image();
      i.crossOrigin = "anonymous", i.src = t.image, t.calculative.canvas.parent.store.options.cdn && !(t.image.startsWith("http") || t.image.startsWith("//") || t.image.startsWith("data:image")) && (i.src = t.calculative.canvas.parent.store.options.cdn + t.image), Se[t.id] = i, i.onload = () => {
        var s;
        Se[t.id] === i && (t.calculative.img = i, t.calculative.imgNaturalWidth = i.naturalWidth || t.iconWidth, t.calculative.imgNaturalHeight = i.naturalHeight || t.iconHeight, (s = t.calculative.canvas.externalElements) == null || s.parentElement.appendChild(i), ni(t, i));
      };
    }
    return t.calculative.patchFlags && Se[t.id] && ni(t, Se[t.id]), e;
  }
}
function Nl(t) {
  Se[t.id] && (Se[t.id].remove(), Se[t.id] = void 0);
}
function ca(t) {
  Se[t.id] && ni(t, Se[t.id]);
}
function Ol(t) {
  Se[t.id] && ni(t, Se[t.id]);
}
function Dl(t) {
  Se[t.id] && (ni(t, Se[t.id]), Se[t.id].getAttribute("src") !== t.image && (Se[t.id].src = t.image));
}
function Bl(t, e, i) {
  Se[e] && (Se[i] = Se[e], delete Se[e]);
}
function ni(t, e) {
  e.style.objectFit = t.imageRatio ? "contain" : "fill", Ce(t, e);
}
function zl(t, e) {
  return t.onResize || (t.onResize = yo, t.onValue = Hl), Tt(t, e);
}
function yo(t) {
  const e = t.anchors.filter((i) => i.flag !== 1);
  mo(t), t.anchors = t.anchors.concat(...e);
}
function Hl(t) {
  yo(t), Vt(t);
}
function mo(t) {
  const e = [], { x: i, y: s, width: a, height: o } = t, r = Fl(t), l = 5;
  for (let d = 0; d < l; d++) {
    if (d === 2)
      continue;
    let f = i + a * (d + 1) / (l + 1), u = s;
    f < i + r ? u = pi(i + r, u + r, f, r, -1) : f > i + a - r && (u = pi(i + a - r, u + r, f, r, -1)), e.push({
      id: String(e.length),
      flag: 1,
      penId: t.id,
      x: (f - i) / a,
      y: (u - s) / o
    });
  }
  const n = 3;
  for (let d = 0; d < n; d++) {
    let f = s + o * (d + 1) / (n + 1), u = i + a;
    f < s + r ? u = mi(u - r, s + r, f, r) : f > s + o - r && (u = mi(u - r, s + o - r, f, r)), e.push({
      id: String(e.length),
      flag: 1,
      penId: t.id,
      x: (u - i) / a,
      y: (f - s) / o
    });
  }
  const h = 5;
  for (let d = 0; d < h; d++) {
    if (d === 2)
      continue;
    let f = i + a * (d + 1) / (h + 1), u = s + o;
    f < i + r ? u = pi(i + r, u - r, f, r) : f > i + a - r && (u = pi(i + a - r, u - r, f, r)), e.push({
      id: String(e.length),
      flag: 1,
      penId: t.id,
      x: (f - i) / a,
      y: (u - s) / o
    });
  }
  const c = 3;
  for (let d = 0; d < c; d++) {
    let f = s + o * (d + 1) / (c + 1), u = i;
    f < s + r ? u = mi(u + r, s + r, f, r, -1) : f > s + o - r && (u = mi(u + r, s + o - r, f, r, -1)), e.push({
      id: String(e.length),
      flag: 1,
      penId: t.id,
      x: (u - i) / a,
      y: (f - s) / o
    });
  }
  t.anchors = e;
}
function Fl(t) {
  let e = t.calculative.borderRadius || 0, i = t.calculative.borderRadius || 0;
  const { width: s, height: a } = t;
  t.calculative.borderRadius < 1 && (e = s * t.calculative.borderRadius, i = a * t.calculative.borderRadius);
  let o = e < i ? e : i;
  return s < 2 * o && (o = s / 2), a < 2 * o && (o = a / 2), o;
}
function mi(t, e, i, s, a = 1) {
  return a * Math.sqrt(s ** 2 - (i - e) ** 2) + t;
}
function pi(t, e, i, s, a = 1) {
  return a * Math.sqrt(s ** 2 - (i - t) ** 2) + e;
}
function Wl(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.moveTo(s, a + r), i.lineTo(s + o, a + r), i.closePath(), i instanceof Path2D) return i;
}
function Vl(t) {
  const e = [
    {
      x: 0,
      y: 1
    },
    {
      x: 1,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: a + "",
    x: i,
    y: s,
    penId: t.id
  }));
}
function jl() {
  return {
    rectangle: Tt,
    square: nr,
    circle: lr,
    svgPath: Pn,
    diamond: En,
    triangle: _n,
    pentagon: Mn,
    pentagram: On,
    hexagon: Bn,
    leftArrow: zn,
    rightArrow: Hn,
    twowayArrow: Fn,
    message: Wn,
    cloud: Vn,
    file: jn,
    people: qn,
    line: Kn,
    iframe: dl,
    video: yl,
    gif: Ml,
    mindNode: zl,
    mindLine: Wl,
    mindNode2: Tt,
    panel: Al,
    combine: Tt
  };
}
function Ul() {
  return {
    triangle: Ln,
    pentagon: Nn,
    pentagram: ao,
    mindNode: mo,
    mindLine: Vl
  };
}
var Ie = /* @__PURE__ */ ((t) => (t[t.Link = 0] = "Link", t[t.SetProps = 1] = "SetProps", t[t.StartAnimate = 2] = "StartAnimate", t[t.PauseAnimate = 3] = "PauseAnimate", t[t.StopAnimate = 4] = "StopAnimate", t[t.JS = 5] = "JS", t[t.GlobalFn = 6] = "GlobalFn", t[t.Emit = 7] = "Emit", t[t.StartVideo = 8] = "StartVideo", t[t.PauseVideo = 9] = "PauseVideo", t[t.StopVideo = 10] = "StopVideo", t[t.SendPropData = 11] = "SendPropData", t[t.SendVarData = 12] = "SendVarData", t[t.Navigator = 13] = "Navigator", t[t.Dialog = 14] = "Dialog", t[t.SendData = 15] = "SendData", t[t.PostMessage = 16] = "PostMessage", t[t.PostMessageToParent = 17] = "PostMessageToParent", t[t.Message = 18] = "Message", t))(Ie || {});
class ql {
  // 可视区域外框
  constructor(e) {
    O(this, "box");
    O(this, "boxWidth", 320);
    O(this, "boxHeight", 180);
    O(this, "ratio", this.boxWidth / this.boxHeight);
    O(this, "padding", 5);
    O(this, "img");
    O(this, "isShow");
    O(this, "isDown");
    O(this, "view");
    O(this, "onMouseDown", (e) => {
      e.preventDefault(), e.stopPropagation(), this.isDown = !0;
    });
    O(this, "onMouseMove", (e) => {
      if (e.preventDefault(), e.stopPropagation(), this.isDown)
        try {
          this.parent.gotoView(
            e.offsetX / this.box.clientWidth,
            e.offsetY / this.box.clientHeight
          );
        } catch (i) {
          console.warn(i.message), this.isDown = !1;
        }
    });
    O(this, "onMouseUp", (e) => {
      e.preventDefault(), e.stopPropagation();
      try {
        this.parent.gotoView(
          e.offsetX / this.box.clientWidth,
          e.offsetY / this.box.clientHeight
        );
      } catch (i) {
        console.warn(i.message);
      } finally {
        this.isDown = !1;
      }
    });
    O(this, "onWheel", (e) => {
      let i = 0.015;
      if (this.parent.store.options.scaleOff)
        i = this.parent.store.options.scaleOff, e.deltaY > 0 && (i = -this.parent.store.options.scaleOff);
      else if (/mac os /i.test(navigator.userAgent))
        e.ctrlKey ? e.deltaY > 0 && (i *= -1) : i *= e.wheelDeltaY / 240;
      else {
        let n = 0.2;
        e.deltaY.toString().indexOf(".") !== -1 && (n = 0.01), e.deltaY > 0 ? i = -n : i = n;
      }
      let { offsetX: s, offsetY: a } = e;
      const o = this.parent.store.data.width || this.parent.store.options.width, r = this.parent.store.data.height || this.parent.store.options.height;
      if (o && r)
        s = s / this.boxWidth * o * this.parent.store.data.scale + this.parent.store.data.origin.x + this.parent.store.data.x, a = a / this.boxHeight * r * this.parent.store.data.scale + this.parent.store.data.origin.y + this.parent.store.data.y;
      else {
        const l = this.parent.parent.getRect();
        s = s / this.boxWidth * l.width + l.x + this.parent.store.data.x, a = a / this.boxHeight * l.height + l.y + this.parent.store.data.y;
      }
      this.parent.scale(this.parent.store.data.scale + i, { x: s, y: a });
    });
    var s;
    this.parent = e, this.box = document.createElement("div"), this.img = new Image(), this.view = document.createElement("div"), this.box.appendChild(this.img), this.box.appendChild(this.view), (s = this.parent.externalElements) == null || s.parentElement.appendChild(this.box), this.box.className = "meta2d-map", this.box.onmousedown = this.onMouseDown, this.box.onmousemove = this.onMouseMove, this.box.onmouseup = this.onMouseUp, this.box.onwheel = this.onWheel;
    let i;
    for (let a = 0; a < document.styleSheets.length; a++)
      document.styleSheets[a].title === "le5le/map" && (i = document.styleSheets[a]);
    if (!i) {
      let a = document.createElement("style");
      a.type = "text/css", a.title = "le5le.com/map", document.head.appendChild(a), a = document.createElement("style"), a.type = "text/css", document.head.appendChild(a), i = a.sheet, i.insertRule(
        `.meta2d-map{display:flex;width:${this.boxWidth + 2 * this.padding}px;height:${this.boxHeight + 2 * this.padding}px;padding:${this.padding}px;background:#f4f4f4;border:1px solid #ffffff;box-shadow: 0px 0px 14px 0px rgba(0,10,38,0.30);border-radius:8px;position:absolute;z-index:9999;right:0;bottom:0;justify-content:center;align-items:center;cursor:default;user-select:none;overflow: hidden;}`
      ), i.insertRule(
        ".meta2d-map img{max-width:100%;max-height:100%;pointer-events: none;}"
      ), i.insertRule(
        ".meta2d-map div{pointer-events: none;border:1px solid #1890ff;position:absolute}"
      );
    }
  }
  show() {
    this.box.style.display = "flex", this.parent.store.data.pens.length ? (this.img.style.display = "block", this.img.src = this.parent.toPng(), this.setView()) : this.img.style.display = "none", this.isShow = !0;
  }
  hide() {
    this.box.style.display = "none", this.isShow = !1;
  }
  setView() {
    const e = this.parent.store.data;
    if (e.pens.length) {
      let i = Ue(e.pens);
      const s = this.parent.store.data.width || this.parent.store.options.width, a = this.parent.store.data.height || this.parent.store.options.height;
      if (s && a && (i = {
        x: this.parent.store.data.origin.x,
        y: this.parent.store.data.origin.y,
        width: s * this.parent.store.data.scale,
        height: a * this.parent.store.data.scale
      }), It(i, e.x, e.y), i.width / i.height > this.ratio) {
        const d = i.width / this.ratio;
        i.y -= (d - i.height) / 2, i.height = d, we(i);
      } else {
        const d = i.height * this.ratio;
        i.x -= (d - i.width) / 2, i.width = d, we(i);
      }
      const r = this.parent.canvasRect;
      let l = 0, n = 0;
      if (i.x < 0)
        l = -i.x / i.width;
      else if (i.x + i.width > r.width) {
        let d = 0;
        r.width > i.width && (d = r.width - i.width), l = (-i.x + d) / i.width;
      }
      if (i.y < 0)
        n = -i.y / i.height;
      else if (i.y + i.height > r.height) {
        let d = 0;
        r.height > i.height && (d = r.height - i.height), n = (-i.y + d) / i.height;
      }
      const h = r.width > i.width ? 1 : r.width / i.width, c = r.height > i.height ? 1 : r.height / i.height;
      this.view.style.left = this.padding + l * this.boxWidth + "px", this.view.style.width = h * this.boxWidth + "px", this.view.style.top = this.padding + n * this.boxHeight + "px", this.view.style.height = c * this.boxHeight + "px";
    }
  }
}
var qe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function xf(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function kf(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var i = function s() {
      return this instanceof s ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);
    };
    i.prototype = e.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(t).forEach(function(s) {
    var a = Object.getOwnPropertyDescriptor(t, s);
    Object.defineProperty(i, s, a.get ? a : {
      enumerable: !0,
      get: function() {
        return t[s];
      }
    });
  }), i;
}
function bi(t) {
  throw new Error('Could not dynamically require "' + t + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var po = { exports: {} };
(function(t, e) {
  (function(i) {
    t.exports = i();
  })(function() {
    return (/* @__PURE__ */ function() {
      return function i(s, a, o) {
        function r(h, c) {
          if (!a[h]) {
            if (!s[h]) {
              var d = typeof bi == "function" && bi;
              if (!c && d) return d(h, !0);
              if (l) return l(h, !0);
              var f = new Error("Cannot find module '" + h + "'");
              throw f.code = "MODULE_NOT_FOUND", f;
            }
            var u = a[h] = { exports: {} };
            s[h][0].call(u.exports, function(g) {
              return r(s[h][1][g] || g);
            }, u, u.exports, i, s, a, o);
          }
          return a[h].exports;
        }
        for (var l = typeof bi == "function" && bi, n = 0; n < o.length; n++) r(o[n]);
        return r;
      };
    }())({ 1: [function(i, s, a) {
      (function(o, r) {
        (function() {
          const l = i("events").EventEmitter, n = i("./store"), h = i("./topic-alias-recv"), c = i("./topic-alias-send"), d = i("mqtt-packet"), f = i("./default-message-id-provider"), u = i("readable-stream").Writable, g = i("inherits"), y = i("reinterval"), v = i("rfdc/default"), b = i("./validations"), x = i("xtend"), p = i("debug")("mqttjs:client"), k = o ? o.nextTick : function(T) {
            setTimeout(T, 0);
          }, R = r.setImmediate || function(T) {
            k(T);
          }, A = { keepalive: 60, reschedulePings: !0, protocolId: "MQTT", protocolVersion: 4, reconnectPeriod: 1e3, connectTimeout: 3e4, clean: !0, resubscribe: !0 }, P = { 0: "", 1: "Unacceptable protocol version", 2: "Identifier rejected", 3: "Server unavailable", 4: "Bad username or password", 5: "Not authorized", 16: "No matching subscribers", 17: "No subscription existed", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 132: "Unsupported Protocol Version", 133: "Client Identifier not valid", 134: "Bad User Name or Password", 135: "Not authorized", 136: "Server unavailable", 137: "Server busy", 138: "Banned", 139: "Server shutting down", 140: "Bad authentication method", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 145: "Packet identifier in use", 146: "Packet Identifier not found", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
          function E(T, _) {
            let z;
            _.properties && (z = _.properties.topicAlias);
            let V = _.topic.toString();
            if (V.length === 0) {
              if (z === void 0) return new Error("Unregistered Topic Alias");
              if ((V = T.topicAliasSend.getTopicByAlias(z)) === void 0) return new Error("Unregistered Topic Alias");
              _.topic = V;
            }
            z && delete _.properties.topicAlias;
          }
          function D(T, _, z) {
            p("sendPacket :: packet: %O", _), p("sendPacket :: emitting `packetsend`"), T.emit("packetsend", _), p("sendPacket :: writing to stream");
            const V = d.writeToStream(_, T.stream, T.options);
            p("sendPacket :: writeToStream result %s", V), !V && z && z !== I ? (p("sendPacket :: handle events on `drain` once through callback."), T.stream.once("drain", z)) : z && (p("sendPacket :: invoking cb"), z());
          }
          function q(T, _, z, V) {
            p("storeAndSend :: store packet with cmd %s to outgoingStore", _.cmd);
            let X, H = _;
            if (H.cmd === "publish" && (H = v(_), X = E(T, H))) return z && z(X);
            T.outgoingStore.put(H, function(M) {
              if (M) return z && z(M);
              V(), D(T, _, z);
            });
          }
          function I(T) {
            p("nop ::", T);
          }
          function S(T, _) {
            let z;
            const V = this;
            if (!(this instanceof S)) return new S(T, _);
            for (z in this.options = _ || {}, A) this.options[z] === void 0 ? this.options[z] = A[z] : this.options[z] = _[z];
            p("MqttClient :: options.protocol", _.protocol), p("MqttClient :: options.protocolVersion", _.protocolVersion), p("MqttClient :: options.username", _.username), p("MqttClient :: options.keepalive", _.keepalive), p("MqttClient :: options.reconnectPeriod", _.reconnectPeriod), p("MqttClient :: options.rejectUnauthorized", _.rejectUnauthorized), p("MqttClient :: options.topicAliasMaximum", _.topicAliasMaximum), this.options.clientId = typeof _.clientId == "string" ? _.clientId : "mqttjs_" + Math.random().toString(16).substr(2, 8), p("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = _.protocolVersion === 5 && _.customHandleAcks ? _.customHandleAcks : function() {
              arguments[3](0);
            }, this.streamBuilder = T, this.messageIdProvider = this.options.messageIdProvider === void 0 ? new f() : this.options.messageIdProvider, this.outgoingStore = _.outgoingStore || new n(), this.incomingStore = _.incomingStore || new n(), this.queueQoSZero = _.queueQoSZero === void 0 || _.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = !1, this.disconnecting = !1, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = !1, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = !0, _.topicAliasMaximum > 0 && (_.topicAliasMaximum > 65535 ? p("MqttClient :: options.topicAliasMaximum is out of range") : this.topicAliasRecv = new h(_.topicAliasMaximum)), this.on("connect", function() {
              const X = this.queue;
              p("connect :: sending queued packets"), function H() {
                const M = X.shift();
                p("deliver :: entry %o", M);
                let B = null;
                if (!M) return void V._resubscribe();
                B = M.packet, p("deliver :: call _sendPacket for %o", B);
                let W = !0;
                B.messageId && B.messageId !== 0 && (V.messageIdProvider.register(B.messageId) || (W = !1)), W ? V._sendPacket(B, function(N) {
                  M.cb && M.cb(N), H();
                }) : (p("messageId: %d has already used. The message is skipped and removed.", B.messageId), H());
              }();
            }), this.on("close", function() {
              p("close :: connected set to `false`"), this.connected = !1, p("close :: clearing connackTimer"), clearTimeout(this.connackTimer), p("close :: clearing ping timer"), V.pingTimer !== null && (V.pingTimer.clear(), V.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), p("close :: calling _setupReconnect"), this._setupReconnect();
            }), l.call(this), p("MqttClient :: setting up stream"), this._setupStream();
          }
          g(S, l), S.prototype._setupStream = function() {
            const T = this, _ = new u(), z = d.parser(this.options);
            let V = null;
            const X = [];
            function H() {
              if (X.length) k(M);
              else {
                const W = V;
                V = null, W();
              }
            }
            function M() {
              p("work :: getting next packet in queue");
              const W = X.shift();
              if (W) p("work :: packet pulled from queue"), T._handlePacket(W, H);
              else {
                p("work :: no packets in queue");
                const N = V;
                V = null, p("work :: done flag is %s", !!N), N && N();
              }
            }
            p("_setupStream :: calling method to clear reconnect"), this._clearReconnect(), p("_setupStream :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), z.on("packet", function(W) {
              p("parser :: on packet push to packets array."), X.push(W);
            }), _._write = function(W, N, U) {
              V = U, p("writable stream :: parsing buffer"), z.parse(W), M();
            }, p("_setupStream :: pipe stream to writable stream"), this.stream.pipe(_), this.stream.on("error", function(W) {
              p("streamErrorHandler :: error", W.message), W.code ? (p("streamErrorHandler :: emitting error"), T.emit("error", W)) : I(W);
            }), this.stream.on("close", function() {
              var W;
              p("(%s)stream :: on close", T.options.clientId), (W = T.outgoing) && (p("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(W).forEach(function(N) {
                W[N].volatile && typeof W[N].cb == "function" && (W[N].cb(new Error("Connection closed")), delete W[N]);
              })), p("stream: emit close to MqttClient"), T.emit("close");
            }), p("_setupStream: sending packet `connect`");
            const B = Object.create(this.options);
            if (B.cmd = "connect", this.topicAliasRecv && (B.properties || (B.properties = {}), this.topicAliasRecv && (B.properties.topicAliasMaximum = this.topicAliasRecv.max)), D(this, B), z.on("error", this.emit.bind(this, "error")), this.options.properties) {
              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) return T.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
              this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket == "object" && D(this, x({ cmd: "auth", reasonCode: 0 }, this.options.authPacket));
            }
            this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(function() {
              p("!!connectTimeout hit!! Calling _cleanUp with force `true`"), T._cleanUp(!0);
            }, this.options.connectTimeout);
          }, S.prototype._handlePacket = function(T, _) {
            const z = this.options;
            if (z.protocolVersion === 5 && z.properties && z.properties.maximumPacketSize && z.properties.maximumPacketSize < T.length) return this.emit("error", new Error("exceeding packets size " + T.cmd)), this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } }), this;
            switch (p("_handlePacket :: emitting packetreceive"), this.emit("packetreceive", T), T.cmd) {
              case "publish":
                this._handlePublish(T, _);
                break;
              case "puback":
              case "pubrec":
              case "pubcomp":
              case "suback":
              case "unsuback":
                this._handleAck(T), _();
                break;
              case "pubrel":
                this._handlePubrel(T, _);
                break;
              case "connack":
                this._handleConnack(T), _();
                break;
              case "auth":
                this._handleAuth(T), _();
                break;
              case "pingresp":
                this._handlePingresp(T), _();
                break;
              case "disconnect":
                this._handleDisconnect(T), _();
            }
          }, S.prototype._checkDisconnecting = function(T) {
            return this.disconnecting && (T && T !== I ? T(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
          }, S.prototype.publish = function(T, _, z, V) {
            p("publish :: message `%s` to topic `%s`", _, T);
            const X = this.options;
            if (typeof z == "function" && (V = z, z = null), z = x({ qos: 0, retain: !1, dup: !1 }, z), this._checkDisconnecting(V)) return this;
            const H = this, M = function() {
              let B = 0;
              if ((z.qos === 1 || z.qos === 2) && (B = H._nextId()) === null) return p("No messageId left"), !1;
              const W = { cmd: "publish", topic: T, payload: _, qos: z.qos, retain: z.retain, messageId: B, dup: z.dup };
              switch (X.protocolVersion === 5 && (W.properties = z.properties), p("publish :: qos", z.qos), z.qos) {
                case 1:
                case 2:
                  H.outgoing[W.messageId] = { volatile: !1, cb: V || I }, p("MqttClient:publish: packet cmd: %s", W.cmd), H._sendPacket(W, void 0, z.cbStorePut);
                  break;
                default:
                  p("MqttClient:publish: packet cmd: %s", W.cmd), H._sendPacket(W, V, z.cbStorePut);
              }
              return !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !M()) && this._storeProcessingQueue.push({ invoke: M, cbStorePut: z.cbStorePut, callback: V }), this;
          }, S.prototype.subscribe = function() {
            const T = this, _ = new Array(arguments.length);
            for (let Y = 0; Y < arguments.length; Y++) _[Y] = arguments[Y];
            const z = [];
            let V = _.shift();
            const X = V.resubscribe;
            let H = _.pop() || I, M = _.pop();
            const B = this.options.protocolVersion;
            delete V.resubscribe, typeof V == "string" && (V = [V]), typeof H != "function" && (M = H, H = I);
            const W = b.validateTopics(V);
            if (W !== null) return R(H, new Error("Invalid topic " + W)), this;
            if (this._checkDisconnecting(H)) return p("subscribe: discconecting true"), this;
            const N = { qos: 0 };
            if (B === 5 && (N.nl = !1, N.rap = !1, N.rh = 0), M = x(N, M), Array.isArray(V) ? V.forEach(function(Y) {
              if (p("subscribe: array topic %s", Y), !Object.prototype.hasOwnProperty.call(T._resubscribeTopics, Y) || T._resubscribeTopics[Y].qos < M.qos || X) {
                const $ = { topic: Y, qos: M.qos };
                B === 5 && ($.nl = M.nl, $.rap = M.rap, $.rh = M.rh, $.properties = M.properties), p("subscribe: pushing topic `%s` and qos `%s` to subs list", $.topic, $.qos), z.push($);
              }
            }) : Object.keys(V).forEach(function(Y) {
              if (p("subscribe: object topic %s", Y), !Object.prototype.hasOwnProperty.call(T._resubscribeTopics, Y) || T._resubscribeTopics[Y].qos < V[Y].qos || X) {
                const $ = { topic: Y, qos: V[Y].qos };
                B === 5 && ($.nl = V[Y].nl, $.rap = V[Y].rap, $.rh = V[Y].rh, $.properties = M.properties), p("subscribe: pushing `%s` to subs list", $), z.push($);
              }
            }), !z.length) return H(null, []), this;
            const U = function() {
              const Y = T._nextId();
              if (Y === null) return p("No messageId left"), !1;
              const $ = { cmd: "subscribe", subscriptions: z, qos: 1, retain: !1, dup: !1, messageId: Y };
              if (M.properties && ($.properties = M.properties), T.options.resubscribe) {
                p("subscribe :: resubscribe true");
                const Z = [];
                z.forEach(function(Q) {
                  if (T.options.reconnectPeriod > 0) {
                    const J = { qos: Q.qos };
                    B === 5 && (J.nl = Q.nl || !1, J.rap = Q.rap || !1, J.rh = Q.rh || 0, J.properties = Q.properties), T._resubscribeTopics[Q.topic] = J, Z.push(Q.topic);
                  }
                }), T.messageIdToTopic[$.messageId] = Z;
              }
              return T.outgoing[$.messageId] = { volatile: !0, cb: function(Z, Q) {
                if (!Z) {
                  const J = Q.granted;
                  for (let m = 0; m < J.length; m += 1) z[m].qos = J[m];
                }
                H(Z, z);
              } }, p("subscribe :: call _sendPacket"), T._sendPacket($), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !U()) && this._storeProcessingQueue.push({ invoke: U, callback: H }), this;
          }, S.prototype.unsubscribe = function() {
            const T = this, _ = new Array(arguments.length);
            for (let B = 0; B < arguments.length; B++) _[B] = arguments[B];
            let z = _.shift(), V = _.pop() || I, X = _.pop();
            typeof z == "string" && (z = [z]), typeof V != "function" && (X = V, V = I);
            const H = b.validateTopics(z);
            if (H !== null) return R(V, new Error("Invalid topic " + H)), this;
            if (T._checkDisconnecting(V)) return this;
            const M = function() {
              const B = T._nextId();
              if (B === null) return p("No messageId left"), !1;
              const W = { cmd: "unsubscribe", qos: 1, messageId: B };
              return typeof z == "string" ? W.unsubscriptions = [z] : Array.isArray(z) && (W.unsubscriptions = z), T.options.resubscribe && W.unsubscriptions.forEach(function(N) {
                delete T._resubscribeTopics[N];
              }), typeof X == "object" && X.properties && (W.properties = X.properties), T.outgoing[W.messageId] = { volatile: !0, cb: V }, p("unsubscribe: call _sendPacket"), T._sendPacket(W), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !M()) && this._storeProcessingQueue.push({ invoke: M, callback: V }), this;
          }, S.prototype.end = function(T, _, z) {
            const V = this;
            function X() {
              p("end :: (%s) :: finish :: calling _cleanUp with force %s", V.options.clientId, T), V._cleanUp(T, () => {
                p("end :: finish :: calling process.nextTick on closeStores"), k((function() {
                  p("end :: closeStores: closing incoming and outgoing stores"), V.disconnected = !0, V.incomingStore.close(function(H) {
                    V.outgoingStore.close(function(M) {
                      if (p("end :: closeStores: emitting end"), V.emit("end"), z) {
                        const B = H || M;
                        p("end :: closeStores: invoking callback with args"), z(B);
                      }
                    });
                  }), V._deferredReconnect && V._deferredReconnect();
                }).bind(V));
              }, _);
            }
            return p("end :: (%s)", this.options.clientId), T != null && typeof T == "boolean" || (z = _ || I, _ = T, T = !1, typeof _ != "object" && (z = _, _ = null, typeof z != "function" && (z = I))), typeof _ != "object" && (z = _, _ = null), p("end :: cb? %s", !!z), z = z || I, this.disconnecting ? (z(), this) : (this._clearReconnect(), this.disconnecting = !0, !T && Object.keys(this.outgoing).length > 0 ? (p("end :: (%s) :: calling finish in 10ms once outgoing is empty", V.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, X, 10))) : (p("end :: (%s) :: immediately calling finish", V.options.clientId), X()), this);
          }, S.prototype.removeOutgoingMessage = function(T) {
            const _ = this.outgoing[T] ? this.outgoing[T].cb : null;
            return delete this.outgoing[T], this.outgoingStore.del({ messageId: T }, function() {
              _(new Error("Message removed"));
            }), this;
          }, S.prototype.reconnect = function(T) {
            p("client reconnect");
            const _ = this, z = function() {
              T ? (_.options.incomingStore = T.incomingStore, _.options.outgoingStore = T.outgoingStore) : (_.options.incomingStore = null, _.options.outgoingStore = null), _.incomingStore = _.options.incomingStore || new n(), _.outgoingStore = _.options.outgoingStore || new n(), _.disconnecting = !1, _.disconnected = !1, _._deferredReconnect = null, _._reconnect();
            };
            return this.disconnecting && !this.disconnected ? this._deferredReconnect = z : z(), this;
          }, S.prototype._reconnect = function() {
            p("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
              this._setupStream();
            }), p("client already connected. disconnecting first.")) : (p("_reconnect: calling _setupStream"), this._setupStream());
          }, S.prototype._setupReconnect = function() {
            const T = this;
            !T.disconnecting && !T.reconnectTimer && T.options.reconnectPeriod > 0 ? (this.reconnecting || (p("_setupReconnect :: emit `offline` state"), this.emit("offline"), p("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = !0), p("_setupReconnect :: setting reconnectTimer for %d ms", T.options.reconnectPeriod), T.reconnectTimer = setInterval(function() {
              p("reconnectTimer :: reconnect triggered!"), T._reconnect();
            }, T.options.reconnectPeriod)) : p("_setupReconnect :: doing nothing...");
          }, S.prototype._clearReconnect = function() {
            p("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
          }, S.prototype._cleanUp = function(T, _) {
            const z = arguments[2];
            if (_ && (p("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", _)), p("_cleanUp :: forced? %s", T), T) this.options.reconnectPeriod === 0 && this.options.clean && (V = this.outgoing) && (p("flush: queue exists? %b", !!V), Object.keys(V).forEach(function(X) {
              typeof V[X].cb == "function" && (V[X].cb(new Error("Connection closed")), delete V[X]);
            })), p("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();
            else {
              const X = x({ cmd: "disconnect" }, z);
              p("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(X, R.bind(null, this.stream.end.bind(this.stream)));
            }
            var V;
            this.disconnecting || (p("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), this.pingTimer !== null && (p("_cleanUp :: clearing pingTimer"), this.pingTimer.clear(), this.pingTimer = null), _ && !this.connected && (p("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", _), _());
          }, S.prototype._sendPacket = function(T, _, z) {
            p("_sendPacket :: (%s) ::  start", this.options.clientId), z = z || I, _ = _ || I;
            const V = function(X, H) {
              if (X.options.protocolVersion === 5 && H.cmd === "publish") {
                let M;
                H.properties && (M = H.properties.topicAlias);
                const B = H.topic.toString();
                if (X.topicAliasSend) if (M) {
                  if (B.length !== 0 && (p("applyTopicAlias :: register topic: %s - alias: %d", B, M), !X.topicAliasSend.put(B, M))) return p("applyTopicAlias :: error out of range. topic: %s - alias: %d", B, M), new Error("Sending Topic Alias out of range");
                } else B.length !== 0 && (X.options.autoAssignTopicAlias ? (M = X.topicAliasSend.getAliasByTopic(B)) ? (H.topic = "", H.properties = { ...H.properties, topicAlias: M }, p("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", B, M)) : (M = X.topicAliasSend.getLruAlias(), X.topicAliasSend.put(B, M), H.properties = { ...H.properties, topicAlias: M }, p("applyTopicAlias :: auto assign topic: %s - alias: %d", B, M)) : X.options.autoUseTopicAlias && (M = X.topicAliasSend.getAliasByTopic(B)) && (H.topic = "", H.properties = { ...H.properties, topicAlias: M }, p("applyTopicAlias :: auto use topic: %s - alias: %d", B, M)));
                else if (M) return p("applyTopicAlias :: error out of range. topic: %s - alias: %d", B, M), new Error("Sending Topic Alias out of range");
              }
            }(this, T);
            if (V) _(V);
            else {
              if (!this.connected) return T.cmd === "auth" ? (this._shiftPingInterval(), void D(this, T, _)) : (p("_sendPacket :: client not connected. Storing packet offline."), void this._storePacket(T, _, z));
              switch (this._shiftPingInterval(), T.cmd) {
                case "publish":
                  break;
                case "pubrel":
                  return void q(this, T, _, z);
                default:
                  return void D(this, T, _);
              }
              switch (T.qos) {
                case 2:
                case 1:
                  q(this, T, _, z);
                  break;
                case 0:
                default:
                  D(this, T, _);
              }
              p("_sendPacket :: (%s) ::  end", this.options.clientId);
            }
          }, S.prototype._storePacket = function(T, _, z) {
            p("_storePacket :: packet: %o", T), p("_storePacket :: cb? %s", !!_), z = z || I;
            let V = T;
            if (V.cmd === "publish") {
              const X = E(this, V = v(T));
              if (X) return _ && _(X);
            }
            (V.qos || 0) === 0 && this.queueQoSZero || V.cmd !== "publish" ? this.queue.push({ packet: V, cb: _ }) : V.qos > 0 ? (_ = this.outgoing[V.messageId] ? this.outgoing[V.messageId].cb : null, this.outgoingStore.put(V, function(X) {
              if (X) return _ && _(X);
              z();
            })) : _ && _(new Error("No connection to broker"));
          }, S.prototype._setupPingTimer = function() {
            p("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
            const T = this;
            !this.pingTimer && this.options.keepalive && (this.pingResp = !0, this.pingTimer = y(function() {
              T._checkPing();
            }, 1e3 * this.options.keepalive));
          }, S.prototype._shiftPingInterval = function() {
            this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive);
          }, S.prototype._checkPing = function() {
            p("_checkPing :: checking ping..."), this.pingResp ? (p("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = !1, this._sendPacket({ cmd: "pingreq" })) : (p("_checkPing :: calling _cleanUp with force true"), this._cleanUp(!0));
          }, S.prototype._handlePingresp = function() {
            this.pingResp = !0;
          }, S.prototype._handleConnack = function(T) {
            p("_handleConnack");
            const _ = this.options, z = _.protocolVersion === 5 ? T.reasonCode : T.returnCode;
            if (clearTimeout(this.connackTimer), delete this.topicAliasSend, T.properties) {
              if (T.properties.topicAliasMaximum) {
                if (T.properties.topicAliasMaximum > 65535) return void this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                T.properties.topicAliasMaximum > 0 && (this.topicAliasSend = new c(T.properties.topicAliasMaximum));
              }
              T.properties.serverKeepAlive && _.keepalive && (_.keepalive = T.properties.serverKeepAlive, this._shiftPingInterval()), T.properties.maximumPacketSize && (_.properties || (_.properties = {}), _.properties.maximumPacketSize = T.properties.maximumPacketSize);
            }
            if (z === 0) this.reconnecting = !1, this._onConnect(T);
            else if (z > 0) {
              const V = new Error("Connection refused: " + P[z]);
              V.code = z, this.emit("error", V);
            }
          }, S.prototype._handleAuth = function(T) {
            const _ = this.options.protocolVersion, z = _ === 5 ? T.reasonCode : T.returnCode;
            if (_ !== 5) {
              const X = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + _);
              return X.code = z, void this.emit("error", X);
            }
            const V = this;
            this.handleAuth(T, function(X, H) {
              if (X) V.emit("error", X);
              else if (z === 24) V.reconnecting = !1, V._sendPacket(H);
              else {
                const M = new Error("Connection refused: " + P[z]);
                X.code = z, V.emit("error", M);
              }
            });
          }, S.prototype.handleAuth = function(T, _) {
            _();
          }, S.prototype._handlePublish = function(T, _) {
            p("_handlePublish: packet %o", T), _ = _ !== void 0 ? _ : I;
            let z = T.topic.toString();
            const V = T.payload, X = T.qos, H = T.messageId, M = this, B = this.options, W = [0, 16, 128, 131, 135, 144, 145, 151, 153];
            if (this.options.protocolVersion === 5) {
              let N;
              if (T.properties && (N = T.properties.topicAlias), N !== void 0) if (z.length === 0) {
                if (!(N > 0 && N <= 65535)) return p("_handlePublish :: topic alias out of range. alias: %d", N), void this.emit("error", new Error("Received Topic Alias is out of range"));
                {
                  const U = this.topicAliasRecv.getTopicByAlias(N);
                  if (!U) return p("_handlePublish :: unregistered topic alias. alias: %d", N), void this.emit("error", new Error("Received unregistered Topic Alias"));
                  p("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", z = U, N);
                }
              } else {
                if (!this.topicAliasRecv.put(z, N)) return p("_handlePublish :: topic alias out of range. alias: %d", N), void this.emit("error", new Error("Received Topic Alias is out of range"));
                p("_handlePublish :: registered topic: %s - alias: %d", z, N);
              }
            }
            switch (p("_handlePublish: qos %d", X), X) {
              case 2:
                B.customHandleAcks(z, V, T, function(N, U) {
                  return N instanceof Error || (U = N, N = null), N ? M.emit("error", N) : W.indexOf(U) === -1 ? M.emit("error", new Error("Wrong reason code for pubrec")) : void (U ? M._sendPacket({ cmd: "pubrec", messageId: H, reasonCode: U }, _) : M.incomingStore.put(T, function() {
                    M._sendPacket({ cmd: "pubrec", messageId: H }, _);
                  }));
                });
                break;
              case 1:
                B.customHandleAcks(z, V, T, function(N, U) {
                  return N instanceof Error || (U = N, N = null), N ? M.emit("error", N) : W.indexOf(U) === -1 ? M.emit("error", new Error("Wrong reason code for puback")) : (U || M.emit("message", z, V, T), void M.handleMessage(T, function(Y) {
                    if (Y) return _ && _(Y);
                    M._sendPacket({ cmd: "puback", messageId: H, reasonCode: U }, _);
                  }));
                });
                break;
              case 0:
                this.emit("message", z, V, T), this.handleMessage(T, _);
                break;
              default:
                p("_handlePublish: unknown QoS. Doing nothing.");
            }
          }, S.prototype.handleMessage = function(T, _) {
            _();
          }, S.prototype._handleAck = function(T) {
            const _ = T.messageId, z = T.cmd;
            let V = null;
            const X = this.outgoing[_] ? this.outgoing[_].cb : null, H = this;
            let M;
            if (X) {
              switch (p("_handleAck :: packet type", z), z) {
                case "pubcomp":
                case "puback": {
                  const B = T.reasonCode;
                  B && B > 0 && B !== 16 && ((M = new Error("Publish error: " + P[B])).code = B, X(M, T)), delete this.outgoing[_], this.outgoingStore.del(T, X), this.messageIdProvider.deallocate(_), this._invokeStoreProcessingQueue();
                  break;
                }
                case "pubrec": {
                  V = { cmd: "pubrel", qos: 2, messageId: _ };
                  const B = T.reasonCode;
                  B && B > 0 && B !== 16 ? ((M = new Error("Publish error: " + P[B])).code = B, X(M, T)) : this._sendPacket(V);
                  break;
                }
                case "suback":
                  delete this.outgoing[_], this.messageIdProvider.deallocate(_);
                  for (let B = 0; B < T.granted.length; B++) if (128 & T.granted[B]) {
                    const W = this.messageIdToTopic[_];
                    W && W.forEach(function(N) {
                      delete H._resubscribeTopics[N];
                    });
                  }
                  this._invokeStoreProcessingQueue(), X(null, T);
                  break;
                case "unsuback":
                  delete this.outgoing[_], this.messageIdProvider.deallocate(_), this._invokeStoreProcessingQueue(), X(null);
                  break;
                default:
                  H.emit("error", new Error("unrecognized packet type"));
              }
              this.disconnecting && Object.keys(this.outgoing).length === 0 && this.emit("outgoingEmpty");
            } else p("_handleAck :: Server sent an ack in error. Ignoring.");
          }, S.prototype._handlePubrel = function(T, _) {
            p("handling pubrel packet"), _ = _ !== void 0 ? _ : I;
            const z = this, V = { cmd: "pubcomp", messageId: T.messageId };
            z.incomingStore.get(T, function(X, H) {
              X ? z._sendPacket(V, _) : (z.emit("message", H.topic, H.payload, H), z.handleMessage(H, function(M) {
                if (M) return _(M);
                z.incomingStore.del(H, I), z._sendPacket(V, _);
              }));
            });
          }, S.prototype._handleDisconnect = function(T) {
            this.emit("disconnect", T);
          }, S.prototype._nextId = function() {
            return this.messageIdProvider.allocate();
          }, S.prototype.getLastMessageId = function() {
            return this.messageIdProvider.getLastAllocated();
          }, S.prototype._resubscribe = function() {
            p("_resubscribe");
            const T = Object.keys(this._resubscribeTopics);
            if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && T.length > 0) if (this.options.resubscribe) if (this.options.protocolVersion === 5) {
              p("_resubscribe: protocolVersion 5");
              for (let _ = 0; _ < T.length; _++) {
                const z = {};
                z[T[_]] = this._resubscribeTopics[T[_]], z.resubscribe = !0, this.subscribe(z, { properties: z[T[_]].properties });
              }
            } else this._resubscribeTopics.resubscribe = !0, this.subscribe(this._resubscribeTopics);
            else this._resubscribeTopics = {};
            this._firstConnection = !1;
          }, S.prototype._onConnect = function(T) {
            if (this.disconnected) return void this.emit("connect", T);
            const _ = this;
            this.connackPacket = T, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = !0, function z() {
              let V = _.outgoingStore.createStream();
              function X() {
                _._storeProcessing = !1, _._packetIdsDuringStoreProcessing = {};
              }
              function H() {
                V.destroy(), V = null, _._flushStoreProcessingQueue(), X();
              }
              _.once("close", H), V.on("error", function(M) {
                X(), _._flushStoreProcessingQueue(), _.removeListener("close", H), _.emit("error", M);
              }), V.on("end", function() {
                let M = !0;
                for (const B in _._packetIdsDuringStoreProcessing) if (!_._packetIdsDuringStoreProcessing[B]) {
                  M = !1;
                  break;
                }
                M ? (X(), _.removeListener("close", H), _._invokeAllStoreProcessingQueue(), _.emit("connect", T)) : z();
              }), function M() {
                if (!V) return;
                _._storeProcessing = !0;
                const B = V.read(1);
                let W;
                B ? _._packetIdsDuringStoreProcessing[B.messageId] ? M() : _.disconnecting || _.reconnectTimer ? V.destroy && V.destroy() : (W = _.outgoing[B.messageId] ? _.outgoing[B.messageId].cb : null, _.outgoing[B.messageId] = { volatile: !1, cb: function(N, U) {
                  W && W(N, U), M();
                } }, _._packetIdsDuringStoreProcessing[B.messageId] = !0, _.messageIdProvider.register(B.messageId) ? _._sendPacket(B) : p("messageId: %d has already used.", B.messageId)) : V.once("readable", M);
              }();
            }();
          }, S.prototype._invokeStoreProcessingQueue = function() {
            if (this._storeProcessingQueue.length > 0) {
              const T = this._storeProcessingQueue[0];
              if (T && T.invoke()) return this._storeProcessingQueue.shift(), !0;
            }
            return !1;
          }, S.prototype._invokeAllStoreProcessingQueue = function() {
            for (; this._invokeStoreProcessingQueue(); ) ;
          }, S.prototype._flushStoreProcessingQueue = function() {
            for (const T of this._storeProcessingQueue) T.cbStorePut && T.cbStorePut(new Error("Connection closed")), T.callback && T.callback(new Error("Connection closed"));
            this._storeProcessingQueue.splice(0);
          }, s.exports = S;
        }).call(this);
      }).call(this, i("_process"), typeof qe < "u" ? qe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./default-message-id-provider": 7, "./store": 8, "./topic-alias-recv": 9, "./topic-alias-send": 10, "./validations": 11, _process: 50, debug: 18, events: 22, inherits: 24, "mqtt-packet": 40, "readable-stream": 69, reinterval: 70, "rfdc/default": 71, xtend: 81 }], 2: [function(i, s, a) {
      const { Buffer: o } = i("buffer"), r = i("readable-stream").Transform, l = i("duplexify");
      let n, h, c, d = !1;
      s.exports = function(f, u) {
        if (u.hostname = u.hostname || u.host, !u.hostname) throw new Error("Could not determine host. Specify host manually.");
        const g = u.protocolId === "MQIsdp" && u.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        (function(v) {
          v.hostname || (v.hostname = "localhost"), v.path || (v.path = "/"), v.wsOptions || (v.wsOptions = {});
        })(u);
        const y = function(v, b) {
          const x = v.protocol === "alis" ? "wss" : "ws";
          let p = x + "://" + v.hostname + v.path;
          return v.port && v.port !== 80 && v.port !== 443 && (p = x + "://" + v.hostname + ":" + v.port + v.path), typeof v.transformWsUrl == "function" && (p = v.transformWsUrl(p, v, b)), p;
        }(u, f);
        return (n = u.my).connectSocket({ url: y, protocols: g }), h = function() {
          const v = new r();
          return v._write = function(b, x, p) {
            n.sendSocketMessage({ data: b.buffer, success: function() {
              p();
            }, fail: function() {
              p(new Error());
            } });
          }, v._flush = function(b) {
            n.closeSocket({ success: function() {
              b();
            } });
          }, v;
        }(), c = l.obj(), d || (d = !0, n.onSocketOpen(function() {
          c.setReadable(h), c.setWritable(h), c.emit("connect");
        }), n.onSocketMessage(function(v) {
          if (typeof v.data == "string") {
            const b = o.from(v.data, "base64");
            h.push(b);
          } else {
            const b = new FileReader();
            b.addEventListener("load", function() {
              let x = b.result;
              x = x instanceof ArrayBuffer ? o.from(x) : o.from(x, "utf8"), h.push(x);
            }), b.readAsArrayBuffer(v.data);
          }
        }), n.onSocketClose(function() {
          c.end(), c.destroy();
        }), n.onSocketError(function(v) {
          c.destroy(v);
        })), c;
      };
    }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 3: [function(i, s, a) {
      const o = i("net"), r = i("debug")("mqttjs:tcp");
      s.exports = function(l, n) {
        n.port = n.port || 1883, n.hostname = n.hostname || n.host || "localhost";
        const h = n.port, c = n.hostname;
        return r("port %d and host %s", h, c), o.createConnection(h, c);
      };
    }, { debug: 18, net: 16 }], 4: [function(i, s, a) {
      const o = i("tls"), r = i("net"), l = i("debug")("mqttjs:tls");
      s.exports = function(n, h) {
        h.port = h.port || 8883, h.host = h.hostname || h.host || "localhost", r.isIP(h.host) === 0 && (h.servername = h.host), h.rejectUnauthorized = h.rejectUnauthorized !== !1, delete h.path, l("port %d host %s rejectUnauthorized %b", h.port, h.host, h.rejectUnauthorized);
        const c = o.connect(h);
        function d(f) {
          h.rejectUnauthorized && n.emit("error", f), c.end();
        }
        return c.on("secureConnect", function() {
          h.rejectUnauthorized && !c.authorized ? c.emit("error", new Error("TLS not authorized")) : c.removeListener("error", d);
        }), c.on("error", d), c;
      };
    }, { debug: 18, net: 16, tls: 16 }], 5: [function(i, s, a) {
      (function(o) {
        (function() {
          const { Buffer: r } = i("buffer"), l = i("ws"), n = i("debug")("mqttjs:ws"), h = i("duplexify"), c = i("readable-stream").Transform, d = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"], f = o !== void 0 && o.title === "browser" || typeof __webpack_require__ == "function";
          function u(y, v) {
            let b = y.protocol + "://" + y.hostname + ":" + y.port + y.path;
            return typeof y.transformWsUrl == "function" && (b = y.transformWsUrl(b, y, v)), b;
          }
          function g(y) {
            const v = y;
            return y.hostname || (v.hostname = "localhost"), y.port || (y.protocol === "wss" ? v.port = 443 : v.port = 80), y.path || (v.path = "/"), y.wsOptions || (v.wsOptions = {}), f || y.protocol !== "wss" || d.forEach(function(b) {
              Object.prototype.hasOwnProperty.call(y, b) && !Object.prototype.hasOwnProperty.call(y.wsOptions, b) && (v.wsOptions[b] = y[b]);
            }), v;
          }
          s.exports = f ? function(y, v) {
            let b;
            n("browserStreamBuilder");
            const x = function(T) {
              const _ = g(T);
              if (_.hostname || (_.hostname = _.host), !_.hostname) {
                if (typeof document > "u") throw new Error("Could not determine host. Specify host manually.");
                const z = new URL(document.URL);
                _.hostname = z.hostname, _.port || (_.port = z.port);
              }
              return _.objectMode === void 0 && (_.objectMode = !(_.binary === !0 || _.binary === void 0)), _;
            }(v).browserBufferSize || 524288, p = v.browserBufferTimeout || 1e3, k = !v.objectMode, R = function(T, _) {
              const z = _.protocolId === "MQIsdp" && _.protocolVersion === 3 ? "mqttv3.1" : "mqtt", V = u(_, T), X = new WebSocket(V, [z]);
              return X.binaryType = "arraybuffer", X;
            }(y, v), A = function(T, _, z) {
              const V = new c({ objectModeMode: T.objectMode });
              return V._write = _, V._flush = z, V;
            }(v, function T(_, z, V) {
              R.bufferedAmount > x && setTimeout(T, p, _, z, V), k && typeof _ == "string" && (_ = r.from(_, "utf8"));
              try {
                R.send(_);
              } catch (X) {
                return V(X);
              }
              V();
            }, function(T) {
              R.close(), T();
            });
            v.objectMode || (A._writev = S), A.on("close", () => {
              R.close();
            });
            const P = R.addEventListener !== void 0;
            function E() {
              b.setReadable(A), b.setWritable(A), b.emit("connect");
            }
            function D() {
              b.end(), b.destroy();
            }
            function q(T) {
              b.destroy(T);
            }
            function I(T) {
              let _ = T.data;
              _ = _ instanceof ArrayBuffer ? r.from(_) : r.from(_, "utf8"), A.push(_);
            }
            function S(T, _) {
              const z = new Array(T.length);
              for (let V = 0; V < T.length; V++) typeof T[V].chunk == "string" ? z[V] = r.from(T[V], "utf8") : z[V] = T[V].chunk;
              this._write(r.concat(z), "binary", _);
            }
            return R.readyState === R.OPEN ? b = A : (b = b = h(void 0, void 0, v), v.objectMode || (b._writev = S), P ? R.addEventListener("open", E) : R.onopen = E), b.socket = R, P ? (R.addEventListener("close", D), R.addEventListener("error", q), R.addEventListener("message", I)) : (R.onclose = D, R.onerror = q, R.onmessage = I), b;
          } : function(y, v) {
            n("streamBuilder");
            const b = g(v), x = u(b, y), p = function(R, A, P) {
              n("createWebSocket"), n("protocol: " + P.protocolId + " " + P.protocolVersion);
              const E = P.protocolId === "MQIsdp" && P.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
              return n("creating new Websocket for url: " + A + " and protocol: " + E), new l(A, [E], P.wsOptions);
            }(0, x, b), k = l.createWebSocketStream(p, b.wsOptions);
            return k.url = x, p.on("close", () => {
              k.destroy();
            }), k;
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50, buffer: 17, debug: 18, duplexify: 20, "readable-stream": 69, ws: 80 }], 6: [function(i, s, a) {
      const { Buffer: o } = i("buffer"), r = i("readable-stream").Transform, l = i("duplexify");
      let n, h, c;
      s.exports = function(d, f) {
        if (f.hostname = f.hostname || f.host, !f.hostname) throw new Error("Could not determine host. Specify host manually.");
        const u = f.protocolId === "MQIsdp" && f.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        (function(v) {
          v.hostname || (v.hostname = "localhost"), v.path || (v.path = "/"), v.wsOptions || (v.wsOptions = {});
        })(f);
        const g = function(v, b) {
          const x = v.protocol === "wxs" ? "wss" : "ws";
          let p = x + "://" + v.hostname + v.path;
          return v.port && v.port !== 80 && v.port !== 443 && (p = x + "://" + v.hostname + ":" + v.port + v.path), typeof v.transformWsUrl == "function" && (p = v.transformWsUrl(p, v, b)), p;
        }(f, d);
        n = wx.connectSocket({ url: g, protocols: [u] }), h = function() {
          const v = new r();
          return v._write = function(b, x, p) {
            n.send({ data: b.buffer, success: function() {
              p();
            }, fail: function(k) {
              p(new Error(k));
            } });
          }, v._flush = function(b) {
            n.close({ success: function() {
              b();
            } });
          }, v;
        }(), (c = l.obj())._destroy = function(v, b) {
          n.close({ success: function() {
            b && b(v);
          } });
        };
        const y = c.destroy;
        return c.destroy = (function() {
          c.destroy = y;
          const v = this;
          setTimeout(function() {
            n.close({ fail: function() {
              v._destroy(new Error());
            } });
          }, 0);
        }).bind(c), n.onOpen(function() {
          c.setReadable(h), c.setWritable(h), c.emit("connect");
        }), n.onMessage(function(v) {
          let b = v.data;
          b = b instanceof ArrayBuffer ? o.from(b) : o.from(b, "utf8"), h.push(b);
        }), n.onClose(function() {
          c.end(), c.destroy();
        }), n.onError(function(v) {
          c.destroy(new Error(v.errMsg));
        }), c;
      };
    }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 7: [function(i, s, a) {
      function o() {
        if (!(this instanceof o)) return new o();
        this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
      }
      o.prototype.allocate = function() {
        const r = this.nextId++;
        return this.nextId === 65536 && (this.nextId = 1), r;
      }, o.prototype.getLastAllocated = function() {
        return this.nextId === 1 ? 65535 : this.nextId - 1;
      }, o.prototype.register = function(r) {
        return !0;
      }, o.prototype.deallocate = function(r) {
      }, o.prototype.clear = function() {
      }, s.exports = o;
    }, {}], 8: [function(i, s, a) {
      const o = i("xtend"), r = i("readable-stream").Readable, l = { objectMode: !0 }, n = { clean: !0 };
      function h(c) {
        if (!(this instanceof h)) return new h(c);
        this.options = c || {}, this.options = o(n, c), this._inflights = /* @__PURE__ */ new Map();
      }
      h.prototype.put = function(c, d) {
        return this._inflights.set(c.messageId, c), d && d(), this;
      }, h.prototype.createStream = function() {
        const c = new r(l), d = [];
        let f = !1, u = 0;
        return this._inflights.forEach(function(g, y) {
          d.push(g);
        }), c._read = function() {
          !f && u < d.length ? this.push(d[u++]) : this.push(null);
        }, c.destroy = function() {
          if (f) return;
          const g = this;
          f = !0, setTimeout(function() {
            g.emit("close");
          }, 0);
        }, c;
      }, h.prototype.del = function(c, d) {
        return (c = this._inflights.get(c.messageId)) ? (this._inflights.delete(c.messageId), d(null, c)) : d && d(new Error("missing packet")), this;
      }, h.prototype.get = function(c, d) {
        return (c = this._inflights.get(c.messageId)) ? d(null, c) : d && d(new Error("missing packet")), this;
      }, h.prototype.close = function(c) {
        this.options.clean && (this._inflights = null), c && c();
      }, s.exports = h;
    }, { "readable-stream": 69, xtend: 81 }], 9: [function(i, s, a) {
      function o(r) {
        if (!(this instanceof o)) return new o(r);
        this.aliasToTopic = {}, this.max = r;
      }
      o.prototype.put = function(r, l) {
        return !(l === 0 || l > this.max) && (this.aliasToTopic[l] = r, this.length = Object.keys(this.aliasToTopic).length, !0);
      }, o.prototype.getTopicByAlias = function(r) {
        return this.aliasToTopic[r];
      }, o.prototype.clear = function() {
        this.aliasToTopic = {};
      }, s.exports = o;
    }, {}], 10: [function(i, s, a) {
      const o = i("lru-cache"), r = i("number-allocator").NumberAllocator;
      function l(n) {
        if (!(this instanceof l)) return new l(n);
        n > 0 && (this.aliasToTopic = new o({ max: n }), this.topicToAlias = {}, this.numberAllocator = new r(1, n), this.max = n, this.length = 0);
      }
      l.prototype.put = function(n, h) {
        if (h === 0 || h > this.max) return !1;
        const c = this.aliasToTopic.get(h);
        return c && delete this.topicToAlias[c], this.aliasToTopic.set(h, n), this.topicToAlias[n] = h, this.numberAllocator.use(h), this.length = this.aliasToTopic.length, !0;
      }, l.prototype.getTopicByAlias = function(n) {
        return this.aliasToTopic.get(n);
      }, l.prototype.getAliasByTopic = function(n) {
        const h = this.topicToAlias[n];
        return h !== void 0 && this.aliasToTopic.get(h), h;
      }, l.prototype.clear = function() {
        this.aliasToTopic.reset(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
      }, l.prototype.getLruAlias = function() {
        return this.numberAllocator.firstVacant() || this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
      }, s.exports = l;
    }, { "lru-cache": 37, "number-allocator": 46 }], 11: [function(i, s, a) {
      function o(r) {
        const l = r.split("/");
        for (let n = 0; n < l.length; n++) if (l[n] !== "+") {
          if (l[n] === "#") return n === l.length - 1;
          if (l[n].indexOf("+") !== -1 || l[n].indexOf("#") !== -1) return !1;
        }
        return !0;
      }
      s.exports = { validateTopics: function(r) {
        if (r.length === 0) return "empty_topic_list";
        for (let l = 0; l < r.length; l++) if (!o(r[l])) return r[l];
        return null;
      } };
    }, {}], 12: [function(i, s, a) {
      (function(o) {
        (function() {
          const r = i("../client"), l = i("../store"), n = i("url"), h = i("xtend"), c = i("debug")("mqttjs"), d = {};
          function f(u, g) {
            if (c("connecting to an MQTT broker..."), typeof u != "object" || g || (g = u, u = null), g = g || {}, u) {
              const v = n.parse(u, !0);
              if (v.port != null && (v.port = Number(v.port)), (g = h(v, g)).protocol === null) throw new Error("Missing protocol");
              g.protocol = g.protocol.replace(/:$/, "");
            }
            if (function(v) {
              let b;
              v.auth && ((b = v.auth.match(/^(.+):(.+)$/)) ? (v.username = b[1], v.password = b[2]) : v.username = v.auth);
            }(g), g.query && typeof g.query.clientId == "string" && (g.clientId = g.query.clientId), g.cert && g.key) {
              if (!g.protocol) throw new Error("Missing secure protocol key");
              if (["mqtts", "wss", "wxs", "alis"].indexOf(g.protocol) === -1) switch (g.protocol) {
                case "mqtt":
                  g.protocol = "mqtts";
                  break;
                case "ws":
                  g.protocol = "wss";
                  break;
                case "wx":
                  g.protocol = "wxs";
                  break;
                case "ali":
                  g.protocol = "alis";
                  break;
                default:
                  throw new Error('Unknown protocol for secure connection: "' + g.protocol + '"!');
              }
            }
            if (!d[g.protocol]) {
              const v = ["mqtts", "wss"].indexOf(g.protocol) !== -1;
              g.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter(function(b, x) {
                return (!v || x % 2 != 0) && typeof d[b] == "function";
              })[0];
            }
            if (g.clean === !1 && !g.clientId) throw new Error("Missing clientId for unclean clients");
            g.protocol && (g.defaultProtocol = g.protocol);
            const y = new r(function(v) {
              return g.servers && (v._reconnectCount && v._reconnectCount !== g.servers.length || (v._reconnectCount = 0), g.host = g.servers[v._reconnectCount].host, g.port = g.servers[v._reconnectCount].port, g.protocol = g.servers[v._reconnectCount].protocol ? g.servers[v._reconnectCount].protocol : g.defaultProtocol, g.hostname = g.host, v._reconnectCount++), c("calling streambuilder for", g.protocol), d[g.protocol](v, g);
            }, g);
            return y.on("error", function() {
            }), y;
          }
          o !== void 0 && o.title !== "browser" || typeof __webpack_require__ != "function" ? (d.mqtt = i("./tcp"), d.tcp = i("./tcp"), d.ssl = i("./tls"), d.tls = i("./tls"), d.mqtts = i("./tls")) : (d.wx = i("./wx"), d.wxs = i("./wx"), d.ali = i("./ali"), d.alis = i("./ali")), d.ws = i("./ws"), d.wss = i("./ws"), s.exports = f, s.exports.connect = f, s.exports.MqttClient = r, s.exports.Store = l;
        }).call(this);
      }).call(this, i("_process"));
    }, { "../client": 1, "../store": 8, "./ali": 2, "./tcp": 3, "./tls": 4, "./ws": 5, "./wx": 6, _process: 50, debug: 18, url: 76, xtend: 81 }], 13: [function(i, s, a) {
      a.byteLength = function(u) {
        var g = d(u), y = g[0], v = g[1];
        return 3 * (y + v) / 4 - v;
      }, a.toByteArray = function(u) {
        var g, y, v = d(u), b = v[0], x = v[1], p = new l(function(A, P, E) {
          return 3 * (P + E) / 4 - E;
        }(0, b, x)), k = 0, R = x > 0 ? b - 4 : b;
        for (y = 0; y < R; y += 4) g = r[u.charCodeAt(y)] << 18 | r[u.charCodeAt(y + 1)] << 12 | r[u.charCodeAt(y + 2)] << 6 | r[u.charCodeAt(y + 3)], p[k++] = g >> 16 & 255, p[k++] = g >> 8 & 255, p[k++] = 255 & g;
        return x === 2 && (g = r[u.charCodeAt(y)] << 2 | r[u.charCodeAt(y + 1)] >> 4, p[k++] = 255 & g), x === 1 && (g = r[u.charCodeAt(y)] << 10 | r[u.charCodeAt(y + 1)] << 4 | r[u.charCodeAt(y + 2)] >> 2, p[k++] = g >> 8 & 255, p[k++] = 255 & g), p;
      }, a.fromByteArray = function(u) {
        for (var g, y = u.length, v = y % 3, b = [], x = 0, p = y - v; x < p; x += 16383) b.push(f(u, x, x + 16383 > p ? p : x + 16383));
        return v === 1 ? (g = u[y - 1], b.push(o[g >> 2] + o[g << 4 & 63] + "==")) : v === 2 && (g = (u[y - 2] << 8) + u[y - 1], b.push(o[g >> 10] + o[g >> 4 & 63] + o[g << 2 & 63] + "=")), b.join("");
      };
      for (var o = [], r = [], l = typeof Uint8Array < "u" ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0, c = n.length; h < c; ++h) o[h] = n[h], r[n.charCodeAt(h)] = h;
      function d(u) {
        var g = u.length;
        if (g % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var y = u.indexOf("=");
        return y === -1 && (y = g), [y, y === g ? 0 : 4 - y % 4];
      }
      function f(u, g, y) {
        for (var v, b, x = [], p = g; p < y; p += 3) v = (u[p] << 16 & 16711680) + (u[p + 1] << 8 & 65280) + (255 & u[p + 2]), x.push(o[(b = v) >> 18 & 63] + o[b >> 12 & 63] + o[b >> 6 & 63] + o[63 & b]);
        return x.join("");
      }
      r[45] = 62, r[95] = 63;
    }, {}], 14: [function(i, s, a) {
      const { Buffer: o } = i("buffer"), r = Symbol.for("BufferList");
      function l(n) {
        if (!(this instanceof l)) return new l(n);
        l._init.call(this, n);
      }
      l._init = function(n) {
        Object.defineProperty(this, r, { value: !0 }), this._bufs = [], this.length = 0, n && this.append(n);
      }, l.prototype._new = function(n) {
        return new l(n);
      }, l.prototype._offset = function(n) {
        if (n === 0) return [0, 0];
        let h = 0;
        for (let c = 0; c < this._bufs.length; c++) {
          const d = h + this._bufs[c].length;
          if (n < d || c === this._bufs.length - 1) return [c, n - h];
          h = d;
        }
      }, l.prototype._reverseOffset = function(n) {
        const h = n[0];
        let c = n[1];
        for (let d = 0; d < h; d++) c += this._bufs[d].length;
        return c;
      }, l.prototype.get = function(n) {
        if (n > this.length || n < 0) return;
        const h = this._offset(n);
        return this._bufs[h[0]][h[1]];
      }, l.prototype.slice = function(n, h) {
        return typeof n == "number" && n < 0 && (n += this.length), typeof h == "number" && h < 0 && (h += this.length), this.copy(null, 0, n, h);
      }, l.prototype.copy = function(n, h, c, d) {
        if ((typeof c != "number" || c < 0) && (c = 0), (typeof d != "number" || d > this.length) && (d = this.length), c >= this.length || d <= 0) return n || o.alloc(0);
        const f = !!n, u = this._offset(c), g = d - c;
        let y = g, v = f && h || 0, b = u[1];
        if (c === 0 && d === this.length) {
          if (!f) return this._bufs.length === 1 ? this._bufs[0] : o.concat(this._bufs, this.length);
          for (let x = 0; x < this._bufs.length; x++) this._bufs[x].copy(n, v), v += this._bufs[x].length;
          return n;
        }
        if (y <= this._bufs[u[0]].length - b) return f ? this._bufs[u[0]].copy(n, h, b, b + y) : this._bufs[u[0]].slice(b, b + y);
        f || (n = o.allocUnsafe(g));
        for (let x = u[0]; x < this._bufs.length; x++) {
          const p = this._bufs[x].length - b;
          if (!(y > p)) {
            this._bufs[x].copy(n, v, b, b + y), v += p;
            break;
          }
          this._bufs[x].copy(n, v, b), v += p, y -= p, b && (b = 0);
        }
        return n.length > v ? n.slice(0, v) : n;
      }, l.prototype.shallowSlice = function(n, h) {
        if (n = n || 0, h = typeof h != "number" ? this.length : h, n < 0 && (n += this.length), h < 0 && (h += this.length), n === h) return this._new();
        const c = this._offset(n), d = this._offset(h), f = this._bufs.slice(c[0], d[0] + 1);
        return d[1] === 0 ? f.pop() : f[f.length - 1] = f[f.length - 1].slice(0, d[1]), c[1] !== 0 && (f[0] = f[0].slice(c[1])), this._new(f);
      }, l.prototype.toString = function(n, h, c) {
        return this.slice(h, c).toString(n);
      }, l.prototype.consume = function(n) {
        if (n = Math.trunc(n), Number.isNaN(n) || n <= 0) return this;
        for (; this._bufs.length; ) {
          if (!(n >= this._bufs[0].length)) {
            this._bufs[0] = this._bufs[0].slice(n), this.length -= n;
            break;
          }
          n -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
        }
        return this;
      }, l.prototype.duplicate = function() {
        const n = this._new();
        for (let h = 0; h < this._bufs.length; h++) n.append(this._bufs[h]);
        return n;
      }, l.prototype.append = function(n) {
        if (n == null) return this;
        if (n.buffer) this._appendBuffer(o.from(n.buffer, n.byteOffset, n.byteLength));
        else if (Array.isArray(n)) for (let h = 0; h < n.length; h++) this.append(n[h]);
        else if (this._isBufferList(n)) for (let h = 0; h < n._bufs.length; h++) this.append(n._bufs[h]);
        else typeof n == "number" && (n = n.toString()), this._appendBuffer(o.from(n));
        return this;
      }, l.prototype._appendBuffer = function(n) {
        this._bufs.push(n), this.length += n.length;
      }, l.prototype.indexOf = function(n, h, c) {
        if (c === void 0 && typeof h == "string" && (c = h, h = void 0), typeof n == "function" || Array.isArray(n)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        if (typeof n == "number" ? n = o.from([n]) : typeof n == "string" ? n = o.from(n, c) : this._isBufferList(n) ? n = n.slice() : Array.isArray(n.buffer) ? n = o.from(n.buffer, n.byteOffset, n.byteLength) : o.isBuffer(n) || (n = o.from(n)), h = Number(h || 0), isNaN(h) && (h = 0), h < 0 && (h = this.length + h), h < 0 && (h = 0), n.length === 0) return h > this.length ? this.length : h;
        const d = this._offset(h);
        let f = d[0], u = d[1];
        for (; f < this._bufs.length; f++) {
          const g = this._bufs[f];
          for (; u < g.length; )
            if (g.length - u >= n.length) {
              const y = g.indexOf(n, u);
              if (y !== -1) return this._reverseOffset([f, y]);
              u = g.length - n.length + 1;
            } else {
              const y = this._reverseOffset([f, u]);
              if (this._match(y, n)) return y;
              u++;
            }
          u = 0;
        }
        return -1;
      }, l.prototype._match = function(n, h) {
        if (this.length - n < h.length) return !1;
        for (let c = 0; c < h.length; c++) if (this.get(n + c) !== h[c]) return !1;
        return !0;
      }, function() {
        const n = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
        for (const h in n) (function(c) {
          l.prototype[c] = n[c] === null ? function(d, f) {
            return this.slice(d, d + f)[c](0, f);
          } : function(d = 0) {
            return this.slice(d, d + n[c])[c](0);
          };
        })(h);
      }(), l.prototype._isBufferList = function(n) {
        return n instanceof l || l.isBufferList(n);
      }, l.isBufferList = function(n) {
        return n != null && n[r];
      }, s.exports = l;
    }, { buffer: 17 }], 15: [function(i, s, a) {
      const o = i("readable-stream").Duplex, r = i("inherits"), l = i("./BufferList");
      function n(h) {
        if (!(this instanceof n)) return new n(h);
        if (typeof h == "function") {
          this._callback = h;
          const c = (function(d) {
            this._callback && (this._callback(d), this._callback = null);
          }).bind(this);
          this.on("pipe", function(d) {
            d.on("error", c);
          }), this.on("unpipe", function(d) {
            d.removeListener("error", c);
          }), h = null;
        }
        l._init.call(this, h), o.call(this);
      }
      r(n, o), Object.assign(n.prototype, l.prototype), n.prototype._new = function(h) {
        return new n(h);
      }, n.prototype._write = function(h, c, d) {
        this._appendBuffer(h), typeof d == "function" && d();
      }, n.prototype._read = function(h) {
        if (!this.length) return this.push(null);
        h = Math.min(h, this.length), this.push(this.slice(0, h)), this.consume(h);
      }, n.prototype.end = function(h) {
        o.prototype.end.call(this, h), this._callback && (this._callback(null, this.slice()), this._callback = null);
      }, n.prototype._destroy = function(h, c) {
        this._bufs.length = 0, this.length = 0, c(h);
      }, n.prototype._isBufferList = function(h) {
        return h instanceof n || h instanceof l || n.isBufferList(h);
      }, n.isBufferList = l.isBufferList, s.exports = n, s.exports.BufferListStream = n, s.exports.BufferList = l;
    }, { "./BufferList": 14, inherits: 24, "readable-stream": 69 }], 16: [function(i, s, a) {
    }, {}], 17: [function(i, s, a) {
      (function(o) {
        (function() {
          var r = i("base64-js"), l = i("ieee754");
          a.Buffer = c, a.SlowBuffer = function(m) {
            return +m != m && (m = 0), c.alloc(+m);
          }, a.INSPECT_MAX_BYTES = 50;
          var n = 2147483647;
          function h(m) {
            if (m > n) throw new RangeError('The value "' + m + '" is invalid for option "size"');
            var w = new Uint8Array(m);
            return w.__proto__ = c.prototype, w;
          }
          function c(m, w, C) {
            if (typeof m == "number") {
              if (typeof w == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
              return u(m);
            }
            return d(m, w, C);
          }
          function d(m, w, C) {
            if (typeof m == "string") return function(j, K) {
              if (typeof K == "string" && K !== "" || (K = "utf8"), !c.isEncoding(K)) throw new TypeError("Unknown encoding: " + K);
              var te = 0 | v(j, K), ee = h(te), oe = ee.write(j, K);
              return oe !== te && (ee = ee.slice(0, oe)), ee;
            }(m, w);
            if (ArrayBuffer.isView(m)) return g(m);
            if (m == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
            if (Q(m, ArrayBuffer) || m && Q(m.buffer, ArrayBuffer)) return function(j, K, te) {
              if (K < 0 || j.byteLength < K) throw new RangeError('"offset" is outside of buffer bounds');
              if (j.byteLength < K + (te || 0)) throw new RangeError('"length" is outside of buffer bounds');
              var ee;
              return ee = K === void 0 && te === void 0 ? new Uint8Array(j) : te === void 0 ? new Uint8Array(j, K) : new Uint8Array(j, K, te), ee.__proto__ = c.prototype, ee;
            }(m, w, C);
            if (typeof m == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            var L = m.valueOf && m.valueOf();
            if (L != null && L !== m) return c.from(L, w, C);
            var F = function(j) {
              if (c.isBuffer(j)) {
                var K = 0 | y(j.length), te = h(K);
                return te.length === 0 || j.copy(te, 0, 0, K), te;
              }
              if (j.length !== void 0) return typeof j.length != "number" || J(j.length) ? h(0) : g(j);
              if (j.type === "Buffer" && Array.isArray(j.data)) return g(j.data);
            }(m);
            if (F) return F;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function") return c.from(m[Symbol.toPrimitive]("string"), w, C);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
          }
          function f(m) {
            if (typeof m != "number") throw new TypeError('"size" argument must be of type number');
            if (m < 0) throw new RangeError('The value "' + m + '" is invalid for option "size"');
          }
          function u(m) {
            return f(m), h(m < 0 ? 0 : 0 | y(m));
          }
          function g(m) {
            for (var w = m.length < 0 ? 0 : 0 | y(m.length), C = h(w), L = 0; L < w; L += 1) C[L] = 255 & m[L];
            return C;
          }
          function y(m) {
            if (m >= n) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
            return 0 | m;
          }
          function v(m, w) {
            if (c.isBuffer(m)) return m.length;
            if (ArrayBuffer.isView(m) || Q(m, ArrayBuffer)) return m.byteLength;
            if (typeof m != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m);
            var C = m.length, L = arguments.length > 2 && arguments[2] === !0;
            if (!L && C === 0) return 0;
            for (var F = !1; ; ) switch (w) {
              case "ascii":
              case "latin1":
              case "binary":
                return C;
              case "utf8":
              case "utf-8":
                return Y(m).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * C;
              case "hex":
                return C >>> 1;
              case "base64":
                return $(m).length;
              default:
                if (F) return L ? -1 : Y(m).length;
                w = ("" + w).toLowerCase(), F = !0;
            }
          }
          function b(m, w, C) {
            var L = m[w];
            m[w] = m[C], m[C] = L;
          }
          function x(m, w, C, L, F) {
            if (m.length === 0) return -1;
            if (typeof C == "string" ? (L = C, C = 0) : C > 2147483647 ? C = 2147483647 : C < -2147483648 && (C = -2147483648), J(C = +C) && (C = F ? 0 : m.length - 1), C < 0 && (C = m.length + C), C >= m.length) {
              if (F) return -1;
              C = m.length - 1;
            } else if (C < 0) {
              if (!F) return -1;
              C = 0;
            }
            if (typeof w == "string" && (w = c.from(w, L)), c.isBuffer(w)) return w.length === 0 ? -1 : p(m, w, C, L, F);
            if (typeof w == "number") return w &= 255, typeof Uint8Array.prototype.indexOf == "function" ? F ? Uint8Array.prototype.indexOf.call(m, w, C) : Uint8Array.prototype.lastIndexOf.call(m, w, C) : p(m, [w], C, L, F);
            throw new TypeError("val must be string, number or Buffer");
          }
          function p(m, w, C, L, F) {
            var j, K = 1, te = m.length, ee = w.length;
            if (L !== void 0 && ((L = String(L).toLowerCase()) === "ucs2" || L === "ucs-2" || L === "utf16le" || L === "utf-16le")) {
              if (m.length < 2 || w.length < 2) return -1;
              K = 2, te /= 2, ee /= 2, C /= 2;
            }
            function oe(We, me) {
              return K === 1 ? We[me] : We.readUInt16BE(me * K);
            }
            if (F) {
              var le = -1;
              for (j = C; j < te; j++) if (oe(m, j) === oe(w, le === -1 ? 0 : j - le)) {
                if (le === -1 && (le = j), j - le + 1 === ee) return le * K;
              } else le !== -1 && (j -= j - le), le = -1;
            } else for (C + ee > te && (C = te - ee), j = C; j >= 0; j--) {
              for (var Fe = !0, Be = 0; Be < ee; Be++) if (oe(m, j + Be) !== oe(w, Be)) {
                Fe = !1;
                break;
              }
              if (Fe) return j;
            }
            return -1;
          }
          function k(m, w, C, L) {
            C = Number(C) || 0;
            var F = m.length - C;
            L ? (L = Number(L)) > F && (L = F) : L = F;
            var j = w.length;
            L > j / 2 && (L = j / 2);
            for (var K = 0; K < L; ++K) {
              var te = parseInt(w.substr(2 * K, 2), 16);
              if (J(te)) return K;
              m[C + K] = te;
            }
            return K;
          }
          function R(m, w, C, L) {
            return Z(Y(w, m.length - C), m, C, L);
          }
          function A(m, w, C, L) {
            return Z(function(F) {
              for (var j = [], K = 0; K < F.length; ++K) j.push(255 & F.charCodeAt(K));
              return j;
            }(w), m, C, L);
          }
          function P(m, w, C, L) {
            return A(m, w, C, L);
          }
          function E(m, w, C, L) {
            return Z($(w), m, C, L);
          }
          function D(m, w, C, L) {
            return Z(function(F, j) {
              for (var K, te, ee, oe = [], le = 0; le < F.length && !((j -= 2) < 0); ++le) K = F.charCodeAt(le), te = K >> 8, ee = K % 256, oe.push(ee), oe.push(te);
              return oe;
            }(w, m.length - C), m, C, L);
          }
          function q(m, w, C) {
            return w === 0 && C === m.length ? r.fromByteArray(m) : r.fromByteArray(m.slice(w, C));
          }
          function I(m, w, C) {
            C = Math.min(m.length, C);
            for (var L = [], F = w; F < C; ) {
              var j, K, te, ee, oe = m[F], le = null, Fe = oe > 239 ? 4 : oe > 223 ? 3 : oe > 191 ? 2 : 1;
              if (F + Fe <= C) switch (Fe) {
                case 1:
                  oe < 128 && (le = oe);
                  break;
                case 2:
                  (192 & (j = m[F + 1])) == 128 && (ee = (31 & oe) << 6 | 63 & j) > 127 && (le = ee);
                  break;
                case 3:
                  j = m[F + 1], K = m[F + 2], (192 & j) == 128 && (192 & K) == 128 && (ee = (15 & oe) << 12 | (63 & j) << 6 | 63 & K) > 2047 && (ee < 55296 || ee > 57343) && (le = ee);
                  break;
                case 4:
                  j = m[F + 1], K = m[F + 2], te = m[F + 3], (192 & j) == 128 && (192 & K) == 128 && (192 & te) == 128 && (ee = (15 & oe) << 18 | (63 & j) << 12 | (63 & K) << 6 | 63 & te) > 65535 && ee < 1114112 && (le = ee);
              }
              le === null ? (le = 65533, Fe = 1) : le > 65535 && (le -= 65536, L.push(le >>> 10 & 1023 | 55296), le = 56320 | 1023 & le), L.push(le), F += Fe;
            }
            return function(Be) {
              var We = Be.length;
              if (We <= S) return String.fromCharCode.apply(String, Be);
              for (var me = "", be = 0; be < We; ) me += String.fromCharCode.apply(String, Be.slice(be, be += S));
              return me;
            }(L);
          }
          a.kMaxLength = n, c.TYPED_ARRAY_SUPPORT = function() {
            try {
              var m = new Uint8Array(1);
              return m.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, m.foo() === 42;
            } catch {
              return !1;
            }
          }(), c.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", { enumerable: !0, get: function() {
            if (c.isBuffer(this)) return this.buffer;
          } }), Object.defineProperty(c.prototype, "offset", { enumerable: !0, get: function() {
            if (c.isBuffer(this)) return this.byteOffset;
          } }), typeof Symbol < "u" && Symbol.species != null && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), c.poolSize = 8192, c.from = function(m, w, C) {
            return d(m, w, C);
          }, c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, c.alloc = function(m, w, C) {
            return function(L, F, j) {
              return f(L), L <= 0 ? h(L) : F !== void 0 ? typeof j == "string" ? h(L).fill(F, j) : h(L).fill(F) : h(L);
            }(m, w, C);
          }, c.allocUnsafe = function(m) {
            return u(m);
          }, c.allocUnsafeSlow = function(m) {
            return u(m);
          }, c.isBuffer = function(m) {
            return m != null && m._isBuffer === !0 && m !== c.prototype;
          }, c.compare = function(m, w) {
            if (Q(m, Uint8Array) && (m = c.from(m, m.offset, m.byteLength)), Q(w, Uint8Array) && (w = c.from(w, w.offset, w.byteLength)), !c.isBuffer(m) || !c.isBuffer(w)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (m === w) return 0;
            for (var C = m.length, L = w.length, F = 0, j = Math.min(C, L); F < j; ++F) if (m[F] !== w[F]) {
              C = m[F], L = w[F];
              break;
            }
            return C < L ? -1 : L < C ? 1 : 0;
          }, c.isEncoding = function(m) {
            switch (String(m).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, c.concat = function(m, w) {
            if (!Array.isArray(m)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (m.length === 0) return c.alloc(0);
            var C;
            if (w === void 0) for (w = 0, C = 0; C < m.length; ++C) w += m[C].length;
            var L = c.allocUnsafe(w), F = 0;
            for (C = 0; C < m.length; ++C) {
              var j = m[C];
              if (Q(j, Uint8Array) && (j = c.from(j)), !c.isBuffer(j)) throw new TypeError('"list" argument must be an Array of Buffers');
              j.copy(L, F), F += j.length;
            }
            return L;
          }, c.byteLength = v, c.prototype._isBuffer = !0, c.prototype.swap16 = function() {
            var m = this.length;
            if (m % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var w = 0; w < m; w += 2) b(this, w, w + 1);
            return this;
          }, c.prototype.swap32 = function() {
            var m = this.length;
            if (m % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var w = 0; w < m; w += 4) b(this, w, w + 3), b(this, w + 1, w + 2);
            return this;
          }, c.prototype.swap64 = function() {
            var m = this.length;
            if (m % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var w = 0; w < m; w += 8) b(this, w, w + 7), b(this, w + 1, w + 6), b(this, w + 2, w + 5), b(this, w + 3, w + 4);
            return this;
          }, c.prototype.toString = function() {
            var m = this.length;
            return m === 0 ? "" : arguments.length === 0 ? I(this, 0, m) : (function(w, C, L) {
              var F = !1;
              if ((C === void 0 || C < 0) && (C = 0), C > this.length || ((L === void 0 || L > this.length) && (L = this.length), L <= 0) || (L >>>= 0) <= (C >>>= 0)) return "";
              for (w || (w = "utf8"); ; ) switch (w) {
                case "hex":
                  return z(this, C, L);
                case "utf8":
                case "utf-8":
                  return I(this, C, L);
                case "ascii":
                  return T(this, C, L);
                case "latin1":
                case "binary":
                  return _(this, C, L);
                case "base64":
                  return q(this, C, L);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return V(this, C, L);
                default:
                  if (F) throw new TypeError("Unknown encoding: " + w);
                  w = (w + "").toLowerCase(), F = !0;
              }
            }).apply(this, arguments);
          }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(m) {
            if (!c.isBuffer(m)) throw new TypeError("Argument must be a Buffer");
            return this === m || c.compare(this, m) === 0;
          }, c.prototype.inspect = function() {
            var m = "", w = a.INSPECT_MAX_BYTES;
            return m = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(), this.length > w && (m += " ... "), "<Buffer " + m + ">";
          }, c.prototype.compare = function(m, w, C, L, F) {
            if (Q(m, Uint8Array) && (m = c.from(m, m.offset, m.byteLength)), !c.isBuffer(m)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m);
            if (w === void 0 && (w = 0), C === void 0 && (C = m ? m.length : 0), L === void 0 && (L = 0), F === void 0 && (F = this.length), w < 0 || C > m.length || L < 0 || F > this.length) throw new RangeError("out of range index");
            if (L >= F && w >= C) return 0;
            if (L >= F) return -1;
            if (w >= C) return 1;
            if (w >>>= 0, C >>>= 0, L >>>= 0, F >>>= 0, this === m) return 0;
            for (var j = F - L, K = C - w, te = Math.min(j, K), ee = this.slice(L, F), oe = m.slice(w, C), le = 0; le < te; ++le) if (ee[le] !== oe[le]) {
              j = ee[le], K = oe[le];
              break;
            }
            return j < K ? -1 : K < j ? 1 : 0;
          }, c.prototype.includes = function(m, w, C) {
            return this.indexOf(m, w, C) !== -1;
          }, c.prototype.indexOf = function(m, w, C) {
            return x(this, m, w, C, !0);
          }, c.prototype.lastIndexOf = function(m, w, C) {
            return x(this, m, w, C, !1);
          }, c.prototype.write = function(m, w, C, L) {
            if (w === void 0) L = "utf8", C = this.length, w = 0;
            else if (C === void 0 && typeof w == "string") L = w, C = this.length, w = 0;
            else {
              if (!isFinite(w)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              w >>>= 0, isFinite(C) ? (C >>>= 0, L === void 0 && (L = "utf8")) : (L = C, C = void 0);
            }
            var F = this.length - w;
            if ((C === void 0 || C > F) && (C = F), m.length > 0 && (C < 0 || w < 0) || w > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            L || (L = "utf8");
            for (var j = !1; ; ) switch (L) {
              case "hex":
                return k(this, m, w, C);
              case "utf8":
              case "utf-8":
                return R(this, m, w, C);
              case "ascii":
                return A(this, m, w, C);
              case "latin1":
              case "binary":
                return P(this, m, w, C);
              case "base64":
                return E(this, m, w, C);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return D(this, m, w, C);
              default:
                if (j) throw new TypeError("Unknown encoding: " + L);
                L = ("" + L).toLowerCase(), j = !0;
            }
          }, c.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var S = 4096;
          function T(m, w, C) {
            var L = "";
            C = Math.min(m.length, C);
            for (var F = w; F < C; ++F) L += String.fromCharCode(127 & m[F]);
            return L;
          }
          function _(m, w, C) {
            var L = "";
            C = Math.min(m.length, C);
            for (var F = w; F < C; ++F) L += String.fromCharCode(m[F]);
            return L;
          }
          function z(m, w, C) {
            var L = m.length;
            (!w || w < 0) && (w = 0), (!C || C < 0 || C > L) && (C = L);
            for (var F = "", j = w; j < C; ++j) F += U(m[j]);
            return F;
          }
          function V(m, w, C) {
            for (var L = m.slice(w, C), F = "", j = 0; j < L.length; j += 2) F += String.fromCharCode(L[j] + 256 * L[j + 1]);
            return F;
          }
          function X(m, w, C) {
            if (m % 1 != 0 || m < 0) throw new RangeError("offset is not uint");
            if (m + w > C) throw new RangeError("Trying to access beyond buffer length");
          }
          function H(m, w, C, L, F, j) {
            if (!c.isBuffer(m)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (w > F || w < j) throw new RangeError('"value" argument is out of bounds');
            if (C + L > m.length) throw new RangeError("Index out of range");
          }
          function M(m, w, C, L, F, j) {
            if (C + L > m.length) throw new RangeError("Index out of range");
            if (C < 0) throw new RangeError("Index out of range");
          }
          function B(m, w, C, L, F) {
            return w = +w, C >>>= 0, F || M(m, 0, C, 4), l.write(m, w, C, L, 23, 4), C + 4;
          }
          function W(m, w, C, L, F) {
            return w = +w, C >>>= 0, F || M(m, 0, C, 8), l.write(m, w, C, L, 52, 8), C + 8;
          }
          c.prototype.slice = function(m, w) {
            var C = this.length;
            m = ~~m, w = w === void 0 ? C : ~~w, m < 0 ? (m += C) < 0 && (m = 0) : m > C && (m = C), w < 0 ? (w += C) < 0 && (w = 0) : w > C && (w = C), w < m && (w = m);
            var L = this.subarray(m, w);
            return L.__proto__ = c.prototype, L;
          }, c.prototype.readUIntLE = function(m, w, C) {
            m >>>= 0, w >>>= 0, C || X(m, w, this.length);
            for (var L = this[m], F = 1, j = 0; ++j < w && (F *= 256); ) L += this[m + j] * F;
            return L;
          }, c.prototype.readUIntBE = function(m, w, C) {
            m >>>= 0, w >>>= 0, C || X(m, w, this.length);
            for (var L = this[m + --w], F = 1; w > 0 && (F *= 256); ) L += this[m + --w] * F;
            return L;
          }, c.prototype.readUInt8 = function(m, w) {
            return m >>>= 0, w || X(m, 1, this.length), this[m];
          }, c.prototype.readUInt16LE = function(m, w) {
            return m >>>= 0, w || X(m, 2, this.length), this[m] | this[m + 1] << 8;
          }, c.prototype.readUInt16BE = function(m, w) {
            return m >>>= 0, w || X(m, 2, this.length), this[m] << 8 | this[m + 1];
          }, c.prototype.readUInt32LE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + 16777216 * this[m + 3];
          }, c.prototype.readUInt32BE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), 16777216 * this[m] + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
          }, c.prototype.readIntLE = function(m, w, C) {
            m >>>= 0, w >>>= 0, C || X(m, w, this.length);
            for (var L = this[m], F = 1, j = 0; ++j < w && (F *= 256); ) L += this[m + j] * F;
            return L >= (F *= 128) && (L -= Math.pow(2, 8 * w)), L;
          }, c.prototype.readIntBE = function(m, w, C) {
            m >>>= 0, w >>>= 0, C || X(m, w, this.length);
            for (var L = w, F = 1, j = this[m + --L]; L > 0 && (F *= 256); ) j += this[m + --L] * F;
            return j >= (F *= 128) && (j -= Math.pow(2, 8 * w)), j;
          }, c.prototype.readInt8 = function(m, w) {
            return m >>>= 0, w || X(m, 1, this.length), 128 & this[m] ? -1 * (255 - this[m] + 1) : this[m];
          }, c.prototype.readInt16LE = function(m, w) {
            m >>>= 0, w || X(m, 2, this.length);
            var C = this[m] | this[m + 1] << 8;
            return 32768 & C ? 4294901760 | C : C;
          }, c.prototype.readInt16BE = function(m, w) {
            m >>>= 0, w || X(m, 2, this.length);
            var C = this[m + 1] | this[m] << 8;
            return 32768 & C ? 4294901760 | C : C;
          }, c.prototype.readInt32LE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
          }, c.prototype.readInt32BE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
          }, c.prototype.readFloatLE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), l.read(this, m, !0, 23, 4);
          }, c.prototype.readFloatBE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), l.read(this, m, !1, 23, 4);
          }, c.prototype.readDoubleLE = function(m, w) {
            return m >>>= 0, w || X(m, 8, this.length), l.read(this, m, !0, 52, 8);
          }, c.prototype.readDoubleBE = function(m, w) {
            return m >>>= 0, w || X(m, 8, this.length), l.read(this, m, !1, 52, 8);
          }, c.prototype.writeUIntLE = function(m, w, C, L) {
            m = +m, w >>>= 0, C >>>= 0, L || H(this, m, w, C, Math.pow(2, 8 * C) - 1, 0);
            var F = 1, j = 0;
            for (this[w] = 255 & m; ++j < C && (F *= 256); ) this[w + j] = m / F & 255;
            return w + C;
          }, c.prototype.writeUIntBE = function(m, w, C, L) {
            m = +m, w >>>= 0, C >>>= 0, L || H(this, m, w, C, Math.pow(2, 8 * C) - 1, 0);
            var F = C - 1, j = 1;
            for (this[w + F] = 255 & m; --F >= 0 && (j *= 256); ) this[w + F] = m / j & 255;
            return w + C;
          }, c.prototype.writeUInt8 = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 1, 255, 0), this[w] = 255 & m, w + 1;
          }, c.prototype.writeUInt16LE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 2, 65535, 0), this[w] = 255 & m, this[w + 1] = m >>> 8, w + 2;
          }, c.prototype.writeUInt16BE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 2, 65535, 0), this[w] = m >>> 8, this[w + 1] = 255 & m, w + 2;
          }, c.prototype.writeUInt32LE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 4, 4294967295, 0), this[w + 3] = m >>> 24, this[w + 2] = m >>> 16, this[w + 1] = m >>> 8, this[w] = 255 & m, w + 4;
          }, c.prototype.writeUInt32BE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 4, 4294967295, 0), this[w] = m >>> 24, this[w + 1] = m >>> 16, this[w + 2] = m >>> 8, this[w + 3] = 255 & m, w + 4;
          }, c.prototype.writeIntLE = function(m, w, C, L) {
            if (m = +m, w >>>= 0, !L) {
              var F = Math.pow(2, 8 * C - 1);
              H(this, m, w, C, F - 1, -F);
            }
            var j = 0, K = 1, te = 0;
            for (this[w] = 255 & m; ++j < C && (K *= 256); ) m < 0 && te === 0 && this[w + j - 1] !== 0 && (te = 1), this[w + j] = (m / K >> 0) - te & 255;
            return w + C;
          }, c.prototype.writeIntBE = function(m, w, C, L) {
            if (m = +m, w >>>= 0, !L) {
              var F = Math.pow(2, 8 * C - 1);
              H(this, m, w, C, F - 1, -F);
            }
            var j = C - 1, K = 1, te = 0;
            for (this[w + j] = 255 & m; --j >= 0 && (K *= 256); ) m < 0 && te === 0 && this[w + j + 1] !== 0 && (te = 1), this[w + j] = (m / K >> 0) - te & 255;
            return w + C;
          }, c.prototype.writeInt8 = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[w] = 255 & m, w + 1;
          }, c.prototype.writeInt16LE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 2, 32767, -32768), this[w] = 255 & m, this[w + 1] = m >>> 8, w + 2;
          }, c.prototype.writeInt16BE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 2, 32767, -32768), this[w] = m >>> 8, this[w + 1] = 255 & m, w + 2;
          }, c.prototype.writeInt32LE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 4, 2147483647, -2147483648), this[w] = 255 & m, this[w + 1] = m >>> 8, this[w + 2] = m >>> 16, this[w + 3] = m >>> 24, w + 4;
          }, c.prototype.writeInt32BE = function(m, w, C) {
            return m = +m, w >>>= 0, C || H(this, m, w, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[w] = m >>> 24, this[w + 1] = m >>> 16, this[w + 2] = m >>> 8, this[w + 3] = 255 & m, w + 4;
          }, c.prototype.writeFloatLE = function(m, w, C) {
            return B(this, m, w, !0, C);
          }, c.prototype.writeFloatBE = function(m, w, C) {
            return B(this, m, w, !1, C);
          }, c.prototype.writeDoubleLE = function(m, w, C) {
            return W(this, m, w, !0, C);
          }, c.prototype.writeDoubleBE = function(m, w, C) {
            return W(this, m, w, !1, C);
          }, c.prototype.copy = function(m, w, C, L) {
            if (!c.isBuffer(m)) throw new TypeError("argument should be a Buffer");
            if (C || (C = 0), L || L === 0 || (L = this.length), w >= m.length && (w = m.length), w || (w = 0), L > 0 && L < C && (L = C), L === C || m.length === 0 || this.length === 0) return 0;
            if (w < 0) throw new RangeError("targetStart out of bounds");
            if (C < 0 || C >= this.length) throw new RangeError("Index out of range");
            if (L < 0) throw new RangeError("sourceEnd out of bounds");
            L > this.length && (L = this.length), m.length - w < L - C && (L = m.length - w + C);
            var F = L - C;
            if (this === m && typeof Uint8Array.prototype.copyWithin == "function") this.copyWithin(w, C, L);
            else if (this === m && C < w && w < L) for (var j = F - 1; j >= 0; --j) m[j + w] = this[j + C];
            else Uint8Array.prototype.set.call(m, this.subarray(C, L), w);
            return F;
          }, c.prototype.fill = function(m, w, C, L) {
            if (typeof m == "string") {
              if (typeof w == "string" ? (L = w, w = 0, C = this.length) : typeof C == "string" && (L = C, C = this.length), L !== void 0 && typeof L != "string") throw new TypeError("encoding must be a string");
              if (typeof L == "string" && !c.isEncoding(L)) throw new TypeError("Unknown encoding: " + L);
              if (m.length === 1) {
                var F = m.charCodeAt(0);
                (L === "utf8" && F < 128 || L === "latin1") && (m = F);
              }
            } else typeof m == "number" && (m &= 255);
            if (w < 0 || this.length < w || this.length < C) throw new RangeError("Out of range index");
            if (C <= w) return this;
            var j;
            if (w >>>= 0, C = C === void 0 ? this.length : C >>> 0, m || (m = 0), typeof m == "number") for (j = w; j < C; ++j) this[j] = m;
            else {
              var K = c.isBuffer(m) ? m : c.from(m, L), te = K.length;
              if (te === 0) throw new TypeError('The value "' + m + '" is invalid for argument "value"');
              for (j = 0; j < C - w; ++j) this[j + w] = K[j % te];
            }
            return this;
          };
          var N = /[^+/0-9A-Za-z-_]/g;
          function U(m) {
            return m < 16 ? "0" + m.toString(16) : m.toString(16);
          }
          function Y(m, w) {
            var C;
            w = w || 1 / 0;
            for (var L = m.length, F = null, j = [], K = 0; K < L; ++K) {
              if ((C = m.charCodeAt(K)) > 55295 && C < 57344) {
                if (!F) {
                  if (C > 56319) {
                    (w -= 3) > -1 && j.push(239, 191, 189);
                    continue;
                  }
                  if (K + 1 === L) {
                    (w -= 3) > -1 && j.push(239, 191, 189);
                    continue;
                  }
                  F = C;
                  continue;
                }
                if (C < 56320) {
                  (w -= 3) > -1 && j.push(239, 191, 189), F = C;
                  continue;
                }
                C = 65536 + (F - 55296 << 10 | C - 56320);
              } else F && (w -= 3) > -1 && j.push(239, 191, 189);
              if (F = null, C < 128) {
                if ((w -= 1) < 0) break;
                j.push(C);
              } else if (C < 2048) {
                if ((w -= 2) < 0) break;
                j.push(C >> 6 | 192, 63 & C | 128);
              } else if (C < 65536) {
                if ((w -= 3) < 0) break;
                j.push(C >> 12 | 224, C >> 6 & 63 | 128, 63 & C | 128);
              } else {
                if (!(C < 1114112)) throw new Error("Invalid code point");
                if ((w -= 4) < 0) break;
                j.push(C >> 18 | 240, C >> 12 & 63 | 128, C >> 6 & 63 | 128, 63 & C | 128);
              }
            }
            return j;
          }
          function $(m) {
            return r.toByteArray(function(w) {
              if ((w = (w = w.split("=")[0]).trim().replace(N, "")).length < 2) return "";
              for (; w.length % 4 != 0; ) w += "=";
              return w;
            }(m));
          }
          function Z(m, w, C, L) {
            for (var F = 0; F < L && !(F + C >= w.length || F >= m.length); ++F) w[F + C] = m[F];
            return F;
          }
          function Q(m, w) {
            return m instanceof w || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === w.name;
          }
          function J(m) {
            return m != m;
          }
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "base64-js": 13, buffer: 17, ieee754: 23 }], 18: [function(i, s, a) {
      (function(o) {
        (function() {
          a.formatArgs = function(l) {
            if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + s.exports.humanize(this.diff), !this.useColors) return;
            const n = "color: " + this.color;
            l.splice(1, 0, n, "color: inherit");
            let h = 0, c = 0;
            l[0].replace(/%[a-zA-Z%]/g, (d) => {
              d !== "%%" && d === "%c" && (c = ++h);
            }), l.splice(c, 0, n);
          }, a.save = function(l) {
            try {
              l ? a.storage.setItem("debug", l) : a.storage.removeItem("debug");
            } catch {
            }
          }, a.load = function() {
            let l;
            try {
              l = a.storage.getItem("debug");
            } catch {
            }
            return !l && o !== void 0 && "env" in o && (l = o.env.DEBUG), l;
          }, a.useColors = function() {
            return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }, a.storage = function() {
            try {
              return localStorage;
            } catch {
            }
          }(), a.destroy = /* @__PURE__ */ (() => {
            let l = !1;
            return () => {
              l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })(), a.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], a.log = console.debug || console.log || (() => {
          }), s.exports = i("./common")(a);
          const { formatters: r } = s.exports;
          r.j = function(l) {
            try {
              return JSON.stringify(l);
            } catch (n) {
              return "[UnexpectedJSONParseError]: " + n.message;
            }
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { "./common": 19, _process: 50 }], 19: [function(i, s, a) {
      s.exports = function(o) {
        function r(h) {
          let c, d, f, u = null;
          function g(...y) {
            if (!g.enabled) return;
            const v = g, b = Number(/* @__PURE__ */ new Date()), x = b - (c || b);
            v.diff = x, v.prev = c, v.curr = b, c = b, y[0] = r.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
            let p = 0;
            y[0] = y[0].replace(/%([a-zA-Z%])/g, (k, R) => {
              if (k === "%%") return "%";
              p++;
              const A = r.formatters[R];
              if (typeof A == "function") {
                const P = y[p];
                k = A.call(v, P), y.splice(p, 1), p--;
              }
              return k;
            }), r.formatArgs.call(v, y), (v.log || r.log).apply(v, y);
          }
          return g.namespace = h, g.useColors = r.useColors(), g.color = r.selectColor(h), g.extend = l, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: !0, configurable: !1, get: () => u !== null ? u : (d !== r.namespaces && (d = r.namespaces, f = r.enabled(h)), f), set: (y) => {
            u = y;
          } }), typeof r.init == "function" && r.init(g), g;
        }
        function l(h, c) {
          const d = r(this.namespace + (c === void 0 ? ":" : c) + h);
          return d.log = this.log, d;
        }
        function n(h) {
          return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        return r.debug = r, r.default = r, r.coerce = function(h) {
          return h instanceof Error ? h.stack || h.message : h;
        }, r.disable = function() {
          const h = [...r.names.map(n), ...r.skips.map(n).map((c) => "-" + c)].join(",");
          return r.enable(""), h;
        }, r.enable = function(h) {
          let c;
          r.save(h), r.namespaces = h, r.names = [], r.skips = [];
          const d = (typeof h == "string" ? h : "").split(/[\s,]+/), f = d.length;
          for (c = 0; c < f; c++) d[c] && ((h = d[c].replace(/\*/g, ".*?"))[0] === "-" ? r.skips.push(new RegExp("^" + h.substr(1) + "$")) : r.names.push(new RegExp("^" + h + "$")));
        }, r.enabled = function(h) {
          if (h[h.length - 1] === "*") return !0;
          let c, d;
          for (c = 0, d = r.skips.length; c < d; c++) if (r.skips[c].test(h)) return !1;
          for (c = 0, d = r.names.length; c < d; c++) if (r.names[c].test(h)) return !0;
          return !1;
        }, r.humanize = i("ms"), r.destroy = function() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(o).forEach((h) => {
          r[h] = o[h];
        }), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function(h) {
          let c = 0;
          for (let d = 0; d < h.length; d++) c = (c << 5) - c + h.charCodeAt(d), c |= 0;
          return r.colors[Math.abs(c) % r.colors.length];
        }, r.enable(r.load()), r;
      };
    }, { ms: 45 }], 20: [function(i, s, a) {
      (function(o, r) {
        (function() {
          var l = i("readable-stream"), n = i("end-of-stream"), h = i("inherits"), c = i("stream-shift"), d = r.from && r.from !== Uint8Array.from ? r.from([0]) : new r([0]), f = function(v, b) {
            v._corked ? v.once("uncork", b) : b();
          }, u = function(v, b) {
            return function(x) {
              x ? function(p, k) {
                p._autoDestroy && p.destroy(k);
              }(v, x.message === "premature close" ? null : x) : b && !v._ended && v.end();
            };
          }, g = function() {
          }, y = function(v, b, x) {
            if (!(this instanceof y)) return new y(v, b, x);
            l.Duplex.call(this, x), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !x || x.autoDestroy !== !1, this._forwardDestroy = !x || x.destroy !== !1, this._forwardEnd = !x || x.end !== !1, this._corked = 1, this._ondrain = null, this._drained = !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, v && this.setWritable(v), b && this.setReadable(b);
          };
          h(y, l.Duplex), y.obj = function(v, b, x) {
            return x || (x = {}), x.objectMode = !0, x.highWaterMark = 16, new y(v, b, x);
          }, y.prototype.cork = function() {
            ++this._corked == 1 && this.emit("cork");
          }, y.prototype.uncork = function() {
            this._corked && --this._corked == 0 && this.emit("uncork");
          }, y.prototype.setWritable = function(v) {
            if (this._unwrite && this._unwrite(), this.destroyed) v && v.destroy && v.destroy();
            else if (v !== null && v !== !1) {
              var b = this, x = n(v, { writable: !0, readable: !1 }, u(this, this._forwardEnd)), p = function() {
                var k = b._ondrain;
                b._ondrain = null, k && k();
              };
              this._unwrite && o.nextTick(p), this._writable = v, this._writable.on("drain", p), this._unwrite = function() {
                b._writable.removeListener("drain", p), x();
              }, this.uncork();
            } else this.end();
          }, y.prototype.setReadable = function(v) {
            if (this._unread && this._unread(), this.destroyed) v && v.destroy && v.destroy();
            else {
              if (v === null || v === !1) return this.push(null), void this.resume();
              var b, x = this, p = n(v, { writable: !1, readable: !0 }, u(this)), k = function() {
                x._forward();
              }, R = function() {
                x.push(null);
              };
              this._drained = !0, this._readable = v, this._readable2 = v._readableState ? v : (b = v, new l.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(b)), this._readable2.on("readable", k), this._readable2.on("end", R), this._unread = function() {
                x._readable2.removeListener("readable", k), x._readable2.removeListener("end", R), p();
              }, this._forward();
            }
          }, y.prototype._read = function() {
            this._drained = !0, this._forward();
          }, y.prototype._forward = function() {
            if (!this._forwarding && this._readable2 && this._drained) {
              var v;
              for (this._forwarding = !0; this._drained && (v = c(this._readable2)) !== null; ) this.destroyed || (this._drained = this.push(v));
              this._forwarding = !1;
            }
          }, y.prototype.destroy = function(v, b) {
            if (b || (b = g), this.destroyed) return b(null);
            this.destroyed = !0;
            var x = this;
            o.nextTick(function() {
              x._destroy(v), b(null);
            });
          }, y.prototype._destroy = function(v) {
            if (v) {
              var b = this._ondrain;
              this._ondrain = null, b ? b(v) : this.emit("error", v);
            }
            this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
          }, y.prototype._write = function(v, b, x) {
            if (!this.destroyed) return this._corked ? f(this, this._write.bind(this, v, b, x)) : v === d ? this._finish(x) : this._writable ? void (this._writable.write(v) === !1 ? this._ondrain = x : this.destroyed || x()) : x();
          }, y.prototype._finish = function(v) {
            var b = this;
            this.emit("preend"), f(this, function() {
              var x, p;
              x = b._forwardEnd && b._writable, p = function() {
                b._writableState.prefinished === !1 && (b._writableState.prefinished = !0), b.emit("prefinish"), f(b, v);
              }, x ? x._writableState && x._writableState.finished ? p() : x._writableState ? x.end(p) : (x.end(), p()) : p();
            });
          }, y.prototype.end = function(v, b, x) {
            return typeof v == "function" ? this.end(null, null, v) : typeof b == "function" ? this.end(v, null, b) : (this._ended = !0, v && this.write(v), this._writableState.ending || this._writableState.destroyed || this.write(d), l.Writable.prototype.end.call(this, x));
          }, s.exports = y;
        }).call(this);
      }).call(this, i("_process"), i("buffer").Buffer);
    }, { _process: 50, buffer: 17, "end-of-stream": 21, inherits: 24, "readable-stream": 69, "stream-shift": 74 }], 21: [function(i, s, a) {
      (function(o) {
        (function() {
          var r = i("once"), l = function() {
          }, n = function(h, c, d) {
            if (typeof c == "function") return n(h, null, c);
            c || (c = {}), d = r(d || l);
            var f = h._writableState, u = h._readableState, g = c.readable || c.readable !== !1 && h.readable, y = c.writable || c.writable !== !1 && h.writable, v = !1, b = function() {
              h.writable || x();
            }, x = function() {
              y = !1, g || d.call(h);
            }, p = function() {
              g = !1, y || d.call(h);
            }, k = function(D) {
              d.call(h, D ? new Error("exited with error code: " + D) : null);
            }, R = function(D) {
              d.call(h, D);
            }, A = function() {
              o.nextTick(P);
            }, P = function() {
              if (!v) return (!g || u && u.ended && !u.destroyed) && (!y || f && f.ended && !f.destroyed) ? void 0 : d.call(h, new Error("premature close"));
            }, E = function() {
              h.req.on("finish", x);
            };
            return function(D) {
              return D.setHeader && typeof D.abort == "function";
            }(h) ? (h.on("complete", x), h.on("abort", A), h.req ? E() : h.on("request", E)) : y && !f && (h.on("end", b), h.on("close", b)), function(D) {
              return D.stdio && Array.isArray(D.stdio) && D.stdio.length === 3;
            }(h) && h.on("exit", k), h.on("end", p), h.on("finish", x), c.error !== !1 && h.on("error", R), h.on("close", A), function() {
              v = !0, h.removeListener("complete", x), h.removeListener("abort", A), h.removeListener("request", E), h.req && h.req.removeListener("finish", x), h.removeListener("end", b), h.removeListener("close", b), h.removeListener("finish", x), h.removeListener("exit", k), h.removeListener("end", p), h.removeListener("error", R), h.removeListener("close", A);
            };
          };
          s.exports = n;
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50, once: 48 }], 22: [function(i, s, a) {
      var o = Object.create || function(p) {
        var k = function() {
        };
        return k.prototype = p, new k();
      }, r = Object.keys || function(p) {
        var k = [];
        for (var R in p) Object.prototype.hasOwnProperty.call(p, R) && k.push(R);
        return R;
      }, l = Function.prototype.bind || function(p) {
        var k = this;
        return function() {
          return k.apply(p, arguments);
        };
      };
      function n() {
        this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = o(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }
      s.exports = n, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._maxListeners = void 0;
      var h, c = 10;
      try {
        var d = {};
        Object.defineProperty && Object.defineProperty(d, "x", { value: 0 }), h = d.x === 0;
      } catch {
        h = !1;
      }
      function f(p) {
        return p._maxListeners === void 0 ? n.defaultMaxListeners : p._maxListeners;
      }
      function u(p, k, R, A) {
        var P, E, D;
        if (typeof R != "function") throw new TypeError('"listener" argument must be a function');
        if ((E = p._events) ? (E.newListener && (p.emit("newListener", k, R.listener ? R.listener : R), E = p._events), D = E[k]) : (E = p._events = o(null), p._eventsCount = 0), D) {
          if (typeof D == "function" ? D = E[k] = A ? [R, D] : [D, R] : A ? D.unshift(R) : D.push(R), !D.warned && (P = f(p)) && P > 0 && D.length > P) {
            D.warned = !0;
            var q = new Error("Possible EventEmitter memory leak detected. " + D.length + ' "' + String(k) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            q.name = "MaxListenersExceededWarning", q.emitter = p, q.type = k, q.count = D.length, typeof console == "object" && console.warn && console.warn("%s: %s", q.name, q.message);
          }
        } else D = E[k] = R, ++p._eventsCount;
        return p;
      }
      function g() {
        if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
          case 0:
            return this.listener.call(this.target);
          case 1:
            return this.listener.call(this.target, arguments[0]);
          case 2:
            return this.listener.call(this.target, arguments[0], arguments[1]);
          case 3:
            return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
          default:
            for (var p = new Array(arguments.length), k = 0; k < p.length; ++k) p[k] = arguments[k];
            this.listener.apply(this.target, p);
        }
      }
      function y(p, k, R) {
        var A = { fired: !1, wrapFn: void 0, target: p, type: k, listener: R }, P = l.call(g, A);
        return P.listener = R, A.wrapFn = P, P;
      }
      function v(p, k, R) {
        var A = p._events;
        if (!A) return [];
        var P = A[k];
        return P ? typeof P == "function" ? R ? [P.listener || P] : [P] : R ? function(E) {
          for (var D = new Array(E.length), q = 0; q < D.length; ++q) D[q] = E[q].listener || E[q];
          return D;
        }(P) : x(P, P.length) : [];
      }
      function b(p) {
        var k = this._events;
        if (k) {
          var R = k[p];
          if (typeof R == "function") return 1;
          if (R) return R.length;
        }
        return 0;
      }
      function x(p, k) {
        for (var R = new Array(k), A = 0; A < k; ++A) R[A] = p[A];
        return R;
      }
      h ? Object.defineProperty(n, "defaultMaxListeners", { enumerable: !0, get: function() {
        return c;
      }, set: function(p) {
        if (typeof p != "number" || p < 0 || p != p) throw new TypeError('"defaultMaxListeners" must be a positive number');
        c = p;
      } }) : n.defaultMaxListeners = c, n.prototype.setMaxListeners = function(p) {
        if (typeof p != "number" || p < 0 || isNaN(p)) throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = p, this;
      }, n.prototype.getMaxListeners = function() {
        return f(this);
      }, n.prototype.emit = function(p) {
        var k, R, A, P, E, D, q = p === "error";
        if (D = this._events) q = q && D.error == null;
        else if (!q) return !1;
        if (q) {
          if (arguments.length > 1 && (k = arguments[1]), k instanceof Error) throw k;
          var I = new Error('Unhandled "error" event. (' + k + ")");
          throw I.context = k, I;
        }
        if (!(R = D[p])) return !1;
        var S = typeof R == "function";
        switch (A = arguments.length) {
          case 1:
            (function(T, _, z) {
              if (_) T.call(z);
              else for (var V = T.length, X = x(T, V), H = 0; H < V; ++H) X[H].call(z);
            })(R, S, this);
            break;
          case 2:
            (function(T, _, z, V) {
              if (_) T.call(z, V);
              else for (var X = T.length, H = x(T, X), M = 0; M < X; ++M) H[M].call(z, V);
            })(R, S, this, arguments[1]);
            break;
          case 3:
            (function(T, _, z, V, X) {
              if (_) T.call(z, V, X);
              else for (var H = T.length, M = x(T, H), B = 0; B < H; ++B) M[B].call(z, V, X);
            })(R, S, this, arguments[1], arguments[2]);
            break;
          case 4:
            (function(T, _, z, V, X, H) {
              if (_) T.call(z, V, X, H);
              else for (var M = T.length, B = x(T, M), W = 0; W < M; ++W) B[W].call(z, V, X, H);
            })(R, S, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            for (P = new Array(A - 1), E = 1; E < A; E++) P[E - 1] = arguments[E];
            (function(T, _, z, V) {
              if (_) T.apply(z, V);
              else for (var X = T.length, H = x(T, X), M = 0; M < X; ++M) H[M].apply(z, V);
            })(R, S, this, P);
        }
        return !0;
      }, n.prototype.addListener = function(p, k) {
        return u(this, p, k, !1);
      }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(p, k) {
        return u(this, p, k, !0);
      }, n.prototype.once = function(p, k) {
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        return this.on(p, y(this, p, k)), this;
      }, n.prototype.prependOnceListener = function(p, k) {
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        return this.prependListener(p, y(this, p, k)), this;
      }, n.prototype.removeListener = function(p, k) {
        var R, A, P, E, D;
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        if (!(A = this._events)) return this;
        if (!(R = A[p])) return this;
        if (R === k || R.listener === k) --this._eventsCount == 0 ? this._events = o(null) : (delete A[p], A.removeListener && this.emit("removeListener", p, R.listener || k));
        else if (typeof R != "function") {
          for (P = -1, E = R.length - 1; E >= 0; E--) if (R[E] === k || R[E].listener === k) {
            D = R[E].listener, P = E;
            break;
          }
          if (P < 0) return this;
          P === 0 ? R.shift() : function(q, I) {
            for (var S = I, T = S + 1, _ = q.length; T < _; S += 1, T += 1) q[S] = q[T];
            q.pop();
          }(R, P), R.length === 1 && (A[p] = R[0]), A.removeListener && this.emit("removeListener", p, D || k);
        }
        return this;
      }, n.prototype.removeAllListeners = function(p) {
        var k, R, A;
        if (!(R = this._events)) return this;
        if (!R.removeListener) return arguments.length === 0 ? (this._events = o(null), this._eventsCount = 0) : R[p] && (--this._eventsCount == 0 ? this._events = o(null) : delete R[p]), this;
        if (arguments.length === 0) {
          var P, E = r(R);
          for (A = 0; A < E.length; ++A) (P = E[A]) !== "removeListener" && this.removeAllListeners(P);
          return this.removeAllListeners("removeListener"), this._events = o(null), this._eventsCount = 0, this;
        }
        if (typeof (k = R[p]) == "function") this.removeListener(p, k);
        else if (k) for (A = k.length - 1; A >= 0; A--) this.removeListener(p, k[A]);
        return this;
      }, n.prototype.listeners = function(p) {
        return v(this, p, !0);
      }, n.prototype.rawListeners = function(p) {
        return v(this, p, !1);
      }, n.listenerCount = function(p, k) {
        return typeof p.listenerCount == "function" ? p.listenerCount(k) : b.call(p, k);
      }, n.prototype.listenerCount = b, n.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }, {}], 23: [function(i, s, a) {
      a.read = function(o, r, l, n, h) {
        var c, d, f = 8 * h - n - 1, u = (1 << f) - 1, g = u >> 1, y = -7, v = l ? h - 1 : 0, b = l ? -1 : 1, x = o[r + v];
        for (v += b, c = x & (1 << -y) - 1, x >>= -y, y += f; y > 0; c = 256 * c + o[r + v], v += b, y -= 8) ;
        for (d = c & (1 << -y) - 1, c >>= -y, y += n; y > 0; d = 256 * d + o[r + v], v += b, y -= 8) ;
        if (c === 0) c = 1 - g;
        else {
          if (c === u) return d ? NaN : 1 / 0 * (x ? -1 : 1);
          d += Math.pow(2, n), c -= g;
        }
        return (x ? -1 : 1) * d * Math.pow(2, c - n);
      }, a.write = function(o, r, l, n, h, c) {
        var d, f, u, g = 8 * c - h - 1, y = (1 << g) - 1, v = y >> 1, b = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : c - 1, p = n ? 1 : -1, k = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (f = isNaN(r) ? 1 : 0, d = y) : (d = Math.floor(Math.log(r) / Math.LN2), r * (u = Math.pow(2, -d)) < 1 && (d--, u *= 2), (r += d + v >= 1 ? b / u : b * Math.pow(2, 1 - v)) * u >= 2 && (d++, u /= 2), d + v >= y ? (f = 0, d = y) : d + v >= 1 ? (f = (r * u - 1) * Math.pow(2, h), d += v) : (f = r * Math.pow(2, v - 1) * Math.pow(2, h), d = 0)); h >= 8; o[l + x] = 255 & f, x += p, f /= 256, h -= 8) ;
        for (d = d << h | f, g += h; g > 0; o[l + x] = 255 & d, x += p, d /= 256, g -= 8) ;
        o[l + x - p] |= 128 * k;
      };
    }, {}], 24: [function(i, s, a) {
      typeof Object.create == "function" ? s.exports = function(o, r) {
        r && (o.super_ = r, o.prototype = Object.create(r.prototype, { constructor: { value: o, enumerable: !1, writable: !0, configurable: !0 } }));
      } : s.exports = function(o, r) {
        if (r) {
          o.super_ = r;
          var l = function() {
          };
          l.prototype = r.prototype, o.prototype = new l(), o.prototype.constructor = o;
        }
      };
    }, {}], 25: [function(i, s, a) {
      Object.defineProperty(a, "__esModule", { value: !0 });
      var o = function() {
        function r(l, n) {
          this.color = !0, this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0, this.leftChild = void 0, this.rightChild = void 0, this.key = l, this.value = n;
        }
        return r.prototype.rotateLeft = function() {
          var l = this.parent, n = this.brother, h = this.leftChild, c = this.rightChild;
          if (!c) throw new Error("unknown error");
          var d = c.leftChild, f = c.rightChild;
          return l && (l.leftChild === this ? l.leftChild = c : l.rightChild === this && (l.rightChild = c)), c.parent = l, c.brother = n, c.leftChild = this, c.rightChild = f, n && (n.brother = c), this.parent = c, this.brother = f, this.leftChild = h, this.rightChild = d, f && (f.parent = c, f.brother = this), h && (h.parent = this, h.brother = d), d && (d.parent = this, d.brother = h), c;
        }, r.prototype.rotateRight = function() {
          var l = this.parent, n = this.brother, h = this.leftChild;
          if (!h) throw new Error("unknown error");
          var c = this.rightChild, d = h.leftChild, f = h.rightChild;
          return l && (l.leftChild === this ? l.leftChild = h : l.rightChild === this && (l.rightChild = h)), h.parent = l, h.brother = n, h.leftChild = d, h.rightChild = this, n && (n.brother = h), d && (d.parent = h, d.brother = this), this.parent = h, this.brother = d, this.leftChild = f, this.rightChild = c, f && (f.parent = this, f.brother = c), c && (c.parent = this, c.brother = f), h;
        }, r.prototype.remove = function() {
          if (this.leftChild || this.rightChild) throw new Error("can only remove leaf node");
          this.parent && (this === this.parent.leftChild ? this.parent.leftChild = void 0 : this === this.parent.rightChild && (this.parent.rightChild = void 0)), this.brother && (this.brother.brother = void 0), this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0;
        }, r.TreeNodeColorType = { red: !0, black: !1 }, r;
      }();
      Object.freeze(o), a.default = o;
    }, {}], 26: [function(i, s, a) {
      var o = this && this.__generator || function(l, n) {
        var h, c, d, f, u = { label: 0, sent: function() {
          if (1 & d[0]) throw d[1];
          return d[1];
        }, trys: [], ops: [] };
        return f = { next: g(0), throw: g(1), return: g(2) }, typeof Symbol == "function" && (f[Symbol.iterator] = function() {
          return this;
        }), f;
        function g(y) {
          return function(v) {
            return function(b) {
              if (h) throw new TypeError("Generator is already executing.");
              for (; u; ) try {
                if (h = 1, c && (d = 2 & b[0] ? c.return : b[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, b[1])).done) return d;
                switch (c = 0, d && (b = [2 & b[0], d.value]), b[0]) {
                  case 0:
                  case 1:
                    d = b;
                    break;
                  case 4:
                    return u.label++, { value: b[1], done: !1 };
                  case 5:
                    u.label++, c = b[1], b = [0];
                    continue;
                  case 7:
                    b = u.ops.pop(), u.trys.pop();
                    continue;
                  default:
                    if (!(d = (d = u.trys).length > 0 && d[d.length - 1]) && (b[0] === 6 || b[0] === 2)) {
                      u = 0;
                      continue;
                    }
                    if (b[0] === 3 && (!d || b[1] > d[0] && b[1] < d[3])) {
                      u.label = b[1];
                      break;
                    }
                    if (b[0] === 6 && u.label < d[1]) {
                      u.label = d[1], d = b;
                      break;
                    }
                    if (d && u.label < d[2]) {
                      u.label = d[2], u.ops.push(b);
                      break;
                    }
                    d[2] && u.ops.pop(), u.trys.pop();
                    continue;
                }
                b = n.call(l, u);
              } catch (x) {
                b = [6, x], c = 0;
              } finally {
                h = d = 0;
              }
              if (5 & b[0]) throw b[1];
              return { value: b[0] ? b[1] : void 0, done: !0 };
            }([y, v]);
          };
        }
      };
      function r(l) {
        var n = this;
        l === void 0 && (l = []);
        var h = [], c = 0, d = 0, f = 0, u = 0, g = 0, y = 0;
        this.size = function() {
          return y;
        }, this.empty = function() {
          return y === 0;
        }, this.clear = function() {
          c = f = d = u = g = y = 0, b.call(this, r.bucketSize), y = 0;
        }, this.front = function() {
          return h[c][d];
        }, this.back = function() {
          return h[f][u];
        }, this.forEach = function(x) {
          if (!this.empty()) {
            var p = 0;
            if (c !== f) {
              for (R = d; R < r.bucketSize; ++R) x(h[c][R], p++);
              for (R = c + 1; R < f; ++R) for (var k = 0; k < r.bucketSize; ++k) x(h[R][k], p++);
              for (R = 0; R <= u; ++R) x(h[f][R], p++);
            } else for (var R = d; R <= u; ++R) x(h[c][R], p++);
          }
        };
        var v = function(x) {
          var p = c * r.bucketSize + d, k = p + x, R = f * r.bucketSize + u;
          if (k < p || k > R) throw new Error("pos should more than 0 and less than queue's size");
          return { curNodeBucketIndex: Math.floor(k / r.bucketSize), curNodePointerIndex: k % r.bucketSize };
        };
        this.getElementByPos = function(x) {
          var p = v(x), k = p.curNodeBucketIndex, R = p.curNodePointerIndex;
          return h[k][R];
        }, this.eraseElementByPos = function(x) {
          var p = this;
          if (x < 0 || x > y) throw new Error("pos should more than 0 and less than queue's size");
          if (x === 0) this.popFront();
          else if (x === this.size()) this.popBack();
          else {
            for (var k = [], R = x + 1; R < y; ++R) k.push(this.getElementByPos(R));
            this.cut(x), this.popBack(), k.forEach(function(A) {
              return p.pushBack(A);
            });
          }
        }, this.eraseElementByValue = function(x) {
          if (!this.empty()) {
            var p = [];
            this.forEach(function(A) {
              A !== x && p.push(A);
            });
            for (var k = p.length, R = 0; R < k; ++R) this.setElementByPos(R, p[R]);
            this.cut(k - 1);
          }
        };
        var b = function(x) {
          for (var p = [], k = x * r.sigma, R = Math.max(Math.ceil(k / r.bucketSize), 2), A = 0; A < R; ++A) p.push(new Array(r.bucketSize));
          var P = Math.ceil(x / r.bucketSize), E = Math.floor(R / 2) - Math.floor(P / 2), D = E, q = 0;
          if (this.size()) for (A = 0; A < P; ++A) {
            for (var I = 0; I < r.bucketSize; ++I) if (p[E + A][I] = this.front(), this.popFront(), this.empty()) {
              D = E + A, q = I;
              break;
            }
            if (this.empty()) break;
          }
          h = p, c = E, d = 0, f = D, u = q, g = R, y = x;
        };
        this.pushBack = function(x) {
          this.empty() || (f === g - 1 && u === r.bucketSize - 1 && b.call(this, this.size()), u < r.bucketSize - 1 ? ++u : f < g - 1 && (++f, u = 0)), ++y, h[f][u] = x;
        }, this.popBack = function() {
          this.empty() || (this.size() !== 1 && (u > 0 ? --u : c < f && (--f, u = r.bucketSize - 1)), y > 0 && --y);
        }, this.setElementByPos = function(x, p) {
          var k = v(x), R = k.curNodeBucketIndex, A = k.curNodePointerIndex;
          h[R][A] = p;
        }, this.insert = function(x, p, k) {
          var R = this;
          if (k === void 0 && (k = 1), x === 0) for (; k--; ) this.pushFront(p);
          else if (x === this.size()) for (; k--; ) this.pushBack(p);
          else {
            for (var A = [], P = x; P < y; ++P) A.push(this.getElementByPos(P));
            for (this.cut(x - 1), P = 0; P < k; ++P) this.pushBack(p);
            A.forEach(function(E) {
              return R.pushBack(E);
            });
          }
        }, this.find = function(x) {
          if (c === f) {
            for (var p = d; p <= u; ++p) if (h[c][p] === x) return !0;
            return !1;
          }
          for (p = d; p < r.bucketSize; ++p) if (h[c][p] === x) return !0;
          for (p = c + 1; p < f; ++p) for (var k = 0; k < r.bucketSize; ++k) if (h[p][k] === x) return !0;
          for (p = 0; p <= u; ++p) if (h[f][p] === x) return !0;
          return !1;
        }, this.reverse = function() {
          for (var x = 0, p = y - 1; x < p; ) {
            var k = this.getElementByPos(x);
            this.setElementByPos(x, this.getElementByPos(p)), this.setElementByPos(p, k), ++x, --p;
          }
        }, this.unique = function() {
          if (!this.empty()) {
            var x = [], p = this.front();
            this.forEach(function(R, A) {
              A !== 0 && R === p || (x.push(R), p = R);
            });
            for (var k = 0; k < y; ++k) this.setElementByPos(k, x[k]);
            this.cut(x.length - 1);
          }
        }, this.sort = function(x) {
          var p = [];
          this.forEach(function(R) {
            p.push(R);
          }), p.sort(x);
          for (var k = 0; k < y; ++k) this.setElementByPos(k, p[k]);
        }, this.pushFront = function(x) {
          this.empty() || (c === 0 && d === 0 && b.call(this, this.size()), d > 0 ? --d : c > 0 && (--c, d = r.bucketSize - 1)), ++y, h[c][d] = x;
        }, this.popFront = function() {
          this.empty() || (this.size() !== 1 && (d < r.bucketSize - 1 ? ++d : c < f && (++c, d = 0)), y > 0 && --y);
        }, this.shrinkToFit = function() {
          var x = this, p = [];
          this.forEach(function(P) {
            p.push(P);
          });
          var k = p.length;
          h = [];
          for (var R = Math.ceil(k / r.bucketSize), A = 0; A < R; ++A) h.push(new Array(r.bucketSize));
          this.clear(), p.forEach(function(P) {
            return x.pushBack(P);
          });
        }, this.cut = function(x) {
          if (x < 0) this.clear();
          else {
            var p = v(x), k = p.curNodeBucketIndex, R = p.curNodePointerIndex;
            f = k, u = R, y = x + 1;
          }
        }, this[Symbol.iterator] = function() {
          return function() {
            var x, p;
            return o(this, function(k) {
              switch (k.label) {
                case 0:
                  if (y === 0) return [2];
                  if (c !== f) return [3, 5];
                  p = d, k.label = 1;
                case 1:
                  return p <= u ? [4, h[c][p]] : [3, 4];
                case 2:
                  k.sent(), k.label = 3;
                case 3:
                  return ++p, [3, 1];
                case 4:
                  return [2];
                case 5:
                  p = d, k.label = 6;
                case 6:
                  return p < r.bucketSize ? [4, h[c][p]] : [3, 9];
                case 7:
                  k.sent(), k.label = 8;
                case 8:
                  return ++p, [3, 6];
                case 9:
                  p = c + 1, k.label = 10;
                case 10:
                  if (!(p < f)) return [3, 15];
                  x = 0, k.label = 11;
                case 11:
                  return x < r.bucketSize ? [4, h[p][x]] : [3, 14];
                case 12:
                  k.sent(), k.label = 13;
                case 13:
                  return ++x, [3, 11];
                case 14:
                  return ++p, [3, 10];
                case 15:
                  p = 0, k.label = 16;
                case 16:
                  return p <= u ? [4, h[f][p]] : [3, 19];
                case 17:
                  k.sent(), k.label = 18;
                case 18:
                  return ++p, [3, 16];
                case 19:
                  return [2];
              }
            });
          }();
        }, function() {
          var x = r.bucketSize;
          l.size ? x = l.size() : l.length && (x = l.length);
          var p = x * r.sigma;
          g = Math.ceil(p / r.bucketSize), g = Math.max(g, 3);
          for (var k = 0; k < g; ++k) h.push(new Array(r.bucketSize));
          var R = Math.ceil(x / r.bucketSize);
          c = Math.floor(g / 2) - Math.floor(R / 2), f = c, l.forEach(function(A) {
            return n.pushBack(A);
          });
        }(), Object.freeze(this);
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), r.sigma = 3, r.bucketSize = 5e3, Object.freeze(r), a.default = r;
    }, {}], 27: [function(i, s, a) {
      var o = this && this.__generator || function(c, d) {
        var f, u, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (f) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (f = 1, u && (g = 2 & k[0] ? u.return : k[0] ? u.throw || ((g = u.return) && g.call(u), 0) : u.next) && !(g = g.call(u, k[1])).done) return g;
                switch (u = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, u = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (R) {
                k = [6, R], u = 0;
              } finally {
                f = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, f = d && c[d], u = 0;
        if (f) return f.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(a, "__esModule", { value: !0 });
      var l = i("../LinkList/LinkList"), n = i("../Map/Map");
      function h(c, d, f) {
        var u = this;
        if (c === void 0 && (c = []), d === void 0 && (d = h.initSize), f = f || function(b) {
          var x, p, k = 0, R = "";
          if (typeof b == "number") k = ((k = Math.floor(b)) << 5) - k, k &= k;
          else {
            R = typeof b != "string" ? JSON.stringify(b) : b;
            try {
              for (var A = r(R), P = A.next(); !P.done; P = A.next())
                k = (k << 5) - k + P.value.charCodeAt(0), k &= k;
            } catch (E) {
              x = { error: E };
            } finally {
              try {
                P && !P.done && (p = A.return) && p.call(A);
              } finally {
                if (x) throw x.error;
              }
            }
          }
          return k ^= k >>> 16;
        }, (d & d - 1) != 0) throw new Error("initBucketNum must be 2 to the power of n");
        var g = 0, y = [], v = Math.max(h.initSize, Math.min(h.maxSize, d));
        this.size = function() {
          return g;
        }, this.empty = function() {
          return g === 0;
        }, this.clear = function() {
          g = 0, v = d, y = [];
        }, this.forEach = function(b) {
          var x = 0;
          y.forEach(function(p) {
            p.forEach(function(k) {
              b(k, x++);
            });
          });
        }, this.setElement = function(b, x) {
          var p, k;
          if (b == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (x != null) {
            var R = f(b) & v - 1;
            if (y[R]) {
              var A = y[R].size();
              if (y[R] instanceof l.default) {
                try {
                  for (var P = r(y[R]), E = P.next(); !E.done; E = P.next()) {
                    var D = E.value;
                    if (D.key === b) return void (D.value = x);
                  }
                } catch (I) {
                  p = { error: I };
                } finally {
                  try {
                    E && !E.done && (k = P.return) && k.call(P);
                  } finally {
                    if (p) throw p.error;
                  }
                }
                y[R].pushBack({ key: b, value: x }), y[R].size() >= h.treeifyThreshold && (y[R] = new n.default(y[R]));
              } else y[R].setElement(b, x);
              var q = y[R].size();
              g += q - A;
            } else ++g, y[R] = new l.default([{ key: b, value: x }]);
            g > v * h.sigma && (function(I) {
              if (!(I >= h.maxSize)) {
                v = 2 * I;
                var S = [];
                y.forEach(function(T, _) {
                  if (!T.empty()) {
                    if (T instanceof l.default && T.size() === 1) {
                      var z = T.front(), V = z.key, X = z.value;
                      S[f(V) & v - 1] = new l.default([{ key: V, value: X }]);
                    } else if (T instanceof n.default) {
                      var H = new l.default(), M = new l.default();
                      T.forEach(function(N) {
                        f(N.key) & I ? M.pushBack(N) : H.pushBack(N);
                      }), H.size() > h.untreeifyThreshold ? S[_] = new n.default(H) : H.size() && (S[_] = H), M.size() > h.untreeifyThreshold ? S[_ + I] = new n.default(M) : M.size() && (S[_ + I] = M);
                    } else {
                      var B = new l.default(), W = new l.default();
                      T.forEach(function(N) {
                        f(N.key) & I ? W.pushBack(N) : B.pushBack(N);
                      }), B.size() && (S[_] = B), W.size() && (S[_ + I] = W);
                    }
                    y[_].clear();
                  }
                }), y = S;
              }
            }).call(this, v);
          } else this.eraseElementByKey(b);
        }, this.getElementByKey = function(b) {
          var x, p, k = f(b) & v - 1;
          if (y[k]) {
            if (y[k] instanceof n.default) return y[k].getElementByKey(b);
            try {
              for (var R = r(y[k]), A = R.next(); !A.done; A = R.next()) {
                var P = A.value;
                if (P.key === b) return P.value;
              }
            } catch (E) {
              x = { error: E };
            } finally {
              try {
                A && !A.done && (p = R.return) && p.call(R);
              } finally {
                if (x) throw x.error;
              }
            }
          }
        }, this.eraseElementByKey = function(b) {
          var x, p, k = f(b) & v - 1;
          if (y[k]) {
            var R = y[k].size();
            if (y[k] instanceof n.default) y[k].eraseElementByKey(b), y[k].size() <= h.untreeifyThreshold && (y[k] = new l.default(y[k]));
            else {
              var A = -1;
              try {
                for (var P = r(y[k]), E = P.next(); !E.done; E = P.next())
                  if (++A, E.value.key === b) {
                    y[k].eraseElementByPos(A);
                    break;
                  }
              } catch (q) {
                x = { error: q };
              } finally {
                try {
                  E && !E.done && (p = P.return) && p.call(P);
                } finally {
                  if (x) throw x.error;
                }
              }
            }
            var D = y[k].size();
            g += D - R;
          }
        }, this.find = function(b) {
          var x, p, k = f(b) & v - 1;
          if (!y[k]) return !1;
          if (y[k] instanceof n.default) return y[k].find(b);
          try {
            for (var R = r(y[k]), A = R.next(); !A.done; A = R.next())
              if (A.value.key === b) return !0;
          } catch (P) {
            x = { error: P };
          } finally {
            try {
              A && !A.done && (p = R.return) && p.call(R);
            } finally {
              if (x) throw x.error;
            }
          }
          return !1;
        }, this[Symbol.iterator] = function() {
          return function() {
            var b, x, p, k, R, A;
            return o(this, function(P) {
              switch (P.label) {
                case 0:
                  b = 0, P.label = 1;
                case 1:
                  if (!(b < v)) return [3, 10];
                  for (; b < v && !y[b]; ) ++b;
                  if (b >= v) return [3, 10];
                  P.label = 2;
                case 2:
                  P.trys.push([2, 7, 8, 9]), R = void 0, x = r(y[b]), p = x.next(), P.label = 3;
                case 3:
                  return p.done ? [3, 6] : [4, p.value];
                case 4:
                  P.sent(), P.label = 5;
                case 5:
                  return p = x.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return k = P.sent(), R = { error: k }, [3, 9];
                case 8:
                  try {
                    p && !p.done && (A = x.return) && A.call(x);
                  } finally {
                    if (R) throw R.error;
                  }
                  return [7];
                case 9:
                  return ++b, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, c.forEach(function(b) {
          var x = b.key, p = b.value;
          return u.setElement(x, p);
        }), Object.freeze(this);
      }
      h.initSize = 16, h.maxSize = 1 << 30, h.sigma = 0.75, h.treeifyThreshold = 8, h.untreeifyThreshold = 6, h.minTreeifySize = 64, Object.freeze(h), a.default = h;
    }, { "../LinkList/LinkList": 29, "../Map/Map": 30 }], 28: [function(i, s, a) {
      var o = this && this.__generator || function(c, d) {
        var f, u, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (f) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (f = 1, u && (g = 2 & k[0] ? u.return : k[0] ? u.throw || ((g = u.return) && g.call(u), 0) : u.next) && !(g = g.call(u, k[1])).done) return g;
                switch (u = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, u = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (R) {
                k = [6, R], u = 0;
              } finally {
                f = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, f = d && c[d], u = 0;
        if (f) return f.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(a, "__esModule", { value: !0 });
      var l = i("../Set/Set"), n = i("../LinkList/LinkList");
      function h(c, d, f) {
        var u = this;
        if (c === void 0 && (c = []), d === void 0 && (d = h.initSize), f = f || function(b) {
          var x = 0, p = "";
          if (typeof b == "number") x = ((x = Math.floor(b)) << 5) - x, x &= x;
          else {
            p = typeof b != "string" ? JSON.stringify(b) : b;
            for (var k = 0; k < p.length; k++)
              x = (x << 5) - x + p.charCodeAt(k), x &= x;
          }
          return x ^= x >>> 16;
        }, (d & d - 1) != 0) throw new Error("initBucketNum must be 2 to the power of n");
        var g = 0, y = [], v = Math.max(h.initSize, Math.min(h.maxSize, d));
        this.size = function() {
          return g;
        }, this.empty = function() {
          return g === 0;
        }, this.clear = function() {
          g = 0, v = d, y = [];
        }, this.forEach = function(b) {
          var x = 0;
          y.forEach(function(p) {
            p.forEach(function(k) {
              b(k, x++);
            });
          });
        }, this.insert = function(b) {
          if (b == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          var x = f(b) & v - 1;
          if (y[x]) {
            var p = y[x].size();
            if (y[x] instanceof n.default) {
              if (y[x].find(b)) return;
              y[x].pushBack(b), y[x].size() >= h.treeifyThreshold && (y[x] = new l.default(y[x]));
            } else y[x].insert(b);
            var k = y[x].size();
            g += k - p;
          } else y[x] = new n.default([b]), ++g;
          g > v * h.sigma && (function(R) {
            if (!(R >= h.maxSize)) {
              v = 2 * R;
              var A = [];
              y.forEach(function(P, E) {
                if (!P.empty()) {
                  if (P instanceof n.default && P.size() === 1) {
                    var D = P.front();
                    if (D === void 0) throw new Error("unknown error");
                    A[f(D) & v - 1] = new n.default([D]);
                  } else if (P instanceof l.default) {
                    var q = new n.default(), I = new n.default();
                    P.forEach(function(_) {
                      f(_) & R ? I.pushBack(_) : q.pushBack(_);
                    }), q.size() > h.untreeifyThreshold ? A[E] = new l.default(q) : q.size() && (A[E] = q), I.size() > h.untreeifyThreshold ? A[E + R] = new l.default(I) : I.size() && (A[E + R] = I);
                  } else {
                    var S = new n.default(), T = new n.default();
                    P.forEach(function(_) {
                      f(_) & R ? T.pushBack(_) : S.pushBack(_);
                    }), S.size() && (A[E] = S), T.size() && (A[E + R] = T);
                  }
                  y[E].clear();
                }
              }), y = A;
            }
          }).call(this, v);
        }, this.eraseElementByValue = function(b) {
          var x = f(b) & v - 1;
          if (y[x]) {
            var p = y[x].size();
            y[x].eraseElementByValue(b), y[x] instanceof l.default && y[x].size() <= h.untreeifyThreshold && (y[x] = new n.default(y[x]));
            var k = y[x].size();
            g += k - p;
          }
        }, this.find = function(b) {
          var x = f(b) & v - 1;
          return !!y[x] && y[x].find(b);
        }, this[Symbol.iterator] = function() {
          return function() {
            var b, x, p, k, R, A;
            return o(this, function(P) {
              switch (P.label) {
                case 0:
                  b = 0, P.label = 1;
                case 1:
                  if (!(b < v)) return [3, 10];
                  for (; b < v && !y[b]; ) ++b;
                  if (b >= v) return [3, 10];
                  P.label = 2;
                case 2:
                  P.trys.push([2, 7, 8, 9]), R = void 0, x = r(y[b]), p = x.next(), P.label = 3;
                case 3:
                  return p.done ? [3, 6] : [4, p.value];
                case 4:
                  P.sent(), P.label = 5;
                case 5:
                  return p = x.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return k = P.sent(), R = { error: k }, [3, 9];
                case 8:
                  try {
                    p && !p.done && (A = x.return) && A.call(x);
                  } finally {
                    if (R) throw R.error;
                  }
                  return [7];
                case 9:
                  return ++b, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, c.forEach(function(b) {
          return u.insert(b);
        }), Object.freeze(this);
      }
      h.initSize = 16, h.maxSize = 1 << 30, h.sigma = 0.75, h.treeifyThreshold = 8, h.untreeifyThreshold = 6, h.minTreeifySize = 64, Object.freeze(h), a.default = h;
    }, { "../LinkList/LinkList": 29, "../Set/Set": 33 }], 29: [function(i, s, a) {
      var o = this && this.__generator || function(n, h) {
        var c, d, f, u, g = { label: 0, sent: function() {
          if (1 & f[0]) throw f[1];
          return f[1];
        }, trys: [], ops: [] };
        return u = { next: y(0), throw: y(1), return: y(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
          return this;
        }), u;
        function y(v) {
          return function(b) {
            return function(x) {
              if (c) throw new TypeError("Generator is already executing.");
              for (; g; ) try {
                if (c = 1, d && (f = 2 & x[0] ? d.return : x[0] ? d.throw || ((f = d.return) && f.call(d), 0) : d.next) && !(f = f.call(d, x[1])).done) return f;
                switch (d = 0, f && (x = [2 & x[0], f.value]), x[0]) {
                  case 0:
                  case 1:
                    f = x;
                    break;
                  case 4:
                    return g.label++, { value: x[1], done: !1 };
                  case 5:
                    g.label++, d = x[1], x = [0];
                    continue;
                  case 7:
                    x = g.ops.pop(), g.trys.pop();
                    continue;
                  default:
                    if (!(f = (f = g.trys).length > 0 && f[f.length - 1]) && (x[0] === 6 || x[0] === 2)) {
                      g = 0;
                      continue;
                    }
                    if (x[0] === 3 && (!f || x[1] > f[0] && x[1] < f[3])) {
                      g.label = x[1];
                      break;
                    }
                    if (x[0] === 6 && g.label < f[1]) {
                      g.label = f[1], f = x;
                      break;
                    }
                    if (f && g.label < f[2]) {
                      g.label = f[2], g.ops.push(x);
                      break;
                    }
                    f[2] && g.ops.pop(), g.trys.pop();
                    continue;
                }
                x = h.call(n, g);
              } catch (p) {
                x = [6, p], d = 0;
              } finally {
                c = f = 0;
              }
              if (5 & x[0]) throw x[1];
              return { value: x[0] ? x[1] : void 0, done: !0 };
            }([v, b]);
          };
        }
      };
      Object.defineProperty(a, "__esModule", { value: !0 });
      var r = /* @__PURE__ */ function() {
        return function(n) {
          this.value = void 0, this.pre = void 0, this.next = void 0, this.value = n;
        };
      }();
      function l(n) {
        var h = this;
        n === void 0 && (n = []);
        var c = 0, d = void 0, f = void 0;
        this.size = function() {
          return c;
        }, this.empty = function() {
          return c === 0;
        }, this.clear = function() {
          d = f = void 0, c = 0;
        }, this.front = function() {
          return d == null ? void 0 : d.value;
        }, this.back = function() {
          return f == null ? void 0 : f.value;
        }, this.forEach = function(u) {
          for (var g = d, y = 0; g; ) {
            if (g.value === void 0) throw new Error("unknown error");
            u(g.value, y++), g = g.next;
          }
        }, this.getElementByPos = function(u) {
          if (u < 0 || u >= c) throw new Error("pos must more then 0 and less then the list length");
          for (var g = d; u-- && g; ) g = g.next;
          if (!g || g.value === void 0) throw new Error("unknown error");
          return g.value;
        }, this.eraseElementByPos = function(u) {
          if (u < 0 || u >= c) throw new Error("erase pos must more then 0 and less then the list length");
          if (u === 0) this.popFront();
          else if (u === c - 1) this.popBack();
          else {
            for (var g = d; u--; ) {
              if (!(g != null && g.next)) throw new Error("unknown error");
              g = g.next;
            }
            if (!g || !g.pre || !g.next) throw new Error("unknown error");
            var y = g.pre, v = g.next;
            v.pre = y, y.next = v, c > 0 && --c;
          }
        }, this.eraseElementByValue = function(u) {
          for (; d && d.value === u; ) this.popFront();
          for (; f && f.value === u; ) this.popBack();
          if (d) for (var g = d; g; ) {
            if (g.value === u) {
              var y = g.pre, v = g.next;
              v && (v.pre = y), y && (y.next = v), c > 0 && --c;
            }
            g = g.next;
          }
        }, this.pushBack = function(u) {
          if (u == null) throw new Error("you can't push null or undefined here");
          ++c;
          var g = new r(u);
          f ? (f.next = g, g.pre = f, f = g) : d = f = g;
        }, this.popBack = function() {
          f && (c > 0 && --c, f && (d === f ? d = f = void 0 : (f = f.pre) && (f.next = void 0)));
        }, this.setElementByPos = function(u, g) {
          if (g == null) throw new Error("you can't set null or undefined here");
          if (u < 0 || u >= c) throw new Error("pos must more then 0 and less then the list length");
          for (var y = d; u--; ) {
            if (!y) throw new Error("unknown error");
            y = y.next;
          }
          y && (y.value = g);
        }, this.insert = function(u, g, y) {
          if (y === void 0 && (y = 1), g == null) throw new Error("you can't insert null or undefined here");
          if (u < 0 || u > c) throw new Error("insert pos must more then 0 and less then or equal to the list length");
          if (y < 0) throw new Error("insert size must more than 0");
          if (u === 0) for (; y--; ) this.pushFront(g);
          else if (u === c) for (; y--; ) this.pushBack(g);
          else {
            for (var v = d, b = 1; b < u; ++b) {
              if (!(v != null && v.next)) throw new Error("unknown error");
              v = v == null ? void 0 : v.next;
            }
            if (!v) throw new Error("unknown error");
            var x = v.next;
            for (c += y; y--; ) v.next = new r(g), v.next.pre = v, v = v.next;
            v.next = x, x && (x.pre = v);
          }
        }, this.find = function(u) {
          for (var g = d; g; ) {
            if (g.value === u) return !0;
            g = g.next;
          }
          return !1;
        }, this.reverse = function() {
          for (var u = d, g = f, y = 0; u && g && 2 * y < c; ) {
            var v = u.value;
            u.value = g.value, g.value = v, u = u.next, g = g.pre, ++y;
          }
        }, this.unique = function() {
          for (var u = d; u; ) {
            for (var g = u; g && g.next && g.value === g.next.value; ) g = g.next, c > 0 && --c;
            u.next = g.next, u.next && (u.next.pre = u), u = u.next;
          }
        }, this.sort = function(u) {
          var g = [];
          this.forEach(function(v) {
            g.push(v);
          }), g.sort(u);
          var y = d;
          g.forEach(function(v) {
            y && (y.value = v, y = y.next);
          });
        }, this.pushFront = function(u) {
          if (u == null) throw new Error("you can't push null or undefined here");
          ++c;
          var g = new r(u);
          d ? (g.next = d, d.pre = g, d = g) : d = f = g;
        }, this.popFront = function() {
          d && (c > 0 && --c, d && (d === f ? d = f = void 0 : (d = d.next) && (d.pre = void 0)));
        }, this.merge = function(u) {
          var g = this, y = d;
          u.forEach(function(v) {
            for (; y && y.value !== void 0 && y.value <= v; ) y = y.next;
            if (y === void 0) g.pushBack(v), y = f;
            else if (y === d) g.pushFront(v), y = d;
            else {
              ++c;
              var b = y.pre;
              b && (b.next = new r(v), b.next.pre = b, b.next.next = y, y && (y.pre = b.next));
            }
          });
        }, this[Symbol.iterator] = function() {
          return function() {
            var u;
            return o(this, function(g) {
              switch (g.label) {
                case 0:
                  u = d, g.label = 1;
                case 1:
                  if (u === void 0) return [3, 3];
                  if (!u.value) throw new Error("unknown error");
                  return [4, u.value];
                case 2:
                  return g.sent(), u = u.next, [3, 1];
                case 3:
                  return [2];
              }
            });
          }();
        }, n.forEach(function(u) {
          return h.pushBack(u);
        }), Object.freeze(this);
      }
      Object.freeze(l), a.default = l;
    }, {}], 30: [function(i, s, a) {
      var o = this && this.__generator || function(h, c) {
        var d, f, u, g, y = { label: 0, sent: function() {
          if (1 & u[0]) throw u[1];
          return u[1];
        }, trys: [], ops: [] };
        return g = { next: v(0), throw: v(1), return: v(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function v(b) {
          return function(x) {
            return function(p) {
              if (d) throw new TypeError("Generator is already executing.");
              for (; y; ) try {
                if (d = 1, f && (u = 2 & p[0] ? f.return : p[0] ? f.throw || ((u = f.return) && u.call(f), 0) : f.next) && !(u = u.call(f, p[1])).done) return u;
                switch (f = 0, u && (p = [2 & p[0], u.value]), p[0]) {
                  case 0:
                  case 1:
                    u = p;
                    break;
                  case 4:
                    return y.label++, { value: p[1], done: !1 };
                  case 5:
                    y.label++, f = p[1], p = [0];
                    continue;
                  case 7:
                    p = y.ops.pop(), y.trys.pop();
                    continue;
                  default:
                    if (!(u = (u = y.trys).length > 0 && u[u.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      y = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!u || p[1] > u[0] && p[1] < u[3])) {
                      y.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && y.label < u[1]) {
                      y.label = u[1], u = p;
                      break;
                    }
                    if (u && y.label < u[2]) {
                      y.label = u[2], y.ops.push(p);
                      break;
                    }
                    u[2] && y.ops.pop(), y.trys.pop();
                    continue;
                }
                p = c.call(h, y);
              } catch (k) {
                p = [6, k], f = 0;
              } finally {
                d = u = 0;
              }
              if (5 & p[0]) throw p[1];
              return { value: p[0] ? p[1] : void 0, done: !0 };
            }([b, x]);
          };
        }
      }, r = this && this.__values || function(h) {
        var c = typeof Symbol == "function" && Symbol.iterator, d = c && h[c], f = 0;
        if (d) return d.call(h);
        if (h && typeof h.length == "number") return { next: function() {
          return h && f >= h.length && (h = void 0), { value: h && h[f++], done: !h };
        } };
        throw new TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(a, "__esModule", { value: !0 });
      var l = i("../Base/TreeNode");
      function n(h, c) {
        var d = this;
        h === void 0 && (h = []), c = c || function(I, S) {
          return I < S ? -1 : I > S ? 1 : 0;
        };
        var f = 0, u = new l.default();
        u.color = l.default.TreeNodeColorType.black, this.size = function() {
          return f;
        }, this.empty = function() {
          return f === 0;
        }, this.clear = function() {
          f = 0, u.key = u.value = void 0, u.leftChild = u.rightChild = u.brother = void 0;
        };
        var g = function(I) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          return I.leftChild ? g(I.leftChild) : I;
        }, y = function(I) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          return I.rightChild ? y(I.rightChild) : I;
        };
        this.front = function() {
          if (!this.empty()) {
            var I = g(u);
            if (I.key === void 0 || I.value === void 0) throw new Error("unknown error");
            return { key: I.key, value: I.value };
          }
        }, this.back = function() {
          if (!this.empty()) {
            var I = y(u);
            if (I.key === void 0 || I.value === void 0) throw new Error("unknown error");
            return { key: I.key, value: I.value };
          }
        }, this.forEach = function(I) {
          var S, T, _ = 0;
          try {
            for (var z = r(this), V = z.next(); !V.done; V = z.next())
              I(V.value, _++);
          } catch (X) {
            S = { error: X };
          } finally {
            try {
              V && !V.done && (T = z.return) && T.call(z);
            } finally {
              if (S) throw S.error;
            }
          }
        }, this.getElementByPos = function(I) {
          var S, T;
          if (I < 0 || I >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var _ = 0;
          try {
            for (var z = r(this), V = z.next(); !V.done; V = z.next()) {
              var X = V.value;
              if (_ === I) return X;
              ++_;
            }
          } catch (H) {
            S = { error: H };
          } finally {
            try {
              V && !V.done && (T = z.return) && T.call(z);
            } finally {
              if (S) throw S.error;
            }
          }
          throw new Error("unknown Error");
        };
        var v = function(I, S) {
          if (I && I.key !== void 0 && I.value !== void 0) {
            var T = c(I.key, S);
            return T === 0 ? { key: I.key, value: I.value } : T < 0 ? v(I.rightChild, S) : v(I.leftChild, S) || { key: I.key, value: I.value };
          }
        };
        this.lowerBound = function(I) {
          return v(u, I);
        };
        var b = function(I, S) {
          if (I && I.key !== void 0 && I.value !== void 0) return c(I.key, S) <= 0 ? b(I.rightChild, S) : b(I.leftChild, S) || { key: I.key, value: I.value };
        };
        this.upperBound = function(I) {
          return b(u, I);
        };
        var x = function(I, S) {
          if (I && I.key !== void 0 && I.value !== void 0) {
            var T = c(I.key, S);
            return T === 0 ? { key: I.key, value: I.value } : T > 0 ? x(I.leftChild, S) : x(I.rightChild, S) || { key: I.key, value: I.value };
          }
        };
        this.reverseLowerBound = function(I) {
          return x(u, I);
        };
        var p = function(I, S) {
          if (I && I.key !== void 0 && I.value !== void 0) return c(I.key, S) >= 0 ? p(I.leftChild, S) : p(I.rightChild, S) || { key: I.key, value: I.value };
        };
        this.reverseUpperBound = function(I) {
          return p(u, I);
        };
        var k = function(I) {
          var S = I.parent;
          if (!S) {
            if (I === u) return;
            throw new Error("unknown error");
          }
          if (I.color !== l.default.TreeNodeColorType.red) {
            var T = I.brother;
            if (!T) throw new Error("unknown error");
            if (I === S.leftChild)
              if (T.color === l.default.TreeNodeColorType.red) {
                T.color = l.default.TreeNodeColorType.black, S.color = l.default.TreeNodeColorType.red;
                var _ = S.rotateLeft();
                u === S && (u = _), k(I);
              } else T.color === l.default.TreeNodeColorType.black && (T.rightChild && T.rightChild.color === l.default.TreeNodeColorType.red ? (T.color = S.color, S.color = l.default.TreeNodeColorType.black, T.rightChild && (T.rightChild.color = l.default.TreeNodeColorType.black), _ = S.rotateLeft(), u === S && (u = _), I.color = l.default.TreeNodeColorType.black) : T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || !T.leftChild || T.leftChild.color !== l.default.TreeNodeColorType.red ? T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || (T.color = l.default.TreeNodeColorType.red, k(S)) : (T.color = l.default.TreeNodeColorType.red, T.leftChild && (T.leftChild.color = l.default.TreeNodeColorType.black), _ = T.rotateRight(), u === T && (u = _), k(I)));
            else I === S.rightChild && (T.color === l.default.TreeNodeColorType.red ? (T.color = l.default.TreeNodeColorType.black, S.color = l.default.TreeNodeColorType.red, _ = S.rotateRight(), u === S && (u = _), k(I)) : T.color === l.default.TreeNodeColorType.black && (T.leftChild && T.leftChild.color === l.default.TreeNodeColorType.red ? (T.color = S.color, S.color = l.default.TreeNodeColorType.black, T.leftChild && (T.leftChild.color = l.default.TreeNodeColorType.black), _ = S.rotateRight(), u === S && (u = _), I.color = l.default.TreeNodeColorType.black) : T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || !T.rightChild || T.rightChild.color !== l.default.TreeNodeColorType.red ? T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || (T.color = l.default.TreeNodeColorType.red, k(S)) : (T.color = l.default.TreeNodeColorType.red, T.rightChild && (T.rightChild.color = l.default.TreeNodeColorType.black), _ = T.rotateLeft(), u === T && (u = _), k(I))));
          } else I.color = l.default.TreeNodeColorType.black;
        }, R = function(I) {
          for (var S = I; S.leftChild || S.rightChild; ) {
            if (S.rightChild) {
              S = g(S.rightChild);
              var T = I.key;
              I.key = S.key, S.key = T;
              var _ = I.value;
              I.value = S.value, S.value = _, I = S;
            }
            S.leftChild && (S = y(S.leftChild), T = I.key, I.key = S.key, S.key = T, _ = I.value, I.value = S.value, S.value = _, I = S);
          }
          k(S), S && S.remove(), --f, u.color = l.default.TreeNodeColorType.black;
        }, A = function(I, S) {
          return !(!I || I.key === void 0) && (!!A(I.leftChild, S) || !!S(I) || A(I.rightChild, S));
        };
        this.eraseElementByPos = function(I) {
          if (I < 0 || I >= f) throw new Error("pos must more than 0 and less than set's size");
          var S = 0;
          A(u, function(T) {
            return I === S ? (R(T), !0) : (++S, !1);
          });
        }, this.eraseElementByKey = function(I) {
          if (!this.empty()) {
            var S = D(u, I);
            S !== void 0 && S.key !== void 0 && c(S.key, I) === 0 && R(S);
          }
        };
        var P = function(I, S) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          var T = c(S, I.key);
          return T < 0 ? I.leftChild ? P(I.leftChild, S) : (I.leftChild = new l.default(), I.leftChild.parent = I, I.leftChild.brother = I.rightChild, I.rightChild && (I.rightChild.brother = I.leftChild), I.leftChild) : T > 0 ? I.rightChild ? P(I.rightChild, S) : (I.rightChild = new l.default(), I.rightChild.parent = I, I.rightChild.brother = I.leftChild, I.leftChild && (I.leftChild.brother = I.rightChild), I.rightChild) : I;
        }, E = function(I) {
          var S = I.parent;
          if (!S) {
            if (I === u) return;
            throw new Error("unknown error");
          }
          if (S.color !== l.default.TreeNodeColorType.black && S.color === l.default.TreeNodeColorType.red) {
            var T = S.brother, _ = S.parent;
            if (!_) throw new Error("unknown error");
            if (T && T.color === l.default.TreeNodeColorType.red) T.color = S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, E(_);
            else if (!T || T.color === l.default.TreeNodeColorType.black) if (S === _.leftChild)
              if (I === S.leftChild) {
                S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red;
                var z = _.rotateRight();
                _ === u && (u = z);
              } else I === S.rightChild && (z = S.rotateLeft(), _ === u && (u = z), E(S));
            else S === _.rightChild && (I === S.leftChild ? (z = S.rotateRight(), _ === u && (u = z), E(S)) : I === S.rightChild && (S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, z = _.rotateLeft(), _ === u && (u = z)));
          }
        };
        this.setElement = function(I, S) {
          if (I == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (S != null) {
            if (this.empty()) return ++f, u.key = I, u.value = S, void (u.color = l.default.TreeNodeColorType.black);
            var T = P(u, I);
            T.key === void 0 || c(T.key, I) !== 0 ? (++f, T.key = I, T.value = S, E(T), u.color = l.default.TreeNodeColorType.black) : T.value = S;
          } else this.eraseElementByKey(I);
        };
        var D = function(I, S) {
          if (I && I.key !== void 0) {
            var T = c(S, I.key);
            return T < 0 ? D(I.leftChild, S) : T > 0 ? D(I.rightChild, S) : I;
          }
        };
        this.find = function(I) {
          return !!D(u, I);
        }, this.getElementByKey = function(I) {
          var S = D(u, I);
          if ((S == null ? void 0 : S.key) === void 0 || (S == null ? void 0 : S.value) === void 0) throw new Error("unknown error");
          return S.value;
        }, this.union = function(I) {
          var S = this;
          I.forEach(function(T) {
            var _ = T.key, z = T.value;
            return S.setElement(_, z);
          });
        }, this.getHeight = function() {
          if (this.empty()) return 0;
          var I = function(S) {
            return S ? Math.max(I(S.leftChild), I(S.rightChild)) + 1 : 1;
          };
          return I(u);
        };
        var q = function(I) {
          return o(this, function(S) {
            switch (S.label) {
              case 0:
                return I && I.key !== void 0 && I.value !== void 0 ? [5, r(q(I.leftChild))] : [2];
              case 1:
                return S.sent(), [4, { key: I.key, value: I.value }];
              case 2:
                return S.sent(), [5, r(q(I.rightChild))];
              case 3:
                return S.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function() {
          return q(u);
        }, h.forEach(function(I) {
          var S = I.key, T = I.value;
          return d.setElement(S, T);
        }), Object.freeze(this);
      }
      Object.freeze(n), a.default = n;
    }, { "../Base/TreeNode": 25 }], 31: [function(i, s, a) {
      function o(r, l) {
        r === void 0 && (r = []), l = l || function(f, u) {
          return f > u ? -1 : f < u ? 1 : 0;
        };
        var n = [];
        r.forEach(function(f) {
          return n.push(f);
        });
        var h = n.length, c = function(f, u) {
          if (f < 0 || f >= h) throw new Error("unknown error");
          if (u < 0 || u >= h) throw new Error("unknown error");
          var g = n[f];
          n[f] = n[u], n[u] = g;
        }, d = function(f) {
          if (f < 0 || f >= h) throw new Error("unknown error");
          var u = 2 * f + 1, g = 2 * f + 2;
          u < h && l(n[f], n[u]) > 0 && c(f, u), g < h && l(n[f], n[g]) > 0 && c(f, g);
        };
        (function() {
          for (var f = Math.floor((h - 1) / 2); f >= 0; --f) for (var u = f, g = 2 * u + 1; g < h; ) {
            var y = g + 1, v = g;
            if (y < h && l(n[g], n[y]) > 0 && (v = y), l(n[u], n[v]) <= 0) break;
            c(u, v), g = 2 * (u = v) + 1;
          }
        })(), this.size = function() {
          return h;
        }, this.empty = function() {
          return h === 0;
        }, this.clear = function() {
          h = 0, n.length = 0;
        }, this.push = function(f) {
          if (n.push(f), ++h !== 1) for (var u = h - 1; u > 0; ) {
            var g = Math.floor((u - 1) / 2);
            if (l(n[g], f) <= 0) break;
            d(g), u = g;
          }
        }, this.pop = function() {
          if (!this.empty()) if (this.size() !== 1) {
            var f = n[h - 1];
            --h;
            for (var u = 0; u < this.size(); ) {
              var g = 2 * u + 1, y = 2 * u + 2;
              if (g >= this.size()) break;
              var v = g;
              if (y < this.size() && l(n[g], n[y]) > 0 && (v = y), l(n[v], f) >= 0) break;
              n[u] = n[v], u = v;
            }
            n[u] = f;
          } else --h;
        }, this.top = function() {
          return n[0];
        }, Object.freeze(this);
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), Object.freeze(o), a.default = o;
    }, {}], 32: [function(i, s, a) {
      Object.defineProperty(a, "__esModule", { value: !0 });
      var o = i("../LinkList/LinkList");
      function r(l) {
        l === void 0 && (l = []);
        var n = new o.default(l);
        this.size = function() {
          return n.size();
        }, this.empty = function() {
          return n.empty();
        }, this.clear = function() {
          n.clear();
        }, this.push = function(h) {
          n.pushBack(h);
        }, this.pop = function() {
          n.popFront();
        }, this.front = function() {
          return n.front();
        }, Object.freeze(this);
      }
      Object.freeze(r), a.default = r;
    }, { "../LinkList/LinkList": 29 }], 33: [function(i, s, a) {
      var o = this && this.__generator || function(h, c) {
        var d, f, u, g, y = { label: 0, sent: function() {
          if (1 & u[0]) throw u[1];
          return u[1];
        }, trys: [], ops: [] };
        return g = { next: v(0), throw: v(1), return: v(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function v(b) {
          return function(x) {
            return function(p) {
              if (d) throw new TypeError("Generator is already executing.");
              for (; y; ) try {
                if (d = 1, f && (u = 2 & p[0] ? f.return : p[0] ? f.throw || ((u = f.return) && u.call(f), 0) : f.next) && !(u = u.call(f, p[1])).done) return u;
                switch (f = 0, u && (p = [2 & p[0], u.value]), p[0]) {
                  case 0:
                  case 1:
                    u = p;
                    break;
                  case 4:
                    return y.label++, { value: p[1], done: !1 };
                  case 5:
                    y.label++, f = p[1], p = [0];
                    continue;
                  case 7:
                    p = y.ops.pop(), y.trys.pop();
                    continue;
                  default:
                    if (!(u = (u = y.trys).length > 0 && u[u.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      y = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!u || p[1] > u[0] && p[1] < u[3])) {
                      y.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && y.label < u[1]) {
                      y.label = u[1], u = p;
                      break;
                    }
                    if (u && y.label < u[2]) {
                      y.label = u[2], y.ops.push(p);
                      break;
                    }
                    u[2] && y.ops.pop(), y.trys.pop();
                    continue;
                }
                p = c.call(h, y);
              } catch (k) {
                p = [6, k], f = 0;
              } finally {
                d = u = 0;
              }
              if (5 & p[0]) throw p[1];
              return { value: p[0] ? p[1] : void 0, done: !0 };
            }([b, x]);
          };
        }
      }, r = this && this.__values || function(h) {
        var c = typeof Symbol == "function" && Symbol.iterator, d = c && h[c], f = 0;
        if (d) return d.call(h);
        if (h && typeof h.length == "number") return { next: function() {
          return h && f >= h.length && (h = void 0), { value: h && h[f++], done: !h };
        } };
        throw new TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(a, "__esModule", { value: !0 });
      var l = i("../Base/TreeNode");
      function n(h, c) {
        var d = this;
        h === void 0 && (h = []), c = c || function(I, S) {
          return I < S ? -1 : I > S ? 1 : 0;
        };
        var f = 0, u = new l.default();
        u.color = l.default.TreeNodeColorType.black, this.size = function() {
          return f;
        }, this.empty = function() {
          return f === 0;
        }, this.clear = function() {
          f = 0, u.key = void 0, u.leftChild = u.rightChild = u.brother = u.parent = void 0, u.color = l.default.TreeNodeColorType.black;
        };
        var g = function(I) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          return I.leftChild ? g(I.leftChild) : I;
        }, y = function(I) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          return I.rightChild ? y(I.rightChild) : I;
        };
        this.front = function() {
          if (!this.empty()) return g(u).key;
        }, this.back = function() {
          if (!this.empty()) return y(u).key;
        }, this.forEach = function(I) {
          var S, T, _ = 0;
          try {
            for (var z = r(this), V = z.next(); !V.done; V = z.next())
              I(V.value, _++);
          } catch (X) {
            S = { error: X };
          } finally {
            try {
              V && !V.done && (T = z.return) && T.call(z);
            } finally {
              if (S) throw S.error;
            }
          }
        }, this.getElementByPos = function(I) {
          var S, T;
          if (I < 0 || I >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var _ = 0;
          try {
            for (var z = r(this), V = z.next(); !V.done; V = z.next()) {
              var X = V.value;
              if (_ === I) return X;
              ++_;
            }
          } catch (H) {
            S = { error: H };
          } finally {
            try {
              V && !V.done && (T = z.return) && T.call(z);
            } finally {
              if (S) throw S.error;
            }
          }
          throw new Error("unknown error");
        };
        var v = function(I) {
          var S = I.parent;
          if (!S) {
            if (I === u) return;
            throw new Error("unknown error");
          }
          if (I.color !== l.default.TreeNodeColorType.red) {
            var T = I.brother;
            if (!T) throw new Error("unknown error");
            if (I === S.leftChild)
              if (T.color === l.default.TreeNodeColorType.red) {
                T.color = l.default.TreeNodeColorType.black, S.color = l.default.TreeNodeColorType.red;
                var _ = S.rotateLeft();
                u === S && (u = _), v(I);
              } else T.color === l.default.TreeNodeColorType.black && (T.rightChild && T.rightChild.color === l.default.TreeNodeColorType.red ? (T.color = S.color, S.color = l.default.TreeNodeColorType.black, T.rightChild && (T.rightChild.color = l.default.TreeNodeColorType.black), _ = S.rotateLeft(), u === S && (u = _), I.color = l.default.TreeNodeColorType.black) : T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || !T.leftChild || T.leftChild.color !== l.default.TreeNodeColorType.red ? T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || (T.color = l.default.TreeNodeColorType.red, v(S)) : (T.color = l.default.TreeNodeColorType.red, T.leftChild && (T.leftChild.color = l.default.TreeNodeColorType.black), _ = T.rotateRight(), u === T && (u = _), v(I)));
            else I === S.rightChild && (T.color === l.default.TreeNodeColorType.red ? (T.color = l.default.TreeNodeColorType.black, S.color = l.default.TreeNodeColorType.red, _ = S.rotateRight(), u === S && (u = _), v(I)) : T.color === l.default.TreeNodeColorType.black && (T.leftChild && T.leftChild.color === l.default.TreeNodeColorType.red ? (T.color = S.color, S.color = l.default.TreeNodeColorType.black, T.leftChild && (T.leftChild.color = l.default.TreeNodeColorType.black), _ = S.rotateRight(), u === S && (u = _), I.color = l.default.TreeNodeColorType.black) : T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || !T.rightChild || T.rightChild.color !== l.default.TreeNodeColorType.red ? T.leftChild && T.leftChild.color !== l.default.TreeNodeColorType.black || T.rightChild && T.rightChild.color !== l.default.TreeNodeColorType.black || (T.color = l.default.TreeNodeColorType.red, v(S)) : (T.color = l.default.TreeNodeColorType.red, T.rightChild && (T.rightChild.color = l.default.TreeNodeColorType.black), _ = T.rotateLeft(), u === T && (u = _), v(I))));
          } else I.color = l.default.TreeNodeColorType.black;
        }, b = function(I) {
          for (var S = I; S.leftChild || S.rightChild; ) {
            if (S.rightChild) {
              S = g(S.rightChild);
              var T = I.key;
              I.key = S.key, S.key = T, I = S;
            }
            S.leftChild && (S = y(S.leftChild), T = I.key, I.key = S.key, S.key = T, I = S);
          }
          v(S), S && S.remove(), --f, u.color = l.default.TreeNodeColorType.black;
        }, x = function(I, S) {
          return !(!I || I.key === void 0) && (!!x(I.leftChild, S) || !!S(I) || x(I.rightChild, S));
        };
        this.eraseElementByPos = function(I) {
          if (I < 0 || I >= f) throw new Error("pos must more than 0 and less than set's size");
          var S = 0;
          x(u, function(T) {
            return I === S ? (b(T), !0) : (++S, !1);
          });
        }, this.eraseElementByValue = function(I) {
          if (!this.empty()) {
            var S = R(u, I);
            S !== void 0 && S.key !== void 0 && c(S.key, I) === 0 && b(S);
          }
        };
        var p = function(I, S) {
          if (!I || I.key === void 0) throw new Error("unknown error");
          var T = c(S, I.key);
          return T < 0 ? I.leftChild ? p(I.leftChild, S) : (I.leftChild = new l.default(), I.leftChild.parent = I, I.leftChild.brother = I.rightChild, I.rightChild && (I.rightChild.brother = I.leftChild), I.leftChild) : T > 0 ? I.rightChild ? p(I.rightChild, S) : (I.rightChild = new l.default(), I.rightChild.parent = I, I.rightChild.brother = I.leftChild, I.leftChild && (I.leftChild.brother = I.rightChild), I.rightChild) : I;
        }, k = function(I) {
          var S = I.parent;
          if (!S) {
            if (I === u) return;
            throw new Error("unknown error");
          }
          if (S.color !== l.default.TreeNodeColorType.black && S.color === l.default.TreeNodeColorType.red) {
            var T = S.brother, _ = S.parent;
            if (!_) throw new Error("unknown error");
            if (T && T.color === l.default.TreeNodeColorType.red) T.color = S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, k(_);
            else if (!T || T.color === l.default.TreeNodeColorType.black) if (S === _.leftChild)
              if (I === S.leftChild) {
                S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red;
                var z = _.rotateRight();
                _ === u && (u = z);
              } else I === S.rightChild && (z = S.rotateLeft(), _ === u && (u = z), k(S));
            else S === _.rightChild && (I === S.leftChild ? (z = S.rotateRight(), _ === u && (u = z), k(S)) : I === S.rightChild && (S.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, z = _.rotateLeft(), _ === u && (u = z)));
          }
        };
        this.insert = function(I) {
          if (I == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (this.empty()) return ++f, u.key = I, void (u.color = l.default.TreeNodeColorType.black);
          var S = p(u, I);
          S.key !== void 0 && c(S.key, I) === 0 || (++f, S.key = I, k(S), u.color = l.default.TreeNodeColorType.black);
        };
        var R = function(I, S) {
          if (I && I.key !== void 0) {
            var T = c(S, I.key);
            return T < 0 ? R(I.leftChild, S) : T > 0 ? R(I.rightChild, S) : I;
          }
        };
        this.find = function(I) {
          var S = R(u, I);
          return S !== void 0 && S.key !== void 0 && c(S.key, I) === 0;
        };
        var A = function(I, S) {
          if (I && I.key !== void 0) {
            var T = c(I.key, S);
            if (T === 0) return I.key;
            if (T < 0) return A(I.rightChild, S);
            var _ = A(I.leftChild, S);
            return _ !== void 0 ? _ : I.key;
          }
        };
        this.lowerBound = function(I) {
          return A(u, I);
        };
        var P = function(I, S) {
          if (I && I.key !== void 0) {
            if (c(I.key, S) <= 0) return P(I.rightChild, S);
            var T = P(I.leftChild, S);
            return T !== void 0 ? T : I.key;
          }
        };
        this.upperBound = function(I) {
          return P(u, I);
        };
        var E = function(I, S) {
          if (I && I.key !== void 0) {
            var T = c(I.key, S);
            if (T === 0) return I.key;
            if (T > 0) return E(I.leftChild, S);
            var _ = E(I.rightChild, S);
            return _ !== void 0 ? _ : I.key;
          }
        };
        this.reverseLowerBound = function(I) {
          return E(u, I);
        };
        var D = function(I, S) {
          if (I && I.key !== void 0) {
            if (c(I.key, S) >= 0) return D(I.leftChild, S);
            var T = D(I.rightChild, S);
            return T !== void 0 ? T : I.key;
          }
        };
        this.reverseUpperBound = function(I) {
          return D(u, I);
        }, this.union = function(I) {
          var S = this;
          I.forEach(function(T) {
            return S.insert(T);
          });
        }, this.getHeight = function() {
          if (this.empty()) return 0;
          var I = function(S) {
            return S ? Math.max(I(S.leftChild), I(S.rightChild)) + 1 : 1;
          };
          return I(u);
        };
        var q = function(I) {
          return o(this, function(S) {
            switch (S.label) {
              case 0:
                return I && I.key !== void 0 ? [5, r(q(I.leftChild))] : [2];
              case 1:
                return S.sent(), [4, I.key];
              case 2:
                return S.sent(), [5, r(q(I.rightChild))];
              case 3:
                return S.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function() {
          return q(u);
        }, h.forEach(function(I) {
          return d.insert(I);
        }), Object.freeze(this);
      }
      Object.freeze(n), a.default = n;
    }, { "../Base/TreeNode": 25 }], 34: [function(i, s, a) {
      function o(r) {
        var l = this;
        r === void 0 && (r = []);
        var n = 0, h = [];
        this.size = function() {
          return n;
        }, this.empty = function() {
          return n === 0;
        }, this.clear = function() {
          n = 0, h.length = 0;
        }, this.push = function(c) {
          h.push(c), ++n;
        }, this.pop = function() {
          h.pop(), n > 0 && --n;
        }, this.top = function() {
          return h[n - 1];
        }, r.forEach(function(c) {
          return l.push(c);
        }), Object.freeze(this);
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), Object.freeze(o), a.default = o;
    }, {}], 35: [function(i, s, a) {
      var o = this && this.__generator || function(c, d) {
        var f, u, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (f) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (f = 1, u && (g = 2 & k[0] ? u.return : k[0] ? u.throw || ((g = u.return) && g.call(u), 0) : u.next) && !(g = g.call(u, k[1])).done) return g;
                switch (u = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, u = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (R) {
                k = [6, R], u = 0;
              } finally {
                f = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__read || function(c, d) {
        var f = typeof Symbol == "function" && c[Symbol.iterator];
        if (!f) return c;
        var u, g, y = f.call(c), v = [];
        try {
          for (; (d === void 0 || d-- > 0) && !(u = y.next()).done; ) v.push(u.value);
        } catch (b) {
          g = { error: b };
        } finally {
          try {
            u && !u.done && (f = y.return) && f.call(y);
          } finally {
            if (g) throw g.error;
          }
        }
        return v;
      }, l = this && this.__spreadArray || function(c, d, f) {
        if (f || arguments.length === 2) for (var u, g = 0, y = d.length; g < y; g++) !u && g in d || (u || (u = Array.prototype.slice.call(d, 0, g)), u[g] = d[g]);
        return c.concat(u || Array.prototype.slice.call(d));
      }, n = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, f = d && c[d], u = 0;
        if (f) return f.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && u >= c.length && (c = void 0), { value: c && c[u++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      function h(c) {
        var d = this;
        c === void 0 && (c = []);
        var f = 0, u = [];
        this.size = function() {
          return f;
        }, this.empty = function() {
          return f === 0;
        }, this.clear = function() {
          f = 0, u.length = 0;
        }, this.front = function() {
          if (!this.empty()) return u[0];
        }, this.back = function() {
          if (!this.empty()) return u[f - 1];
        }, this.forEach = function(g) {
          u.forEach(g);
        }, this.getElementByPos = function(g) {
          if (g < 0 || g >= f) throw new Error("pos must more than 0 and less than vector's size");
          return u[g];
        }, this.eraseElementByPos = function(g) {
          if (g < 0 || g >= f) throw new Error("pos must more than 0 and less than vector's size");
          for (var y = g; y < f - 1; ++y) u[y] = u[y + 1];
          this.popBack();
        }, this.eraseElementByValue = function(g) {
          var y = [];
          this.forEach(function(b) {
            b !== g && y.push(b);
          }), y.forEach(function(b, x) {
            u[x] = b;
          });
          for (var v = y.length; f > v; ) this.popBack();
        }, this.pushBack = function(g) {
          u.push(g), ++f;
        }, this.popBack = function() {
          u.pop(), f > 0 && --f;
        }, this.setElementByPos = function(g, y) {
          if (g < 0 || g >= f) throw new Error("pos must more than 0 and less than vector's size");
          u[g] = y;
        }, this.insert = function(g, y, v) {
          if (v === void 0 && (v = 1), g < 0 || g > f) throw new Error("pos must more than 0 and less than or equal to vector's size");
          u.splice.apply(u, l([g, 0], r(new Array(v).fill(y)), !1)), f += v;
        }, this.find = function(g) {
          return u.includes(g);
        }, this.reverse = function() {
          u.reverse();
        }, this.unique = function() {
          var g, y = [];
          this.forEach(function(b, x) {
            x !== 0 && b === g || (y.push(b), g = b);
          }), y.forEach(function(b, x) {
            u[x] = b;
          });
          for (var v = y.length; f > v; ) this.popBack();
        }, this.sort = function(g) {
          u.sort(g);
        }, this[Symbol.iterator] = function() {
          return function() {
            return o(this, function(g) {
              switch (g.label) {
                case 0:
                  return [5, n(u)];
                case 1:
                  return [2, g.sent()];
              }
            });
          }();
        }, c.forEach(function(g) {
          return d.pushBack(g);
        }), Object.freeze(this);
      }
      Object.defineProperty(a, "__esModule", { value: !0 }), Object.freeze(h), a.default = h;
    }, {}], 36: [function(i, s, a) {
      Object.defineProperty(a, "__esModule", { value: !0 }), a.HashMap = a.HashSet = a.Map = a.Set = a.PriorityQueue = a.Deque = a.LinkList = a.Queue = a.Stack = a.Vector = void 0;
      var o = i("./Vector/Vector");
      a.Vector = o.default;
      var r = i("./Stack/Stack");
      a.Stack = r.default;
      var l = i("./Queue/Queue");
      a.Queue = l.default;
      var n = i("./LinkList/LinkList");
      a.LinkList = n.default;
      var h = i("./Deque/Deque");
      a.Deque = h.default;
      var c = i("./PriorityQueue/PriorityQueue");
      a.PriorityQueue = c.default;
      var d = i("./Set/Set");
      a.Set = d.default;
      var f = i("./Map/Map");
      a.Map = f.default;
      var u = i("./HashSet/HashSet");
      a.HashSet = u.default;
      var g = i("./HashMap/HashMap");
      a.HashMap = g.default;
    }, { "./Deque/Deque": 26, "./HashMap/HashMap": 27, "./HashSet/HashSet": 28, "./LinkList/LinkList": 29, "./Map/Map": 30, "./PriorityQueue/PriorityQueue": 31, "./Queue/Queue": 32, "./Set/Set": 33, "./Stack/Stack": 34, "./Vector/Vector": 35 }], 37: [function(i, s, a) {
      const o = i("yallist"), r = Symbol("max"), l = Symbol("length"), n = Symbol("lengthCalculator"), h = Symbol("allowStale"), c = Symbol("maxAge"), d = Symbol("dispose"), f = Symbol("noDisposeOnSet"), u = Symbol("lruList"), g = Symbol("cache"), y = Symbol("updateAgeOnGet"), v = () => 1, b = (P, E, D) => {
        const q = P[g].get(E);
        if (q) {
          const I = q.value;
          if (x(P, I)) {
            if (k(P, q), !P[h]) return;
          } else D && (P[y] && (q.value.now = Date.now()), P[u].unshiftNode(q));
          return I.value;
        }
      }, x = (P, E) => {
        if (!E || !E.maxAge && !P[c]) return !1;
        const D = Date.now() - E.now;
        return E.maxAge ? D > E.maxAge : P[c] && D > P[c];
      }, p = (P) => {
        if (P[l] > P[r]) for (let E = P[u].tail; P[l] > P[r] && E !== null; ) {
          const D = E.prev;
          k(P, E), E = D;
        }
      }, k = (P, E) => {
        if (E) {
          const D = E.value;
          P[d] && P[d](D.key, D.value), P[l] -= D.length, P[g].delete(D.key), P[u].removeNode(E);
        }
      };
      class R {
        constructor(E, D, q, I, S) {
          this.key = E, this.value = D, this.length = q, this.now = I, this.maxAge = S || 0;
        }
      }
      const A = (P, E, D, q) => {
        let I = D.value;
        x(P, I) && (k(P, D), P[h] || (I = void 0)), I && E.call(q, I.value, I.key, P);
      };
      s.exports = class {
        constructor(P) {
          if (typeof P == "number" && (P = { max: P }), P || (P = {}), P.max && (typeof P.max != "number" || P.max < 0)) throw new TypeError("max must be a non-negative number");
          this[r] = P.max || 1 / 0;
          const E = P.length || v;
          if (this[n] = typeof E != "function" ? v : E, this[h] = P.stale || !1, P.maxAge && typeof P.maxAge != "number") throw new TypeError("maxAge must be a number");
          this[c] = P.maxAge || 0, this[d] = P.dispose, this[f] = P.noDisposeOnSet || !1, this[y] = P.updateAgeOnGet || !1, this.reset();
        }
        set max(P) {
          if (typeof P != "number" || P < 0) throw new TypeError("max must be a non-negative number");
          this[r] = P || 1 / 0, p(this);
        }
        get max() {
          return this[r];
        }
        set allowStale(P) {
          this[h] = !!P;
        }
        get allowStale() {
          return this[h];
        }
        set maxAge(P) {
          if (typeof P != "number") throw new TypeError("maxAge must be a non-negative number");
          this[c] = P, p(this);
        }
        get maxAge() {
          return this[c];
        }
        set lengthCalculator(P) {
          typeof P != "function" && (P = v), P !== this[n] && (this[n] = P, this[l] = 0, this[u].forEach((E) => {
            E.length = this[n](E.value, E.key), this[l] += E.length;
          })), p(this);
        }
        get lengthCalculator() {
          return this[n];
        }
        get length() {
          return this[l];
        }
        get itemCount() {
          return this[u].length;
        }
        rforEach(P, E) {
          E = E || this;
          for (let D = this[u].tail; D !== null; ) {
            const q = D.prev;
            A(this, P, D, E), D = q;
          }
        }
        forEach(P, E) {
          E = E || this;
          for (let D = this[u].head; D !== null; ) {
            const q = D.next;
            A(this, P, D, E), D = q;
          }
        }
        keys() {
          return this[u].toArray().map((P) => P.key);
        }
        values() {
          return this[u].toArray().map((P) => P.value);
        }
        reset() {
          this[d] && this[u] && this[u].length && this[u].forEach((P) => this[d](P.key, P.value)), this[g] = /* @__PURE__ */ new Map(), this[u] = new o(), this[l] = 0;
        }
        dump() {
          return this[u].map((P) => !x(this, P) && { k: P.key, v: P.value, e: P.now + (P.maxAge || 0) }).toArray().filter((P) => P);
        }
        dumpLru() {
          return this[u];
        }
        set(P, E, D) {
          if ((D = D || this[c]) && typeof D != "number") throw new TypeError("maxAge must be a number");
          const q = D ? Date.now() : 0, I = this[n](E, P);
          if (this[g].has(P)) {
            if (I > this[r]) return k(this, this[g].get(P)), !1;
            const T = this[g].get(P).value;
            return this[d] && (this[f] || this[d](P, T.value)), T.now = q, T.maxAge = D, T.value = E, this[l] += I - T.length, T.length = I, this.get(P), p(this), !0;
          }
          const S = new R(P, E, I, q, D);
          return S.length > this[r] ? (this[d] && this[d](P, E), !1) : (this[l] += S.length, this[u].unshift(S), this[g].set(P, this[u].head), p(this), !0);
        }
        has(P) {
          if (!this[g].has(P)) return !1;
          const E = this[g].get(P).value;
          return !x(this, E);
        }
        get(P) {
          return b(this, P, !0);
        }
        peek(P) {
          return b(this, P, !1);
        }
        pop() {
          const P = this[u].tail;
          return P ? (k(this, P), P.value) : null;
        }
        del(P) {
          k(this, this[g].get(P));
        }
        load(P) {
          this.reset();
          const E = Date.now();
          for (let D = P.length - 1; D >= 0; D--) {
            const q = P[D], I = q.e || 0;
            if (I === 0) this.set(q.k, q.v);
            else {
              const S = I - E;
              S > 0 && this.set(q.k, q.v, S);
            }
          }
        }
        prune() {
          this[g].forEach((P, E) => b(this, E, !1));
        }
      };
    }, { yallist: 83 }], 38: [function(i, s, a) {
      (function(o) {
        (function() {
          const r = s.exports;
          r.types = { 0: "reserved", 1: "connect", 2: "connack", 3: "publish", 4: "puback", 5: "pubrec", 6: "pubrel", 7: "pubcomp", 8: "subscribe", 9: "suback", 10: "unsubscribe", 11: "unsuback", 12: "pingreq", 13: "pingresp", 14: "disconnect", 15: "auth" }, r.codes = {};
          for (const n in r.types) {
            const h = r.types[n];
            r.codes[h] = n;
          }
          r.CMD_SHIFT = 4, r.CMD_MASK = 240, r.DUP_MASK = 8, r.QOS_MASK = 3, r.QOS_SHIFT = 1, r.RETAIN_MASK = 1, r.VARBYTEINT_MASK = 127, r.VARBYTEINT_FIN_MASK = 128, r.VARBYTEINT_MAX = 268435455, r.SESSIONPRESENT_MASK = 1, r.SESSIONPRESENT_HEADER = o.from([r.SESSIONPRESENT_MASK]), r.CONNACK_HEADER = o.from([r.codes.connack << r.CMD_SHIFT]), r.USERNAME_MASK = 128, r.PASSWORD_MASK = 64, r.WILL_RETAIN_MASK = 32, r.WILL_QOS_MASK = 24, r.WILL_QOS_SHIFT = 3, r.WILL_FLAG_MASK = 4, r.CLEAN_SESSION_MASK = 2, r.CONNECT_HEADER = o.from([r.codes.connect << r.CMD_SHIFT]), r.properties = { sessionExpiryInterval: 17, willDelayInterval: 24, receiveMaximum: 33, maximumPacketSize: 39, topicAliasMaximum: 34, requestResponseInformation: 25, requestProblemInformation: 23, userProperties: 38, authenticationMethod: 21, authenticationData: 22, payloadFormatIndicator: 1, messageExpiryInterval: 2, contentType: 3, responseTopic: 8, correlationData: 9, maximumQoS: 36, retainAvailable: 37, assignedClientIdentifier: 18, reasonString: 31, wildcardSubscriptionAvailable: 40, subscriptionIdentifiersAvailable: 41, sharedSubscriptionAvailable: 42, serverKeepAlive: 19, responseInformation: 26, serverReference: 28, topicAlias: 35, subscriptionIdentifier: 11 }, r.propertiesCodes = {};
          for (const n in r.properties) {
            const h = r.properties[n];
            r.propertiesCodes[h] = n;
          }
          function l(n) {
            return [0, 1, 2].map((h) => [0, 1].map((c) => [0, 1].map((d) => {
              const f = o.alloc(1);
              return f.writeUInt8(r.codes[n] << r.CMD_SHIFT | (c ? r.DUP_MASK : 0) | h << r.QOS_SHIFT | d, 0, !0), f;
            })));
          }
          r.propertiesTypes = { sessionExpiryInterval: "int32", willDelayInterval: "int32", receiveMaximum: "int16", maximumPacketSize: "int32", topicAliasMaximum: "int16", requestResponseInformation: "byte", requestProblemInformation: "byte", userProperties: "pair", authenticationMethod: "string", authenticationData: "binary", payloadFormatIndicator: "byte", messageExpiryInterval: "int32", contentType: "string", responseTopic: "string", correlationData: "binary", maximumQoS: "int8", retainAvailable: "byte", assignedClientIdentifier: "string", reasonString: "string", wildcardSubscriptionAvailable: "byte", subscriptionIdentifiersAvailable: "byte", sharedSubscriptionAvailable: "byte", serverKeepAlive: "int16", responseInformation: "string", serverReference: "string", topicAlias: "int16", subscriptionIdentifier: "var" }, r.PUBLISH_HEADER = l("publish"), r.SUBSCRIBE_HEADER = l("subscribe"), r.SUBSCRIBE_OPTIONS_QOS_MASK = 3, r.SUBSCRIBE_OPTIONS_NL_MASK = 1, r.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, r.SUBSCRIBE_OPTIONS_RAP_MASK = 1, r.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, r.SUBSCRIBE_OPTIONS_RH_MASK = 3, r.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, r.SUBSCRIBE_OPTIONS_RH = [0, 16, 32], r.SUBSCRIBE_OPTIONS_NL = 4, r.SUBSCRIBE_OPTIONS_RAP = 8, r.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2], r.UNSUBSCRIBE_HEADER = l("unsubscribe"), r.ACKS = { unsuback: l("unsuback"), puback: l("puback"), pubcomp: l("pubcomp"), pubrel: l("pubrel"), pubrec: l("pubrec") }, r.SUBACK_HEADER = o.from([r.codes.suback << r.CMD_SHIFT]), r.VERSION3 = o.from([3]), r.VERSION4 = o.from([4]), r.VERSION5 = o.from([5]), r.VERSION131 = o.from([131]), r.VERSION132 = o.from([132]), r.QOS = [0, 1, 2].map((n) => o.from([n])), r.EMPTY = { pingreq: o.from([r.codes.pingreq << 4, 0]), pingresp: o.from([r.codes.pingresp << 4, 0]), disconnect: o.from([r.codes.disconnect << 4, 0]) };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 39: [function(i, s, a) {
      (function(o) {
        (function() {
          const r = i("./writeToStream"), l = i("events");
          class n extends l {
            constructor() {
              super(), this._array = new Array(20), this._i = 0;
            }
            write(c) {
              return this._array[this._i++] = c, !0;
            }
            concat() {
              let c = 0;
              const d = new Array(this._array.length), f = this._array;
              let u, g = 0;
              for (u = 0; u < f.length && f[u] !== void 0; u++) typeof f[u] != "string" ? d[u] = f[u].length : d[u] = o.byteLength(f[u]), c += d[u];
              const y = o.allocUnsafe(c);
              for (u = 0; u < f.length && f[u] !== void 0; u++) typeof f[u] != "string" ? (f[u].copy(y, g), g += d[u]) : (y.write(f[u], g), g += d[u]);
              return y;
            }
          }
          s.exports = function(h, c) {
            const d = new n();
            return r(h, d, c), d.concat();
          };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "./writeToStream": 44, buffer: 17, events: 22 }], 40: [function(i, s, a) {
      a.parser = i("./parser").parser, a.generate = i("./generate"), a.writeToStream = i("./writeToStream");
    }, { "./generate": 39, "./parser": 43, "./writeToStream": 44 }], 41: [function(i, s, a) {
      (function(o) {
        (function() {
          const l = {}, n = o.isBuffer(o.from([1, 2]).subarray(0, 1));
          function h(c) {
            const d = o.allocUnsafe(2);
            return d.writeUInt8(c >> 8, 0), d.writeUInt8(255 & c, 1), d;
          }
          s.exports = { cache: l, generateCache: function() {
            for (let c = 0; c < 65536; c++) l[c] = h(c);
          }, generateNumber: h, genBufVariableByteInt: function(c) {
            let d = 0, f = 0;
            const u = o.allocUnsafe(4);
            do
              d = c % 128 | 0, (c = c / 128 | 0) > 0 && (d |= 128), u.writeUInt8(d, f++);
            while (c > 0 && f < 4);
            return c > 0 && (f = 0), n ? u.subarray(0, f) : u.slice(0, f);
          }, generate4ByteBuffer: function(c) {
            const d = o.allocUnsafe(4);
            return d.writeUInt32BE(c, 0), d;
          } };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 42: [function(i, s, a) {
      s.exports = class {
        constructor() {
          this.cmd = null, this.retain = !1, this.qos = 0, this.dup = !1, this.length = -1, this.topic = null, this.payload = null;
        }
      };
    }, {}], 43: [function(i, s, a) {
      const o = i("bl"), r = i("events"), l = i("./packet"), n = i("./constants"), h = i("debug")("mqtt-packet:parser");
      class c extends r {
        constructor() {
          super(), this.parser = this.constructor.parser;
        }
        static parser(f) {
          return this instanceof c ? (this.settings = f || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new c().parser(f);
        }
        _resetState() {
          h("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new l(), this.error = null, this._list = o(), this._stateCounter = 0;
        }
        parse(f) {
          for (this.error && this._resetState(), this._list.append(f), h("parse: current state: %s", this._states[this._stateCounter]); (this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; ) this._stateCounter++, h("parse: state complete. _stateCounter is now: %d", this._stateCounter), h("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
          return h("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
        }
        _parseHeader() {
          const f = this._list.readUInt8(0);
          return this.packet.cmd = n.types[f >> n.CMD_SHIFT], this.packet.retain = (f & n.RETAIN_MASK) != 0, this.packet.qos = f >> n.QOS_SHIFT & n.QOS_MASK, this.packet.dup = (f & n.DUP_MASK) != 0, h("_parseHeader: packet: %o", this.packet), this._list.consume(1), !0;
        }
        _parseLength() {
          const f = this._parseVarByteNum(!0);
          return f && (this.packet.length = f.value, this._list.consume(f.bytes)), h("_parseLength %d", f.value), !!f;
        }
        _parsePayload() {
          h("_parsePayload: payload %O", this._list);
          let f = !1;
          if (this.packet.length === 0 || this._list.length >= this.packet.length) {
            switch (this._pos = 0, this.packet.cmd) {
              case "connect":
                this._parseConnect();
                break;
              case "connack":
                this._parseConnack();
                break;
              case "publish":
                this._parsePublish();
                break;
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                this._parseConfirmation();
                break;
              case "subscribe":
                this._parseSubscribe();
                break;
              case "suback":
                this._parseSuback();
                break;
              case "unsubscribe":
                this._parseUnsubscribe();
                break;
              case "unsuback":
                this._parseUnsuback();
                break;
              case "pingreq":
              case "pingresp":
                break;
              case "disconnect":
                this._parseDisconnect();
                break;
              case "auth":
                this._parseAuth();
                break;
              default:
                this._emitError(new Error("Not supported"));
            }
            f = !0;
          }
          return h("_parsePayload complete result: %s", f), f;
        }
        _parseConnect() {
          let f, u, g, y;
          h("_parseConnect");
          const v = {}, b = this.packet, x = this._parseString();
          if (x === null) return this._emitError(new Error("Cannot parse protocolId"));
          if (x !== "MQTT" && x !== "MQIsdp") return this._emitError(new Error("Invalid protocolId"));
          if (b.protocolId = x, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (b.protocolVersion = this._list.readUInt8(this._pos), b.protocolVersion >= 128 && (b.bridgeMode = !0, b.protocolVersion = b.protocolVersion - 128), b.protocolVersion !== 3 && b.protocolVersion !== 4 && b.protocolVersion !== 5) return this._emitError(new Error("Invalid protocol version"));
          if (this._pos++, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (v.username = this._list.readUInt8(this._pos) & n.USERNAME_MASK, v.password = this._list.readUInt8(this._pos) & n.PASSWORD_MASK, v.will = this._list.readUInt8(this._pos) & n.WILL_FLAG_MASK, v.will && (b.will = {}, b.will.retain = (this._list.readUInt8(this._pos) & n.WILL_RETAIN_MASK) != 0, b.will.qos = (this._list.readUInt8(this._pos) & n.WILL_QOS_MASK) >> n.WILL_QOS_SHIFT), b.clean = (this._list.readUInt8(this._pos) & n.CLEAN_SESSION_MASK) != 0, this._pos++, b.keepalive = this._parseNum(), b.keepalive === -1) return this._emitError(new Error("Packet too short"));
          if (b.protocolVersion === 5) {
            const k = this._parseProperties();
            Object.getOwnPropertyNames(k).length && (b.properties = k);
          }
          const p = this._parseString();
          if (p === null) return this._emitError(new Error("Packet too short"));
          if (b.clientId = p, h("_parseConnect: packet.clientId: %s", b.clientId), v.will) {
            if (b.protocolVersion === 5) {
              const k = this._parseProperties();
              Object.getOwnPropertyNames(k).length && (b.will.properties = k);
            }
            if ((f = this._parseString()) === null) return this._emitError(new Error("Cannot parse will topic"));
            if (b.will.topic = f, h("_parseConnect: packet.will.topic: %s", b.will.topic), (u = this._parseBuffer()) === null) return this._emitError(new Error("Cannot parse will payload"));
            b.will.payload = u, h("_parseConnect: packet.will.paylaod: %s", b.will.payload);
          }
          if (v.username) {
            if ((y = this._parseString()) === null) return this._emitError(new Error("Cannot parse username"));
            b.username = y, h("_parseConnect: packet.username: %s", b.username);
          }
          if (v.password) {
            if ((g = this._parseBuffer()) === null) return this._emitError(new Error("Cannot parse password"));
            b.password = g;
          }
          return this.settings = b, h("_parseConnect: complete"), b;
        }
        _parseConnack() {
          h("_parseConnack");
          const f = this.packet;
          if (this._list.length < 1) return null;
          if (f.sessionPresent = !!(this._list.readUInt8(this._pos++) & n.SESSIONPRESENT_MASK), this.settings.protocolVersion === 5) this._list.length >= 2 ? f.reasonCode = this._list.readUInt8(this._pos++) : f.reasonCode = 0;
          else {
            if (this._list.length < 2) return null;
            f.returnCode = this._list.readUInt8(this._pos++);
          }
          if (f.returnCode === -1 || f.reasonCode === -1) return this._emitError(new Error("Cannot parse return code"));
          if (this.settings.protocolVersion === 5) {
            const u = this._parseProperties();
            Object.getOwnPropertyNames(u).length && (f.properties = u);
          }
          h("_parseConnack: complete");
        }
        _parsePublish() {
          h("_parsePublish");
          const f = this.packet;
          if (f.topic = this._parseString(), f.topic === null) return this._emitError(new Error("Cannot parse topic"));
          if (!(f.qos > 0) || this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const u = this._parseProperties();
              Object.getOwnPropertyNames(u).length && (f.properties = u);
            }
            f.payload = this._list.slice(this._pos, f.length), h("_parsePublish: payload from buffer list: %o", f.payload);
          }
        }
        _parseSubscribe() {
          h("_parseSubscribe");
          const f = this.packet;
          let u, g, y, v, b, x, p;
          if (f.qos !== 1) return this._emitError(new Error("Wrong subscribe header"));
          if (f.subscriptions = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const k = this._parseProperties();
              Object.getOwnPropertyNames(k).length && (f.properties = k);
            }
            for (; this._pos < f.length; ) {
              if ((u = this._parseString()) === null) return this._emitError(new Error("Cannot parse topic"));
              if (this._pos >= f.length) return this._emitError(new Error("Malformed Subscribe Payload"));
              y = (g = this._parseByte()) & n.SUBSCRIBE_OPTIONS_QOS_MASK, x = (g >> n.SUBSCRIBE_OPTIONS_NL_SHIFT & n.SUBSCRIBE_OPTIONS_NL_MASK) != 0, b = (g >> n.SUBSCRIBE_OPTIONS_RAP_SHIFT & n.SUBSCRIBE_OPTIONS_RAP_MASK) != 0, v = g >> n.SUBSCRIBE_OPTIONS_RH_SHIFT & n.SUBSCRIBE_OPTIONS_RH_MASK, p = { topic: u, qos: y }, this.settings.protocolVersion === 5 ? (p.nl = x, p.rap = b, p.rh = v) : this.settings.bridgeMode && (p.rh = 0, p.rap = !0, p.nl = !0), h("_parseSubscribe: push subscription `%s` to subscription", p), f.subscriptions.push(p);
            }
          }
        }
        _parseSuback() {
          h("_parseSuback");
          const f = this.packet;
          if (this.packet.granted = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const u = this._parseProperties();
              Object.getOwnPropertyNames(u).length && (f.properties = u);
            }
            for (; this._pos < this.packet.length; ) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseUnsubscribe() {
          h("_parseUnsubscribe");
          const f = this.packet;
          if (f.unsubscriptions = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const u = this._parseProperties();
              Object.getOwnPropertyNames(u).length && (f.properties = u);
            }
            for (; this._pos < f.length; ) {
              const u = this._parseString();
              if (u === null) return this._emitError(new Error("Cannot parse topic"));
              h("_parseUnsubscribe: push topic `%s` to unsubscriptions", u), f.unsubscriptions.push(u);
            }
          }
        }
        _parseUnsuback() {
          h("_parseUnsuback");
          const f = this.packet;
          if (!this._parseMessageId()) return this._emitError(new Error("Cannot parse messageId"));
          if (this.settings.protocolVersion === 5) {
            const u = this._parseProperties();
            for (Object.getOwnPropertyNames(u).length && (f.properties = u), f.granted = []; this._pos < this.packet.length; ) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseConfirmation() {
          h("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
          const f = this.packet;
          if (this._parseMessageId(), this.settings.protocolVersion === 5 && (f.length > 2 ? (f.reasonCode = this._parseByte(), h("_parseConfirmation: packet.reasonCode `%d`", f.reasonCode)) : f.reasonCode = 0, f.length > 3)) {
            const u = this._parseProperties();
            Object.getOwnPropertyNames(u).length && (f.properties = u);
          }
          return !0;
        }
        _parseDisconnect() {
          const f = this.packet;
          if (h("_parseDisconnect"), this.settings.protocolVersion === 5) {
            this._list.length > 0 ? f.reasonCode = this._parseByte() : f.reasonCode = 0;
            const u = this._parseProperties();
            Object.getOwnPropertyNames(u).length && (f.properties = u);
          }
          return h("_parseDisconnect result: true"), !0;
        }
        _parseAuth() {
          h("_parseAuth");
          const f = this.packet;
          if (this.settings.protocolVersion !== 5) return this._emitError(new Error("Not supported auth packet for this version MQTT"));
          f.reasonCode = this._parseByte();
          const u = this._parseProperties();
          return Object.getOwnPropertyNames(u).length && (f.properties = u), h("_parseAuth: result: true"), !0;
        }
        _parseMessageId() {
          const f = this.packet;
          return f.messageId = this._parseNum(), f.messageId === null ? (this._emitError(new Error("Cannot parse messageId")), !1) : (h("_parseMessageId: packet.messageId %d", f.messageId), !0);
        }
        _parseString(f) {
          const u = this._parseNum(), g = u + this._pos;
          if (u === -1 || g > this._list.length || g > this.packet.length) return null;
          const y = this._list.toString("utf8", this._pos, g);
          return this._pos += u, h("_parseString: result: %s", y), y;
        }
        _parseStringPair() {
          return h("_parseStringPair"), { name: this._parseString(), value: this._parseString() };
        }
        _parseBuffer() {
          const f = this._parseNum(), u = f + this._pos;
          if (f === -1 || u > this._list.length || u > this.packet.length) return null;
          const g = this._list.slice(this._pos, u);
          return this._pos += f, h("_parseBuffer: result: %o", g), g;
        }
        _parseNum() {
          if (this._list.length - this._pos < 2) return -1;
          const f = this._list.readUInt16BE(this._pos);
          return this._pos += 2, h("_parseNum: result: %s", f), f;
        }
        _parse4ByteNum() {
          if (this._list.length - this._pos < 4) return -1;
          const f = this._list.readUInt32BE(this._pos);
          return this._pos += 4, h("_parse4ByteNum: result: %s", f), f;
        }
        _parseVarByteNum(f) {
          h("_parseVarByteNum");
          let u, g = 0, y = 1, v = 0, b = !1;
          const x = this._pos ? this._pos : 0;
          for (; g < 4 && x + g < this._list.length; ) {
            if (v += y * ((u = this._list.readUInt8(x + g++)) & n.VARBYTEINT_MASK), y *= 128, (u & n.VARBYTEINT_FIN_MASK) == 0) {
              b = !0;
              break;
            }
            if (this._list.length <= g) break;
          }
          return !b && g === 4 && this._list.length >= g && this._emitError(new Error("Invalid variable byte integer")), x && (this._pos += g), h("_parseVarByteNum: result: %o", b = !!b && (f ? { bytes: g, value: v } : v)), b;
        }
        _parseByte() {
          let f;
          return this._pos < this._list.length && (f = this._list.readUInt8(this._pos), this._pos++), h("_parseByte: result: %o", f), f;
        }
        _parseByType(f) {
          switch (h("_parseByType: type: %s", f), f) {
            case "byte":
              return this._parseByte() !== 0;
            case "int8":
              return this._parseByte();
            case "int16":
              return this._parseNum();
            case "int32":
              return this._parse4ByteNum();
            case "var":
              return this._parseVarByteNum();
            case "string":
              return this._parseString();
            case "pair":
              return this._parseStringPair();
            case "binary":
              return this._parseBuffer();
          }
        }
        _parseProperties() {
          h("_parseProperties");
          const f = this._parseVarByteNum(), u = this._pos + f, g = {};
          for (; this._pos < u; ) {
            const y = this._parseByte();
            if (!y) return this._emitError(new Error("Cannot parse property code type")), !1;
            const v = n.propertiesCodes[y];
            if (!v) return this._emitError(new Error("Unknown property")), !1;
            if (v !== "userProperties") g[v] ? Array.isArray(g[v]) ? g[v].push(this._parseByType(n.propertiesTypes[v])) : (g[v] = [g[v]], g[v].push(this._parseByType(n.propertiesTypes[v]))) : g[v] = this._parseByType(n.propertiesTypes[v]);
            else {
              g[v] || (g[v] = /* @__PURE__ */ Object.create(null));
              const b = this._parseByType(n.propertiesTypes[v]);
              if (g[v][b.name]) if (Array.isArray(g[v][b.name])) g[v][b.name].push(b.value);
              else {
                const x = g[v][b.name];
                g[v][b.name] = [x], g[v][b.name].push(b.value);
              }
              else g[v][b.name] = b.value;
            }
          }
          return g;
        }
        _newPacket() {
          return h("_newPacket"), this.packet && (this._list.consume(this.packet.length), h("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), h("_newPacket: new packet"), this.packet = new l(), this._pos = 0, !0;
        }
        _emitError(f) {
          h("_emitError"), this.error = f, this.emit("error", f);
        }
      }
      s.exports = c;
    }, { "./constants": 38, "./packet": 42, bl: 15, debug: 18, events: 22 }], 44: [function(i, s, a) {
      (function(o) {
        (function() {
          const r = i("./constants"), l = o.allocUnsafe(0), n = o.from([0]), h = i("./numbers"), c = i("process-nextick-args").nextTick, d = i("debug")("mqtt-packet:writeToStream"), f = h.cache, u = h.generateNumber, g = h.generateCache, y = h.genBufVariableByteInt, v = h.generate4ByteBuffer;
          let b = D, x = !0;
          function p(H, M, B) {
            switch (d("generate called"), M.cork && (M.cork(), c(k, M)), x && (x = !1, g()), d("generate: packet.cmd: %s", H.cmd), H.cmd) {
              case "connect":
                return function(W, N, U) {
                  const Y = W || {}, $ = Y.protocolId || "MQTT";
                  let Z = Y.protocolVersion || 4;
                  const Q = Y.will;
                  let J = Y.clean;
                  const m = Y.keepalive || 0, w = Y.clientId || "", C = Y.username, L = Y.password, F = Y.properties;
                  J === void 0 && (J = !0);
                  let j = 0;
                  if (typeof $ != "string" && !o.isBuffer($)) return N.emit("error", new Error("Invalid protocolId")), !1;
                  if (j += $.length + 2, Z !== 3 && Z !== 4 && Z !== 5) return N.emit("error", new Error("Invalid protocol version")), !1;
                  if (j += 1, (typeof w == "string" || o.isBuffer(w)) && (w || Z >= 4) && (w || J)) j += o.byteLength(w) + 2;
                  else {
                    if (Z < 4) return N.emit("error", new Error("clientId must be supplied before 3.1.1")), !1;
                    if (1 * J == 0) return N.emit("error", new Error("clientId must be given if cleanSession set to 0")), !1;
                  }
                  if (typeof m != "number" || m < 0 || m > 65535 || m % 1 != 0) return N.emit("error", new Error("Invalid keepalive")), !1;
                  if (j += 2, j += 1, Z === 5) {
                    var K = S(N, F);
                    if (!K) return !1;
                    j += K.length;
                  }
                  if (Q) {
                    if (typeof Q != "object") return N.emit("error", new Error("Invalid will")), !1;
                    if (!Q.topic || typeof Q.topic != "string") return N.emit("error", new Error("Invalid will topic")), !1;
                    if (j += o.byteLength(Q.topic) + 2, j += 2, Q.payload) {
                      if (!(Q.payload.length >= 0)) return N.emit("error", new Error("Invalid will payload")), !1;
                      typeof Q.payload == "string" ? j += o.byteLength(Q.payload) : j += Q.payload.length;
                    }
                    var te = {};
                    if (Z === 5) {
                      if (!(te = S(N, Q.properties))) return !1;
                      j += te.length;
                    }
                  }
                  let ee = !1;
                  if (C != null) {
                    if (!X(C)) return N.emit("error", new Error("Invalid username")), !1;
                    ee = !0, j += o.byteLength(C) + 2;
                  }
                  if (L != null) {
                    if (!ee) return N.emit("error", new Error("Username is required to use password")), !1;
                    if (!X(L)) return N.emit("error", new Error("Invalid password")), !1;
                    j += V(L) + 2;
                  }
                  N.write(r.CONNECT_HEADER), A(N, j), I(N, $), Y.bridgeMode && (Z += 128), N.write(Z === 131 ? r.VERSION131 : Z === 132 ? r.VERSION132 : Z === 4 ? r.VERSION4 : Z === 5 ? r.VERSION5 : r.VERSION3);
                  let oe = 0;
                  return oe |= C != null ? r.USERNAME_MASK : 0, oe |= L != null ? r.PASSWORD_MASK : 0, oe |= Q && Q.retain ? r.WILL_RETAIN_MASK : 0, oe |= Q && Q.qos ? Q.qos << r.WILL_QOS_SHIFT : 0, oe |= Q ? r.WILL_FLAG_MASK : 0, oe |= J ? r.CLEAN_SESSION_MASK : 0, N.write(o.from([oe])), b(N, m), Z === 5 && K.write(), I(N, w), Q && (Z === 5 && te.write(), P(N, Q.topic), I(N, Q.payload)), C != null && I(N, C), L != null && I(N, L), !0;
                }(H, M);
              case "connack":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = Y === 5 ? $.reasonCode : $.returnCode, Q = $.properties;
                  let J = 2;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid return code")), !1;
                  let m = null;
                  if (Y === 5) {
                    if (!(m = S(N, Q))) return !1;
                    J += m.length;
                  }
                  return N.write(r.CONNACK_HEADER), A(N, J), N.write($.sessionPresent ? r.SESSIONPRESENT_HEADER : n), N.write(o.from([Z])), m != null && m.write(), !0;
                }(H, M, B);
              case "publish":
                return function(W, N, U) {
                  d("publish: packet: %o", W);
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.qos || 0, Q = $.retain ? r.RETAIN_MASK : 0, J = $.topic, m = $.payload || l, w = $.messageId, C = $.properties;
                  let L = 0;
                  if (typeof J == "string") L += o.byteLength(J) + 2;
                  else {
                    if (!o.isBuffer(J)) return N.emit("error", new Error("Invalid topic")), !1;
                    L += J.length + 2;
                  }
                  if (o.isBuffer(m) ? L += m.length : L += o.byteLength(m), Z && typeof w != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  Z && (L += 2);
                  let F = null;
                  if (Y === 5) {
                    if (!(F = S(N, C))) return !1;
                    L += F.length;
                  }
                  return N.write(r.PUBLISH_HEADER[Z][$.dup ? 1 : 0][Q ? 1 : 0]), A(N, L), b(N, V(J)), N.write(J), Z > 0 && b(N, w), F != null && F.write(), d("publish: payload: %o", m), N.write(m);
                }(H, M, B);
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.cmd || "puback", Q = $.messageId, J = $.dup && Z === "pubrel" ? r.DUP_MASK : 0;
                  let m = 0;
                  const w = $.reasonCode, C = $.properties;
                  let L = Y === 5 ? 3 : 2;
                  if (Z === "pubrel" && (m = 1), typeof Q != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  let F = null;
                  if (Y === 5 && typeof C == "object") {
                    if (!(F = T(N, C, U, L))) return !1;
                    L += F.length;
                  }
                  return N.write(r.ACKS[Z][m][J][0]), A(N, L), b(N, Q), Y === 5 && N.write(o.from([w])), F !== null && F.write(), !0;
                }(H, M, B);
              case "subscribe":
                return function(W, N, U) {
                  d("subscribe: packet: ");
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.dup ? r.DUP_MASK : 0, Q = $.messageId, J = $.subscriptions, m = $.properties;
                  let w = 0;
                  if (typeof Q != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  w += 2;
                  let C = null;
                  if (Y === 5) {
                    if (!(C = S(N, m))) return !1;
                    w += C.length;
                  }
                  if (typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid subscriptions")), !1;
                  for (let F = 0; F < J.length; F += 1) {
                    const j = J[F].topic, K = J[F].qos;
                    if (typeof j != "string") return N.emit("error", new Error("Invalid subscriptions - invalid topic")), !1;
                    if (typeof K != "number") return N.emit("error", new Error("Invalid subscriptions - invalid qos")), !1;
                    if (Y === 5) {
                      if (typeof (J[F].nl || !1) != "boolean") return N.emit("error", new Error("Invalid subscriptions - invalid No Local")), !1;
                      if (typeof (J[F].rap || !1) != "boolean") return N.emit("error", new Error("Invalid subscriptions - invalid Retain as Published")), !1;
                      const oe = J[F].rh || 0;
                      if (typeof oe != "number" || oe > 2) return N.emit("error", new Error("Invalid subscriptions - invalid Retain Handling")), !1;
                    }
                    w += o.byteLength(j) + 2 + 1;
                  }
                  d("subscribe: writing to stream: %o", r.SUBSCRIBE_HEADER), N.write(r.SUBSCRIBE_HEADER[1][Z ? 1 : 0][0]), A(N, w), b(N, Q), C !== null && C.write();
                  let L = !0;
                  for (const F of J) {
                    const j = F.topic, K = F.qos, te = +F.nl, ee = +F.rap, oe = F.rh;
                    let le;
                    P(N, j), le = r.SUBSCRIBE_OPTIONS_QOS[K], Y === 5 && (le |= te ? r.SUBSCRIBE_OPTIONS_NL : 0, le |= ee ? r.SUBSCRIBE_OPTIONS_RAP : 0, le |= oe ? r.SUBSCRIBE_OPTIONS_RH[oe] : 0), L = N.write(o.from([le]));
                  }
                  return L;
                }(H, M, B);
              case "suback":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.messageId, Q = $.granted, J = $.properties;
                  let m = 0;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (m += 2, typeof Q != "object" || !Q.length) return N.emit("error", new Error("Invalid qos vector")), !1;
                  for (let C = 0; C < Q.length; C += 1) {
                    if (typeof Q[C] != "number") return N.emit("error", new Error("Invalid qos vector")), !1;
                    m += 1;
                  }
                  let w = null;
                  if (Y === 5) {
                    if (!(w = T(N, J, U, m))) return !1;
                    m += w.length;
                  }
                  return N.write(r.SUBACK_HEADER), A(N, m), b(N, Z), w !== null && w.write(), N.write(o.from(Q));
                }(H, M, B);
              case "unsubscribe":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.messageId, Q = $.dup ? r.DUP_MASK : 0, J = $.unsubscriptions, m = $.properties;
                  let w = 0;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (w += 2, typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid unsubscriptions")), !1;
                  for (let F = 0; F < J.length; F += 1) {
                    if (typeof J[F] != "string") return N.emit("error", new Error("Invalid unsubscriptions")), !1;
                    w += o.byteLength(J[F]) + 2;
                  }
                  let C = null;
                  if (Y === 5) {
                    if (!(C = S(N, m))) return !1;
                    w += C.length;
                  }
                  N.write(r.UNSUBSCRIBE_HEADER[1][Q ? 1 : 0][0]), A(N, w), b(N, Z), C !== null && C.write();
                  let L = !0;
                  for (let F = 0; F < J.length; F++) L = P(N, J[F]);
                  return L;
                }(H, M, B);
              case "unsuback":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.messageId, Q = $.dup ? r.DUP_MASK : 0, J = $.granted, m = $.properties, w = $.cmd;
                  let C = 2;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (Y === 5) {
                    if (typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid qos vector")), !1;
                    for (let F = 0; F < J.length; F += 1) {
                      if (typeof J[F] != "number") return N.emit("error", new Error("Invalid qos vector")), !1;
                      C += 1;
                    }
                  }
                  let L = null;
                  if (Y === 5) {
                    if (!(L = T(N, m, U, C))) return !1;
                    C += L.length;
                  }
                  return N.write(r.ACKS[w][0][Q][0]), A(N, C), b(N, Z), L !== null && L.write(), Y === 5 && N.write(o.from(J)), !0;
                }(H, M, B);
              case "pingreq":
              case "pingresp":
                return function(W, N, U) {
                  return N.write(r.EMPTY[W.cmd]);
                }(H, M);
              case "disconnect":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.reasonCode, Q = $.properties;
                  let J = Y === 5 ? 1 : 0, m = null;
                  if (Y === 5) {
                    if (!(m = T(N, Q, U, J))) return !1;
                    J += m.length;
                  }
                  return N.write(o.from([r.codes.disconnect << 4])), A(N, J), Y === 5 && N.write(o.from([Z])), m !== null && m.write(), !0;
                }(H, M, B);
              case "auth":
                return function(W, N, U) {
                  const Y = U ? U.protocolVersion : 4, $ = W || {}, Z = $.reasonCode, Q = $.properties;
                  let J = Y === 5 ? 1 : 0;
                  Y !== 5 && N.emit("error", new Error("Invalid mqtt version for auth packet"));
                  const m = T(N, Q, U, J);
                  return m ? (J += m.length, N.write(o.from([r.codes.auth << 4])), A(N, J), N.write(o.from([Z])), m !== null && m.write(), !0) : !1;
                }(H, M, B);
              default:
                return M.emit("error", new Error("Unknown command")), !1;
            }
          }
          function k(H) {
            H.uncork();
          }
          Object.defineProperty(p, "cacheNumbers", { get: () => b === D, set(H) {
            H ? (f && Object.keys(f).length !== 0 || (x = !0), b = D) : (x = !1, b = q);
          } });
          const R = {};
          function A(H, M) {
            if (M > r.VARBYTEINT_MAX) return H.emit("error", new Error(`Invalid variable byte integer: ${M}`)), !1;
            let B = R[M];
            return B || (B = y(M), M < 16384 && (R[M] = B)), d("writeVarByteInt: writing to stream: %o", B), H.write(B);
          }
          function P(H, M) {
            const B = o.byteLength(M);
            return b(H, B), d("writeString: %s", M), H.write(M, "utf8");
          }
          function E(H, M, B) {
            P(H, M), P(H, B);
          }
          function D(H, M) {
            return d("writeNumberCached: number: %d", M), d("writeNumberCached: %o", f[M]), H.write(f[M]);
          }
          function q(H, M) {
            const B = u(M);
            return d("writeNumberGenerated: %o", B), H.write(B);
          }
          function I(H, M) {
            typeof M == "string" ? P(H, M) : M ? (b(H, M.length), H.write(M)) : b(H, 0);
          }
          function S(H, M) {
            if (typeof M != "object" || M.length != null) return { length: 1, write() {
              z(H, {}, 0);
            } };
            let B = 0;
            function W(N, U) {
              let Y = 0;
              switch (r.propertiesTypes[N]) {
                case "byte":
                  if (typeof U != "boolean") return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 2;
                  break;
                case "int8":
                  if (typeof U != "number" || U < 0 || U > 255) return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 2;
                  break;
                case "binary":
                  if (U && U === null) return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 1 + o.byteLength(U) + 2;
                  break;
                case "int16":
                  if (typeof U != "number" || U < 0 || U > 65535) return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 3;
                  break;
                case "int32":
                  if (typeof U != "number" || U < 0 || U > 4294967295) return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 5;
                  break;
                case "var":
                  if (typeof U != "number" || U < 0 || U > 268435455) return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 1 + o.byteLength(y(U));
                  break;
                case "string":
                  if (typeof U != "string") return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += 3 + o.byteLength(U.toString());
                  break;
                case "pair":
                  if (typeof U != "object") return H.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  Y += Object.getOwnPropertyNames(U).reduce(($, Z) => {
                    const Q = U[Z];
                    return Array.isArray(Q) ? $ += Q.reduce((J, m) => J += 3 + o.byteLength(Z.toString()) + 2 + o.byteLength(m.toString()), 0) : $ += 3 + o.byteLength(Z.toString()) + 2 + o.byteLength(U[Z].toString()), $;
                  }, 0);
                  break;
                default:
                  return H.emit("error", new Error(`Invalid property ${N}: ${U}`)), !1;
              }
              return Y;
            }
            if (M) for (const N in M) {
              let U = 0, Y = 0;
              const $ = M[N];
              if (Array.isArray($)) for (let Z = 0; Z < $.length; Z++) {
                if (!(Y = W(N, $[Z]))) return !1;
                U += Y;
              }
              else {
                if (!(Y = W(N, $))) return !1;
                U = Y;
              }
              if (!U) return !1;
              B += U;
            }
            return { length: o.byteLength(y(B)) + B, write() {
              z(H, M, B);
            } };
          }
          function T(H, M, B, W) {
            const N = ["reasonString", "userProperties"], U = B && B.properties && B.properties.maximumPacketSize ? B.properties.maximumPacketSize : 0;
            let Y = S(H, M);
            if (U) for (; W + Y.length > U; ) {
              const $ = N.shift();
              if (!$ || !M[$]) return !1;
              delete M[$], Y = S(H, M);
            }
            return Y;
          }
          function _(H, M, B) {
            switch (r.propertiesTypes[M]) {
              case "byte":
                H.write(o.from([r.properties[M]])), H.write(o.from([+B]));
                break;
              case "int8":
                H.write(o.from([r.properties[M]])), H.write(o.from([B]));
                break;
              case "binary":
                H.write(o.from([r.properties[M]])), I(H, B);
                break;
              case "int16":
                H.write(o.from([r.properties[M]])), b(H, B);
                break;
              case "int32":
                H.write(o.from([r.properties[M]])), function(W, N) {
                  const U = v(N);
                  d("write4ByteNumber: %o", U), W.write(U);
                }(H, B);
                break;
              case "var":
                H.write(o.from([r.properties[M]])), A(H, B);
                break;
              case "string":
                H.write(o.from([r.properties[M]])), P(H, B);
                break;
              case "pair":
                Object.getOwnPropertyNames(B).forEach((W) => {
                  const N = B[W];
                  Array.isArray(N) ? N.forEach((U) => {
                    H.write(o.from([r.properties[M]])), E(H, W.toString(), U.toString());
                  }) : (H.write(o.from([r.properties[M]])), E(H, W.toString(), N.toString()));
                });
                break;
              default:
                return H.emit("error", new Error(`Invalid property ${M} value: ${B}`)), !1;
            }
          }
          function z(H, M, B) {
            A(H, B);
            for (const W in M) if (Object.prototype.hasOwnProperty.call(M, W) && M[W] !== null) {
              const N = M[W];
              if (Array.isArray(N)) for (let U = 0; U < N.length; U++) _(H, W, N[U]);
              else _(H, W, N);
            }
          }
          function V(H) {
            return H ? H instanceof o ? H.length : o.byteLength(H) : 0;
          }
          function X(H) {
            return typeof H == "string" || H instanceof o;
          }
          s.exports = p;
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "./constants": 38, "./numbers": 41, buffer: 17, debug: 18, "process-nextick-args": 49 }], 45: [function(i, s, a) {
      var o = 1e3, r = 60 * o, l = 60 * r, n = 24 * l, h = 7 * n, c = 365.25 * n;
      function d(f, u, g, y) {
        var v = u >= 1.5 * g;
        return Math.round(f / g) + " " + y + (v ? "s" : "");
      }
      s.exports = function(f, u) {
        u = u || {};
        var g = typeof f;
        if (g === "string" && f.length > 0) return function(y) {
          if (!((y = String(y)).length > 100)) {
            var v = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(y);
            if (v) {
              var b = parseFloat(v[1]);
              switch ((v[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return b * c;
                case "weeks":
                case "week":
                case "w":
                  return b * h;
                case "days":
                case "day":
                case "d":
                  return b * n;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return b * l;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return b * r;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return b * o;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return b;
                default:
                  return;
              }
            }
          }
        }(f);
        if (g === "number" && isFinite(f)) return u.long ? function(y) {
          var v = Math.abs(y);
          return v >= n ? d(y, v, n, "day") : v >= l ? d(y, v, l, "hour") : v >= r ? d(y, v, r, "minute") : v >= o ? d(y, v, o, "second") : y + " ms";
        }(f) : function(y) {
          var v = Math.abs(y);
          return v >= n ? Math.round(y / n) + "d" : v >= l ? Math.round(y / l) + "h" : v >= r ? Math.round(y / r) + "m" : v >= o ? Math.round(y / o) + "s" : y + "ms";
        }(f);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(f));
      };
    }, {}], 46: [function(i, s, a) {
      const o = i("./lib/number-allocator.js");
      s.exports.NumberAllocator = o;
    }, { "./lib/number-allocator.js": 47 }], 47: [function(i, s, a) {
      const o = i("js-sdsl").Set, r = i("debug")("number-allocator:trace"), l = i("debug")("number-allocator:error");
      function n(c, d) {
        this.low = c, this.high = d;
      }
      function h(c, d) {
        if (!(this instanceof h)) return new h(c, d);
        this.min = c, this.max = d, this.ss = new o([], (f, u) => f.compare(u)), r("Create"), this.clear();
      }
      n.prototype.equals = function(c) {
        return this.low === c.low && this.high === c.high;
      }, n.prototype.compare = function(c) {
        return this.low < c.low && this.high < c.low ? -1 : c.low < this.low && c.high < this.low ? 1 : 0;
      }, h.prototype.firstVacant = function() {
        return this.ss.size() === 0 ? null : this.ss.front().low;
      }, h.prototype.alloc = function() {
        if (this.ss.size() === 0) return r("alloc():empty"), null;
        const c = this.ss.front(), d = c.low;
        return d + 1 <= c.high ? ++c.low : this.ss.eraseElementByPos(0), r("alloc():" + d), d;
      }, h.prototype.use = function(c) {
        const d = new n(c, c), f = this.ss.lowerBound(d);
        if (f) {
          if (f.equals(d)) return this.ss.eraseElementByValue(f), r("use():" + c), !0;
          if (f.low > c) return !1;
          if (f.low === c) return ++f.low, r("use():" + c), !0;
          if (f.high === c) return --f.high, r("use():" + c), !0;
          const u = f.low;
          return f.low = c + 1, this.ss.insert(new n(u, c - 1)), r("use():" + c), !0;
        }
        return r("use():failed"), !1;
      }, h.prototype.free = function(c) {
        if (c < this.min || c > this.max) return void l("free():" + c + " is out of range");
        const d = new n(c, c), f = this.ss.lowerBound(d);
        if (f) {
          if (f.low <= c && c <= f.high) return void l("free():" + c + " has already been vacant");
          if (f === this.ss.front()) c + 1 === f.low ? --f.low : this.ss.insert(d);
          else {
            const u = this.ss.reverseLowerBound(d);
            u.high + 1 === c ? c + 1 === f.low ? (this.ss.eraseElementByValue(u), f.low = u.low) : u.high = c : c + 1 === f.low ? f.low = c : this.ss.insert(d);
          }
        } else {
          if (f === this.ss.front()) return void this.ss.insert(d);
          const u = this.ss.reverseLowerBound(d);
          u.high + 1 === c ? u.high = c : this.ss.insert(d);
        }
        r("free():" + c);
      }, h.prototype.clear = function() {
        r("clear()"), this.ss.clear(), this.ss.insert(new n(this.min, this.max));
      }, h.prototype.intervalCount = function() {
        return this.ss.size();
      }, h.prototype.dump = function() {
        console.log("length:" + this.ss.size());
        for (const c of this.ss) console.log(c);
      }, s.exports = h;
    }, { debug: 18, "js-sdsl": 36 }], 48: [function(i, s, a) {
      var o = i("wrappy");
      function r(n) {
        var h = function() {
          return h.called ? h.value : (h.called = !0, h.value = n.apply(this, arguments));
        };
        return h.called = !1, h;
      }
      function l(n) {
        var h = function() {
          if (h.called) throw new Error(h.onceError);
          return h.called = !0, h.value = n.apply(this, arguments);
        }, c = n.name || "Function wrapped with `once`";
        return h.onceError = c + " shouldn't be called more than once", h.called = !1, h;
      }
      s.exports = o(r), s.exports.strict = o(l), r.proto = r(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return r(this);
        }, configurable: !0 }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return l(this);
        }, configurable: !0 });
      });
    }, { wrappy: 79 }], 49: [function(i, s, a) {
      (function(o) {
        (function() {
          o === void 0 || !o.version || o.version.indexOf("v0.") === 0 || o.version.indexOf("v1.") === 0 && o.version.indexOf("v1.8.") !== 0 ? s.exports = { nextTick: function(r, l, n, h) {
            if (typeof r != "function") throw new TypeError('"callback" argument must be a function');
            var c, d, f = arguments.length;
            switch (f) {
              case 0:
              case 1:
                return o.nextTick(r);
              case 2:
                return o.nextTick(function() {
                  r.call(null, l);
                });
              case 3:
                return o.nextTick(function() {
                  r.call(null, l, n);
                });
              case 4:
                return o.nextTick(function() {
                  r.call(null, l, n, h);
                });
              default:
                for (c = new Array(f - 1), d = 0; d < c.length; ) c[d++] = arguments[d];
                return o.nextTick(function() {
                  r.apply(null, c);
                });
            }
          } } : s.exports = o;
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50 }], 50: [function(i, s, a) {
      var o, r, l = s.exports = {};
      function n() {
        throw new Error("setTimeout has not been defined");
      }
      function h() {
        throw new Error("clearTimeout has not been defined");
      }
      function c(p) {
        if (o === setTimeout) return setTimeout(p, 0);
        if ((o === n || !o) && setTimeout) return o = setTimeout, setTimeout(p, 0);
        try {
          return o(p, 0);
        } catch {
          try {
            return o.call(null, p, 0);
          } catch {
            return o.call(this, p, 0);
          }
        }
      }
      (function() {
        try {
          o = typeof setTimeout == "function" ? setTimeout : n;
        } catch {
          o = n;
        }
        try {
          r = typeof clearTimeout == "function" ? clearTimeout : h;
        } catch {
          r = h;
        }
      })();
      var d, f = [], u = !1, g = -1;
      function y() {
        u && d && (u = !1, d.length ? f = d.concat(f) : g = -1, f.length && v());
      }
      function v() {
        if (!u) {
          var p = c(y);
          u = !0;
          for (var k = f.length; k; ) {
            for (d = f, f = []; ++g < k; ) d && d[g].run();
            g = -1, k = f.length;
          }
          d = null, u = !1, function(R) {
            if (r === clearTimeout) return clearTimeout(R);
            if ((r === h || !r) && clearTimeout) return r = clearTimeout, clearTimeout(R);
            try {
              r(R);
            } catch {
              try {
                return r.call(null, R);
              } catch {
                return r.call(this, R);
              }
            }
          }(p);
        }
      }
      function b(p, k) {
        this.fun = p, this.array = k;
      }
      function x() {
      }
      l.nextTick = function(p) {
        var k = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var R = 1; R < arguments.length; R++) k[R - 1] = arguments[R];
        f.push(new b(p, k)), f.length !== 1 || u || c(v);
      }, b.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {}, l.on = x, l.addListener = x, l.once = x, l.off = x, l.removeListener = x, l.removeAllListeners = x, l.emit = x, l.prependListener = x, l.prependOnceListener = x, l.listeners = function(p) {
        return [];
      }, l.binding = function(p) {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function(p) {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    }, {}], 51: [function(i, s, a) {
      (function(o) {
        (function() {
          (function(r) {
            var l = typeof a == "object" && a && !a.nodeType && a, n = typeof s == "object" && s && !s.nodeType && s, h = typeof o == "object" && o;
            h.global !== h && h.window !== h && h.self !== h || (r = h);
            var c, d, f = 2147483647, u = 36, g = 1, y = 26, v = 38, b = 700, x = 72, p = 128, k = "-", R = /^xn--/, A = /[^\x20-\x7E]/, P = /[\x2E\u3002\uFF0E\uFF61]/g, E = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, D = u - g, q = Math.floor, I = String.fromCharCode;
            function S(W) {
              throw new RangeError(E[W]);
            }
            function T(W, N) {
              for (var U = W.length, Y = []; U--; ) Y[U] = N(W[U]);
              return Y;
            }
            function _(W, N) {
              var U = W.split("@"), Y = "";
              return U.length > 1 && (Y = U[0] + "@", W = U[1]), Y + T((W = W.replace(P, ".")).split("."), N).join(".");
            }
            function z(W) {
              for (var N, U, Y = [], $ = 0, Z = W.length; $ < Z; ) (N = W.charCodeAt($++)) >= 55296 && N <= 56319 && $ < Z ? (64512 & (U = W.charCodeAt($++))) == 56320 ? Y.push(((1023 & N) << 10) + (1023 & U) + 65536) : (Y.push(N), $--) : Y.push(N);
              return Y;
            }
            function V(W) {
              return T(W, function(N) {
                var U = "";
                return N > 65535 && (U += I((N -= 65536) >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), U += I(N);
              }).join("");
            }
            function X(W, N) {
              return W + 22 + 75 * (W < 26) - ((N != 0) << 5);
            }
            function H(W, N, U) {
              var Y = 0;
              for (W = U ? q(W / b) : W >> 1, W += q(W / N); W > D * y >> 1; Y += u) W = q(W / D);
              return q(Y + (D + 1) * W / (W + v));
            }
            function M(W) {
              var N, U, Y, $, Z, Q, J, m, w, C, L, F = [], j = W.length, K = 0, te = p, ee = x;
              for ((U = W.lastIndexOf(k)) < 0 && (U = 0), Y = 0; Y < U; ++Y) W.charCodeAt(Y) >= 128 && S("not-basic"), F.push(W.charCodeAt(Y));
              for ($ = U > 0 ? U + 1 : 0; $ < j; ) {
                for (Z = K, Q = 1, J = u; $ >= j && S("invalid-input"), ((m = (L = W.charCodeAt($++)) - 48 < 10 ? L - 22 : L - 65 < 26 ? L - 65 : L - 97 < 26 ? L - 97 : u) >= u || m > q((f - K) / Q)) && S("overflow"), K += m * Q, !(m < (w = J <= ee ? g : J >= ee + y ? y : J - ee)); J += u) Q > q(f / (C = u - w)) && S("overflow"), Q *= C;
                ee = H(K - Z, N = F.length + 1, Z == 0), q(K / N) > f - te && S("overflow"), te += q(K / N), K %= N, F.splice(K++, 0, te);
              }
              return V(F);
            }
            function B(W) {
              var N, U, Y, $, Z, Q, J, m, w, C, L, F, j, K, te, ee = [];
              for (F = (W = z(W)).length, N = p, U = 0, Z = x, Q = 0; Q < F; ++Q) (L = W[Q]) < 128 && ee.push(I(L));
              for (Y = $ = ee.length, $ && ee.push(k); Y < F; ) {
                for (J = f, Q = 0; Q < F; ++Q) (L = W[Q]) >= N && L < J && (J = L);
                for (J - N > q((f - U) / (j = Y + 1)) && S("overflow"), U += (J - N) * j, N = J, Q = 0; Q < F; ++Q) if ((L = W[Q]) < N && ++U > f && S("overflow"), L == N) {
                  for (m = U, w = u; !(m < (C = w <= Z ? g : w >= Z + y ? y : w - Z)); w += u) te = m - C, K = u - C, ee.push(I(X(C + te % K, 0))), m = q(te / K);
                  ee.push(I(X(m, 0))), Z = H(U, j, Y == $), U = 0, ++Y;
                }
                ++U, ++N;
              }
              return ee.join("");
            }
            if (c = { version: "1.4.1", ucs2: { decode: z, encode: V }, decode: M, encode: B, toASCII: function(W) {
              return _(W, function(N) {
                return A.test(N) ? "xn--" + B(N) : N;
              });
            }, toUnicode: function(W) {
              return _(W, function(N) {
                return R.test(N) ? M(N.slice(4).toLowerCase()) : N;
              });
            } }, l && n) if (s.exports == l) n.exports = c;
            else for (d in c) c.hasOwnProperty(d) && (l[d] = c[d]);
            else r.punycode = c;
          })(this);
        }).call(this);
      }).call(this, typeof qe < "u" ? qe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 52: [function(i, s, a) {
      function o(l, n) {
        return Object.prototype.hasOwnProperty.call(l, n);
      }
      s.exports = function(l, n, h, c) {
        n = n || "&", h = h || "=";
        var d = {};
        if (typeof l != "string" || l.length === 0) return d;
        var f = /\+/g;
        l = l.split(n);
        var u = 1e3;
        c && typeof c.maxKeys == "number" && (u = c.maxKeys);
        var g = l.length;
        u > 0 && g > u && (g = u);
        for (var y = 0; y < g; ++y) {
          var v, b, x, p, k = l[y].replace(f, "%20"), R = k.indexOf(h);
          R >= 0 ? (v = k.substr(0, R), b = k.substr(R + 1)) : (v = k, b = ""), x = decodeURIComponent(v), p = decodeURIComponent(b), o(d, x) ? r(d[x]) ? d[x].push(p) : d[x] = [d[x], p] : d[x] = p;
        }
        return d;
      };
      var r = Array.isArray || function(l) {
        return Object.prototype.toString.call(l) === "[object Array]";
      };
    }, {}], 53: [function(i, s, a) {
      var o = function(h) {
        switch (typeof h) {
          case "string":
            return h;
          case "boolean":
            return h ? "true" : "false";
          case "number":
            return isFinite(h) ? h : "";
          default:
            return "";
        }
      };
      s.exports = function(h, c, d, f) {
        return c = c || "&", d = d || "=", h === null && (h = void 0), typeof h == "object" ? l(n(h), function(u) {
          var g = encodeURIComponent(o(u)) + d;
          return r(h[u]) ? l(h[u], function(y) {
            return g + encodeURIComponent(o(y));
          }).join(c) : g + encodeURIComponent(o(h[u]));
        }).join(c) : f ? encodeURIComponent(o(f)) + d + encodeURIComponent(o(h)) : "";
      };
      var r = Array.isArray || function(h) {
        return Object.prototype.toString.call(h) === "[object Array]";
      };
      function l(h, c) {
        if (h.map) return h.map(c);
        for (var d = [], f = 0; f < h.length; f++) d.push(c(h[f], f));
        return d;
      }
      var n = Object.keys || function(h) {
        var c = [];
        for (var d in h) Object.prototype.hasOwnProperty.call(h, d) && c.push(d);
        return c;
      };
    }, {}], 54: [function(i, s, a) {
      a.decode = a.parse = i("./decode"), a.encode = a.stringify = i("./encode");
    }, { "./decode": 52, "./encode": 53 }], 55: [function(i, s, a) {
      var o = {};
      function r(n, h, c) {
        c || (c = Error);
        var d = function(f) {
          var u, g;
          function y(v, b, x) {
            return f.call(this, function(p, k, R) {
              return typeof h == "string" ? h : h(p, k, R);
            }(v, b, x)) || this;
          }
          return g = f, (u = y).prototype = Object.create(g.prototype), u.prototype.constructor = u, u.__proto__ = g, y;
        }(c);
        d.prototype.name = c.name, d.prototype.code = n, o[n] = d;
      }
      function l(n, h) {
        if (Array.isArray(n)) {
          var c = n.length;
          return n = n.map(function(d) {
            return String(d);
          }), c > 2 ? "one of ".concat(h, " ").concat(n.slice(0, c - 1).join(", "), ", or ") + n[c - 1] : c === 2 ? "one of ".concat(h, " ").concat(n[0], " or ").concat(n[1]) : "of ".concat(h, " ").concat(n[0]);
        }
        return "of ".concat(h, " ").concat(String(n));
      }
      r("ERR_INVALID_OPT_VALUE", function(n, h) {
        return 'The value "' + h + '" is invalid for option "' + n + '"';
      }, TypeError), r("ERR_INVALID_ARG_TYPE", function(n, h, c) {
        var d, f, u;
        if (typeof h == "string" && (f = "not ", h.substr(0, f.length) === f) ? (d = "must not be", h = h.replace(/^not /, "")) : d = "must be", function(y, v, b) {
          return (b === void 0 || b > y.length) && (b = y.length), y.substring(b - v.length, b) === v;
        }(n, " argument")) u = "The ".concat(n, " ").concat(d, " ").concat(l(h, "type"));
        else {
          var g = function(y, v, b) {
            return typeof b != "number" && (b = 0), !(b + v.length > y.length) && y.indexOf(v, b) !== -1;
          }(n, ".") ? "property" : "argument";
          u = 'The "'.concat(n, '" ').concat(g, " ").concat(d, " ").concat(l(h, "type"));
        }
        return u += ". Received type ".concat(typeof c);
      }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(n) {
        return "The " + n + " method is not implemented";
      }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(n) {
        return "Cannot call " + n + " after a stream was destroyed";
      }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(n) {
        return "Unknown encoding: " + n;
      }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), s.exports.codes = o;
    }, {}], 56: [function(i, s, a) {
      (function(o) {
        (function() {
          var r = Object.keys || function(y) {
            var v = [];
            for (var b in y) v.push(b);
            return v;
          };
          s.exports = f;
          var l = i("./_stream_readable"), n = i("./_stream_writable");
          i("inherits")(f, l);
          for (var h = r(n.prototype), c = 0; c < h.length; c++) {
            var d = h[c];
            f.prototype[d] || (f.prototype[d] = n.prototype[d]);
          }
          function f(y) {
            if (!(this instanceof f)) return new f(y);
            l.call(this, y), n.call(this, y), this.allowHalfOpen = !0, y && (y.readable === !1 && (this.readable = !1), y.writable === !1 && (this.writable = !1), y.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", u)));
          }
          function u() {
            this._writableState.ended || o.nextTick(g, this);
          }
          function g(y) {
            y.end();
          }
          Object.defineProperty(f.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), Object.defineProperty(f.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(f.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(f.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(y) {
            this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = y, this._writableState.destroyed = y);
          } });
        }).call(this);
      }).call(this, i("_process"));
    }, { "./_stream_readable": 58, "./_stream_writable": 60, _process: 50, inherits: 24 }], 57: [function(i, s, a) {
      s.exports = r;
      var o = i("./_stream_transform");
      function r(l) {
        if (!(this instanceof r)) return new r(l);
        o.call(this, l);
      }
      i("inherits")(r, o), r.prototype._transform = function(l, n, h) {
        h(null, l);
      };
    }, { "./_stream_transform": 59, inherits: 24 }], 58: [function(i, s, a) {
      (function(o, r) {
        (function() {
          var l;
          s.exports = S, S.ReadableState = I, i("events").EventEmitter;
          var n = function(m, w) {
            return m.listeners(w).length;
          }, h = i("./internal/streams/stream"), c = i("buffer").Buffer, d = r.Uint8Array || function() {
          }, f, u = i("util");
          f = u && u.debuglog ? u.debuglog("stream") : function() {
          };
          var g, y, v, b = i("./internal/streams/buffer_list"), x = i("./internal/streams/destroy"), p = i("./internal/streams/state").getHighWaterMark, k = i("../errors").codes, R = k.ERR_INVALID_ARG_TYPE, A = k.ERR_STREAM_PUSH_AFTER_EOF, P = k.ERR_METHOD_NOT_IMPLEMENTED, E = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          i("inherits")(S, h);
          var D = x.errorOrDestroy, q = ["error", "close", "destroy", "pause", "resume"];
          function I(m, w, C) {
            l = l || i("./_stream_duplex"), m = m || {}, typeof C != "boolean" && (C = w instanceof l), this.objectMode = !!m.objectMode, C && (this.objectMode = this.objectMode || !!m.readableObjectMode), this.highWaterMark = p(this, m, "readableHighWaterMark", C), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = m.emitClose !== !1, this.autoDestroy = !!m.autoDestroy, this.destroyed = !1, this.defaultEncoding = m.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, m.encoding && (g || (g = i("string_decoder/").StringDecoder), this.decoder = new g(m.encoding), this.encoding = m.encoding);
          }
          function S(m) {
            if (l = l || i("./_stream_duplex"), !(this instanceof S)) return new S(m);
            var w = this instanceof l;
            this._readableState = new I(m, this, w), this.readable = !0, m && (typeof m.read == "function" && (this._read = m.read), typeof m.destroy == "function" && (this._destroy = m.destroy)), h.call(this);
          }
          function T(m, w, C, L, F) {
            f("readableAddChunk", w);
            var j, K = m._readableState;
            if (w === null) K.reading = !1, function(te, ee) {
              if (f("onEofChunk"), !ee.ended) {
                if (ee.decoder) {
                  var oe = ee.decoder.end();
                  oe && oe.length && (ee.buffer.push(oe), ee.length += ee.objectMode ? 1 : oe.length);
                }
                ee.ended = !0, ee.sync ? X(te) : (ee.needReadable = !1, ee.emittedReadable || (ee.emittedReadable = !0, H(te)));
              }
            }(m, K);
            else if (F || (j = function(te, ee) {
              var oe;
              le = ee, c.isBuffer(le) || le instanceof d || typeof ee == "string" || ee === void 0 || te.objectMode || (oe = new R("chunk", ["string", "Buffer", "Uint8Array"], ee));
              var le;
              return oe;
            }(K, w)), j) D(m, j);
            else if (K.objectMode || w && w.length > 0) if (typeof w == "string" || K.objectMode || Object.getPrototypeOf(w) === c.prototype || (w = function(te) {
              return c.from(te);
            }(w)), L) K.endEmitted ? D(m, new E()) : _(m, K, w, !0);
            else if (K.ended) D(m, new A());
            else {
              if (K.destroyed) return !1;
              K.reading = !1, K.decoder && !C ? (w = K.decoder.write(w), K.objectMode || w.length !== 0 ? _(m, K, w, !1) : M(m, K)) : _(m, K, w, !1);
            }
            else L || (K.reading = !1, M(m, K));
            return !K.ended && (K.length < K.highWaterMark || K.length === 0);
          }
          function _(m, w, C, L) {
            w.flowing && w.length === 0 && !w.sync ? (w.awaitDrain = 0, m.emit("data", C)) : (w.length += w.objectMode ? 1 : C.length, L ? w.buffer.unshift(C) : w.buffer.push(C), w.needReadable && X(m)), M(m, w);
          }
          Object.defineProperty(S.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._readableState.destroyed;
          }, set: function(m) {
            this._readableState && (this._readableState.destroyed = m);
          } }), S.prototype.destroy = x.destroy, S.prototype._undestroy = x.undestroy, S.prototype._destroy = function(m, w) {
            w(m);
          }, S.prototype.push = function(m, w) {
            var C, L = this._readableState;
            return L.objectMode ? C = !0 : typeof m == "string" && ((w = w || L.defaultEncoding) !== L.encoding && (m = c.from(m, w), w = ""), C = !0), T(this, m, w, !1, C);
          }, S.prototype.unshift = function(m) {
            return T(this, m, null, !0, !1);
          }, S.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, S.prototype.setEncoding = function(m) {
            g || (g = i("string_decoder/").StringDecoder);
            var w = new g(m);
            this._readableState.decoder = w, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var C = this._readableState.buffer.head, L = ""; C !== null; ) L += w.write(C.data), C = C.next;
            return this._readableState.buffer.clear(), L !== "" && this._readableState.buffer.push(L), this._readableState.length = L.length, this;
          };
          var z = 1073741824;
          function V(m, w) {
            return m <= 0 || w.length === 0 && w.ended ? 0 : w.objectMode ? 1 : m != m ? w.flowing && w.length ? w.buffer.head.data.length : w.length : (m > w.highWaterMark && (w.highWaterMark = function(C) {
              return C >= z ? C = z : (C--, C |= C >>> 1, C |= C >>> 2, C |= C >>> 4, C |= C >>> 8, C |= C >>> 16, C++), C;
            }(m)), m <= w.length ? m : w.ended ? w.length : (w.needReadable = !0, 0));
          }
          function X(m) {
            var w = m._readableState;
            f("emitReadable", w.needReadable, w.emittedReadable), w.needReadable = !1, w.emittedReadable || (f("emitReadable", w.flowing), w.emittedReadable = !0, o.nextTick(H, m));
          }
          function H(m) {
            var w = m._readableState;
            f("emitReadable_", w.destroyed, w.length, w.ended), w.destroyed || !w.length && !w.ended || (m.emit("readable"), w.emittedReadable = !1), w.needReadable = !w.flowing && !w.ended && w.length <= w.highWaterMark, Y(m);
          }
          function M(m, w) {
            w.readingMore || (w.readingMore = !0, o.nextTick(B, m, w));
          }
          function B(m, w) {
            for (; !w.reading && !w.ended && (w.length < w.highWaterMark || w.flowing && w.length === 0); ) {
              var C = w.length;
              if (f("maybeReadMore read 0"), m.read(0), C === w.length) break;
            }
            w.readingMore = !1;
          }
          function W(m) {
            var w = m._readableState;
            w.readableListening = m.listenerCount("readable") > 0, w.resumeScheduled && !w.paused ? w.flowing = !0 : m.listenerCount("data") > 0 && m.resume();
          }
          function N(m) {
            f("readable nexttick read 0"), m.read(0);
          }
          function U(m, w) {
            f("resume", w.reading), w.reading || m.read(0), w.resumeScheduled = !1, m.emit("resume"), Y(m), w.flowing && !w.reading && m.read(0);
          }
          function Y(m) {
            var w = m._readableState;
            for (f("flow", w.flowing); w.flowing && m.read() !== null; ) ;
          }
          function $(m, w) {
            return w.length === 0 ? null : (w.objectMode ? C = w.buffer.shift() : !m || m >= w.length ? (C = w.decoder ? w.buffer.join("") : w.buffer.length === 1 ? w.buffer.first() : w.buffer.concat(w.length), w.buffer.clear()) : C = w.buffer.consume(m, w.decoder), C);
            var C;
          }
          function Z(m) {
            var w = m._readableState;
            f("endReadable", w.endEmitted), w.endEmitted || (w.ended = !0, o.nextTick(Q, w, m));
          }
          function Q(m, w) {
            if (f("endReadableNT", m.endEmitted, m.length), !m.endEmitted && m.length === 0 && (m.endEmitted = !0, w.readable = !1, w.emit("end"), m.autoDestroy)) {
              var C = w._writableState;
              (!C || C.autoDestroy && C.finished) && w.destroy();
            }
          }
          function J(m, w) {
            for (var C = 0, L = m.length; C < L; C++) if (m[C] === w) return C;
            return -1;
          }
          S.prototype.read = function(m) {
            f("read", m), m = parseInt(m, 10);
            var w = this._readableState, C = m;
            if (m !== 0 && (w.emittedReadable = !1), m === 0 && w.needReadable && ((w.highWaterMark !== 0 ? w.length >= w.highWaterMark : w.length > 0) || w.ended)) return f("read: emitReadable", w.length, w.ended), w.length === 0 && w.ended ? Z(this) : X(this), null;
            if ((m = V(m, w)) === 0 && w.ended) return w.length === 0 && Z(this), null;
            var L, F = w.needReadable;
            return f("need readable", F), (w.length === 0 || w.length - m < w.highWaterMark) && f("length less than watermark", F = !0), w.ended || w.reading ? f("reading or ended", F = !1) : F && (f("do read"), w.reading = !0, w.sync = !0, w.length === 0 && (w.needReadable = !0), this._read(w.highWaterMark), w.sync = !1, w.reading || (m = V(C, w))), (L = m > 0 ? $(m, w) : null) === null ? (w.needReadable = w.length <= w.highWaterMark, m = 0) : (w.length -= m, w.awaitDrain = 0), w.length === 0 && (w.ended || (w.needReadable = !0), C !== m && w.ended && Z(this)), L !== null && this.emit("data", L), L;
          }, S.prototype._read = function(m) {
            D(this, new P("_read()"));
          }, S.prototype.pipe = function(m, w) {
            var C = this, L = this._readableState;
            switch (L.pipesCount) {
              case 0:
                L.pipes = m;
                break;
              case 1:
                L.pipes = [L.pipes, m];
                break;
              default:
                L.pipes.push(m);
            }
            L.pipesCount += 1, f("pipe count=%d opts=%j", L.pipesCount, w);
            var F = (!w || w.end !== !1) && m !== o.stdout && m !== o.stderr ? K : We;
            function j(me, be) {
              f("onunpipe"), me === C && be && be.hasUnpiped === !1 && (be.hasUnpiped = !0, f("cleanup"), m.removeListener("close", Fe), m.removeListener("finish", Be), m.removeListener("drain", te), m.removeListener("error", le), m.removeListener("unpipe", j), C.removeListener("end", K), C.removeListener("end", We), C.removeListener("data", oe), ee = !0, !L.awaitDrain || m._writableState && !m._writableState.needDrain || te());
            }
            function K() {
              f("onend"), m.end();
            }
            L.endEmitted ? o.nextTick(F) : C.once("end", F), m.on("unpipe", j);
            var te = /* @__PURE__ */ function(me) {
              return function() {
                var be = me._readableState;
                f("pipeOnDrain", be.awaitDrain), be.awaitDrain && be.awaitDrain--, be.awaitDrain === 0 && n(me, "data") && (be.flowing = !0, Y(me));
              };
            }(C);
            m.on("drain", te);
            var ee = !1;
            function oe(me) {
              f("ondata");
              var be = m.write(me);
              f("dest.write", be), be === !1 && ((L.pipesCount === 1 && L.pipes === m || L.pipesCount > 1 && J(L.pipes, m) !== -1) && !ee && (f("false write response, pause", L.awaitDrain), L.awaitDrain++), C.pause());
            }
            function le(me) {
              f("onerror", me), We(), m.removeListener("error", le), n(m, "error") === 0 && D(m, me);
            }
            function Fe() {
              m.removeListener("finish", Be), We();
            }
            function Be() {
              f("onfinish"), m.removeListener("close", Fe), We();
            }
            function We() {
              f("unpipe"), C.unpipe(m);
            }
            return C.on("data", oe), function(me, be, hi) {
              if (typeof me.prependListener == "function") return me.prependListener(be, hi);
              me._events && me._events[be] ? Array.isArray(me._events[be]) ? me._events[be].unshift(hi) : me._events[be] = [hi, me._events[be]] : me.on(be, hi);
            }(m, "error", le), m.once("close", Fe), m.once("finish", Be), m.emit("pipe", C), L.flowing || (f("pipe resume"), C.resume()), m;
          }, S.prototype.unpipe = function(m) {
            var w = this._readableState, C = { hasUnpiped: !1 };
            if (w.pipesCount === 0) return this;
            if (w.pipesCount === 1) return m && m !== w.pipes ? this : (m || (m = w.pipes), w.pipes = null, w.pipesCount = 0, w.flowing = !1, m && m.emit("unpipe", this, C), this);
            if (!m) {
              var L = w.pipes, F = w.pipesCount;
              w.pipes = null, w.pipesCount = 0, w.flowing = !1;
              for (var j = 0; j < F; j++) L[j].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var K = J(w.pipes, m);
            return K === -1 ? this : (w.pipes.splice(K, 1), w.pipesCount -= 1, w.pipesCount === 1 && (w.pipes = w.pipes[0]), m.emit("unpipe", this, C), this);
          }, S.prototype.on = function(m, w) {
            var C = h.prototype.on.call(this, m, w), L = this._readableState;
            return m === "data" ? (L.readableListening = this.listenerCount("readable") > 0, L.flowing !== !1 && this.resume()) : m === "readable" && (L.endEmitted || L.readableListening || (L.readableListening = L.needReadable = !0, L.flowing = !1, L.emittedReadable = !1, f("on readable", L.length, L.reading), L.length ? X(this) : L.reading || o.nextTick(N, this))), C;
          }, S.prototype.addListener = S.prototype.on, S.prototype.removeListener = function(m, w) {
            var C = h.prototype.removeListener.call(this, m, w);
            return m === "readable" && o.nextTick(W, this), C;
          }, S.prototype.removeAllListeners = function(m) {
            var w = h.prototype.removeAllListeners.apply(this, arguments);
            return m !== "readable" && m !== void 0 || o.nextTick(W, this), w;
          }, S.prototype.resume = function() {
            var m = this._readableState;
            return m.flowing || (f("resume"), m.flowing = !m.readableListening, function(w, C) {
              C.resumeScheduled || (C.resumeScheduled = !0, o.nextTick(U, w, C));
            }(this, m)), m.paused = !1, this;
          }, S.prototype.pause = function() {
            return f("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (f("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, S.prototype.wrap = function(m) {
            var w = this, C = this._readableState, L = !1;
            for (var F in m.on("end", function() {
              if (f("wrapped end"), C.decoder && !C.ended) {
                var K = C.decoder.end();
                K && K.length && w.push(K);
              }
              w.push(null);
            }), m.on("data", function(K) {
              f("wrapped data"), C.decoder && (K = C.decoder.write(K)), (!C.objectMode || K != null) && (C.objectMode || K && K.length) && (w.push(K) || (L = !0, m.pause()));
            }), m) this[F] === void 0 && typeof m[F] == "function" && (this[F] = /* @__PURE__ */ function(K) {
              return function() {
                return m[K].apply(m, arguments);
              };
            }(F));
            for (var j = 0; j < q.length; j++) m.on(q[j], this.emit.bind(this, q[j]));
            return this._read = function(K) {
              f("wrapped _read", K), L && (L = !1, m.resume());
            }, this;
          }, typeof Symbol == "function" && (S.prototype[Symbol.asyncIterator] = function() {
            return y === void 0 && (y = i("./internal/streams/async_iterator")), y(this);
          }), Object.defineProperty(S.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
            return this._readableState.highWaterMark;
          } }), Object.defineProperty(S.prototype, "readableBuffer", { enumerable: !1, get: function() {
            return this._readableState && this._readableState.buffer;
          } }), Object.defineProperty(S.prototype, "readableFlowing", { enumerable: !1, get: function() {
            return this._readableState.flowing;
          }, set: function(m) {
            this._readableState && (this._readableState.flowing = m);
          } }), S._fromList = $, Object.defineProperty(S.prototype, "readableLength", { enumerable: !1, get: function() {
            return this._readableState.length;
          } }), typeof Symbol == "function" && (S.from = function(m, w) {
            return v === void 0 && (v = i("./internal/streams/from")), v(S, m, w);
          });
        }).call(this);
      }).call(this, i("_process"), typeof qe < "u" ? qe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/async_iterator": 61, "./internal/streams/buffer_list": 62, "./internal/streams/destroy": 63, "./internal/streams/from": 65, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, events: 22, inherits: 24, "string_decoder/": 75, util: 16 }], 59: [function(i, s, a) {
      s.exports = d;
      var o = i("../errors").codes, r = o.ERR_METHOD_NOT_IMPLEMENTED, l = o.ERR_MULTIPLE_CALLBACK, n = o.ERR_TRANSFORM_ALREADY_TRANSFORMING, h = o.ERR_TRANSFORM_WITH_LENGTH_0, c = i("./_stream_duplex");
      function d(g) {
        if (!(this instanceof d)) return new d(g);
        c.call(this, g), this._transformState = { afterTransform: (function(y, v) {
          var b = this._transformState;
          b.transforming = !1;
          var x = b.writecb;
          if (x === null) return this.emit("error", new l());
          b.writechunk = null, b.writecb = null, v != null && this.push(v), x(y);
          var p = this._readableState;
          p.reading = !1, (p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
        }).bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, g && (typeof g.transform == "function" && (this._transform = g.transform), typeof g.flush == "function" && (this._flush = g.flush)), this.on("prefinish", f);
      }
      function f() {
        var g = this;
        typeof this._flush != "function" || this._readableState.destroyed ? u(this, null, null) : this._flush(function(y, v) {
          u(g, y, v);
        });
      }
      function u(g, y, v) {
        if (y) return g.emit("error", y);
        if (v != null && g.push(v), g._writableState.length) throw new h();
        if (g._transformState.transforming) throw new n();
        return g.push(null);
      }
      i("inherits")(d, c), d.prototype.push = function(g, y) {
        return this._transformState.needTransform = !1, c.prototype.push.call(this, g, y);
      }, d.prototype._transform = function(g, y, v) {
        v(new r("_transform()"));
      }, d.prototype._write = function(g, y, v) {
        var b = this._transformState;
        if (b.writecb = v, b.writechunk = g, b.writeencoding = y, !b.transforming) {
          var x = this._readableState;
          (b.needTransform || x.needReadable || x.length < x.highWaterMark) && this._read(x.highWaterMark);
        }
      }, d.prototype._read = function(g) {
        var y = this._transformState;
        y.writechunk === null || y.transforming ? y.needTransform = !0 : (y.transforming = !0, this._transform(y.writechunk, y.writeencoding, y.afterTransform));
      }, d.prototype._destroy = function(g, y) {
        c.prototype._destroy.call(this, g, function(v) {
          y(v);
        });
      };
    }, { "../errors": 55, "./_stream_duplex": 56, inherits: 24 }], 60: [function(i, s, a) {
      (function(o, r) {
        (function() {
          function l(M) {
            var B = this;
            this.next = null, this.entry = null, this.finish = function() {
              (function(W, N, U) {
                var Y = W.entry;
                for (W.entry = null; Y; ) {
                  var $ = Y.callback;
                  N.pendingcb--, $(U), Y = Y.next;
                }
                N.corkedRequestsFree.next = W;
              })(B, M);
            };
          }
          var n;
          s.exports = S, S.WritableState = I;
          var h = { deprecate: i("util-deprecate") }, c = i("./internal/streams/stream"), d = i("buffer").Buffer, f = r.Uint8Array || function() {
          }, u, g = i("./internal/streams/destroy"), y = i("./internal/streams/state").getHighWaterMark, v = i("../errors").codes, b = v.ERR_INVALID_ARG_TYPE, x = v.ERR_METHOD_NOT_IMPLEMENTED, p = v.ERR_MULTIPLE_CALLBACK, k = v.ERR_STREAM_CANNOT_PIPE, R = v.ERR_STREAM_DESTROYED, A = v.ERR_STREAM_NULL_VALUES, P = v.ERR_STREAM_WRITE_AFTER_END, E = v.ERR_UNKNOWN_ENCODING, D = g.errorOrDestroy;
          function q() {
          }
          function I(M, B, W) {
            n = n || i("./_stream_duplex"), M = M || {}, typeof W != "boolean" && (W = B instanceof n), this.objectMode = !!M.objectMode, W && (this.objectMode = this.objectMode || !!M.writableObjectMode), this.highWaterMark = y(this, M, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var N = M.decodeStrings === !1;
            this.decodeStrings = !N, this.defaultEncoding = M.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(U) {
              (function(Y, $) {
                var Z = Y._writableState, Q = Z.sync, J = Z.writecb;
                if (typeof J != "function") throw new p();
                if (function(w) {
                  w.writing = !1, w.writecb = null, w.length -= w.writelen, w.writelen = 0;
                }(Z), $) (function(w, C, L, F, j) {
                  --C.pendingcb, L ? (o.nextTick(j, F), o.nextTick(H, w, C), w._writableState.errorEmitted = !0, D(w, F)) : (j(F), w._writableState.errorEmitted = !0, D(w, F), H(w, C));
                })(Y, Z, Q, $, J);
                else {
                  var m = V(Z) || Y.destroyed;
                  m || Z.corked || Z.bufferProcessing || !Z.bufferedRequest || z(Y, Z), Q ? o.nextTick(_, Y, Z, m, J) : _(Y, Z, m, J);
                }
              })(B, U);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = M.emitClose !== !1, this.autoDestroy = !!M.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new l(this);
          }
          function S(M) {
            var B = this instanceof (n = n || i("./_stream_duplex"));
            if (!B && !u.call(S, this)) return new S(M);
            this._writableState = new I(M, this, B), this.writable = !0, M && (typeof M.write == "function" && (this._write = M.write), typeof M.writev == "function" && (this._writev = M.writev), typeof M.destroy == "function" && (this._destroy = M.destroy), typeof M.final == "function" && (this._final = M.final)), c.call(this);
          }
          function T(M, B, W, N, U, Y, $) {
            B.writelen = N, B.writecb = $, B.writing = !0, B.sync = !0, B.destroyed ? B.onwrite(new R("write")) : W ? M._writev(U, B.onwrite) : M._write(U, Y, B.onwrite), B.sync = !1;
          }
          function _(M, B, W, N) {
            W || function(U, Y) {
              Y.length === 0 && Y.needDrain && (Y.needDrain = !1, U.emit("drain"));
            }(M, B), B.pendingcb--, N(), H(M, B);
          }
          function z(M, B) {
            B.bufferProcessing = !0;
            var W = B.bufferedRequest;
            if (M._writev && W && W.next) {
              var N = B.bufferedRequestCount, U = new Array(N), Y = B.corkedRequestsFree;
              Y.entry = W;
              for (var $ = 0, Z = !0; W; ) U[$] = W, W.isBuf || (Z = !1), W = W.next, $ += 1;
              U.allBuffers = Z, T(M, B, !0, B.length, U, "", Y.finish), B.pendingcb++, B.lastBufferedRequest = null, Y.next ? (B.corkedRequestsFree = Y.next, Y.next = null) : B.corkedRequestsFree = new l(B), B.bufferedRequestCount = 0;
            } else {
              for (; W; ) {
                var Q = W.chunk, J = W.encoding, m = W.callback;
                if (T(M, B, !1, B.objectMode ? 1 : Q.length, Q, J, m), W = W.next, B.bufferedRequestCount--, B.writing) break;
              }
              W === null && (B.lastBufferedRequest = null);
            }
            B.bufferedRequest = W, B.bufferProcessing = !1;
          }
          function V(M) {
            return M.ending && M.length === 0 && M.bufferedRequest === null && !M.finished && !M.writing;
          }
          function X(M, B) {
            M._final(function(W) {
              B.pendingcb--, W && D(M, W), B.prefinished = !0, M.emit("prefinish"), H(M, B);
            });
          }
          function H(M, B) {
            var W = V(B);
            if (W && (function(U, Y) {
              Y.prefinished || Y.finalCalled || (typeof U._final != "function" || Y.destroyed ? (Y.prefinished = !0, U.emit("prefinish")) : (Y.pendingcb++, Y.finalCalled = !0, o.nextTick(X, U, Y)));
            }(M, B), B.pendingcb === 0 && (B.finished = !0, M.emit("finish"), B.autoDestroy))) {
              var N = M._readableState;
              (!N || N.autoDestroy && N.endEmitted) && M.destroy();
            }
            return W;
          }
          i("inherits")(S, c), I.prototype.getBuffer = function() {
            for (var M = this.bufferedRequest, B = []; M; ) B.push(M), M = M.next;
            return B;
          }, function() {
            try {
              Object.defineProperty(I.prototype, "buffer", { get: h.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch {
            }
          }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (u = Function.prototype[Symbol.hasInstance], Object.defineProperty(S, Symbol.hasInstance, { value: function(M) {
            return !!u.call(this, M) || this === S && M && M._writableState instanceof I;
          } })) : u = function(M) {
            return M instanceof this;
          }, S.prototype.pipe = function() {
            D(this, new k());
          }, S.prototype.write = function(M, B, W) {
            var N, U = this._writableState, Y = !1, $ = !U.objectMode && (N = M, d.isBuffer(N) || N instanceof f);
            return $ && !d.isBuffer(M) && (M = function(Z) {
              return d.from(Z);
            }(M)), typeof B == "function" && (W = B, B = null), $ ? B = "buffer" : B || (B = U.defaultEncoding), typeof W != "function" && (W = q), U.ending ? function(Z, Q) {
              var J = new P();
              D(Z, J), o.nextTick(Q, J);
            }(this, W) : ($ || function(Z, Q, J, m) {
              var w;
              return J === null ? w = new A() : typeof J == "string" || Q.objectMode || (w = new b("chunk", ["string", "Buffer"], J)), !w || (D(Z, w), o.nextTick(m, w), !1);
            }(this, U, M, W)) && (U.pendingcb++, Y = function(Z, Q, J, m, w, C) {
              if (!J) {
                var L = function(te, ee, oe) {
                  return te.objectMode || te.decodeStrings === !1 || typeof ee != "string" || (ee = d.from(ee, oe)), ee;
                }(Q, m, w);
                m !== L && (J = !0, w = "buffer", m = L);
              }
              var F = Q.objectMode ? 1 : m.length;
              Q.length += F;
              var j = Q.length < Q.highWaterMark;
              if (j || (Q.needDrain = !0), Q.writing || Q.corked) {
                var K = Q.lastBufferedRequest;
                Q.lastBufferedRequest = { chunk: m, encoding: w, isBuf: J, callback: C, next: null }, K ? K.next = Q.lastBufferedRequest : Q.bufferedRequest = Q.lastBufferedRequest, Q.bufferedRequestCount += 1;
              } else T(Z, Q, !1, F, m, w, C);
              return j;
            }(this, U, $, M, B, W)), Y;
          }, S.prototype.cork = function() {
            this._writableState.corked++;
          }, S.prototype.uncork = function() {
            var M = this._writableState;
            M.corked && (M.corked--, M.writing || M.corked || M.bufferProcessing || !M.bufferedRequest || z(this, M));
          }, S.prototype.setDefaultEncoding = function(M) {
            if (typeof M == "string" && (M = M.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((M + "").toLowerCase()) > -1)) throw new E(M);
            return this._writableState.defaultEncoding = M, this;
          }, Object.defineProperty(S.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(S.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), S.prototype._write = function(M, B, W) {
            W(new x("_write()"));
          }, S.prototype._writev = null, S.prototype.end = function(M, B, W) {
            var N = this._writableState;
            return typeof M == "function" ? (W = M, M = null, B = null) : typeof B == "function" && (W = B, B = null), M != null && this.write(M, B), N.corked && (N.corked = 1, this.uncork()), N.ending || function(U, Y, $) {
              Y.ending = !0, H(U, Y), $ && (Y.finished ? o.nextTick($) : U.once("finish", $)), Y.ended = !0, U.writable = !1;
            }(this, N, W), this;
          }, Object.defineProperty(S.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(S.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._writableState !== void 0 && this._writableState.destroyed;
          }, set: function(M) {
            this._writableState && (this._writableState.destroyed = M);
          } }), S.prototype.destroy = g.destroy, S.prototype._undestroy = g.undestroy, S.prototype._destroy = function(M, B) {
            B(M);
          };
        }).call(this);
      }).call(this, i("_process"), typeof qe < "u" ? qe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/destroy": 63, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, inherits: 24, "util-deprecate": 78 }], 61: [function(i, s, a) {
      (function(o) {
        (function() {
          var r;
          function l(k, R, A) {
            return R in k ? Object.defineProperty(k, R, { value: A, enumerable: !0, configurable: !0, writable: !0 }) : k[R] = A, k;
          }
          var n = i("./end-of-stream"), h = Symbol("lastResolve"), c = Symbol("lastReject"), d = Symbol("error"), f = Symbol("ended"), u = Symbol("lastPromise"), g = Symbol("handlePromise"), y = Symbol("stream");
          function v(k, R) {
            return { value: k, done: R };
          }
          function b(k) {
            var R = k[h];
            if (R !== null) {
              var A = k[y].read();
              A !== null && (k[u] = null, k[h] = null, k[c] = null, R(v(A, !1)));
            }
          }
          var x = Object.getPrototypeOf(function() {
          }), p = Object.setPrototypeOf((l(r = { get stream() {
            return this[y];
          }, next: function() {
            var k = this, R = this[d];
            if (R !== null) return Promise.reject(R);
            if (this[f]) return Promise.resolve(v(void 0, !0));
            if (this[y].destroyed) return new Promise(function(D, q) {
              o.nextTick(function() {
                k[d] ? q(k[d]) : D(v(void 0, !0));
              });
            });
            var A, P = this[u];
            if (P) A = new Promise(/* @__PURE__ */ function(D, q) {
              return function(I, S) {
                D.then(function() {
                  q[f] ? I(v(void 0, !0)) : q[g](I, S);
                }, S);
              };
            }(P, this));
            else {
              var E = this[y].read();
              if (E !== null) return Promise.resolve(v(E, !1));
              A = new Promise(this[g]);
            }
            return this[u] = A, A;
          } }, Symbol.asyncIterator, function() {
            return this;
          }), l(r, "return", function() {
            var k = this;
            return new Promise(function(R, A) {
              k[y].destroy(null, function(P) {
                P ? A(P) : R(v(void 0, !0));
              });
            });
          }), r), x);
          s.exports = function(k) {
            var R, A = Object.create(p, (l(R = {}, y, { value: k, writable: !0 }), l(R, h, { value: null, writable: !0 }), l(R, c, { value: null, writable: !0 }), l(R, d, { value: null, writable: !0 }), l(R, f, { value: k._readableState.endEmitted, writable: !0 }), l(R, g, { value: function(P, E) {
              var D = A[y].read();
              D ? (A[u] = null, A[h] = null, A[c] = null, P(v(D, !1))) : (A[h] = P, A[c] = E);
            }, writable: !0 }), R));
            return A[u] = null, n(k, function(P) {
              if (P && P.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var E = A[c];
                return E !== null && (A[u] = null, A[h] = null, A[c] = null, E(P)), void (A[d] = P);
              }
              var D = A[h];
              D !== null && (A[u] = null, A[h] = null, A[c] = null, D(v(void 0, !0))), A[f] = !0;
            }), k.on("readable", (function(P) {
              o.nextTick(b, P);
            }).bind(null, A)), A;
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { "./end-of-stream": 64, _process: 50 }], 62: [function(i, s, a) {
      function o(d, f) {
        var u = Object.keys(d);
        if (Object.getOwnPropertySymbols) {
          var g = Object.getOwnPropertySymbols(d);
          f && (g = g.filter(function(y) {
            return Object.getOwnPropertyDescriptor(d, y).enumerable;
          })), u.push.apply(u, g);
        }
        return u;
      }
      function r(d, f, u) {
        return f in d ? Object.defineProperty(d, f, { value: u, enumerable: !0, configurable: !0, writable: !0 }) : d[f] = u, d;
      }
      function l(d, f) {
        for (var u = 0; u < f.length; u++) {
          var g = f[u];
          g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(d, g.key, g);
        }
      }
      var n = i("buffer").Buffer, h = i("util").inspect, c = h && h.custom || "inspect";
      s.exports = function() {
        function d() {
          (function(g, y) {
            if (!(g instanceof y)) throw new TypeError("Cannot call a class as a function");
          })(this, d), this.head = null, this.tail = null, this.length = 0;
        }
        var f, u;
        return f = d, (u = [{ key: "push", value: function(g) {
          var y = { data: g, next: null };
          this.length > 0 ? this.tail.next = y : this.head = y, this.tail = y, ++this.length;
        } }, { key: "unshift", value: function(g) {
          var y = { data: g, next: this.head };
          this.length === 0 && (this.tail = y), this.head = y, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var g = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, g;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(g) {
          if (this.length === 0) return "";
          for (var y = this.head, v = "" + y.data; y = y.next; ) v += g + y.data;
          return v;
        } }, { key: "concat", value: function(g) {
          if (this.length === 0) return n.alloc(0);
          for (var y, v, b, x = n.allocUnsafe(g >>> 0), p = this.head, k = 0; p; ) y = p.data, v = x, b = k, n.prototype.copy.call(y, v, b), k += p.data.length, p = p.next;
          return x;
        } }, { key: "consume", value: function(g, y) {
          var v;
          return g < this.head.data.length ? (v = this.head.data.slice(0, g), this.head.data = this.head.data.slice(g)) : v = g === this.head.data.length ? this.shift() : y ? this._getString(g) : this._getBuffer(g), v;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(g) {
          var y = this.head, v = 1, b = y.data;
          for (g -= b.length; y = y.next; ) {
            var x = y.data, p = g > x.length ? x.length : g;
            if (p === x.length ? b += x : b += x.slice(0, g), (g -= p) === 0) {
              p === x.length ? (++v, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = x.slice(p));
              break;
            }
            ++v;
          }
          return this.length -= v, b;
        } }, { key: "_getBuffer", value: function(g) {
          var y = n.allocUnsafe(g), v = this.head, b = 1;
          for (v.data.copy(y), g -= v.data.length; v = v.next; ) {
            var x = v.data, p = g > x.length ? x.length : g;
            if (x.copy(y, y.length - g, 0, p), (g -= p) === 0) {
              p === x.length ? (++b, v.next ? this.head = v.next : this.head = this.tail = null) : (this.head = v, v.data = x.slice(p));
              break;
            }
            ++b;
          }
          return this.length -= b, y;
        } }, { key: c, value: function(g, y) {
          return h(this, function(v) {
            for (var b = 1; b < arguments.length; b++) {
              var x = arguments[b] != null ? arguments[b] : {};
              b % 2 ? o(Object(x), !0).forEach(function(p) {
                r(v, p, x[p]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(x)) : o(Object(x)).forEach(function(p) {
                Object.defineProperty(v, p, Object.getOwnPropertyDescriptor(x, p));
              });
            }
            return v;
          }({}, y, { depth: 0, customInspect: !1 }));
        } }]) && l(f.prototype, u), d;
      }();
    }, { buffer: 17, util: 16 }], 63: [function(i, s, a) {
      (function(o) {
        (function() {
          function r(h, c) {
            n(h, c), l(h);
          }
          function l(h) {
            h._writableState && !h._writableState.emitClose || h._readableState && !h._readableState.emitClose || h.emit("close");
          }
          function n(h, c) {
            h.emit("error", c);
          }
          s.exports = { destroy: function(h, c) {
            var d = this, f = this._readableState && this._readableState.destroyed, u = this._writableState && this._writableState.destroyed;
            return f || u ? (c ? c(h) : h && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, o.nextTick(n, this, h)) : o.nextTick(n, this, h)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(h || null, function(g) {
              !c && g ? d._writableState ? d._writableState.errorEmitted ? o.nextTick(l, d) : (d._writableState.errorEmitted = !0, o.nextTick(r, d, g)) : o.nextTick(r, d, g) : c ? (o.nextTick(l, d), c(g)) : o.nextTick(l, d);
            }), this);
          }, undestroy: function() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }, errorOrDestroy: function(h, c) {
            var d = h._readableState, f = h._writableState;
            d && d.autoDestroy || f && f.autoDestroy ? h.destroy(c) : h.emit("error", c);
          } };
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50 }], 64: [function(i, s, a) {
      var o = i("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function r() {
      }
      s.exports = function l(n, h, c) {
        if (typeof h == "function") return l(n, null, h);
        h || (h = {}), c = /* @__PURE__ */ function(R) {
          var A = !1;
          return function() {
            if (!A) {
              A = !0;
              for (var P = arguments.length, E = new Array(P), D = 0; D < P; D++) E[D] = arguments[D];
              R.apply(this, E);
            }
          };
        }(c || r);
        var d = h.readable || h.readable !== !1 && n.readable, f = h.writable || h.writable !== !1 && n.writable, u = function() {
          n.writable || y();
        }, g = n._writableState && n._writableState.finished, y = function() {
          f = !1, g = !0, d || c.call(n);
        }, v = n._readableState && n._readableState.endEmitted, b = function() {
          d = !1, v = !0, f || c.call(n);
        }, x = function(R) {
          c.call(n, R);
        }, p = function() {
          var R;
          return d && !v ? (n._readableState && n._readableState.ended || (R = new o()), c.call(n, R)) : f && !g ? (n._writableState && n._writableState.ended || (R = new o()), c.call(n, R)) : void 0;
        }, k = function() {
          n.req.on("finish", y);
        };
        return function(R) {
          return R.setHeader && typeof R.abort == "function";
        }(n) ? (n.on("complete", y), n.on("abort", p), n.req ? k() : n.on("request", k)) : f && !n._writableState && (n.on("end", u), n.on("close", u)), n.on("end", b), n.on("finish", y), h.error !== !1 && n.on("error", x), n.on("close", p), function() {
          n.removeListener("complete", y), n.removeListener("abort", p), n.removeListener("request", k), n.req && n.req.removeListener("finish", y), n.removeListener("end", u), n.removeListener("close", u), n.removeListener("finish", y), n.removeListener("end", b), n.removeListener("error", x), n.removeListener("close", p);
        };
      };
    }, { "../../../errors": 55 }], 65: [function(i, s, a) {
      s.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 66: [function(i, s, a) {
      var o, r = i("../../../errors").codes, l = r.ERR_MISSING_ARGS, n = r.ERR_STREAM_DESTROYED;
      function h(f) {
        if (f) throw f;
      }
      function c(f) {
        f();
      }
      function d(f, u) {
        return f.pipe(u);
      }
      s.exports = function() {
        for (var f = arguments.length, u = new Array(f), g = 0; g < f; g++) u[g] = arguments[g];
        var y, v = function(x) {
          return x.length ? typeof x[x.length - 1] != "function" ? h : x.pop() : h;
        }(u);
        if (Array.isArray(u[0]) && (u = u[0]), u.length < 2) throw new l("streams");
        var b = u.map(function(x, p) {
          var k = p < u.length - 1;
          return function(R, A, P, E) {
            E = /* @__PURE__ */ function(I) {
              var S = !1;
              return function() {
                S || (S = !0, I.apply(void 0, arguments));
              };
            }(E);
            var D = !1;
            R.on("close", function() {
              D = !0;
            }), o === void 0 && (o = i("./end-of-stream")), o(R, { readable: A, writable: P }, function(I) {
              if (I) return E(I);
              D = !0, E();
            });
            var q = !1;
            return function(I) {
              if (!D && !q) return q = !0, function(S) {
                return S.setHeader && typeof S.abort == "function";
              }(R) ? R.abort() : typeof R.destroy == "function" ? R.destroy() : void E(I || new n("pipe"));
            };
          }(x, k, p > 0, function(R) {
            y || (y = R), R && b.forEach(c), k || (b.forEach(c), v(y));
          });
        });
        return u.reduce(d);
      };
    }, { "../../../errors": 55, "./end-of-stream": 64 }], 67: [function(i, s, a) {
      var o = i("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      s.exports = { getHighWaterMark: function(r, l, n, h) {
        var c = function(d, f, u) {
          return d.highWaterMark != null ? d.highWaterMark : f ? d[u] : null;
        }(l, h, n);
        if (c != null) {
          if (!isFinite(c) || Math.floor(c) !== c || c < 0) throw new o(h ? n : "highWaterMark", c);
          return Math.floor(c);
        }
        return r.objectMode ? 16 : 16384;
      } };
    }, { "../../../errors": 55 }], 68: [function(i, s, a) {
      s.exports = i("events").EventEmitter;
    }, { events: 22 }], 69: [function(i, s, a) {
      (a = s.exports = i("./lib/_stream_readable.js")).Stream = a, a.Readable = a, a.Writable = i("./lib/_stream_writable.js"), a.Duplex = i("./lib/_stream_duplex.js"), a.Transform = i("./lib/_stream_transform.js"), a.PassThrough = i("./lib/_stream_passthrough.js"), a.finished = i("./lib/internal/streams/end-of-stream.js"), a.pipeline = i("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 56, "./lib/_stream_passthrough.js": 57, "./lib/_stream_readable.js": 58, "./lib/_stream_transform.js": 59, "./lib/_stream_writable.js": 60, "./lib/internal/streams/end-of-stream.js": 64, "./lib/internal/streams/pipeline.js": 66 }], 70: [function(i, s, a) {
      s.exports = function() {
        if (typeof arguments[0] != "function") throw new Error("callback needed");
        if (typeof arguments[1] != "number") throw new Error("interval needed");
        var o;
        if (arguments.length > 0) {
          o = new Array(arguments.length - 2);
          for (var r = 0; r < o.length; r++) o[r] = arguments[r + 2];
        }
        return new function(l, n, h) {
          var c = this;
          this._callback = l, this._args = h, this._interval = setInterval(l, n, this._args), this.reschedule = function(d) {
            d || (d = c._interval), c._interval && clearInterval(c._interval), c._interval = setInterval(c._callback, d, c._args);
          }, this.clear = function() {
            c._interval && (clearInterval(c._interval), c._interval = void 0);
          }, this.destroy = function() {
            c._interval && clearInterval(c._interval), c._callback = void 0, c._interval = void 0, c._args = void 0;
          };
        }(arguments[0], arguments[1], o);
      };
    }, {}], 71: [function(i, s, a) {
      s.exports = i("./index.js")();
    }, { "./index.js": 72 }], 72: [function(i, s, a) {
      (function(o) {
        (function() {
          function r(l) {
            return l instanceof o ? o.from(l) : new l.constructor(l.buffer.slice(), l.byteOffset, l.length);
          }
          s.exports = function(l) {
            return (l = l || {}).circles ? function(h) {
              var c = [], d = [];
              return h.proto ? function u(g) {
                if (typeof g != "object" || g === null) return g;
                if (g instanceof Date) return new Date(g);
                if (Array.isArray(g)) return f(g, u);
                if (g instanceof Map) return new Map(f(Array.from(g), u));
                if (g instanceof Set) return new Set(f(Array.from(g), u));
                var y = {};
                for (var v in c.push(g), d.push(y), g) {
                  var b = g[v];
                  if (typeof b != "object" || b === null) y[v] = b;
                  else if (b instanceof Date) y[v] = new Date(b);
                  else if (b instanceof Map) y[v] = new Map(f(Array.from(b), u));
                  else if (b instanceof Set) y[v] = new Set(f(Array.from(b), u));
                  else if (ArrayBuffer.isView(b)) y[v] = r(b);
                  else {
                    var x = c.indexOf(b);
                    y[v] = x !== -1 ? d[x] : u(b);
                  }
                }
                return c.pop(), d.pop(), y;
              } : function u(g) {
                if (typeof g != "object" || g === null) return g;
                if (g instanceof Date) return new Date(g);
                if (Array.isArray(g)) return f(g, u);
                if (g instanceof Map) return new Map(f(Array.from(g), u));
                if (g instanceof Set) return new Set(f(Array.from(g), u));
                var y = {};
                for (var v in c.push(g), d.push(y), g) if (Object.hasOwnProperty.call(g, v) !== !1) {
                  var b = g[v];
                  if (typeof b != "object" || b === null) y[v] = b;
                  else if (b instanceof Date) y[v] = new Date(b);
                  else if (b instanceof Map) y[v] = new Map(f(Array.from(b), u));
                  else if (b instanceof Set) y[v] = new Set(f(Array.from(b), u));
                  else if (ArrayBuffer.isView(b)) y[v] = r(b);
                  else {
                    var x = c.indexOf(b);
                    y[v] = x !== -1 ? d[x] : u(b);
                  }
                }
                return c.pop(), d.pop(), y;
              };
              function f(u, g) {
                for (var y = Object.keys(u), v = new Array(y.length), b = 0; b < y.length; b++) {
                  var x = y[b], p = u[x];
                  if (typeof p != "object" || p === null) v[x] = p;
                  else if (p instanceof Date) v[x] = new Date(p);
                  else if (ArrayBuffer.isView(p)) v[x] = r(p);
                  else {
                    var k = c.indexOf(p);
                    v[x] = k !== -1 ? d[k] : g(p);
                  }
                }
                return v;
              }
            }(l) : l.proto ? function h(c) {
              if (typeof c != "object" || c === null) return c;
              if (c instanceof Date) return new Date(c);
              if (Array.isArray(c)) return n(c, h);
              if (c instanceof Map) return new Map(n(Array.from(c), h));
              if (c instanceof Set) return new Set(n(Array.from(c), h));
              var d = {};
              for (var f in c) {
                var u = c[f];
                typeof u != "object" || u === null ? d[f] = u : u instanceof Date ? d[f] = new Date(u) : u instanceof Map ? d[f] = new Map(n(Array.from(u), h)) : u instanceof Set ? d[f] = new Set(n(Array.from(u), h)) : ArrayBuffer.isView(u) ? d[f] = r(u) : d[f] = h(u);
              }
              return d;
            } : function h(c) {
              if (typeof c != "object" || c === null) return c;
              if (c instanceof Date) return new Date(c);
              if (Array.isArray(c)) return n(c, h);
              if (c instanceof Map) return new Map(n(Array.from(c), h));
              if (c instanceof Set) return new Set(n(Array.from(c), h));
              var d = {};
              for (var f in c) if (Object.hasOwnProperty.call(c, f) !== !1) {
                var u = c[f];
                typeof u != "object" || u === null ? d[f] = u : u instanceof Date ? d[f] = new Date(u) : u instanceof Map ? d[f] = new Map(n(Array.from(u), h)) : u instanceof Set ? d[f] = new Set(n(Array.from(u), h)) : ArrayBuffer.isView(u) ? d[f] = r(u) : d[f] = h(u);
              }
              return d;
            };
            function n(h, c) {
              for (var d = Object.keys(h), f = new Array(d.length), u = 0; u < d.length; u++) {
                var g = d[u], y = h[g];
                typeof y != "object" || y === null ? f[g] = y : y instanceof Date ? f[g] = new Date(y) : ArrayBuffer.isView(y) ? f[g] = r(y) : f[g] = c(y);
              }
              return f;
            }
          };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 73: [function(i, s, a) {
      var o = i("buffer"), r = o.Buffer;
      function l(h, c) {
        for (var d in h) c[d] = h[d];
      }
      function n(h, c, d) {
        return r(h, c, d);
      }
      r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? s.exports = o : (l(o, a), a.Buffer = n), n.prototype = Object.create(r.prototype), l(r, n), n.from = function(h, c, d) {
        if (typeof h == "number") throw new TypeError("Argument must not be a number");
        return r(h, c, d);
      }, n.alloc = function(h, c, d) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        var f = r(h);
        return c !== void 0 ? typeof d == "string" ? f.fill(c, d) : f.fill(c) : f.fill(0), f;
      }, n.allocUnsafe = function(h) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        return r(h);
      }, n.allocUnsafeSlow = function(h) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        return o.SlowBuffer(h);
      };
    }, { buffer: 17 }], 74: [function(i, s, a) {
      s.exports = function(o) {
        var r = o._readableState;
        return r ? r.objectMode || typeof o._duplexState == "number" ? o.read() : o.read((l = r, l.buffer.length ? l.buffer.head ? l.buffer.head.data.length : l.buffer[0].length : l.length)) : null;
        var l;
      };
    }, {}], 75: [function(i, s, a) {
      var o = i("safe-buffer").Buffer, r = o.isEncoding || function(v) {
        switch ((v = "" + v) && v.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function l(v) {
        var b;
        switch (this.encoding = function(x) {
          var p = function(k) {
            if (!k) return "utf8";
            for (var R; ; ) switch (k) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return k;
              default:
                if (R) return;
                k = ("" + k).toLowerCase(), R = !0;
            }
          }(x);
          if (typeof p != "string" && (o.isEncoding === r || !r(x))) throw new Error("Unknown encoding: " + x);
          return p || x;
        }(v), this.encoding) {
          case "utf16le":
            this.text = c, this.end = d, b = 4;
            break;
          case "utf8":
            this.fillLast = h, b = 4;
            break;
          case "base64":
            this.text = f, this.end = u, b = 3;
            break;
          default:
            return this.write = g, void (this.end = y);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = o.allocUnsafe(b);
      }
      function n(v) {
        return v <= 127 ? 0 : v >> 5 == 6 ? 2 : v >> 4 == 14 ? 3 : v >> 3 == 30 ? 4 : v >> 6 == 2 ? -1 : -2;
      }
      function h(v) {
        var b = this.lastTotal - this.lastNeed, x = function(p, k, R) {
          if ((192 & k[0]) != 128) return p.lastNeed = 0, "�";
          if (p.lastNeed > 1 && k.length > 1) {
            if ((192 & k[1]) != 128) return p.lastNeed = 1, "�";
            if (p.lastNeed > 2 && k.length > 2 && (192 & k[2]) != 128) return p.lastNeed = 2, "�";
          }
        }(this, v);
        return x !== void 0 ? x : this.lastNeed <= v.length ? (v.copy(this.lastChar, b, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (v.copy(this.lastChar, b, 0, v.length), void (this.lastNeed -= v.length));
      }
      function c(v, b) {
        if ((v.length - b) % 2 == 0) {
          var x = v.toString("utf16le", b);
          if (x) {
            var p = x.charCodeAt(x.length - 1);
            if (p >= 55296 && p <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1], x.slice(0, -1);
          }
          return x;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = v[v.length - 1], v.toString("utf16le", b, v.length - 1);
      }
      function d(v) {
        var b = v && v.length ? this.write(v) : "";
        if (this.lastNeed) {
          var x = this.lastTotal - this.lastNeed;
          return b + this.lastChar.toString("utf16le", 0, x);
        }
        return b;
      }
      function f(v, b) {
        var x = (v.length - b) % 3;
        return x === 0 ? v.toString("base64", b) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = v[v.length - 1] : (this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1]), v.toString("base64", b, v.length - x));
      }
      function u(v) {
        var b = v && v.length ? this.write(v) : "";
        return this.lastNeed ? b + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : b;
      }
      function g(v) {
        return v.toString(this.encoding);
      }
      function y(v) {
        return v && v.length ? this.write(v) : "";
      }
      a.StringDecoder = l, l.prototype.write = function(v) {
        if (v.length === 0) return "";
        var b, x;
        if (this.lastNeed) {
          if ((b = this.fillLast(v)) === void 0) return "";
          x = this.lastNeed, this.lastNeed = 0;
        } else x = 0;
        return x < v.length ? b ? b + this.text(v, x) : this.text(v, x) : b || "";
      }, l.prototype.end = function(v) {
        var b = v && v.length ? this.write(v) : "";
        return this.lastNeed ? b + "�" : b;
      }, l.prototype.text = function(v, b) {
        var x = function(k, R, A) {
          var P = R.length - 1;
          if (P < A) return 0;
          var E = n(R[P]);
          return E >= 0 ? (E > 0 && (k.lastNeed = E - 1), E) : --P < A || E === -2 ? 0 : (E = n(R[P])) >= 0 ? (E > 0 && (k.lastNeed = E - 2), E) : --P < A || E === -2 ? 0 : (E = n(R[P])) >= 0 ? (E > 0 && (E === 2 ? E = 0 : k.lastNeed = E - 3), E) : 0;
        }(this, v, b);
        if (!this.lastNeed) return v.toString("utf8", b);
        this.lastTotal = x;
        var p = v.length - (x - this.lastNeed);
        return v.copy(this.lastChar, 0, p), v.toString("utf8", b, p);
      }, l.prototype.fillLast = function(v) {
        if (this.lastNeed <= v.length) return v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, v.length), this.lastNeed -= v.length;
      };
    }, { "safe-buffer": 73 }], 76: [function(i, s, a) {
      var o = i("punycode"), r = i("./util");
      function l() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      a.parse = R, a.resolve = function(A, P) {
        return R(A, !1, !0).resolve(P);
      }, a.resolveObject = function(A, P) {
        return A ? R(A, !1, !0).resolveObject(P) : P;
      }, a.format = function(A) {
        return r.isString(A) && (A = R(A)), A instanceof l ? A.format() : l.prototype.format.call(A);
      }, a.Url = l;
      var n = /^([a-z0-9.+-]+:)/i, h = /:[0-9]*$/, c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, d = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), f = ["'"].concat(d), u = ["%", "/", "?", ";", "#"].concat(f), g = ["/", "?", "#"], y = /^[+a-z0-9A-Z_-]{0,63}$/, v = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, b = { javascript: !0, "javascript:": !0 }, x = { javascript: !0, "javascript:": !0 }, p = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, k = i("querystring");
      function R(A, P, E) {
        if (A && r.isObject(A) && A instanceof l) return A;
        var D = new l();
        return D.parse(A, P, E), D;
      }
      l.prototype.parse = function(A, P, E) {
        if (!r.isString(A)) throw new TypeError("Parameter 'url' must be a string, not " + typeof A);
        var D = A.indexOf("?"), q = D !== -1 && D < A.indexOf("#") ? "?" : "#", I = A.split(q);
        I[0] = I[0].replace(/\\/g, "/");
        var S = A = I.join(q);
        if (S = S.trim(), !E && A.split("#").length === 1) {
          var T = c.exec(S);
          if (T) return this.path = S, this.href = S, this.pathname = T[1], T[2] ? (this.search = T[2], this.query = P ? k.parse(this.search.substr(1)) : this.search.substr(1)) : P && (this.search = "", this.query = {}), this;
        }
        var _ = n.exec(S);
        if (_) {
          var z = (_ = _[0]).toLowerCase();
          this.protocol = z, S = S.substr(_.length);
        }
        if (E || _ || S.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var V = S.substr(0, 2) === "//";
          !V || _ && x[_] || (S = S.substr(2), this.slashes = !0);
        }
        if (!x[_] && (V || _ && !p[_])) {
          for (var X, H, M = -1, B = 0; B < g.length; B++)
            (W = S.indexOf(g[B])) !== -1 && (M === -1 || W < M) && (M = W);
          for ((H = M === -1 ? S.lastIndexOf("@") : S.lastIndexOf("@", M)) !== -1 && (X = S.slice(0, H), S = S.slice(H + 1), this.auth = decodeURIComponent(X)), M = -1, B = 0; B < u.length; B++) {
            var W;
            (W = S.indexOf(u[B])) !== -1 && (M === -1 || W < M) && (M = W);
          }
          M === -1 && (M = S.length), this.host = S.slice(0, M), S = S.slice(M), this.parseHost(), this.hostname = this.hostname || "";
          var N = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!N) for (var U = this.hostname.split(/\./), Y = (B = 0, U.length); B < Y; B++) {
            var $ = U[B];
            if ($ && !$.match(y)) {
              for (var Z = "", Q = 0, J = $.length; Q < J; Q++) $.charCodeAt(Q) > 127 ? Z += "x" : Z += $[Q];
              if (!Z.match(y)) {
                var m = U.slice(0, B), w = U.slice(B + 1), C = $.match(v);
                C && (m.push(C[1]), w.unshift(C[2])), w.length && (S = "/" + w.join(".") + S), this.hostname = m.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), N || (this.hostname = o.toASCII(this.hostname));
          var L = this.port ? ":" + this.port : "", F = this.hostname || "";
          this.host = F + L, this.href += this.host, N && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), S[0] !== "/" && (S = "/" + S));
        }
        if (!b[z]) for (B = 0, Y = f.length; B < Y; B++) {
          var j = f[B];
          if (S.indexOf(j) !== -1) {
            var K = encodeURIComponent(j);
            K === j && (K = escape(j)), S = S.split(j).join(K);
          }
        }
        var te = S.indexOf("#");
        te !== -1 && (this.hash = S.substr(te), S = S.slice(0, te));
        var ee = S.indexOf("?");
        if (ee !== -1 ? (this.search = S.substr(ee), this.query = S.substr(ee + 1), P && (this.query = k.parse(this.query)), S = S.slice(0, ee)) : P && (this.search = "", this.query = {}), S && (this.pathname = S), p[z] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          L = this.pathname || "";
          var oe = this.search || "";
          this.path = L + oe;
        }
        return this.href = this.format(), this;
      }, l.prototype.format = function() {
        var A = this.auth || "";
        A && (A = (A = encodeURIComponent(A)).replace(/%3A/i, ":"), A += "@");
        var P = this.protocol || "", E = this.pathname || "", D = this.hash || "", q = !1, I = "";
        this.host ? q = A + this.host : this.hostname && (q = A + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (q += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (I = k.stringify(this.query));
        var S = this.search || I && "?" + I || "";
        return P && P.substr(-1) !== ":" && (P += ":"), this.slashes || (!P || p[P]) && q !== !1 ? (q = "//" + (q || ""), E && E.charAt(0) !== "/" && (E = "/" + E)) : q || (q = ""), D && D.charAt(0) !== "#" && (D = "#" + D), S && S.charAt(0) !== "?" && (S = "?" + S), P + q + (E = E.replace(/[?#]/g, function(T) {
          return encodeURIComponent(T);
        })) + (S = S.replace("#", "%23")) + D;
      }, l.prototype.resolve = function(A) {
        return this.resolveObject(R(A, !1, !0)).format();
      }, l.prototype.resolveObject = function(A) {
        if (r.isString(A)) {
          var P = new l();
          P.parse(A, !1, !0), A = P;
        }
        for (var E = new l(), D = Object.keys(this), q = 0; q < D.length; q++) {
          var I = D[q];
          E[I] = this[I];
        }
        if (E.hash = A.hash, A.href === "") return E.href = E.format(), E;
        if (A.slashes && !A.protocol) {
          for (var S = Object.keys(A), T = 0; T < S.length; T++) {
            var _ = S[T];
            _ !== "protocol" && (E[_] = A[_]);
          }
          return p[E.protocol] && E.hostname && !E.pathname && (E.path = E.pathname = "/"), E.href = E.format(), E;
        }
        if (A.protocol && A.protocol !== E.protocol) {
          if (!p[A.protocol]) {
            for (var z = Object.keys(A), V = 0; V < z.length; V++) {
              var X = z[V];
              E[X] = A[X];
            }
            return E.href = E.format(), E;
          }
          if (E.protocol = A.protocol, A.host || x[A.protocol]) E.pathname = A.pathname;
          else {
            for (var H = (A.pathname || "").split("/"); H.length && !(A.host = H.shift()); ) ;
            A.host || (A.host = ""), A.hostname || (A.hostname = ""), H[0] !== "" && H.unshift(""), H.length < 2 && H.unshift(""), E.pathname = H.join("/");
          }
          if (E.search = A.search, E.query = A.query, E.host = A.host || "", E.auth = A.auth, E.hostname = A.hostname || A.host, E.port = A.port, E.pathname || E.search) {
            var M = E.pathname || "", B = E.search || "";
            E.path = M + B;
          }
          return E.slashes = E.slashes || A.slashes, E.href = E.format(), E;
        }
        var W = E.pathname && E.pathname.charAt(0) === "/", N = A.host || A.pathname && A.pathname.charAt(0) === "/", U = N || W || E.host && A.pathname, Y = U, $ = E.pathname && E.pathname.split("/") || [], Z = (H = A.pathname && A.pathname.split("/") || [], E.protocol && !p[E.protocol]);
        if (Z && (E.hostname = "", E.port = null, E.host && ($[0] === "" ? $[0] = E.host : $.unshift(E.host)), E.host = "", A.protocol && (A.hostname = null, A.port = null, A.host && (H[0] === "" ? H[0] = A.host : H.unshift(A.host)), A.host = null), U = U && (H[0] === "" || $[0] === "")), N) E.host = A.host || A.host === "" ? A.host : E.host, E.hostname = A.hostname || A.hostname === "" ? A.hostname : E.hostname, E.search = A.search, E.query = A.query, $ = H;
        else if (H.length) $ || ($ = []), $.pop(), $ = $.concat(H), E.search = A.search, E.query = A.query;
        else if (!r.isNullOrUndefined(A.search))
          return Z && (E.hostname = E.host = $.shift(), (C = !!(E.host && E.host.indexOf("@") > 0) && E.host.split("@")) && (E.auth = C.shift(), E.host = E.hostname = C.shift())), E.search = A.search, E.query = A.query, r.isNull(E.pathname) && r.isNull(E.search) || (E.path = (E.pathname ? E.pathname : "") + (E.search ? E.search : "")), E.href = E.format(), E;
        if (!$.length) return E.pathname = null, E.search ? E.path = "/" + E.search : E.path = null, E.href = E.format(), E;
        for (var Q = $.slice(-1)[0], J = (E.host || A.host || $.length > 1) && (Q === "." || Q === "..") || Q === "", m = 0, w = $.length; w >= 0; w--) (Q = $[w]) === "." ? $.splice(w, 1) : Q === ".." ? ($.splice(w, 1), m++) : m && ($.splice(w, 1), m--);
        if (!U && !Y) for (; m--; m) $.unshift("..");
        !U || $[0] === "" || $[0] && $[0].charAt(0) === "/" || $.unshift(""), J && $.join("/").substr(-1) !== "/" && $.push("");
        var C, L = $[0] === "" || $[0] && $[0].charAt(0) === "/";
        return Z && (E.hostname = E.host = L ? "" : $.length ? $.shift() : "", (C = !!(E.host && E.host.indexOf("@") > 0) && E.host.split("@")) && (E.auth = C.shift(), E.host = E.hostname = C.shift())), (U = U || E.host && $.length) && !L && $.unshift(""), $.length ? E.pathname = $.join("/") : (E.pathname = null, E.path = null), r.isNull(E.pathname) && r.isNull(E.search) || (E.path = (E.pathname ? E.pathname : "") + (E.search ? E.search : "")), E.auth = A.auth || E.auth, E.slashes = E.slashes || A.slashes, E.href = E.format(), E;
      }, l.prototype.parseHost = function() {
        var A = this.host, P = h.exec(A);
        P && ((P = P[0]) !== ":" && (this.port = P.substr(1)), A = A.substr(0, A.length - P.length)), A && (this.hostname = A);
      };
    }, { "./util": 77, punycode: 51, querystring: 54 }], 77: [function(i, s, a) {
      s.exports = { isString: function(o) {
        return typeof o == "string";
      }, isObject: function(o) {
        return typeof o == "object" && o !== null;
      }, isNull: function(o) {
        return o === null;
      }, isNullOrUndefined: function(o) {
        return o == null;
      } };
    }, {}], 78: [function(i, s, a) {
      (function(o) {
        (function() {
          function r(l) {
            try {
              if (!o.localStorage) return !1;
            } catch {
              return !1;
            }
            var n = o.localStorage[l];
            return n != null && String(n).toLowerCase() === "true";
          }
          s.exports = function(l, n) {
            if (r("noDeprecation")) return l;
            var h = !1;
            return function() {
              if (!h) {
                if (r("throwDeprecation")) throw new Error(n);
                r("traceDeprecation") ? console.trace(n) : console.warn(n), h = !0;
              }
              return l.apply(this, arguments);
            };
          };
        }).call(this);
      }).call(this, typeof qe < "u" ? qe : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 79: [function(i, s, a) {
      s.exports = function o(r, l) {
        if (r && l) return o(r)(l);
        if (typeof r != "function") throw new TypeError("need wrapper function");
        return Object.keys(r).forEach(function(h) {
          n[h] = r[h];
        }), n;
        function n() {
          for (var h = new Array(arguments.length), c = 0; c < h.length; c++) h[c] = arguments[c];
          var d = r.apply(this, h), f = h[h.length - 1];
          return typeof d == "function" && d !== f && Object.keys(f).forEach(function(u) {
            d[u] = f[u];
          }), d;
        }
      };
    }, {}], 80: [function(i, s, a) {
      s.exports = function() {
        throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
      };
    }, {}], 81: [function(i, s, a) {
      s.exports = function() {
        for (var r = {}, l = 0; l < arguments.length; l++) {
          var n = arguments[l];
          for (var h in n) o.call(n, h) && (r[h] = n[h]);
        }
        return r;
      };
      var o = Object.prototype.hasOwnProperty;
    }, {}], 82: [function(i, s, a) {
      s.exports = function(o) {
        o.prototype[Symbol.iterator] = function* () {
          for (let r = this.head; r; r = r.next) yield r.value;
        };
      };
    }, {}], 83: [function(i, s, a) {
      function o(c) {
        var d = this;
        if (d instanceof o || (d = new o()), d.tail = null, d.head = null, d.length = 0, c && typeof c.forEach == "function") c.forEach(function(g) {
          d.push(g);
        });
        else if (arguments.length > 0) for (var f = 0, u = arguments.length; f < u; f++) d.push(arguments[f]);
        return d;
      }
      function r(c, d, f) {
        var u = d === c.head ? new h(f, null, d, c) : new h(f, d, d.next, c);
        return u.next === null && (c.tail = u), u.prev === null && (c.head = u), c.length++, u;
      }
      function l(c, d) {
        c.tail = new h(d, c.tail, null, c), c.head || (c.head = c.tail), c.length++;
      }
      function n(c, d) {
        c.head = new h(d, null, c.head, c), c.tail || (c.tail = c.head), c.length++;
      }
      function h(c, d, f, u) {
        if (!(this instanceof h)) return new h(c, d, f, u);
        this.list = u, this.value = c, d ? (d.next = this, this.prev = d) : this.prev = null, f ? (f.prev = this, this.next = f) : this.next = null;
      }
      s.exports = o, o.Node = h, o.create = o, o.prototype.removeNode = function(c) {
        if (c.list !== this) throw new Error("removing node which does not belong to this list");
        var d = c.next, f = c.prev;
        return d && (d.prev = f), f && (f.next = d), c === this.head && (this.head = d), c === this.tail && (this.tail = f), c.list.length--, c.next = null, c.prev = null, c.list = null, d;
      }, o.prototype.unshiftNode = function(c) {
        if (c !== this.head) {
          c.list && c.list.removeNode(c);
          var d = this.head;
          c.list = this, c.next = d, d && (d.prev = c), this.head = c, this.tail || (this.tail = c), this.length++;
        }
      }, o.prototype.pushNode = function(c) {
        if (c !== this.tail) {
          c.list && c.list.removeNode(c);
          var d = this.tail;
          c.list = this, c.prev = d, d && (d.next = c), this.tail = c, this.head || (this.head = c), this.length++;
        }
      }, o.prototype.push = function() {
        for (var c = 0, d = arguments.length; c < d; c++) l(this, arguments[c]);
        return this.length;
      }, o.prototype.unshift = function() {
        for (var c = 0, d = arguments.length; c < d; c++) n(this, arguments[c]);
        return this.length;
      }, o.prototype.pop = function() {
        if (this.tail) {
          var c = this.tail.value;
          return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, c;
        }
      }, o.prototype.shift = function() {
        if (this.head) {
          var c = this.head.value;
          return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, c;
        }
      }, o.prototype.forEach = function(c, d) {
        d = d || this;
        for (var f = this.head, u = 0; f !== null; u++) c.call(d, f.value, u, this), f = f.next;
      }, o.prototype.forEachReverse = function(c, d) {
        d = d || this;
        for (var f = this.tail, u = this.length - 1; f !== null; u--) c.call(d, f.value, u, this), f = f.prev;
      }, o.prototype.get = function(c) {
        for (var d = 0, f = this.head; f !== null && d < c; d++) f = f.next;
        if (d === c && f !== null) return f.value;
      }, o.prototype.getReverse = function(c) {
        for (var d = 0, f = this.tail; f !== null && d < c; d++) f = f.prev;
        if (d === c && f !== null) return f.value;
      }, o.prototype.map = function(c, d) {
        d = d || this;
        for (var f = new o(), u = this.head; u !== null; ) f.push(c.call(d, u.value, this)), u = u.next;
        return f;
      }, o.prototype.mapReverse = function(c, d) {
        d = d || this;
        for (var f = new o(), u = this.tail; u !== null; ) f.push(c.call(d, u.value, this)), u = u.prev;
        return f;
      }, o.prototype.reduce = function(c, d) {
        var f, u = this.head;
        if (arguments.length > 1) f = d;
        else {
          if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
          u = this.head.next, f = this.head.value;
        }
        for (var g = 0; u !== null; g++) f = c(f, u.value, g), u = u.next;
        return f;
      }, o.prototype.reduceReverse = function(c, d) {
        var f, u = this.tail;
        if (arguments.length > 1) f = d;
        else {
          if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
          u = this.tail.prev, f = this.tail.value;
        }
        for (var g = this.length - 1; u !== null; g--) f = c(f, u.value, g), u = u.prev;
        return f;
      }, o.prototype.toArray = function() {
        for (var c = new Array(this.length), d = 0, f = this.head; f !== null; d++) c[d] = f.value, f = f.next;
        return c;
      }, o.prototype.toArrayReverse = function() {
        for (var c = new Array(this.length), d = 0, f = this.tail; f !== null; d++) c[d] = f.value, f = f.prev;
        return c;
      }, o.prototype.slice = function(c, d) {
        (d = d || this.length) < 0 && (d += this.length), (c = c || 0) < 0 && (c += this.length);
        var f = new o();
        if (d < c || d < 0) return f;
        c < 0 && (c = 0), d > this.length && (d = this.length);
        for (var u = 0, g = this.head; g !== null && u < c; u++) g = g.next;
        for (; g !== null && u < d; u++, g = g.next) f.push(g.value);
        return f;
      }, o.prototype.sliceReverse = function(c, d) {
        (d = d || this.length) < 0 && (d += this.length), (c = c || 0) < 0 && (c += this.length);
        var f = new o();
        if (d < c || d < 0) return f;
        c < 0 && (c = 0), d > this.length && (d = this.length);
        for (var u = this.length, g = this.tail; g !== null && u > d; u--) g = g.prev;
        for (; g !== null && u > c; u--, g = g.prev) f.push(g.value);
        return f;
      }, o.prototype.splice = function(c, d, ...f) {
        c > this.length && (c = this.length - 1), c < 0 && (c = this.length + c);
        for (var u = 0, g = this.head; g !== null && u < c; u++) g = g.next;
        var y = [];
        for (u = 0; g && u < d; u++) y.push(g.value), g = this.removeNode(g);
        for (g === null && (g = this.tail), g !== this.head && g !== this.tail && (g = g.prev), u = 0; u < f.length; u++) g = r(this, g, f[u]);
        return y;
      }, o.prototype.reverse = function() {
        for (var c = this.head, d = this.tail, f = c; f !== null; f = f.prev) {
          var u = f.prev;
          f.prev = f.next, f.next = u;
        }
        return this.head = d, this.tail = c, this;
      };
      try {
        i("./iterator.js")(o);
      } catch {
      }
    }, { "./iterator.js": 82 }] }, {}, [12])(12);
  });
})(po);
var wi = po.exports;
const ha = {
  success: {
    color: "#2ba471",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM7.5 10.59l3 3 6-6L17.91 9l-7.41 7.41L6.09 12l1.41-1.41z"></path></svg>'
  },
  info: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  },
  warning: {
    color: "#e37318",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  error: {
    color: "#d54941",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  question: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zm-.17-11.11c.43-.53.97-.97 1.4-1.32A2 2 0 0012 7a2 2 0 00-1.89 1.33l-.33.95L7.9 8.6l.34-.94a4 4 0 116.24 4.47 7 7 0 00-1.1 1.01c-.27.34-.37.61-.37.85v1.25h-2V14c0-.87.39-1.57.83-2.11zM11 18.25v-2h2v2h-2z"></path></svg>'
  }
}, Me = {};
class Yl {
  constructor(e, i) {
    O(this, "box");
    O(this, "icon");
    O(this, "text");
    O(this, "closeBtn");
    O(this, "duration");
    //定时销毁时间
    O(this, "content");
    O(this, "theme");
    //主题
    O(this, "placement");
    //位置
    O(this, "id");
    this.parentElement = e, this.box = document.createElement("div"), this.icon = document.createElement("div"), this.text = document.createElement("div"), this.box.className = "meta2d-message", this.icon.className = "icon", this.text.className = "text", this.icon.innerHTML = ha[i.theme || "info"].icon, this.text.innerHTML = i.content, this.box.appendChild(this.icon), this.box.appendChild(this.text), i.closeBtn && (this.closeBtn = document.createElement("div"), this.closeBtn.className = "close", this.closeBtn.innerHTML = "x", this.closeBtn.onclick = () => {
      this.close();
    }, this.box.appendChild(this.closeBtn)), e.appendChild(this.box);
    let s;
    for (let a = 0; a < document.styleSheets.length; a++)
      document.styleSheets[a].title === "le5le.com/message" && (s = document.styleSheets[a]);
    if (!s) {
      let a = document.createElement("style");
      a.type = "text/css", a.title = "le5le.com/message", document.head.appendChild(a), a = document.createElement("style"), a.type = "text/css", document.head.appendChild(a), s = a.sheet, s.insertRule(
        `.meta2d-message{
           position:absolute;
           z-index:999;
           transform: translateX(-50%); 
           padding:12px 16px;
           max-width:400px;
           background:#fff;
           border-radius:6px;
           box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);
           display:flex;
           animation: fadein .5s;}`
      ), s.insertRule(
        `
        @keyframes fadein {
          0% {
              transform: translate(-50%, -100%);
          }
          100% {
              transform: translate(-50%,0);
          }
      }`
      ), s.insertRule(".meta2d-message .icon{width:20px;height:20px;}"), s.insertRule(
        ".meta2d-message .text{color:rgba(0, 0, 0, 0.9);font-size:12px;margin-left:8px;line-height:20px;}"
      ), s.insertRule(
        ".meta2d-message .close{width:20px;height:20px;padding-left: 16px; cursor: pointer;}"
      );
    }
    this.id = i.id || ne(), this.duration = i.duration ?? 3e3, this.placement = i.placement || "top", this.theme = i.theme || "info";
  }
  init() {
    Me[this.id] = this, this.duration && setTimeout(() => {
      this.close();
    }, this.duration);
    let e = -1;
    Object.keys(Me).forEach((i) => {
      var s;
      ((s = Me[i]) == null ? void 0 : s.placement) === this.placement && e++;
    }), this.setPosition(this.placement, e), this.icon.children[0].style.fill = ha[this.theme].color;
  }
  setPosition(e, i = 0) {
    switch (e) {
      case "top":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.left = "50%";
        break;
      case "bottom":
        this.box.style.bottom = `${30 + i * 60}px`, this.box.style.left = "50%";
        break;
      case "left":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.left = "30px";
        break;
      case "right":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.right = "30px";
        break;
    }
  }
  close() {
    Object.keys(Me).forEach((e) => {
      var i;
      if (((i = Me[e]) == null ? void 0 : i.placement) === this.placement)
        switch (this.placement) {
          case "top":
          case "left":
          case "right":
            Me[e].box.style.top = parseInt(Me[e].box.style.top) - 60 + "px";
            break;
          case "bottom":
            Me[e].box.style.bottom = parseInt(Me[e].box.style.bottom) - 60 + "px";
            break;
        }
    }), Me[this.id] = null, delete Me[this.id], this.box.remove();
  }
}
class $l {
  constructor(e, i = {}) {
    O(this, "store");
    O(this, "canvas");
    O(this, "websocket");
    O(this, "mqttClient");
    O(this, "websockets");
    O(this, "mqttClients");
    O(this, "penPluginMap", /* @__PURE__ */ new Map());
    O(this, "socketFn");
    O(this, "events", {});
    O(this, "map");
    O(this, "mapTimer");
    O(this, "facePen", jt);
    O(this, "getWords", Oa);
    O(this, "calcTextLines", ci);
    O(this, "calcTextRect", Xe);
    O(this, "calcTextDrawRect", Na);
    O(this, "jetLinksList", []);
    O(this, "jetLinksClient");
    O(this, "register", xt);
    O(this, "registerCanvasDraw", Ot);
    O(this, "registerAnchors", Qi);
    O(this, "websocketTimes", 0);
    O(this, "mqttTimes", 0);
    O(this, "httpTimer");
    O(this, "httpTimerList", []);
    O(this, "updateTimer");
    O(this, "updateTimerList", []);
    O(this, "sqlTimerList", []);
    O(this, "onEvent", (e, i) => {
      switch (e) {
        case "add":
          i.forEach((s) => {
            var a;
            (a = s.onAdd) == null || a.call(s, s);
          }), this.onSizeUpdate();
          break;
        case "enter":
          i && i.onMouseEnter && i.onMouseEnter(i, this.canvas.mousePos), this.store.data.locked && this.doEvent(i, e);
          break;
        case "leave":
          i && i.onMouseLeave && i.onMouseLeave(i, this.canvas.mousePos), this.store.data.locked && this.doEvent(i, e);
          break;
        case "active":
        case "inactive":
          this.store.data.locked && i.forEach((s) => {
            this.doEvent(s, e);
          });
          break;
        case "click":
          this.store.data.locked && i.pen && !i.pen.disabled && i.pen.switch && (i.pen.checked = !i.pen.checked, i.pen.calculative.checked = i.pen.checked, i.pen.calculative.gradient = void 0, i.pen.calculative.radialGradient = void 0), i.pen && i.pen.onClick && !i.pen.disabled && i.pen.onClick(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, e);
          break;
        case "contextmenu":
          i.pen && i.pen.onContextmenu && !i.pen.disabled && i.pen.onContextmenu(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, e);
          break;
        case "mousedown":
          i.pen && i.pen.onMouseDown && !i.pen.disabled && i.pen.onMouseDown(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, e);
          break;
        case "mouseup":
          i.pen && i.pen.onMouseUp && !i.pen.disabled && i.pen.onMouseUp(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, e);
          break;
        case "dblclick":
          this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, e);
          break;
        case "valueUpdate":
          this.store.data.locked && this.doEvent(i, e), this.canvas.tooltip.updateText(i);
          break;
        case "update":
        case "delete":
        case "translatePens":
        case "rotatePens":
        case "resizePens":
          this.onSizeUpdate();
          break;
        case "navigator":
          this.store.data.id || console.warn("请先保存当前图纸"), this.navigatorTo(i.params);
          break;
        case "input":
          this.store.data.locked && i && !i.disabled && this.doEvent(i, e);
          break;
        case "change":
          this.store.data.locked && i && !i.disabled && this.doEvent(i, e);
          break;
      }
      this.doMessageEvent(e);
    });
    O(this, "doEvent", (e, i) => {
      var o, r, l, n, h, c, d, f, u, g;
      if (!e)
        return;
      let s = !1, a = [];
      if ((o = e.events) == null || o.forEach((y, v) => {
        var b;
        if (y.actions && y.actions.length) {
          if (y.name === i) {
            let x = !1;
            y.conditions && y.conditions.length ? y.conditionType === "and" ? x = y.conditions.every((p) => this.judgeCondition(e, p.key, p)) : y.conditionType === "or" && (x = y.conditions.some((p) => this.judgeCondition(e, p.key, p))) : x = !0, x && a.push(v);
          }
        } else if (s = !0, this.events[y.action] && y.name === i) {
          let x = !((b = y.where) != null && b.type);
          if (y.where) {
            const { fn: p, fnJs: k, comparison: R, key: A, value: P } = y.where;
            if (p)
              x = p(e, { meta2d: this });
            else if (k) {
              try {
                y.where.fn = new Function("pen", "context", k);
              } catch (E) {
                console.error("Error: make function:", E);
              }
              y.where.fn && (x = y.where.fn(e, { meta2d: this }));
            } else {
              let E = e[A];
              switch (["x", "y", "width", "height"].includes(A) && (E = this.getPenRect(e)[A]), R) {
                case ">":
                  x = E > +P;
                  break;
                case ">=":
                  x = E >= +P;
                  break;
                case "<":
                  x = E < +P;
                  break;
                case "<=":
                  x = E <= +P;
                  break;
                case "=":
                case "==":
                  x = E == P;
                  break;
                case "!=":
                  x = E != P;
                  break;
                case "[)":
                  x = _t(+E, P);
                  break;
                case "![)":
                  x = !_t(+E, P);
                  break;
                case "[]":
                  x = Lt(E, P);
                  break;
                case "![]":
                  x = !Lt(E, P);
                  break;
              }
            }
          }
          x && a.push(v);
        }
      }), s ? (r = e.events) == null || r.forEach((y, v) => {
        a.includes(v) && this.events[y.action](e, y);
      }) : (l = e.events) == null || l.forEach(async (y, v) => {
        if (a.includes(v)) {
          if (y.confirm && !await this.canvas.popconfirm.showModal(e, this.canvas.mousePos, y.confirmTitle))
            return;
          y.actions.forEach((b) => {
            if (b.timeout) {
              let x = setTimeout(() => {
                this.events[b.action] && (this.events[b.action](e, b), clearTimeout(x), x = null);
              }, b.timeout);
            } else
              this.events[b.action] && this.events[b.action](e, b);
          });
        }
      }), i === "valueUpdate") {
        (n = e.realTimes) == null || n.forEach((v) => {
          var x, p;
          let b = [];
          (x = v.triggers) == null || x.forEach((k, R) => {
            var P;
            let A = !1;
            (P = k.conditions) != null && P.length ? k.conditionType === "and" ? A = k.conditions.every((E) => this.judgeCondition(e, v.key, E)) : k.conditionType === "or" && (A = k.conditions.some((E) => this.judgeCondition(e, v.key, E))) : A = !0, A && b.push(R);
          }), (p = v.triggers) == null || p.forEach((k, R) => {
            var A;
            b.includes(R) && ((A = k.actions) == null || A.forEach((P) => {
              if (P.timeout) {
                let E = setTimeout(() => {
                  this.events[P.action] && (this.events[P.action](e, P), clearTimeout(E), E = null);
                }, P.timeout);
              } else
                this.events[P.action](e, P);
            }));
          });
        });
        let y = [];
        if ((h = this.store.globalTriggers[e.id]) == null || h.forEach((v, b) => {
          var p;
          let x = !1;
          (p = v.conditions) != null && p.length ? v.conditionType === "and" ? x = v.conditions.every((k) => this.judgeCondition(this.store.pens[k.source], k.key, k)) : v.conditionType === "or" && (x = v.conditions.some((k) => this.judgeCondition(this.store.pens[k.source], k.key, k))) : x = !0, x && y.push(b);
        }), (c = this.store.globalTriggers[e.id]) == null || c.forEach((v, b) => {
          var x;
          y.includes(b) && ((x = v.actions) == null || x.forEach((p) => {
            if (p.timeout) {
              let k = setTimeout(() => {
                this.events[p.action] && (this.events[p.action](e, p), clearTimeout(k), k = null);
              }, p.timeout);
            } else
              this.events[p.action](e, p);
          }));
        }), (d = e.triggers) != null && d.length) {
          for (let v of e.triggers)
            if ((f = v.status) != null && f.length)
              for (let b of v.status) {
                let x = !1;
                if ((u = b.conditions) != null && u.length ? b.conditionType === "and" ? x = b.conditions.every((p) => this.judgeCondition(e, p.key, p)) : b.conditionType === "or" && (x = b.conditions.some((p) => this.judgeCondition(e, p.key, p))) : x = !0, x) {
                  (g = b.actions) == null || g.forEach((p) => {
                    if (p.timeout) {
                      let k = setTimeout(() => {
                        this.events[p.action] && (this.events[p.action](e, p), clearTimeout(k), k = null);
                      }, p.timeout);
                    } else
                      this.events[p.action](e, p);
                  });
                  break;
                }
              }
        }
      }
      this.doEvent(this.store.pens[e.parentId], i);
    });
    O(this, "doDataEvent", (e) => {
      var a, o, r;
      if (!((a = this.store.data.dataEvents) != null && a.length))
        return;
      const i = e.reduce((l, { dataId: n, id: h, value: c }) => (l[h || n] = c, l), {});
      let s = [];
      (o = this.store.data.dataEvents) == null || o.forEach((l, n) => {
        let h = !1;
        l.conditions && l.conditions.length ? l.conditionType === "and" ? h = l.conditions.every((c) => this.dataJudegeCondition(i, c.key, c)) : l.conditionType === "or" && (h = l.conditions.some((c) => this.dataJudegeCondition(i, c.key, c))) : h = !0, h && s.push(n);
      }), (r = this.store.data.dataEvents) == null || r.forEach((l, n) => {
        var h;
        s.includes(n) && ((h = l.actions) == null || h.forEach((c) => {
          this.events[c.action](i, c);
        }));
      });
    });
    O(this, "renderPenRaw", Ti);
    O(this, "setElemPosition", Ce);
    O(this, "setLifeCycleFunc", un);
    this.store = kr(ne()), this.setOptions(i), this.setDatabyOptions(i), this.init(e), this.register(jl()), this.registerCanvasDraw({ cube: Un }), this.registerAnchors(Ul()), globalThis.meta2d = this, this.initEventFns(), this.store.emitter.on("*", this.onEvent);
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  get beforeAddPen() {
    return this.canvas.beforeAddPen;
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  set beforeAddPen(e) {
    this.canvas.beforeAddPen = e;
  }
  get beforeAddPens() {
    return this.canvas.beforeAddPens;
  }
  set beforeAddPens(e) {
    this.canvas.beforeAddPens = e;
  }
  get beforeAddAnchor() {
    return this.canvas.beforeAddAnchor;
  }
  set beforeAddAnchor(e) {
    this.canvas.beforeAddAnchor = e;
  }
  get beforeRemovePens() {
    return this.canvas.beforeRemovePens;
  }
  set beforeRemovePens(e) {
    this.canvas.beforeRemovePens = e;
  }
  get beforeRemoveAnchor() {
    return this.canvas.beforeRemoveAnchor;
  }
  set beforeRemoveAnchor(e) {
    this.canvas.beforeRemoveAnchor = e;
  }
  setOptions(e = {}) {
    var i;
    (e.grid !== void 0 || e.gridColor !== void 0 || e.gridSize !== void 0) && this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), (e.rule !== void 0 || e.ruleColor !== void 0 || e.ruleOptions !== void 0) && (this.store.patchFlagsTop = !0, e.ruleOptions && (i = this.store.options) != null && i.ruleOptions && (Object.assign(this.store.options.ruleOptions, e.ruleOptions), e.ruleOptions = this.store.options.ruleOptions)), e.background !== void 0 && this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), e.resizeMode !== void 0 && (e.resizeMode || (this.canvas.hotkeyType = ge.None)), (e.width !== void 0 || e.height !== void 0) && (this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), this.canvas && this.canvas.canvasTemplate.canvas.style.backgroundImage && (this.canvas.canvasTemplate.canvas.style.backgroundImage = "")), this.store.options = Object.assign(this.store.options, e), this.canvas && e.scroll !== void 0 && (e.scroll ? (!this.canvas.scroll && (this.canvas.scroll = new go(this.canvas)), this.canvas.scroll.show()) : this.canvas.scroll && this.canvas.scroll.hide());
  }
  getOptions() {
    return this.store.options;
  }
  setTheme(e) {
    this.store.data.theme = e, this.setBackgroundColor(this.store.theme[e].background), this.canvas.parentElement.style.background = this.store.theme[e].parentBackground, this.store.data.color = this.store.theme[e].color, this.setOptions({
      ruleColor: this.store.theme[e].ruleColor,
      ruleOptions: this.store.theme[e].ruleOptions
    }), this.render();
  }
  setDatabyOptions(e = {}) {
    const {
      color: i,
      activeColor: s,
      activeBackground: a,
      grid: o,
      gridColor: r,
      gridSize: l,
      fromArrow: n,
      toArrow: h,
      rule: c,
      ruleColor: d,
      textColor: f,
      x: u = 0,
      y: g = 0
    } = e;
    this.setRule({ rule: c, ruleColor: d }), this.setGrid({
      grid: o,
      gridColor: r,
      gridSize: l
    }), this.store.data = Object.assign(this.store.data, {
      textColor: f,
      color: i,
      activeColor: s,
      activeBackground: a,
      fromArrow: n,
      toArrow: h,
      x: u,
      y: g
    });
  }
  init(e) {
    typeof e == "string" ? this.canvas = new na(
      this,
      document.getElementById(e),
      this.store
    ) : this.canvas = new na(this, e, this.store), this.resize(), this.canvas.listen();
  }
  initEventFns() {
    this.events[Ie.Link] = (e, i) => {
      if (window && i.value && typeof i.value == "string") {
        window.open(i.value, i.params ?? "_blank");
        return;
      }
      console.warn("[meta2d] Link param is not a string");
    }, this.events[Ie.SetProps] = (e, i) => {
      const s = i.value;
      if (s && typeof s == "object") {
        (i.params ? this.find(i.params) : this.find(e.id)).forEach((o) => {
          s.hasOwnProperty("visible") && o.visible !== s.visible && this.setVisible(o, s.visible), this.setValue(
            { id: o.id, ...s },
            { render: !1, doEvent: !1 }
          );
        }), this.render();
        return;
      }
      console.warn("[meta2d] SetProps value is not an object");
    }, this.events[Ie.StartAnimate] = (e, i) => {
      let s = e;
      if (i.value && (s = this.findOne(i.value)), !(this.store.animates.has(s) && !s.calculative.pause && s.animateName === i.params)) {
        if (i.targetType && i.params) {
          this.startAnimate(i.value || [e], i.params);
          return;
        }
        if (!i.value || typeof i.value == "string") {
          this.startAnimate(i.value || [e]);
          return;
        }
        console.warn("[meta2d] StartAnimate value is not a string");
      }
    }, this.events[Ie.PauseAnimate] = (e, i) => {
      if (!i.value || typeof i.value == "string") {
        this.pauseAnimate(i.value || [e]);
        return;
      }
      console.warn("[meta2d] PauseAnimate value is not a string");
    }, this.events[Ie.StopAnimate] = (e, i) => {
      if (!i.value || typeof i.value == "string") {
        if (i.value) {
          let s = this.findOne(i.value);
          if (!this.store.animates.has(s))
            return;
        } else if (!this.store.animates.has(e))
          return;
        this.stopAnimate(i.value || [e]);
        return;
      }
      console.warn("[meta2d] StopAnimate event value is not a string");
    }, this.events[Ie.StartVideo] = (e, i) => {
      if (!i.value || typeof i.value == "string") {
        this.startVideo(i.value || [e]);
        return;
      }
      console.warn("[meta2d] StartVideo value is not a string");
    }, this.events[Ie.PauseVideo] = (e, i) => {
      if (!i.value || typeof i.value == "string") {
        this.pauseVideo(i.value || [e]);
        return;
      }
      console.warn("[meta2d] PauseVideo value is not a string");
    }, this.events[Ie.StopVideo] = (e, i) => {
      if (!i.value || typeof i.value == "string") {
        this.stopVideo(i.value || [e]);
        return;
      }
      console.warn("[meta2d] StopVideo event value is not a string");
    }, this.events[Ie.JS] = (e, i, s) => {
      var a;
      if (i.value && !i.fn)
        try {
          if (typeof i.value != "string")
            throw new Error("[meta2d] Function value must be string");
          const o = i.value;
          i.fn = new Function("pen", "params", "context", o);
        } catch (o) {
          console.error("[meta2d]: Error on make a function:", o);
        }
      (a = i.fn) == null || a.call(i, e, s || i.params, { meta2d: this, eventName: i.name });
    }, this.events[Ie.GlobalFn] = (e, i) => {
      if (typeof i.value != "string") {
        console.warn("[meta2d] GlobalFn value must be a string");
        return;
      }
      globalThis[i.value] && globalThis[i.value](e, i.params);
    }, this.events[Ie.Emit] = (e, i) => {
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      this.store.emitter.emit(i.value, {
        pen: e,
        params: i.params,
        eventName: i.name
      });
    }, this.events[Ie.SendPropData] = (e, i) => {
      const s = G(i.value);
      if (s && typeof s == "object") {
        const a = i.params ? this.findOne(i.params) : e;
        for (let o in s)
          (s[o] === void 0 || s[o] === "") && (s[o] = a[o]);
        s.id = a.id, this.doSendDataEvent(s, i.extend);
        return;
      }
      console.warn("[meta2d] SendPropData value is not an object");
    }, this.events[Ie.SendVarData] = (e, i) => {
      const s = G(i.value);
      if (s && typeof s == "object") {
        const a = i.params ? this.findOne(i.params) : e;
        let o = [];
        for (let r in s) {
          let l = {
            dataId: r,
            value: s[r]
          };
          if (!l.value) {
            let n = a.form.find(
              (h) => h.dataIds && h.dataIds.dataId === l.dataId
            );
            n && (l.value = a[n.key]);
          }
          o.push(l);
        }
        this.doSendDataEvent(o, i.extend);
        return;
      }
      console.warn("[meta2d] SendVarData value is not an object");
    }, this.events[Ie.Navigator] = (e, i) => {
      i.value && typeof i.value == "string" && this.navigatorTo(i.value);
    }, this.events[Ie.Dialog] = (e, i) => {
      if (i.params && typeof i.params == "string") {
        let s = i.params;
        if (i.params.includes("${")) {
          let a = i.params.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
          a && (a == null || a.forEach((o) => {
            s = s.replace(`\${${o}}`, e[o]);
          }));
        }
        this.canvas.dialog.show(i.value, s, i.extend);
      }
    }, this.events[Ie.SendData] = (e, i) => {
      var a, o;
      if ((a = i.list) != null && a.length) {
        if (i.network && i.network.protocol === "jetLinks") {
          const l = [];
          i.list.forEach((n, h) => {
            var d, f;
            const c = n.params ? this.findOne(n.params) : e;
            l[h] = {
              deviceId: c.deviceId,
              productId: c.productId,
              properties: {}
            };
            for (let u in n.value)
              if (n.value[u] === void 0 || n.value[u] === "") {
                const g = (d = c.realTimes) == null ? void 0 : d.find((y) => y.propertyId === u);
                g && (l[h].properties[u] = c[g.key]);
              } else if (typeof n.value[u] == "string" && ((f = n.value[u]) == null ? void 0 : f.indexOf("${")) > -1) {
                let g = n.value[u].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
                g != null && g.length && (l[h].properties[u] = c[g[0]]);
              } else
                l[h].properties[u] = n.value[u];
          }), this.jetLinksClient && l.length && l.forEach((n) => {
            this.jetLinksClient.send(JSON.stringify({
              type: "sub",
              topic: `/device-message-sender/${n.productId}/${n.deviceId}`,
              parameter: {
                messageType: "WRITE_PROPERTY",
                properties: n.properties,
                headers: {
                  async: !1
                }
              },
              id: n.productId + "/" + n.deviceId + "-" + ne()
            }));
          });
          return;
        }
        const r = {};
        i.list.forEach((l) => {
          var h;
          const n = l.params ? this.findOne(l.params) : e;
          for (let c in l.value)
            if (l.value[c] === void 0 || l.value[c] === "")
              r[c] = n[c];
            else if (typeof l.value[c] == "string" && ((h = l.value[c]) == null ? void 0 : h.indexOf("${")) > -1) {
              let d = l.value[c].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
              d != null && d.length && (r[c] = n[d[0]]);
            } else
              r[c] = l.value[c];
        }), e.deviceId && (r.deviceId = e.deviceId), this.sendDataToNetWork(r, e, i);
        return;
      }
      const s = G(i.value);
      if (s && typeof s == "object" && i.targetType === "id") {
        const r = i.params ? this.findOne(i.params) : e;
        for (let l in s)
          if (s[l] === void 0 || s[l] === "")
            s[l] = r[l];
          else if (typeof s[l] == "string" && ((o = s[l]) == null ? void 0 : o.indexOf("${")) > -1) {
            let n = s[l].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            n != null && n.length && (s[l] = r[n[0]]);
          }
        r.deviceId && (s.deviceId = r.deviceId), this.sendDataToNetWork(s, e, i);
        return;
      }
    }, this.events[Ie.PostMessage] = (e, i) => {
      var r;
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const s = i.params ? this.findOne(i.params) : e;
      if (s.name !== "iframe" || !s.iframe) {
        console.warn("不是嵌入页面");
        return;
      }
      let a = zi(s.iframe.split("?")[1]);
      const o = {};
      (r = i.list) != null && r.length && i.list.forEach((l) => {
        var h;
        const n = l.params ? this.findOne(l.params) : e;
        for (let c in l.value)
          if (l.value[c] === void 0 || l.value[c] === "")
            o[c] = n[c];
          else if (typeof l.value[c] == "string" && ((h = l.value[c]) == null ? void 0 : h.indexOf("${")) > -1) {
            let d = l.value[c].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            d != null && d.length && (o[c] = n[d[0]]);
          } else
            o[c] = l.value[c];
      }), s.calculative.singleton.div.children[0].contentWindow.postMessage(
        JSON.stringify({
          name: i.value,
          id: a.id,
          value: o
        }),
        "*"
      );
    }, this.events[Ie.PostMessageToParent] = (e, i) => {
      var a;
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const s = {};
      (a = i.list) != null && a.length && i.list.forEach((o) => {
        var l;
        const r = o.params ? this.findOne(o.params) : e;
        for (let n in o.value)
          if (o.value[n] === void 0 || o.value[n] === "")
            s[n] = r[n];
          else if (typeof o.value[n] == "string" && ((l = o.value[n]) == null ? void 0 : l.indexOf("${")) > -1) {
            let h = o.value[n].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            h != null && h.length && (s[n] = r[h[0]]);
          } else
            s[n] = o.value[n];
      }), window.parent.postMessage(JSON.stringify({ name: i.value, value: s }), "*");
    }, this.events[Ie.Message] = (e, i) => {
      this.message({
        theme: i.params,
        content: i.value,
        ...i.extend
      });
    };
  }
  message(e) {
    new Yl(this.canvas.parentElement, e).init();
  }
  closeAll() {
    for (let e in Me)
      Me[e].close();
  }
  async navigatorTo(e) {
    if (!e)
      return;
    const i = new URL(window.location);
    i.searchParams.set("id", e), history.pushState({}, "", i);
    const s = this.store.options.navigatorNetWork, a = location.href.includes("2d.") || location.href.includes("/2d") ? "2d" : "v", o = await fetch(((s == null ? void 0 : s.url) || `/api/data/${a}/get`) + ((s == null ? void 0 : s.method) === "GET" ? `?id=${e}` : ""), {
      headers: {
        Authorization: `Bearer ${this.getCookie("token") || localStorage.getItem("token") || new URLSearchParams(location.search).get("token") || ""}`
      },
      method: (s == null ? void 0 : s.method) || "POST",
      body: (s == null ? void 0 : s.method) === "GET" ? void 0 : JSON.stringify({ id: e })
    });
    if (o.ok) {
      let r = await o.text();
      r.constructor === Object || r.constructor === Array ? r = JSON.parse(JSON.stringify(r)) : typeof r == "string" && (r = JSON.parse(r)), r.data && (r = r.data), this.open(r);
    } else
      this.store.emitter.emit("error", { type: "http", error: o });
  }
  doSendDataEvent(e, i) {
    let s = JSON.stringify(e);
    this.mqttClient && this.mqttClient.connected && (i ? i.split(",").forEach((a) => {
      this.mqttClient.publish(a, s);
    }) : this.store.data.mqttTopics && this.store.data.mqttTopics.split(",").forEach((a) => {
      this.mqttClient.publish(a, s);
    })), this.websocket && this.websocket.readyState === 1 && this.websocket.send(s), (this.store.data.https || this.store.data.http) && this.sendDatabyHttp(s), this.store.emitter.emit("sendData", s);
  }
  async sendDataToNetWork(e, i, s) {
    var o;
    const a = G(s.network);
    if (a.data && (Object.assign(a, a.data), delete a.data), !!a.url) {
      if (a.protocol === "http") {
        if (typeof a.headers == "object") {
          for (let h in a.headers)
            if (typeof a.headers[h] == "string") {
              let c = a.headers[h].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
              c && (a.headers[h] = a.headers[h].replace(
                `\${${c[0]}}`,
                this.getDynamicParam(c[0])
              ));
            }
        }
        let r, l = a.url;
        if (a.method === "GET" && (r = "?" + Object.keys(e).map((h) => h + "=" + e[h]).join("&")), a.method === "POST" && l.indexOf("${") > -1) {
          let h = l.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
          h && h.forEach((c) => {
            l = l.replace(`\${${c}}`, Bt(i, c) || this.getDynamicParam(c));
          });
        }
        const n = await fetch(l + (r || ""), {
          headers: a.headers || {},
          method: a.method,
          body: a.method === "POST" ? JSON.stringify(e) : void 0
        });
        if (n.ok) {
          if (s.callback) {
            const h = await n.text();
            if (!s.fn)
              try {
                if (typeof s.callback != "string")
                  throw new Error("[meta2d] Function callback must be string");
                const c = s.callback;
                s.fn = new Function("pen", "data", "context", c);
              } catch (c) {
                console.error("[meta2d]: Error on make a function:", c);
              }
            (o = s.fn) == null || o.call(s, i, h, { meta2d: this, e: s });
          }
          console.info("http消息发送成功");
        }
      } else if (a.protocol === "mqtt") {
        const r = this.mqttClients.filter(
          (l) => l.options.href === a.url
        );
        if (r && r.length)
          r[0].connected && a.topics.split(",").forEach((l) => {
            r[0].publish(l, e);
          });
        else {
          let l = wi.connect(a.url, a.options);
          l.on("connect", () => {
            console.info("mqtt连接成功"), a.topics.split(",").forEach((n) => {
              l.publish(n, e), l == null || l.end();
            });
          });
        }
      } else if (a.protocol === "websocket") {
        const r = this.websockets.filter(
          (l) => l.url === a.url
        );
        if (r && r.length)
          r[0].readyState === 1 && r[0].send(e);
        else {
          let l = new WebSocket(
            a.url,
            a.protocols || void 0
          );
          l.onopen = function() {
            console.info("websocket连接成功"), l.send(e), setTimeout(() => {
              l.close();
            }, 100);
          };
        }
      }
    }
  }
  resize(e, i) {
    this.canvas.resize(e, i), this.render(), this.store.emitter.emit("resize", { width: e, height: i }), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.init();
  }
  /**
   *
   * @param emit 是否发送消息
   */
  async addPen(e, i, s = !0, a = !1) {
    return await this.canvas.addPen(e, i, s, a);
  }
  async addPens(e, i, s = !1) {
    return await this.canvas.addPens(e, i, s);
  }
  render(e) {
    var i;
    (i = this.canvas) == null || i.render(e);
  }
  async setBackgroundImage(e, i) {
    var l, n, h, c;
    let s = this;
    async function a(d) {
      return new Promise((f) => {
        const u = new Image();
        u.src = d, s.store.options.cdn && !(d.startsWith("http") || d.startsWith("//") || d.startsWith("data:image")) && (u.src = s.store.options.cdn + d), u.crossOrigin = "anonymous", u.onload = () => {
          f(u);
        };
      });
    }
    this.store.data.bkImage = e;
    const o = (i == null ? void 0 : i.width) || ((l = this.store.data) == null ? void 0 : l.width) || ((n = this.store.options) == null ? void 0 : n.width), r = (i == null ? void 0 : i.height) || ((h = this.store.data) == null ? void 0 : h.height) || ((c = this.store.options) == null ? void 0 : c.height);
    if (o && r ? (this.canvas.canvasTemplate.canvas.style.backgroundImage = null, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0)) : this.canvas.canvasTemplate.canvas.style.backgroundImage = e ? `url('${e}')` : "", e) {
      const d = await a(e);
      this.store.bkImg = d, o && r && this.canvas && (this.canvas.canvasTemplate.init(), this.render());
    } else
      this.store.bkImg = null;
  }
  setBackgroundColor(e = this.store.data.background) {
    this.store.data.background = e, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0);
  }
  setGrid({
    grid: e = this.store.data.grid,
    gridColor: i = this.store.data.gridColor,
    gridSize: s = this.store.data.gridSize,
    gridRotate: a = this.store.data.gridRotate
  } = {}) {
    this.store.data.grid = e, this.store.data.gridColor = i, this.store.data.gridSize = s < 0 ? 0 : s, this.store.data.gridRotate = a, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0);
  }
  setRule({
    rule: e = this.store.data.rule,
    ruleColor: i = this.store.data.ruleColor
  } = {}) {
    this.store.data.rule = e, this.store.data.ruleColor = i, this.store.patchFlagsTop = !0;
  }
  open(e, i = !0) {
    if (this.clear(!1, e == null ? void 0 : e.template), this.canvas.autoPolylineFlag = !0, e) {
      this.setBackgroundImage(e.bkImage, e), Object.assign(this.store.data, e), this.store.data.pens = [];
      for (const s of e.pens)
        s.id || (s.id = ne()), !s.calculative && (s.calculative = { canvas: this.canvas }), this.store.pens[s.id] = s;
      for (const s of e.pens)
        this.canvas.makePen(s);
    }
    if (this.canvas.patchFlagsLines.forEach((s) => {
      s.type && this.canvas.initLineRect(s);
    }), this.store.data.template || (this.store.data.template = ne()), i || (this.canvas.opening = !0), this.initBindDatas(), this.initBinds(), this.initMessageEvents(), this.initGlobalTriggers(), this.render(), this.listenSocket(), this.connectSocket(), this.connectNetwork(), this.startDataMock(), this.startAnimate(), this.startVideo(), this.doInitJS(), this.doInitFn(), setTimeout(() => {
      const s = this.store.data.pens.find((a) => a.autofocus);
      s && this.focus(s.id);
    }, 100), this.store.data.iconUrls)
      for (const s of this.store.data.iconUrls)
        Pr(s, () => {
          this.render();
        });
    this.canvas.autoPolylineFlag = !1, this.store.emitter.emit("opened"), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.init();
  }
  cacheData(e) {
    if (e && this.store.options.cacheLength) {
      let i = this.store.cacheDatas.findIndex(
        (s) => s.data && s.data._id === e
      );
      if (i === -1)
        this.store.cacheDatas.push({
          data: G(this.store.data, !0)
          // offscreen: new Array(2),
          // flag: new Array(2)
        }), this.store.cacheDatas.length > this.store.options.cacheLength && this.store.cacheDatas.shift();
      else {
        let s = this.store.cacheDatas.splice(i, 1)[0];
        this.store.cacheDatas.push(s);
      }
    }
  }
  loadCacheData(e) {
    let i = this.store.cacheDatas.findIndex(
      (s) => s.data && s.data._id === e
    );
    i !== -1 && (this.store.data = this.store.cacheDatas[i].data, this.setBackgroundImage(this.store.data.bkImage), this.store.pens = {}, this.store.data.pens.forEach((s) => {
      s.calculative.canvas = this.canvas, this.store.pens[s.id] = s, re.path2dDraws[s.name] && this.store.path2dMap.set(s, re.path2dDraws[s.name](s)), s.type && this.store.path2dMap.set(s, re.path2dDraws[s.name](s)), s.image && (s.calculative.imageDrawed = !1, this.canvas.loadImage(s));
    }), this.render());
  }
  initBindDatas() {
    this.store.bindDatas = {}, this.store.data.pens.forEach((e) => {
      var i;
      (i = e.form) == null || i.forEach((s) => {
        let a;
        s.dataIds && (Array.isArray(s.dataIds) ? a = s.dataIds : a = [s.dataIds]), a == null || a.forEach((o) => {
          this.store.bindDatas[o.dataId] || (this.store.bindDatas[o.dataId] = []), this.store.bindDatas[o.dataId].push({
            id: e.id,
            formItem: s
          });
        });
      });
    });
  }
  initBinds() {
    this.jetLinksList = [], this.store.bind = {}, this.store.data.pens.forEach((e) => {
      var i;
      (i = e.realTimes) == null || i.forEach((s) => {
        if (s.bind && s.bind.id) {
          this.store.bind[s.bind.id] || (this.store.bind[s.bind.id] = []), this.store.bind[s.bind.id].push({
            id: e.id,
            key: s.key
          });
          const a = s.productId || e.productId, o = s.deviceId || e.deviceId, r = s.propertyId;
          if (a && o && r) {
            const l = this.jetLinksList.findIndex((n) => n.topic.startsWith(`/${a}/${o}`));
            l > -1 ? this.jetLinksList[l].properties.includes(s.propertyId) || this.jetLinksList[l].properties.push(s.propertyId) : this.jetLinksList.push({
              topic: `/${a}/${o}`,
              deviceId: o,
              properties: [s.propertyId]
            });
          }
        }
      });
    });
  }
  connectSocket() {
    this.connectWebsocket(), this.connectMqtt(), this.connectHttp();
  }
  /**
   * open 后执行初始化 Js ，每个图纸可配置一个初始化 js
   */
  doInitJS() {
    const e = this.store.data.initJs;
    if (e && e.trim())
      try {
        new Function("context", e)({ meta2d: this });
      } catch (i) {
        console.warn("initJs error", i);
      }
  }
  doInitFn() {
    let e = zi(), i = [];
    for (let s in e)
      e.hasOwnProperty(s) && s.startsWith("bind-") && i.push({
        id: s.replace("bind-", ""),
        dataId: s.replace("bind-", ""),
        value: e[s]
      });
    i.length && this.setDatas(i, { history: !1 });
  }
  drawLine(e) {
    e && vo(this.store), this.canvas.drawingLineName = e;
  }
  alignPenToGrid(e) {
    this.canvas.alignPenToGrid(e);
  }
  drawingPencil() {
    this.canvas.drawingPencil();
  }
  stopPencil() {
    this.canvas.stopPencil();
  }
  lock(e) {
    this.store.data.locked = e, this.finishDrawLine(!0), this.canvas.drawingLineName = "", this.stopPencil(), this.store.data.pens.forEach((i) => {
      var s;
      i.externElement === !0 && (s = i.calculative.singleton) != null && s.div && Ce(i, i.calculative.singleton.div);
    }), e > 0 && this.initMessageEvents();
  }
  // end  - 当前鼠标位置，是否作为终点
  async finishDrawLine(e) {
    await this.canvas.finishDrawline(e);
  }
  async finishPencil() {
    await this.canvas.finishPencil();
  }
  updateLineType(e, i) {
    if (!e || e.name != "line" || !i || !this.canvas[i])
      return;
    e.lineName = i;
    const s = xe(e), a = ue(e);
    s.prev = void 0, s.next = void 0, a.prev = void 0, a.next = void 0, e.calculative.worldAnchors = [s, a], e.calculative.activeAnchor = s, this.canvas[i](this.store, e, a), e.lineName === "curve" && (s.prev = {
      penId: s.penId,
      x: s.x - 50,
      y: s.y
    }, s.next = {
      penId: s.penId,
      x: s.x + 50,
      y: s.y
    }, a.prev = {
      penId: a.penId,
      x: a.x - 50,
      y: a.y
    }, a.next = {
      penId: a.penId,
      x: a.x + 50,
      y: a.y
    }), e.calculative.activeAnchor = void 0, this.canvas.initLineRect(e), this.render();
  }
  addDrawLineFn(e, i) {
    this.canvas[e] = i, this.canvas.drawLineFns.push(e);
  }
  removeDrawLineFn(e) {
    const i = this.canvas.drawLineFns.indexOf(e);
    i > -1 && this.canvas.drawLineFns.splice(i, 1);
  }
  showMagnifier() {
    this.canvas.showMagnifier();
  }
  hideMagnifier() {
    this.canvas.hideMagnifier();
  }
  toggleMagnifier() {
    this.canvas.toggleMagnifier();
  }
  /**
   * 擦除画布，释放 store 上的 pens
   * @param render 是否重绘
   */
  clear(e = !0, i) {
    var s;
    for (const a of this.store.data.pens)
      (s = a.onDestroy) == null || s.call(a, a);
    Ir(this.store, i), this.hideInput(), this.canvas.tooltip.hide(), this.map && this.map.isShow && (this.map.show(), this.map.setView()), this.canvas.clearCanvas(), sessionStorage.removeItem("page"), this.store.clipboard = void 0, this.store.sameTemplate || (this.canvas.canvasTemplate.bgPatchFlags = !0), this.store.patchFlagsBackground = !0, this.store.patchFlagsTop = !0, this.setBackgroundImage(void 0), e && this.render();
  }
  emit(e, i) {
    this.store.emitter.emit(e, i);
  }
  on(e, i) {
    return this.store.emitter.on(e, i), this;
  }
  off(e, i) {
    return this.store.emitter.off(e, i), this;
  }
  // customeDock = (store, rect, pens, offset) => {xDock, yDock}
  // customDock return:
  // {
  //   xDock: {x, y, step, prev, penId},
  //   yDock: {x, y, step, prev, penId},
  // }
  // xDock，yDock - 水平或垂直方向的参考线
  // prev - 参考线的起点
  // x,y - 参考线的终点
  // step - 自动吸附需要的偏移量
  // penId - 参考线的笔
  registerMoveDock(e) {
    this.canvas.customMoveDock = e;
  }
  /**
   * 参数同方法 registerMoveDock ，最后一个参数由 offset 偏移修改成了当前 resize 的点
   */
  registerResizeDock(e) {
    this.canvas.customResizeDock = e;
  }
  find(e) {
    return this.canvas.find(e);
  }
  findOne(e) {
    return this.canvas.findOne(e);
  }
  getPenRect(e) {
    return this.canvas.getPenRect(e);
  }
  setPenRect(e, i, s = !0) {
    this.canvas.setPenRect(e, i, s);
  }
  startAnimate(e, i) {
    this.stopAnimate(e);
    let s;
    e ? typeof e == "string" ? s = this.find(e) : s = e : s = this.store.data.pens.filter((a) => (a.type || a.frames) && a.autoPlay || a.animations && a.animations.length && a.animations.findIndex((o) => o.autoPlay) !== -1), s.length && (s.forEach((a) => {
      var o, r;
      if (a.calculative.pause) {
        const l = Date.now() - a.calculative.pause;
        a.calculative.pause = void 0, a.calculative.frameStart += l, a.calculative.frameEnd += l;
      } else {
        let l = -1;
        if (i !== void 0 && a.animations) {
          if (typeof i == "string") {
            if (l = a.animations.findIndex(
              (n) => n.name === i
            ), l === -1)
              return;
          } else if (typeof i == "number")
            if (a.animations.length > i)
              l = i;
            else
              return;
        } else i === void 0 && (l = (o = a.animations) == null ? void 0 : o.findIndex((n) => n.autoPlay), l === -1 && ((r = a.animations) != null && r.length) && (l = 0));
        if (l !== -1 && l !== void 0) {
          const n = G(a.animations[l]);
          n.animateName = n.name, delete n.name, n.currentAnimation = l, !a.type && n.frames && (n.showDuration = this.calcAnimateDuration(n)), this.setValue(
            {
              id: a.id,
              ...n
            },
            {
              doEvent: !1,
              history: !1
            }
          );
        }
        this.store.animates.add(a), a.type || this.store.animateMap.set(
          a,
          a.calculative.canvas.getFrameProps(a)
        );
      }
    }), this.initImageCanvas(s), this.canvas.animate());
  }
  pauseAnimate(e) {
    let i = [];
    e ? typeof e == "string" ? i = this.find(e) : i = e : this.store.animates.forEach((s) => {
      i.push(s);
    }), i.forEach((s) => {
      s.calculative.pause || (s.calculative.pause = Date.now());
    });
  }
  stopAnimate(e) {
    let i = [];
    e ? typeof e == "string" ? i = this.find(e) : i = e : this.store.animates.forEach((s) => {
      i.push(s);
    }), i.forEach((s) => {
      s.currentAnimation = void 0, s.calculative.pause = void 0, s.calculative.start = void 0, s.calculative.duration = void 0, s.calculative.animatePos = 0, this.store.animates.delete(s), this.canvas.restoreNodeAnimate(s), this.canvas.updateLines(s), this.store.animateMap.delete(s);
    }), this.initImageCanvas(i), setTimeout(() => {
      var s;
      (s = this.canvas) == null || s.calcActiveRect(), this.render();
    }, 20);
  }
  startVideo(e) {
    let i;
    e ? typeof e == "string" ? i = this.find(e) : i = e : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var a, o;
      (a = s.calculative.media) == null || a.play(), (o = s.onStartVideo) == null || o.call(s, s);
    });
  }
  pauseVideo(e) {
    let i = [];
    e ? typeof e == "string" ? i = this.find(e) : i = e : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var a, o;
      (a = s.calculative.media) == null || a.pause(), (o = s.onPauseVideo) == null || o.call(s, s);
    });
  }
  stopVideo(e) {
    let i = [];
    e ? typeof e == "string" ? i = this.find(e) : i = e : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var a;
      s.calculative.media && (s.calculative.media.currentTime = 0, s.calculative.media.pause()), (a = s.onStopVideo) == null || a.call(s, s);
    });
  }
  calcAnimateDuration(e) {
    return e.frames.reduce((i, s) => i + s.duration, 0);
  }
  /**
   * 组合
   * @param pens 组合的画笔们
   * @param showChild 组合后展示第几个孩子
   */
  combine(e = this.store.active, i) {
    if (!e || !e.length)
      return;
    const s = G(e);
    if (e.length === 1 && e[0].type) {
      e[0].type = fe.Node, this.canvas.active(e), this.pushHistory({
        type: ie.Update,
        initPens: s,
        pens: G(e, !0)
      }), this.render();
      return;
    }
    const a = Ue(e);
    let o = {
      id: ne(),
      name: "combine",
      ...a,
      children: [],
      showChild: i
    };
    this.canvas.makePen(o);
    const r = G(o);
    let l = 1 / 0;
    return e.forEach((n) => {
      const h = this.store.data.pens.findIndex(
        (d) => d.id === n.id
      );
      if (h < l && (l = h), n === o || n.parentId === o.id || n.id === o.id)
        return;
      o.children.push(n.id), n.parentId = o.id;
      const c = lt(n.calculative.worldRect, a);
      Object.assign(n, c), n.locked = n.lockedOnCombine ?? he.None, n.locked = n.interaction || Oi.includes(n.name) ? 0 : n.locked;
    }), this.store.data.pens.splice(l, 0, o), this.store.data.pens.pop(), this.canvas.active([o]), this.pushHistory({
      type: ie.Add,
      pens: [r],
      step: 3
    }), this.pushHistory({
      type: ie.Update,
      initPens: [r],
      pens: [o],
      step: 3
    }), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: e,
      step: 3
    }), i != null && (e.forEach((n) => {
      Ze(n, !0);
    }), this.initImageCanvas([o])), this.store.emitter.emit("combine", [o]), this.render(), o;
  }
  uncombine(e) {
    if (!e && this.store.active && (e = this.store.active[0]), !e || !e.children)
      return;
    const i = e.children.map((o) => this.store.pens[o]);
    let s = G(i);
    i.forEach((o) => {
      o.parentId = void 0, o.x = o.calculative.worldRect.x, o.y = o.calculative.worldRect.y, o.width = o.calculative.worldRect.width, o.height = o.calculative.worldRect.height, o.locked = he.None, o.calculative.active = void 0, o.calculative.hover = !1, this.setVisible(o, !0);
    });
    const a = this.isCombine(e) ? 3 : 2;
    this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: i,
      step: a
    }), s = [G(e)], e.children = void 0, this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: [e],
      step: a
    }), this.isCombine(e) && (this.delete([e]), this.store.histories[this.store.histories.length - 1].step = a), this.inactive();
  }
  appendChild(e = this.store.active) {
    if (!e || e.length < 2)
      return;
    const i = e.findIndex((s) => s.name === "combine" && s.showChild !== void 0);
    if (i !== -1) {
      let s = e[i];
      const a = Ue(e);
      Object.assign(s, a), Object.assign(s.calculative.worldRect, a), Vt(s), s.children.forEach((o) => {
        const r = this.store.pens[o], l = lt(r.calculative.worldRect, a);
        Object.assign(r, l);
      }), e.forEach((o) => {
        if (o.id !== s.id) {
          s.children.push(o.id), o.parentId = s.id;
          const r = lt(o.calculative.worldRect, a);
          Object.assign(o, r), o.locked = o.lockedOnCombine ?? he.DisableMove, o.locked = o.interaction || Oi.includes(o.name) ? 0 : o.locked, Ze(o, !0);
        }
      }), this.initImageCanvas(e), this.render();
    } else
      console.warn("Invalid operation!");
  }
  /***
   * 修改子图元大小，更新整个组合图元
   * @param rect 新的大小 世界坐标
   * @param child 待更新子图元
   * @param parent 父图元
   */
  updateRectbyChild(e, i, s) {
    if (we(e), pe(e), i.calculative.worldRect = e, tt(e, s.calculative.worldRect, !0)) {
      const a = lt(e, s.calculative.worldRect);
      Object.assign(i, a);
    } else {
      let a = Math.min(e.x, s.calculative.worldRect.x), o = Math.min(e.y, s.calculative.worldRect.y), r = Math.max(e.ex, s.calculative.worldRect.ex), l = Math.max(e.ey, s.calculative.worldRect.ey);
      s.calculative.worldRect = {
        x: a,
        y: o,
        width: r - a,
        height: l - o,
        ex: r,
        ey: l
      }, s.parentId || Object.assign(s, s.calculative.worldRect), pe(s.calculative.worldRect), s.children.forEach((n) => {
        const h = this.store.pens[n], c = lt(h.calculative.worldRect, s.calculative.worldRect);
        Object.assign(h, c);
      }), s.parentId && this.updateRectbyChild(s.calculative.worldRect, s, this.store.pens[s.parentId]);
    }
    this.canvas.updatePenRect(s), this.render();
  }
  isCombine(e) {
    return !!(e.name === "combine" || e.children && e.children.length > 0);
  }
  active(e, i = !0) {
    this.canvas.active(e, i);
  }
  inactive() {
    this.canvas.inactive();
  }
  activeAll() {
    this.canvas.active(
      this.store.data.pens.filter(
        (e) => !e.parentId && e.locked !== he.Disable
      )
    ), this.render();
  }
  focus(e) {
    const i = this.findOne(e);
    i && (this.store.hover = i, this.store.hover.calculative.hover = !0, this.showInput(i));
  }
  /**
   * 删除画笔
   * @param pens 需要删除的画笔们
   * @param canDelLocked 是否删除已经锁住的画笔
   */
  delete(e, i = !1, s = !0) {
    this.canvas.delete(e, i, s);
  }
  scale(e, i = { x: 0, y: 0 }) {
    this.canvas.scale(e, i);
  }
  translate(e, i) {
    this.canvas.translate(e, i);
  }
  translatePens(e, i, s) {
    this.canvas.translatePens(e, i, s);
  }
  getParent(e, i) {
    return Ne(e, i);
  }
  getAllChildren(e) {
    return je(e, this.store);
  }
  getAllFollowers(e) {
    return ps(e, this.store);
  }
  data() {
    const e = G(this.store.data), { pens: i, paths: s } = this.store.data;
    e.version = Ma.version, e.paths = {};
    for (const a in s)
      Object.prototype.hasOwnProperty.call(s, a) && i.find((o) => o.pathId === a) && (e.paths[a] = s[a]);
    return e.dataPoints = [...Object.keys(this.store.bind), ...Object.keys(this.store.bindDatas)], e;
  }
  copy(e) {
    this.canvas.copy(e);
  }
  cut(e) {
    this.canvas.cut(e);
  }
  paste() {
    this.canvas.paste();
  }
  undo() {
    this.canvas.undo();
  }
  redo() {
    this.canvas.redo();
  }
  listenSocket() {
    try {
      let e;
      const i = this.store.data.socketCbJs;
      if (i && (e = new Function("e", "context", i)), !e)
        return this.socketFn = null, !1;
      this.socketFn = e;
    } catch (e) {
      return console.error("Create the function for socket:", e), !1;
    }
    return !0;
  }
  connectWebsocket(e) {
    this.closeWebsocket(), e && (this.store.data.websocket = e), this.store.data.websocket && (this.websocket = new WebSocket(
      this.store.data.websocket,
      this.store.data.websocketProtocols || void 0
    ), this.websocket.onmessage = (i) => {
      this.socketCallback(i.data, {
        type: "websocket",
        url: this.store.data.websocket
      });
    }, this.websocket.onerror = (i) => {
      this.store.emitter.emit("error", { type: "websocket", error: i });
    }, this.websocket.onclose = () => {
      if (this.store.options.reconnetTimes && (this.websocketTimes++, this.websocketTimes >= this.store.options.reconnetTimes)) {
        this.websocketTimes = 0, this.closeWebsocket();
        return;
      }
      console.info("Canvas websocket closed and reconneting..."), this.connectWebsocket();
    });
  }
  closeWebsocket() {
    this.websocket && (this.websocket.onclose = void 0, this.websocket.close(), this.websocket = void 0);
  }
  connectMqtt(e) {
    if (this.closeMqtt(), e && (this.store.data.mqtt = e.mqtt, this.store.data.mqttTopics = e.mqttTopics, this.store.data.mqttOptions = e.mqttOptions), this.store.data.mqtt) {
      this.store.data.mqttOptions.clientId && !this.store.data.mqttOptions.customClientId && (this.store.data.mqttOptions.clientId = ne());
      const i = { ...this.store.data.mqttOptions };
      i.username || delete i.username, i.password || delete i.password;
      const { username: s, password: a } = i;
      s && a || !s && !a ? (this.mqttClient = wi.connect(
        this.store.data.mqtt,
        i
      ), this.mqttClient.on("message", (o, r) => {
        this.socketCallback(r.toString(), {
          topic: o,
          type: "mqtt",
          url: this.store.data.mqtt
        });
      }), this.mqttClient.on("error", (o) => {
        this.store.emitter.emit("error", { type: "mqtt", error: o });
      }), this.mqttClient.on("close", () => {
        this.store.options.reconnetTimes && (this.mqttTimes++, this.mqttTimes >= this.store.options.reconnetTimes && (this.mqttTimes = 0, this.closeMqtt()));
      }), this.store.data.mqttTopics && this.mqttClient.subscribe(this.store.data.mqttTopics.split(","))) : console.warn("缺少用户名或密码");
    }
  }
  closeMqtt() {
    var e;
    (e = this.mqttClient) == null || e.end();
  }
  connectHttp() {
    this.closeHttp();
    const { https: e } = this.store.data;
    if (e)
      this.store.data.cancelFirstConnect || e.forEach(async (i) => {
        this.oldRequestHttp(i);
      }), e.forEach((i, s) => {
        i.http && (i.times = 0, this.httpTimerList[s] = setInterval(async () => {
          this.oldRequestHttp(i), this.store.options.reconnetTimes && (i.times++, i.times >= this.store.options.reconnetTimes && (i.times = 0, clearInterval(this.httpTimerList[s]), this.httpTimerList[s] = void 0));
        }, i.httpTimeInterval || 1e3));
      });
    else {
      const { http: i, httpTimeInterval: s, httpHeaders: a } = this.store.data;
      i && (this.httpTimer = setInterval(async () => {
        const o = await fetch(i, {
          headers: a
        });
        if (o.ok) {
          const r = await o.text();
          this.socketCallback(r, { type: "http", url: i });
        }
      }, s || 1e3));
    }
  }
  async oldRequestHttp(e) {
    let i = G(e);
    if (i.http) {
      const s = await fetch(i.http, {
        headers: i.httpHeaders,
        method: i.method || "GET",
        body: i.method === "POST" ? JSON.stringify(i.body) : void 0
      });
      if (s.ok) {
        const a = await s.text();
        this.socketCallback(a, { type: "http", url: i.http });
      } else
        this.store.emitter.emit("error", { type: "http", error: s });
    }
  }
  async sendDatabyHttp(e) {
    const { https: i } = this.store.data;
    if (i)
      i.forEach(async (s) => {
        s.http && (await fetch(s.http, {
          method: "post",
          body: e,
          headers: s.httpHeaders
        })).ok && console.info("http消息发送成功");
      });
    else {
      const { http: s, httpHeaders: a } = this.store.data;
      s && (await fetch(s, {
        method: "post",
        body: e,
        headers: a
      })).ok && console.info("http消息发送成功");
    }
  }
  closeHttp() {
    clearInterval(this.httpTimer), this.httpTimer = void 0, this.httpTimerList && this.httpTimerList.forEach((e) => {
      clearInterval(e), e = void 0;
    });
  }
  connectNetwork() {
    this.closeNetwork();
    const { networks: e } = this.store.data, i = [];
    if (e) {
      let s = 0;
      this.mqttClients = [];
      let a = 0, o = 0;
      this.websockets = [], e.forEach(async (r) => {
        if (r.protocol === "mqtt")
          r.index = s, r.options.clientId && !r.options.customClientId && (r.options.clientId = ne()), r.times = 0, this.mqttClients[s] = wi.connect(r.url, r.options), this.mqttClients[s].on(
            "message",
            (l, n) => {
              this.socketCallback(n.toString(), {
                topic: l,
                type: "mqtt",
                url: r.url
              });
            }
          ), this.mqttClients[s].on("error", (l) => {
            this.store.emitter.emit("error", { type: "mqtt", error: l });
          }), this.mqttClients[s].on("close", () => {
            var l;
            this.store.options.reconnetTimes && (r.times++, r.times >= this.store.options.reconnetTimes && (r.times = 0, this.mqttClients && ((l = this.mqttClients[r.index]) == null || l.end())));
          }), r.topics && this.mqttClients[s].subscribe(r.topics.split(",")), s += 1;
        else if (r.protocol === "websocket")
          r.index = a, this.connectNetWebSocket(r), a += 1;
        else if (r.protocol === "http")
          i.push({
            url: r.url,
            interval: r.interval,
            headers: r.headers || void 0,
            method: r.method,
            body: r.body
          });
        else if (r.protocol === "iot") {
          const l = await this.getIotToken(r.devices);
          r.method === "mqtt" ? (r.index = s, this.mqttClients[s] = wi.connect(r.url), this.mqttClients[s].on("message", (n, h) => {
            this.socketCallback(h.toString(), {
              topic: `le5le-iot/properties/${l}`,
              type: "iot",
              url: r.url,
              method: "mqtt"
            });
          }), this.mqttClients[s].on("error", (n) => {
            this.store.emitter.emit("error", { type: "mqtt", error: n });
          }), this.mqttClients[s].subscribe(`le5le-iot/properties/${l}`), s += 1) : r.method === "websocket" && (r.index = a, this.websockets[a] = new WebSocket(
            `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/api/ws/iot/properties`,
            l
          ), this.websockets[a].onmessage = (n) => {
            this.socketCallback(n.data, { type: "iot", method: "websocket" });
          }, this.websockets[a].onerror = (n) => {
            this.store.emitter.emit("error", { type: "websocket", error: n });
          }, a += 1);
        } else r.protocol === "sql" ? (await this.doSqlCode("list", r.dbId, r.sql), r.interval && (r.index = o, this.sqlTimerList[o] = setInterval(async () => {
          await this.doSqlCode("list", r.dbId, r.sql);
        }, r.interval), o += 1)) : r.protocol === "jetLinks" && this.jetLinksList.length && (this.jetLinksClient = new WebSocket(
          `${r.url}/${localStorage.getItem("X-Access-Token") || this.getCookie("X-Access-Token") || new URLSearchParams(location.search).get("X-Access-Token") || ""}`
          // 'ws://8.134.86.52:29000/api/messaging/961d8b395298d3ec3a021df70d6b6ca4'
        ), this.jetLinksClient.onmessage = (l) => {
          var h;
          const n = JSON.parse(l.data);
          if (n.payload && n.payload.success && ((h = n.payload) != null && h.properties)) {
            const c = [];
            for (let d in n.payload.properties)
              d.startsWith("_") || c.push({
                id: `${n.payload.headers.productId}#${n.payload.deviceId}#${d}`,
                value: n.payload.properties[d]
              });
            this.setDatas(c, { history: !1 });
          }
        }, this.jetLinksClient.onopen = () => {
          this.jetLinksList.forEach((l) => {
            this.jetLinksClient.send(JSON.stringify({
              type: "sub",
              topic: `/device${l.topic}/message/property/report`,
              parameter: {
                deviceId: l.deviceId,
                properties: l.properties,
                history: 1
              },
              id: l.topic + "-" + ne()
            }));
          });
        });
      });
    }
    this.onNetworkConnect(i);
  }
  connectNetWebSocket(e) {
    var i;
    this.websockets[e.index] && (this.websockets[e.index].onclose = void 0, (i = this.websockets[e.index]) == null || i.close(), this.websockets[e.index] = void 0), this.websockets[e.index] = new WebSocket(
      e.url,
      e.protocols || void 0
    ), this.websockets[e.index].onmessage = (s) => {
      this.socketCallback(s.data, { type: "websocket", url: e.url });
    }, this.websockets[e.index].onerror = (s) => {
      this.store.emitter.emit("error", { type: "websocket", error: s });
    }, this.websockets[e.index].onclose = () => {
      var s;
      if (this.store.options.reconnetTimes && (e.times++, e.times >= this.store.options.reconnetTimes)) {
        e.times = 0, this.websockets[e.index].onclose = void 0, (s = this.websockets[e.index]) == null || s.close(), this.websockets[e.index] = void 0;
        return;
      }
      setTimeout(() => {
        console.info("Canvas websocket closed and reconneting..."), this.connectNetWebSocket(e);
      }, 2e3);
    };
  }
  async getIotToken(e) {
    const i = await fetch("/api/iot/subscribe/properties", {
      method: "POST",
      body: JSON.stringify({ devices: e })
    });
    if (i.ok) {
      const s = await i.text();
      return JSON.parse(s).token;
    }
  }
  async doSqlCode(e, i, s) {
    const a = await fetch(`/api/iot/data/sql/${e}`, {
      method: "POST",
      body: JSON.stringify({ dbid: i, sql: s })
    });
    if (a.ok) {
      const o = await a.text();
      o && this.socketCallback(o, { type: "sql", url: `/api/iot/data/sql/${e}` });
    }
  }
  randomString(e) {
    e = e || 32;
    let i = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", s = i.length, a = "";
    for (let o = 0; o < e; o++)
      a += i.charAt(Math.floor(Math.random() * s));
    return a;
  }
  mockValue(e) {
    let i;
    if (e.enableMock && e.mock !== void 0)
      if (e.type === "float")
        if (e.mock && e.mock.indexOf(",") !== -1) {
          let s = e.mock.split(","), a = Math.floor(Math.random() * s.length);
          i = parseFloat(s[a]);
        } else if (e.mock && e.mock.indexOf("-") !== -1) {
          let s, a, o, r = e.mock.split("-");
          if (e.mock.charAt(0) === "-" ? r.length === 4 ? (s = -parseFloat(r[3]), a = -parseFloat(r[1]), o = r[3]) : (s = parseFloat(r[2]), a = -parseFloat(r[1]), o = r[2]) : (s = parseFloat(r[1]), a = parseFloat(r[0]), o = r[1]), (o + "").indexOf(".") !== -1) {
            let l = (o + "").split(".")[1].length;
            i = (Math.random() * (s - a) + a).toFixed(
              l
            );
          } else
            i = Math.random() * (s - a) + a;
        } else
          i = parseFloat(e.mock);
      else if (e.type === "integer")
        if (e.mock && e.mock.indexOf(",") !== -1) {
          let s = e.mock.split(","), a = Math.floor(Math.random() * s.length);
          i = parseInt(s[a]);
        } else if (e.mock && e.mock.indexOf("-") !== -1) {
          let s, a, o = e.mock.split("-");
          e.mock.charAt(0) === "-" ? o.length === 4 ? (s = -parseFloat(o[3]), a = -parseFloat(o[1])) : (s = parseFloat(o[2]), a = -parseFloat(o[1])) : (s = parseInt(o[1]), a = parseInt(o[0])), i = parseInt(
            Math.random() * (s - a) + a + ""
          );
        } else
          i = parseInt(e.mock);
      else if (e.type === "bool")
        typeof e.mock == "boolean" ? i = e.mock : e.mock === "true" ? i = !0 : e.mock === "false" ? i = !1 : i = Math.random() < 0.5;
      else if (e.type === "object" || e.type === "array")
        e.mock;
      else if (e.mock && e.mock.indexOf(",") !== -1) {
        let a = e.mock.substring(1, e.mock.length - 1).split(","), o = Math.floor(Math.random() * a.length);
        i = a[o];
      } else if (e.mock && e.mock.startsWith("[") && e.mock.endsWith("]")) {
        let s = parseInt(
          e.mock.substring(1, e.mock.length - 1)
        );
        i = this.randomString(s);
      } else
        i = e.mock;
    return i;
  }
  //数据模拟
  dataMock() {
    var i, s;
    let e = [];
    (s = (i = this.store.data.dataset) == null ? void 0 : i.devices) == null || s.forEach((a) => {
      let o = this.mockValue(a);
      o !== void 0 && e.push({
        id: a.id,
        value: o
      });
    }), e.length && this.setDatas(e, {
      render: !0,
      doEvent: !0,
      history: !1
    });
  }
  startDataMock() {
    this.store.data.enableMock && (this.stopDataMock(), this.initBinds(), this.updateTimer = setInterval(() => {
      this.store.data.pens.forEach((i) => {
        this.penMock(i);
      }), this.dataMock(), this.render();
    }, this.store.data.networkInterval || 1e3));
  }
  stopDataMock() {
    clearInterval(this.updateTimer), this.updateTimer = void 0;
  }
  penMock(e) {
    var i;
    if (e.realTimes) {
      let s = {};
      if (e.realTimes.forEach((a) => {
        let o = this.mockValue(a);
        o !== void 0 && (s[a.key] = o);
      }), Object.keys(s).length) {
        let a = e.onBeforeValue ? e.onBeforeValue(e, s) : s;
        this.canvas.updateValue(e, a), (i = e.onValue) == null || i.call(e, e), this.store.emitter.emit("valueUpdate", e);
      }
    }
  }
  penNetwork(e) {
    const i = {
      url: e.apiUrl,
      method: e.apiMethod,
      headers: e.apiHeaders,
      body: e.apiBody
    };
    this.requestHttp(i), e.apiEnable ? (this.store.pensNetwork || (this.store.pensNetwork = {}), this.store.pensNetwork[e.id] = i) : delete this.store.pensNetwork[e.id];
  }
  getCookie(e) {
    let i;
    const s = new RegExp("(^| )" + e + "=([^;]*)(;|$)");
    return (i = document.cookie.match(s)) ? decodeURIComponent(i[2]) : "";
  }
  //获取动态参数
  getDynamicParam(e) {
    return zi()[e] || localStorage[e] || this.getCookie(e) || "";
  }
  onNetworkConnect(e) {
    if (e && e.length) {
      if (this.store.pensNetwork)
        for (let i in this.store.pensNetwork)
          e.push(this.store.pensNetwork[i]);
      this.store.data.cancelFirstConnect || e.forEach(async (i) => {
        this.requestHttp(i);
      }), e.forEach((i, s) => {
        i.times = 0, this.updateTimerList[s] = setInterval(async () => {
          this.requestHttp(i), this.store.options.reconnetTimes && (i.times++, i.times >= this.store.options.reconnetTimes && (i.times = 0, clearInterval(this.updateTimerList[s]), this.updateTimerList[s] = void 0));
        }, i.interval || 1e3);
      });
    }
  }
  async requestHttp(e) {
    let i = G(e);
    if (i.url) {
      if (typeof i.headers == "object") {
        for (let a in i.headers)
          if (typeof i.headers[a] == "string") {
            let o = i.headers[a].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            o && (i.headers[a] = i.headers[a].replace(
              `\${${o[0]}}`,
              this.getDynamicParam(o[0])
            ));
          }
      }
      if (typeof i.body == "object") {
        for (let a in i.body)
          if (typeof i.body[a] == "string") {
            let o = i.body[a].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            o && (i.body[a] = i.body[a].replace(
              `\${${o[0]}}`,
              this.getDynamicParam(o[0])
            ));
          }
      }
      const s = await fetch(i.url, {
        headers: i.headers,
        method: i.method,
        body: i.method === "GET" ? void 0 : JSON.stringify(i.body)
      });
      if (s.ok) {
        const a = await s.text();
        this.socketCallback(a, { type: "http", url: i.url });
      } else
        this.store.emitter.emit("error", { type: "http", error: s });
    }
  }
  closeNetwork() {
    this.mqttClients && this.mqttClients.forEach((e) => {
      e.end();
    }), this.websockets && this.websockets.forEach((e) => {
      e && (e.onclose = void 0, e.close(), e = void 0);
    }), this.mqttClients = void 0, this.websockets = void 0, this.updateTimerList && this.updateTimerList.forEach((e) => {
      clearInterval(e), e = void 0;
    }), this.sqlTimerList && this.sqlTimerList.forEach((e) => {
      clearInterval(e), e = void 0;
    });
  }
  socketCallback(e, i) {
    this.store.emitter.emit("socket", { message: e, context: i });
    let s = e;
    if (this.socketFn && (s = this.socketFn(e, {
      meta2d: this,
      type: i.type,
      topic: i.topic,
      url: i.url,
      method: i.method
    }), !s))
      return;
    s === !0 && (s = e);
    let a;
    if (s.constructor === Object || s.constructor === Array)
      a = s;
    else if (typeof s == "string")
      try {
        a = JSON.parse(s);
      } catch (o) {
        console.warn("Invalid socket data:", a, o);
      }
    else
      return;
    a && (Array.isArray(a) || (a = [a]), a.length && (a[0].dataId ? this.setDatas(a) : a.forEach((o) => {
      this.setValue(o);
    })));
  }
  // 绑定变量方式更新组件数据
  setDatas(e, {
    render: i = !0,
    doEvent: s = !0,
    history: a
  } = {}) {
    const o = /* @__PURE__ */ new Map();
    e.forEach((n) => {
      var h, c;
      (h = this.store.bindDatas[n.dataId]) == null || h.forEach(
        (d) => {
          const f = this.store.pens[d.id];
          if (!f)
            return;
          let u = o.get(f);
          if (!f.noOnBinds && typeof f.onBinds == "function") {
            if (u)
              return;
            o.set(f, f.onBinds(f, e, d.formItem));
            return;
          }
          u ? u[d.formItem.key] = n.value : (u = {
            id: d.id,
            [d.formItem.key]: n.value
          }, o.set(f, u));
        }
      ), (c = this.store.bind[n.id || n.dataId]) == null || c.forEach((d) => {
        const f = this.store.pens[d.id];
        if (!f)
          return;
        let u = o.get(f);
        u ? u[d.key] = n.value : (u = {
          id: d.id,
          [d.key]: n.value
        }, o.set(f, u));
      });
    }), this.store.data.locked && this.doDataEvent(e);
    let r, l;
    a && (r = []), o.forEach((n, h) => {
      this.setValue(n, { render: !1, doEvent: s, history: !1 }), a && (r.push(G(h, !0)), l.push(h));
    }), i && this.render(), a && this.pushHistory({
      type: ie.Update,
      initPens: r,
      pens: l
    });
  }
  setValue(e, {
    render: i = !0,
    doEvent: s = !0,
    history: a
  } = {}) {
    let o = [];
    if (!e)
      return;
    if (e.id) {
      if (e.id === this.store.data.id) {
        this.setDatabyOptions(e), e.bkImage && this.setBackgroundImage(e.bkImage), e.background && this.setBackgroundColor(e.background), this.render();
        return;
      }
      const l = this.store.pens[e.id];
      if (l)
        o = [l];
      else {
        let n = this.store.bind[e.id];
        if (n && n.length) {
          o = [], this.setDatas([e], {
            render: i,
            doEvent: s,
            history: a
          });
          return;
        }
      }
    } else if (e.dataId) {
      o = [], this.setDatas([e], {
        render: i,
        doEvent: s,
        history: a
      });
      return;
    } else if (e.tag)
      o = this.find(e.tag);
    else {
      let l = [];
      for (let n in e)
        l.push({
          dataId: n,
          id: n,
          value: e[n]
        });
      l.length && this.setDatas(l, {
        render: i,
        doEvent: s,
        history: a
      });
      return;
    }
    a = a && !this.store.data.locked;
    let r;
    if (a && (r = G(o)), o.forEach((l) => {
      var h;
      const n = l.onBeforeValue ? l.onBeforeValue(l, e) : e;
      e.frames && (this.stopAnimate([l]), e.showDuration || (e.showDuration = e.frames.reduce((c, d) => c + d.duration, 0))), Is(l, n), this.canvas.updateValue(l, n), (h = l.onValue) == null || h.call(l, l);
    }), !this.store.data.locked && this.store.active.length && !this.canvas.movingPens && this.canvas.calcActiveRect(), a) {
      let l = G(o);
      this.pushHistory({
        type: ie.Update,
        initPens: r,
        pens: l
      });
    }
    s && o.forEach((l) => {
      this.store.emitter.emit("valueUpdate", l);
    }), i && this.render();
  }
  /**
   * @deprecated 改用 setValue
   */
  _setValue(e, i = !1) {
    this.setValue(e, { history: i, render: !1, doEvent: !1 });
  }
  pushHistory(e) {
    this.canvas.pushHistory(e);
  }
  showInput(e, i) {
    this.canvas.showInput(e, i);
  }
  hideInput() {
    this.canvas.hideInput();
  }
  clearDropdownList() {
    this.canvas.clearDropdownList();
  }
  clearRuleLines() {
    this.canvas.clearRuleLines();
  }
  doMessageEvent(e, i) {
    this.store.messageEvents[e] && this.store.messageEvents[e].forEach((s) => {
      let a = !1;
      s.event.conditions && s.event.conditions.length ? s.event.conditionType === "and" ? a = s.event.conditions.every((o) => this.judgeCondition(s.pen, o.key, o)) : s.event.conditionType === "or" && (a = s.event.conditions.some((o) => this.judgeCondition(s.pen, o.key, o))) : a = !0, a && s.event.actions.forEach((o) => {
        this.events[o.action](s.pen, o);
      });
    });
  }
  initGlobalTriggers() {
    var e;
    this.store.globalTriggers = {}, (e = this.store.data.triggers) == null || e.forEach((i) => {
      i.conditions.forEach((s) => {
        s.source && (this.store.globalTriggers[s.source] || (this.store.globalTriggers[s.source] = []), this.store.globalTriggers[s.source].includes(i) || this.store.globalTriggers[s.source].push(i));
      });
    });
  }
  initMessageEvents() {
    this.store.messageEvents = {}, this.store.data.pens.forEach((e) => {
      var i;
      (i = e.events) == null || i.forEach((s) => {
        s.name === "message" && s.message && (this.store.messageEvents[s.message] || (this.store.messageEvents[s.message] = []), this.store.messageEvents[s.message].push({
          pen: e,
          event: s
        }));
      });
    });
  }
  dataJudegeCondition(e, i, s) {
    const { type: a, target: o, fnJs: r, fn: l, operator: n, valueType: h } = s;
    let c = !1;
    if (a === "fn") {
      if (l)
        c = l(e, { meta2d: this });
      else if (r) {
        try {
          s.fn = new Function("data", "context", r);
        } catch (d) {
          console.error("Error: make function:", d);
        }
        s.fn && (c = s.fn(e, { meta2d: this }));
      }
    } else {
      let d = s.value;
      h === "prop" && (d = e[s.value]);
      let f = e[i];
      switch (n) {
        case ">":
          c = f > +d;
          break;
        case ">=":
          c = f >= +d;
          break;
        case "<":
          c = f < +d;
          break;
        case "<=":
          c = f <= +d;
          break;
        case "=":
        case "==":
          c = f == d;
          break;
        case "!=":
          c = f != d;
          break;
        case "[)":
          c = _t(+f, d);
          break;
        case "![)":
          c = !_t(+f, d);
          break;
        case "[]":
          c = Lt(f, d);
          break;
        case "![]":
          c = !Lt(f, d);
          break;
      }
    }
    return c;
  }
  judgeCondition(e, i, s) {
    const { type: a, target: o, fnJs: r, fn: l, operator: n, valueType: h } = s;
    let c = !1;
    if (a === "fn") {
      if (l)
        c = l(e, { meta2d: this });
      else if (r) {
        try {
          s.fn = new Function("pen", "context", r);
        } catch (d) {
          console.error("Error: make function:", d);
        }
        s.fn && (c = s.fn(e, { meta2d: this }));
      }
    } else {
      let d = s.value;
      h === "prop" && (d = this.store.pens[o][s.value]);
      let f = Bt(e, i);
      switch (["x", "y", "width", "height"].includes(i) && (f = this.getPenRect(e)[i]), n) {
        case ">":
          c = f > +d;
          break;
        case ">=":
          c = f >= +d;
          break;
        case "<":
          c = f < +d;
          break;
        case "<=":
          c = f <= +d;
          break;
        case "=":
        case "==":
          c = f == d;
          break;
        case "!=":
          c = f != d;
          break;
        case "[)":
          c = _t(+f, d);
          break;
        case "![)":
          c = !_t(+f, d);
          break;
        case "[]":
          c = Lt(f, d);
          break;
        case "![]":
          c = !Lt(f, d);
          break;
      }
    }
    return c;
  }
  pushChildren(e, i) {
    const s = [G(e, !0)], a = [];
    e.children || (e.children = []);
    const o = [];
    i.forEach((l) => {
      let n = G(l, !0);
      if ((!l.id || !this.store.pens[l.id]) && (this.canvas.makePen(l), n = null), l.parentId) {
        const c = this.store.pens[l.parentId], d = c.children.findIndex((f) => f === l.id);
        s.push(G(c, !0)), c.children.splice(d, 1), o.push(G(c, !0));
      }
      e.children.push(l.id), l.parentId = e.id;
      const h = lt(
        l.calculative.worldRect,
        e.calculative.worldRect
      );
      Object.assign(l, h), l.locked = l.lockedOnCombine ?? he.DisableMove, l.locked = l.interaction || Oi.includes(l.name) ? 0 : l.locked, n ? (s.push(n), o.push(G(l, !0))) : a.push(G(l, !0));
    }), o.push(G(e, !0));
    let r = 1;
    a.length && (r = 2, this.pushHistory({
      type: ie.Add,
      pens: a,
      step: r
    })), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: o,
      step: r
    });
  }
  toPng(e, i, s = !1, a) {
    return this.canvas.toPng(e, i, s, a);
  }
  activeToPng(e, i) {
    return this.canvas.activeToPng(e, i);
  }
  pensToPng(e = this.store.active, i, s) {
    return this.canvas.pensToPng(e, i, s);
  }
  /**
   * 下载 png
   * @param name 传入参数自带文件后缀名 例如：'test.png'
   * @param padding 上右下左的内边距
   */
  downloadPng(e, i, s) {
    var a;
    for (const o of this.store.data.pens)
      (o.calculative.img || ["iframe"].includes(o.name)) && ((a = o.onRenderPenRaw) == null || a.call(o, o));
    setTimeout(() => {
      const o = document.createElement("a");
      o.setAttribute(
        "download",
        (e || this.store.data.name || "le5le.meta2d") + ".png"
      ), o.setAttribute("href", this.toPng(i, void 0, !0, s));
      const r = document.createEvent("MouseEvents");
      r.initEvent("click", !0, !0), o.dispatchEvent(r);
    }, 1e3);
  }
  downloadSvg() {
    if (!window.C2S)
      throw console.error(
        "请先加载乐吾乐官网下的canvas2svg.js",
        "https://assets.le5lecdn.com/2d/canvas2svg.js"
      ), new Error("请先加载乐吾乐官网下的canvas2svg.js");
    const e = this.getRect();
    e.x -= 10, e.y -= 10;
    const i = new window.C2S(e.width + 20, e.height + 20);
    i.textBaseline = "middle";
    for (const h of this.store.data.pens)
      h.visible == !1 || !Ci(h, this.store) || Ti(i, h, e, !0);
    let s = i.getSerializedSvg();
    this.store.data.background ? (s = s.replace("{{bk}}", ""), s = s.replace(
      "{{bkRect}}",
      `<rect x="0" y="0" width="100%" height="100%" fill="${this.store.data.background}"></rect>`
    )) : (s = s.replace("{{bk}}", ""), s = s.replace("{{bkRect}}", "")), s = s.replace(/--le5le--/g, "&#x");
    const a = window.URL, o = new Blob([s]), r = a.createObjectURL(o), l = document.createElement("a");
    l.setAttribute("download", `${this.store.data.name || "le5le.meta2d"}.svg`), l.setAttribute("href", r);
    const n = document.createEvent("MouseEvents");
    n.initEvent("click", !0, !0), l.dispatchEvent(n);
  }
  getRect(e = this.store.data.pens) {
    return Ue(e);
  }
  hiddenTemplate() {
    this.canvas.canvasTemplate.hidden();
  }
  showTemplate() {
    this.canvas.canvasTemplate.show();
  }
  lockTemplate(e) {
    this.store.data.pens.forEach((i) => {
      i.canvasLayer === de.CanvasTemplate && (i.locked = e);
    });
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitView(e = !0, i = 10) {
    var d, f;
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: a, offsetHeight: o } = s;
    this.resize(a, o);
    const r = Qe(i), l = this.getRect(), n = (a - r[1] - r[3]) / l.width, h = (o - r[0] - r[2]) / l.height;
    let c = n;
    e ? c = n > h ? h : n : c = n > h ? n : h, (d = this.store.data.fits) != null && d.length && (this.canvas.opening = !0), this.scale(c * this.store.data.scale), this.centerView(), (f = this.store.data.fits) != null && f.length && this.fillView();
  }
  fillView() {
    var a, o;
    const e = this.getRect(), i = this.canvas.width - e.width, s = this.canvas.height - e.height;
    if (Math.abs(i) > 10) {
      (a = this.store.data.fits) == null || a.forEach((l) => {
        let n = [];
        l.children.forEach((c) => {
          this.store.pens[c].locked = he.None, n.push(this.store.pens[c]);
        });
        let h = i / 2;
        if (l.left && l.right) {
          let c = l.leftValue, d = l.rightValue;
          c ? c = Math.abs(c) < 1 ? c * this.canvas.width : c : c = 0, d ? d = Math.abs(d) < 1 ? d * this.canvas.width : d : d = 0;
          let f = (this.canvas.width - c - d) / (e.width - c - d);
          n.forEach((u) => {
            var g;
            u.image && u.imageRatio && u.calculative.worldRect.width / this.canvas.width > 0.1 && (u.imageRatio = !1), u.calculative.worldRect.x = e.x - i / 2 + c + (u.calculative.worldRect.x - e.x) * f, u.calculative.worldRect.width *= f, u.calculative.worldRect.ex = u.calculative.worldRect.x + u.calculative.worldRect.width, u.calculative.width = u.calculative.worldRect.width, u.calculative.x = u.calculative.worldRect.x, u.width = u.calculative.worldRect.width, u.x = u.calculative.worldRect.x, this.canvas.updatePenRect(u, { worldRectIsReady: !1 }), u.externElement && ((g = u.onResize) == null || g.call(u, u));
          });
        } else l.left ? (h = -h, l.leftValue && (h += Math.abs(l.leftValue) < 1 ? l.leftValue * this.canvas.width : l.leftValue), this.translatePens(n, h, 0)) : l.right && (l.rightValue && (h = h - (Math.abs(l.rightValue) < 1 ? l.rightValue * this.canvas.width : l.rightValue)), this.translatePens(n, h, 0));
      });
      const r = this.store.data.pens.filter((l) => l.name === "iframe");
      r == null || r.forEach((l) => {
        var h, c;
        const n = l.calculative.worldRect;
        if (n.width / this.store.data.scale > e.width * 0.8) {
          let d = n.width;
          l.calculative.worldRect.x = n.x - i / 2, l.calculative.worldRect.width = n.width + i, l.calculative.worldRect.ex = n.ex + i, l.operationalRect.x = l.operationalRect.x * d / l.calculative.worldRect.width, l.operationalRect.width = (l.calculative.worldRect.width - (1 - l.operationalRect.width) * d) / l.calculative.worldRect.width, (h = l.onBeforeValue) == null || h.call(l, l, {
            operationalRect: l.operationalRect
          }), (c = l.onResize) == null || c.call(l, l);
        }
      });
    }
    if (Math.abs(s) > 10) {
      (o = this.store.data.fits) == null || o.forEach((l) => {
        let n = [];
        l.children.forEach((c) => {
          this.store.pens[c].locked = he.None, n.push(this.store.pens[c]);
        });
        let h = s / 2;
        if (l.top && l.bottom) {
          let c = l.topValue, d = l.bottomValue;
          c ? c = Math.abs(c) < 1 ? c * this.canvas.height : c : c = 0, d ? d = Math.abs(d) < 1 ? d * this.canvas.height : d : d = 0;
          let f = (this.canvas.height - c - d) / (e.height - c - d);
          n.forEach((u) => {
            var g;
            u.image && u.imageRatio && u.calculative.worldRect.height / this.canvas.height > 0.1 && (u.imageRatio = !1), u.calculative.worldRect.y = e.y - s / 2 + c + (u.calculative.worldRect.y - e.y) * f, u.calculative.worldRect.height *= f, u.calculative.worldRect.ey = u.calculative.worldRect.y + u.calculative.worldRect.height, u.calculative.height = u.calculative.worldRect.height, u.calculative.y = u.calculative.worldRect.y, u.height = u.calculative.worldRect.height, u.y = u.calculative.worldRect.y, this.canvas.updatePenRect(u, { worldRectIsReady: !1 }), u.externElement && ((g = u.onResize) == null || g.call(u, u));
          });
        } else l.top ? (h = -h, l.topValue && (h += Math.abs(l.topValue) < 1 ? l.topValue * this.canvas.height : l.topValue), this.translatePens(n, 0, h)) : l.bottom && (l.bottomValue && (h = h - (Math.abs(l.bottomValue) < 1 ? l.bottomValue * this.canvas.height : l.bottomValue)), this.translatePens(n, 0, h));
      });
      const r = this.store.data.pens.filter((l) => l.name === "iframe");
      r == null || r.forEach((l) => {
        var h, c;
        const n = l.calculative.worldRect;
        if (n.height / this.store.data.scale > e.height * 0.8) {
          let d = n.height;
          l.calculative.worldRect.y = n.y - s / 2, l.calculative.worldRect.height = n.height + s, l.calculative.worldRect.ey = n.ey + s, l.operationalRect.y = l.operationalRect.y * d / l.calculative.worldRect.width, l.operationalRect.height = (l.calculative.worldRect.height - (1 - l.operationalRect.height) * d) / l.calculative.worldRect.height, (h = l.onBeforeValue) == null || h.call(l, l, {
            operationalRect: l.operationalRect
          }), (c = l.onResize) == null || c.call(l, l);
        }
      });
    }
    this.canvas.canvasTemplate.init(), this.canvas.canvasImage.init(), this.canvas.canvasImageBottom.init(), this.render(!0);
  }
  trimPens() {
    let e = this.store.data.pens.filter(
      (i) => i.name === "line" && i.anchors.length < 2
    );
    this.delete(e);
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitTemplateView(e = !0, i = 10) {
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: a, offsetHeight: o } = s, r = Qe(i), l = this.getRect(), n = (a - r[1] - r[3]) / l.width, h = (o - r[0] - r[2]) / l.height;
    let c = n;
    e ? c = n > h ? h : n : c = n > h ? n : h, this.canvas.templateScale(c * this.store.data.scale);
    let d = this.getRect(), f = this.store.data.pens.filter((u) => !u.parentId);
    this.canvas.templateTranslatePens(f, -d.x, -d.y), this.store.data.pens.forEach((u) => {
      u.type ? this.canvas.initLineRect(u) : this.canvas.updateLines(u);
    }), this.centerView();
  }
  fitSizeView(e = !0, i = 10) {
    var f, u;
    const { canvas: s } = this.canvas, { offsetWidth: a, offsetHeight: o } = s;
    this.resize(a, o);
    const r = Qe(i), l = (this.store.data.width || this.store.options.width) * this.store.data.scale, n = (this.store.data.height || this.store.options.height) * this.store.data.scale, h = (a - r[1] - r[3]) / l, c = (o - r[0] - r[2]) / n;
    let d = h;
    e === "width" ? d = h : e === "height" ? d = c : e ? d = h > c ? c : h : d = h > c ? h : c, (f = this.store.data.fits) != null && f.length && (this.canvas.opening = !0), this.scale(d * this.store.data.scale), this.centerSizeView(), (u = this.store.data.fits) != null && u.length && this.fillView();
  }
  centerSizeView() {
    const e = this.getViewCenter(), i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height, a = {
      x: 0,
      y: 0,
      width: i,
      height: s
    };
    pe(a);
    const { center: o } = a, { scale: r, origin: l, x: n, y: h } = this.store.data;
    this.translate(
      (e.x - l.x) / r - o.x - n / r,
      (e.y - l.y) / r - o.y - h / r
    );
    const { canvas: c } = this.canvas, d = (c.scrollWidth - c.offsetWidth) / 2, f = (c.scrollHeight - c.offsetHeight) / 2;
    c.scrollTo(d, f);
  }
  /**
   * 宽度放大到屏幕尺寸，并滚动到最顶部
   *
   */
  scrollView(e = 10, i = !1) {
    if (!this.hasView() || !this.canvas.scroll)
      return;
    const { canvas: s } = this.canvas, { offsetWidth: a, offsetHeight: o } = s;
    this.resize(a, o);
    const r = Qe(e), l = this.getRect(), n = (a - r[1] - r[3]) / l.width;
    this.scale(n * this.store.data.scale), this.topView(r[0]), i && this.canvas.scroll.changeMode();
  }
  screenView(e = 10, i = !0) {
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: a, offsetHeight: o } = s;
    this.resize(a, o);
    const r = Qe(e), l = this.getRect();
    let n = (a - r[1] - r[3]) / l.width;
    i || (n = (o - r[0] - r[2]) / l.height), this.scale(n * this.store.data.scale), this.topView(r[0]);
  }
  topView(e = 10) {
    if (!this.hasView()) return;
    const i = this.getRect(), s = this.getViewCenter(), a = this.getPenRect(i);
    pe(a);
    const { center: o } = a, { scale: r, origin: l, x: n, y: h } = this.store.data;
    this.translate(
      (s.x - l.x) / r - o.x - n / r,
      (e - l.y) / r - a.y - h / r
    );
    const { canvas: c } = this.canvas, d = (c.scrollWidth - c.offsetWidth) / 2, f = (c.scrollHeight - c.offsetHeight) / 2;
    c.scrollTo(d, f);
  }
  centerView() {
    if (!this.hasView()) return;
    const e = this.getRect(), i = this.getViewCenter(), s = this.getPenRect(e);
    pe(s);
    const { center: a } = s, { scale: o, origin: r, x: l, y: n } = this.store.data;
    this.translate(
      (i.x - r.x) / o - a.x - l / o,
      (i.y - r.y) / o - a.y - n / o
    );
    const { canvas: h } = this.canvas, c = (h.scrollWidth - h.offsetWidth) / 2, d = (h.scrollHeight - h.offsetHeight) / 2;
    h.scrollTo(c, d);
  }
  /**
   * 画布是否有 画笔
   * RuleLine 不算
   */
  hasView() {
    return !!this.store.data.pens.filter((e) => !e.isRuleLine).length;
  }
  getViewCenter() {
    const { width: e, height: i } = this.canvas;
    return {
      x: e / 2,
      y: i / 2
    };
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByFirst(e = this.store.data.pens, i) {
    const s = G(e), a = e[0], { width: o, height: r } = this.getPenRect(a);
    for (let l = 1; l < e.length; l++) {
      const n = e[l];
      i === "width" ? this.setValue({ id: n.id, width: o }, { render: !1, doEvent: !1 }) : i === "height" ? this.setValue(
        { id: n.id, height: r },
        { render: !1, doEvent: !1 }
      ) : this.setValue(
        { id: n.id, width: o, height: r },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: e
    });
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByLast(e = this.store.data.pens, i) {
    const s = G(e), a = e[e.length - 1], { width: o, height: r } = this.getPenRect(a);
    for (let l = 0; l < e.length - 1; l++) {
      const n = e[l];
      i === "width" ? this.setValue({ id: n.id, width: o }, { render: !1, doEvent: !1 }) : i === "height" ? this.setValue(
        { id: n.id, height: r },
        { render: !1, doEvent: !1 }
      ) : this.setValue(
        { id: n.id, width: o, height: r },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: e
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByFirst(e = this.store.data.pens) {
    const i = G(e), s = e[0], a = {};
    qt.forEach((o) => {
      a[o] = s[o];
    });
    for (let o = 1; o < e.length; o++) {
      const r = e[o];
      this.setValue(
        { id: r.id, ...a },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: ie.Update,
      initPens: i,
      pens: e
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByLast(e = this.store.data.pens) {
    const i = G(e), s = e[e.length - 1], a = {};
    qt.forEach((o) => {
      a[o] = s[o];
    });
    for (let o = 0; o < e.length - 1; o++) {
      const r = e[o];
      this.setValue(
        { id: r.id, ...a },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: ie.Update,
      initPens: i,
      pens: e
    });
  }
  setFormatPainter() {
    const e = this.store.active, i = {};
    if (e.length > 0) {
      const s = e[0];
      qt.forEach((a) => {
        i[a] = s[a] !== void 0 ? s[a] : this.store.options.defaultFormat[a] || this.store.data[a] || this.store.options[a];
      });
    } else
      qt.forEach((s) => {
        this.store.options.defaultFormat[s] || this.store.data[s] || this.store.options[s];
      });
    localStorage.setItem("meta2d-formatPainter", JSON.stringify(i));
  }
  formatPainter() {
    const e = this.store.active, i = G(e), s = JSON.parse(localStorage.getItem("meta2d-formatPainter"));
    for (let a = 0; a < e.length; a++) {
      const o = e[a];
      this.setValue(
        { id: o.id, ...s },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: ie.Update,
      initPens: i,
      pens: e
    });
  }
  clearFormatPainter() {
    const e = this.store.active, i = G(e);
    qt.forEach((s) => {
      for (let a = 0; a < e.length; a++) {
        const o = e[a], { fontSize: r, lineHeight: l } = this.store.options;
        s === "lineWidth" ? (o.lineWidth = 1, o.calculative.lineWidth = 1) : s === "fontSize" ? (o.fontSize = r, o.calculative.fontSize = r) : s === "lineHeight" ? (o.lineHeight = l, o.calculative.lineHeight = l) : (delete o[s], delete o.calculative[s]);
      }
    }), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: i,
      pens: e
    });
  }
  alignNodes(e, i = this.store.data.pens, s) {
    !s && (s = this.getPenRect(this.getRect(i)));
    const a = G(i);
    for (const o of i)
      this.alignPen(e, o, s);
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: a,
      pens: i
    });
  }
  //对齐大屏
  alignNodesV(e, i = this.store.data.pens, s = !1) {
    const a = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
    let r = {
      x: 0,
      y: 0,
      width: a,
      height: o
    };
    const l = G(i);
    if (s) {
      const n = this.store.data.scale, h = this.getRect(i), c = (h.x - this.store.data.origin.x) / n, d = (h.y - this.store.data.origin.y) / n, f = h.width / n, u = h.height / n;
      let g = 0, y = 0;
      switch (e) {
        case "left":
          g = -c;
          break;
        case "right":
          g = a - (c + f);
          break;
        case "top":
          y = -d;
          break;
        case "bottom":
          y = o - (d + u);
          break;
        case "center":
          g = a / 2 - (c + f / 2);
          break;
        case "middle":
          y = o / 2 - (d + u / 2);
          break;
      }
      this.translatePens(i, g * n, y * n);
    } else
      for (const n of i)
        this.alignPen(e, n, r);
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: l,
      pens: i
    });
  }
  /**
   * 对齐画笔，基于第一个画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByFirst(e, i = this.store.data.pens) {
    const s = G(i), a = i[0], o = this.getPenRect(a);
    for (let r = 1; r < i.length; r++) {
      const l = i[r];
      this.alignPen(e, l, o);
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: i
    });
  }
  /**
   * 对齐画笔，基于最后选中的画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByLast(e, i = this.store.data.pens) {
    const s = G(i), a = i[i.length - 1], o = this.getPenRect(a);
    for (let r = 0; r < i.length - 1; r++) {
      const l = i[r];
      this.alignPen(e, l, o);
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: s,
      pens: i
    });
  }
  /**
   * 将画笔参照 rect 进行 align 对齐
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pen 当前需要对齐的画笔
   * @param rect 参照矩形
   * @returns
   */
  alignPen(e, i, s) {
    const a = this.getPenRect(i);
    switch (e) {
      case "left":
        a.x = s.x;
        break;
      case "right":
        a.x = s.x + s.width - a.width;
        break;
      case "top":
        a.y = s.y;
        break;
      case "bottom":
        a.y = s.y + s.height - a.height;
        break;
      case "center":
        a.x = s.x + s.width / 2 - a.width / 2;
        break;
      case "middle":
        a.y = s.y + s.height / 2 - a.height / 2;
        break;
    }
    this.setValue(
      { id: i.id, ...a },
      { render: !1, doEvent: !1 }
    );
  }
  /**
   * 水平或垂直方向的均分
   * @param direction 方向，width 说明水平方向间距相同
   * @param pens 节点们，默认全部的
   * @param distance 总的宽 or 高
   */
  spaceBetweenByDirection(e, i = this.store.data.pens, s) {
    if (!s) {
      let h = 1 / 0, c = -1 / 0, d = e === "width" ? "x" : "y";
      i.forEach((f) => {
        h = Math.min(h, f.calculative.worldRect[d]), c = Math.max(c, f.calculative.worldRect["e" + d]);
      }), s = (c - h) / this.store.data.scale;
    }
    if (i = i.filter((h) => !h.parentId), i.length <= 2)
      return;
    const a = G(i), o = i.reduce((h, c) => {
      const d = this.getPenRect(c);
      return h + d[e];
    }, 0), r = (s - o) / (i.length - 1);
    i = i.sort((h, c) => e === "width" ? h.x - c.x : h.y - c.y);
    const l = this.getPenRect(i[0]);
    let n = e === "width" ? l.x : l.y;
    for (const h of i) {
      const c = this.getPenRect(h);
      e === "width" ? c.x = n : c.y = n, n += c[e] + r, this.setValue(
        { id: h.id, ...c },
        { render: !1, doEvent: !1 }
      );
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: a,
      pens: i
    });
  }
  spaceBetween(e, i) {
    this.spaceBetweenByDirection("width", e, i);
  }
  spaceBetweenColumn(e, i) {
    this.spaceBetweenByDirection("height", e, i);
  }
  layout(e = this.store.data.pens, i, s = 30) {
    const a = this.getPenRect(Ue(e));
    !i && (i = a.width), e = e.filter((h) => !h.type && !h.parentId);
    const o = G(e);
    let r = 0;
    e.forEach((h) => {
      const c = this.getPenRect(h);
      c.height > r && (r = c.height);
    });
    let l = a.x, n = a.y;
    e.forEach((h, c) => {
      const d = this.getPenRect(h);
      if (d.x = l, d.y = n + r / 2 - d.height / 2, this.setValue(
        { id: h.id, ...d },
        { render: !1, doEvent: !1 }
      ), c === e.length - 1)
        return;
      const f = l + d.width - a.x, u = this.getPenRect(e[c + 1]);
      Math.round(i - f) >= Math.round(u.width + s) ? l += d.width + s : (l = a.x, n += r + s);
    }), this.initImageCanvas(e), this.initTemplateCanvas(e), this.render(), this.pushHistory({
      type: ie.Update,
      initPens: o,
      pens: e
    });
  }
  gotoView(e) {
    const i = this.getViewCenter(), s = i.x - e.calculative.worldRect.x - e.calculative.worldRect.width / 2, a = i.y - e.calculative.worldRect.y - e.calculative.worldRect.height / 2;
    this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.translate(
      s - this.store.data.x,
      a - this.store.data.y
    ), this.store.data.x = s, this.store.data.y = a;
    for (const o of this.store.data.pens)
      Ze(o);
    this.canvas.canvasImage.init(), this.canvas.canvasImageBottom.init(), this.render();
  }
  showMap() {
    this.map || (this.map = new ql(this.canvas)), this.map.show();
  }
  hideMap() {
    this.map.hide();
  }
  onSizeUpdate() {
    this.mapTimer && (clearTimeout(this.mapTimer), this.mapTimer = void 0), this.mapTimer = setTimeout(() => {
      this.map && this.map.isShow && this.map.show(), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.resize();
    }, 500);
  }
  toggleAnchorMode() {
    this.canvas.toggleAnchorMode();
  }
  addAnchorHand() {
    this.canvas.addAnchorHand();
  }
  removeAnchorHand() {
    this.canvas.removeAnchorHand();
  }
  toggleAnchorHand() {
    this.canvas.toggleAnchorHand();
  }
  /**
   * 将该画笔置顶，即放到数组最后，最后绘制即在顶部
   * @param pens pen 置顶的画笔
   */
  top(e) {
    e || (e = this.store.active), Array.isArray(e) || (e = [e]);
    for (const i of e) {
      const s = this.store.data.pens, a = [...je(i, this.store), i].map((r) => r.id);
      s.filter((r) => a.includes(r.id)).forEach((r) => {
        const l = s.findIndex((n) => n.id === r.id);
        l > -1 && (s.push(s[l]), s.splice(l, 1), this.initTemplateCanvas([r]), this.initImageCanvas([r])), this.specificLayerMove(r, "top");
      });
    }
    this.store.emitter.emit("layer", { type: "top", pens: e });
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(e) {
    this.canvas.initImageCanvas(e);
  }
  /**
   * 模版图元图层改变
   * @param pens 本次改变的 pens
   */
  initTemplateCanvas(e) {
    this.canvas.initTemplateCanvas(e);
  }
  /**
   * 该画笔置底，即放到数组最前，最后绘制即在底部
   * @param pens 画笔们，注意 pen 必须在该数组内才有效
   */
  bottom(e) {
    e || (e = this.store.active), Array.isArray(e) || (e = [e]);
    for (const i of e) {
      const s = this.store.data.pens, a = [...je(i, this.store), i].map((r) => r.id), o = s.filter((r) => a.includes(r.id));
      for (let r = o.length - 1; r >= 0; r--) {
        const l = o[r], n = s.findIndex((h) => h.id === l.id);
        n > -1 && (s.unshift(s[n]), s.splice(n + 1, 1), this.initTemplateCanvas([l]), this.initImageCanvas([l])), this.specificLayerMove(l, "bottom");
      }
    }
    this.store.emitter.emit("layer", { type: "bottom", pens: e });
  }
  /**
   * data.pens 决定了绘制顺序，即越后面的越在上层
   * 该方法通过区域重叠计算，找出该画笔之后第一个与其重叠的画笔，然后把该画笔放到找出的画笔之后
   * @param pen 画笔
   */
  upByArea(e) {
    if (this.store.data.pens.findIndex((n) => n.id === e.id) === -1) {
      console.warn("upByArea: pen not in canvas");
      return;
    }
    const s = [e, ...je(e, this.store)];
    let a = s.map(
      (n) => this.store.data.pens.findIndex((h) => h.id === n.id)
    );
    a.includes(-1) && (console.warn("upByArea: pen children not in canvas"), a = a.filter((n) => n !== -1));
    const o = Math.min(...a), r = e.calculative.worldRect, l = this.store.data.pens.findIndex((n, h) => {
      if (h <= o || n.id === e.id || _r(n, e))
        return !1;
      const c = n.calculative.worldRect;
      return tt(r, c);
    });
    if (l === -1) {
      this.up(e);
      return;
    }
    this.store.data.pens.splice(l + 1, 0, ...s);
    for (const n of s) {
      const h = this.store.data.pens.findIndex((c) => c.id === n.id);
      h > -1 && this.store.data.pens.splice(h, 1);
    }
    this.initImageCanvas([e]);
  }
  //特殊图元层级处理
  specificLayerMove(e, i) {
    var s;
    if (e.image && e.name !== "gif") {
      let a = de.CanvasImageBottom;
      i === "top" ? a = de.CanvasImage : (i === "up" || i === "down") && (a = de.CanvasMain), this.setValue(
        { id: e.id, canvasLayer: a },
        { render: !1, doEvent: !1, history: !1 }
      );
    } else if (e.externElement || e.name === "gif") {
      let a = 0;
      i === "top" ? (e.calculative.canvas.maxZindex += 1, a = e.calculative.canvas.maxZindex) : i === "up" ? a = e.calculative.zIndex === void 0 ? 6 : e.calculative.zIndex + 1 : i === "down" && (a = e.calculative.zIndex === void 0 ? 3 : e.calculative.zIndex - 1, a < 0 && (a = 0)), this.setValue(
        { id: e.id, zIndex: a },
        { render: !1, doEvent: !1, history: !1 }
      ), (s = e.calculative.singleton) != null && s.div && Ce(e, e.calculative.singleton.div);
    }
  }
  /**
   * 该画笔上移，即把该画笔在数组中的位置向后移动一个
   * @param pens 画笔
   */
  up(e) {
    e || (e = this.store.active), Array.isArray(e) || (e = [e]);
    for (const i of e) {
      const s = this.store.data.pens;
      if (i.children && i.children.length) {
        const a = [...je(i, this.store), i], o = [];
        for (let n = 0; n < s.length; n++) {
          const h = s[n];
          a.findIndex((c) => c.id === h.id) !== -1 && (h.temIndex = n, o.push(h));
        }
        let r = -1, l = 0;
        o.forEach((n) => {
          n.temIndex -= l, s.splice(n.temIndex, 1), l += 1, r = n.temIndex, delete n.temIndex, this.specificLayerMove(n, "up");
        }), s.splice(r + 1, 0, ...o), this.initTemplateCanvas(o), this.initImageCanvas(o);
      } else {
        const a = s.findIndex((o) => o.id === i.id);
        a > -1 && a !== s.length - 1 && (s.splice(a + 2, 0, s[a]), s.splice(a, 1), this.initTemplateCanvas([i]), this.initImageCanvas([i])), this.specificLayerMove(i, "up");
      }
    }
    this.store.emitter.emit("layer", { type: "up", pens: e });
  }
  /**
   * 该画笔下移，即把该画笔在该数组中的位置前移一个
   * @param pen 画笔
   */
  down(e) {
    e || (e = this.store.active), Array.isArray(e) || (e = [e]);
    for (const i of e) {
      const s = this.store.data.pens;
      if (i.children && i.children.length) {
        const a = [...je(i, this.store), i], o = [];
        for (let n = 0; n < s.length; n++) {
          const h = s[n];
          a.findIndex((c) => c.id === h.id) !== -1 && (h.temIndex = n, o.push(h));
        }
        let r = -1, l = 0;
        o.forEach((n, h) => {
          n.temIndex -= l, s.splice(n.temIndex, 1), l += 1, h === 0 && (r = n.temIndex), delete n.temIndex, this.specificLayerMove(n, "down");
        }), s.splice(r - 1, 0, ...o), this.initTemplateCanvas(o), this.initImageCanvas(o);
      } else {
        const a = s.findIndex((o) => o.id === i.id);
        a > -1 && a !== 0 && (s.splice(a - 1, 0, s[a]), s.splice(a + 1, 1), this.initTemplateCanvas([i]), this.initImageCanvas([i])), this.specificLayerMove(i, "down");
      }
    }
    this.store.emitter.emit("layer", { type: "down", pens: e });
  }
  setLayer(e, i, s = this.store.data.pens) {
    const a = s.findIndex((o) => o.id === e.id);
    a > -1 && (a > i ? (s.splice(i, 0, s[a]), s.splice(a + 1, 1)) : a < i && (s.splice(i, 0, s[a]), s.splice(a, 1)));
  }
  changePenId(e, i) {
    this.canvas.changePenId(e, i);
  }
  /**
   * 得到与当前节点连接的线
   * @param node 节点，非连线
   * @param type 类型，全部的连接线/入线/出线
   */
  getLines(e, i = "all") {
    var a;
    if (e.type === fe.Line)
      return [];
    const s = [];
    return (a = e.connectedLines) == null || a.forEach(({ lineId: o }) => {
      const r = this.store.pens[o];
      if (!r) {
        console.warn(e, "node contain a error connectedLine");
        return;
      }
      if (!s.find((l) => l.id === r.id))
        switch (i) {
          case "all":
            s.push(r);
            break;
          case "in":
            ue(r).connectTo === e.id && s.push(r);
            break;
          case "out":
            xe(r).connectTo === e.id && s.push(r);
            break;
        }
    }), s;
  }
  /**
   * 得到当前节点的下一个节点，即出口节点数组
   * 得到当前连线的出口节点
   * @param pen 节点或连线
   */
  nextNode(e) {
    if (e.type === fe.Line) {
      const i = this.store.pens[ue(e).connectTo];
      return i ? [i] : [];
    } else {
      const i = this.getLines(e, "out"), s = [];
      return i.forEach((a) => {
        const o = this.nextNode(a);
        for (const r of o)
          !s.find((n) => n.id === r.id) && s.push(r);
      }), s;
    }
  }
  /**
   * 得到当前节点的上一个节点，即入口节点数组
   * 得到当前连线的入口节点
   * @param pen 节点或连线
   */
  previousNode(e) {
    if (e.type === fe.Line) {
      const i = this.store.pens[xe(e).connectTo];
      return i ? [i] : [];
    } else {
      const i = this.getLines(e, "in"), s = [];
      return i.forEach((a) => {
        const o = this.previousNode(a);
        for (const r of o)
          !s.find((n) => n.id === r.id) && s.push(r);
      }), s;
    }
  }
  /**
   * 获取节点所有的下一个连接关系
   * @param pen
   *
   */
  getNext(e) {
    var s;
    if (e.type === fe.Line) {
      console.warn("非连线节点");
      return;
    }
    const i = [];
    return (s = e.connectedLines) == null || s.forEach(({ lineId: a, anchor: o }) => {
      var n, h;
      const r = (n = e.anchors) == null ? void 0 : n.filter(
        (c) => c.id === o
      )[0], l = this.findOne(a);
      if (l.anchors[0].connectTo == e.id) {
        const c = l.anchors[l.anchors.length - 1].connectTo;
        if (c) {
          const d = this.findOne(c), f = (h = d.connectedLines) == null ? void 0 : h.filter(
            (g) => g.lineId === l.id
          )[0], u = d.anchors.filter(
            (g) => g.id === f.anchor
          )[0];
          i.push({
            from: e,
            fromAnchor: r,
            line: l,
            to: d,
            toAnchor: u
          });
        }
      }
    }), i;
  }
  /**
   * 为画布添加锚点
   * @param pen 画笔
   * @param anchor 待添加锚点
   * @param index 连线类型 添加锚点到哪个位置
   */
  addAnchor(e, i, s) {
    if (!e)
      return;
    if (e.anchors || (e.anchors = []), e.calculative.worldAnchors || (e.calculative.worldAnchors = []), e.type === fe.Line && (s < 0 && (s = e.anchors.length + 1 + s), s > e.anchors.length && (s = e.anchors.length), s < 0 && (s = 0), s == 0 && e.anchors[0].connectTo || s == e.anchors.length && e.anchors[s - 1].connectTo)) {
      console.warn("端点存在连接关系");
      return;
    }
    let a = null, o = null;
    i.x <= 1 && i.x >= 0 && i.y <= 1 && i.y >= 0 ? (o = {
      id: i.id || ne(),
      penId: e.id,
      x: e.calculative.worldRect.x + e.calculative.worldRect.width * i.x,
      y: e.calculative.worldRect.y + e.calculative.worldRect.height * i.y
    }, e.calculative.worldRect && e.rotate % 360 && ve(
      o,
      e.rotate,
      e.calculative.worldRect.center
    ), a = {
      id: o.id,
      penId: e.id,
      x: i.x,
      y: i.y
    }) : (o = {
      id: i.id || ne(),
      penId: e.id,
      x: i.x,
      y: i.y
    }, e.calculative.worldRect && (e.rotate % 360 && ve(i, -e.rotate, e.calculative.worldRect.center), a = {
      id: o.id,
      penId: e.id,
      x: (i.x - e.calculative.worldRect.x) / e.calculative.worldRect.width,
      y: (i.y - e.calculative.worldRect.y) / e.calculative.worldRect.height
    })), e.type === fe.Line ? (e.calculative.worldAnchors.splice(s, 0, o), e.anchors.splice(s, 0, a), this.canvas.updateLines(e), this.canvas.initLineRect(e), this.render()) : (e.calculative.worldAnchors.push(o), e.anchors.push(a));
  }
  /**
   *
   * @param from 连接节点
   * @param fromAnchor 连接节点锚点
   * @param to 被连接节点
   * @param toAnchor 被连接节点锚点
   */
  connectLine(e, i, s, a, o = !0) {
    if (!s) {
      const h = i.calculative.worldRect;
      s = zt(e, {
        x: h.x + h.width / 2,
        y: h.y + h.height / 2
      });
    }
    if (!a) {
      const h = e.calculative.worldRect;
      a = zt(i, {
        x: h.x + h.width / 2,
        y: h.y + h.height / 2
      });
    }
    const r = Math.abs(s.x - a.x), n = {
      height: Math.abs(s.y - a.y),
      lineName: "line",
      lineWidth: 1,
      name: "line",
      type: 1,
      width: r,
      x: Math.min(s.x, a.x),
      y: Math.min(s.y, a.y),
      anchors: [
        {
          x: s.x > a.x ? 1 : 0,
          y: s.y > a.y ? 1 : 0,
          id: ne()
        },
        {
          x: s.x > a.x ? 0 : 1,
          y: s.x > a.x ? 0 : 1,
          id: ne()
        }
      ]
    };
    return this.addPens([n]), Ae(e, s, n, n.calculative.worldAnchors[0]), Ae(i, a, n, n.calculative.worldAnchors[1]), n.calculative.active = !1, this.canvas.updateLines(n), this.canvas.updateLines(e), this.canvas.updateLines(i), this.canvas.initLineRect(n), o && this.render(), n;
  }
  /**
   * 生成一个拷贝组合后的 画笔数组（组合图形），不影响原画布画笔，常用作 二次复用的组件
   * @param pens 画笔数组
   * @param showChild 是否作为状态复用（参考 combine showChild）
   * @param anchor 是否产生默认的锚点
   * @returns 组合图形
   */
  toComponent(e = this.store.data.pens, i, s) {
    if (e.length === 1) {
      const c = G(e[0]);
      return c.type = fe.Node, c.id = void 0, [c];
    }
    const a = G(e, !0), o = Ue(a);
    let r = {
      id: ne(),
      name: "combine",
      ...o,
      children: [],
      showChild: i
    };
    s && (r.anchors = [
      {
        id: "0",
        penId: r.id,
        x: 0.5,
        y: 0
      },
      {
        id: "1",
        penId: r.id,
        x: 1,
        y: 0.5
      },
      {
        id: "2",
        penId: r.id,
        x: 0.5,
        y: 1
      },
      {
        id: "3",
        penId: r.id,
        x: 0,
        y: 0.5
      }
    ]);
    const l = a.filter((c) => !c.parentId), n = a.find((c) => c.width === o.width && c.height === o.height), h = n && i === void 0;
    return l.length === 1 ? r = l[0] : h && (n.children || (n.children = []), r = n), a.forEach((c) => {
      if (c === r || c.parentId === r.id || c.parentId)
        return;
      r.children.push(c.id), c.parentId = r.id;
      const d = lt(c.calculative.worldRect, o);
      Object.assign(c, d), c.locked = c.lockedOnCombine ?? he.DisableMove;
    }), h || l.length === 1 ? G(a) : G([r, ...a]);
  }
  // TODO 安装pen插件 此处是否应当进行相关的适配？不再让插件内部处理install的目标逻辑？
  /**
   * @description 安装插件方法
   * @param plugins 插件列表及其配置项
   * @param pen {string | Pen} 接受tag、name、或者Pen对象*/
  installPenPlugins(e, i) {
    if (!e.tag && !e.name && !e.id) return;
    let s;
    e.id ? s = "id" : e.tag ? s = "tag" : e.name && (s = "name"), i.forEach((a) => {
      let o = a.plugin, r = a.options;
      if (o && fn(o) && s)
        if (o.install(e, r), !this.penPluginMap.has(o))
          this.penPluginMap.set(o, [{ [s]: e[s], option: r }]);
        else {
          let l = this.penPluginMap.get(o).find((n) => n[s] === e[s]);
          l ? l.option = r : this.penPluginMap.get(o).push({
            [s]: e[s],
            option: r
          });
        }
    });
  }
  uninstallPenPlugins(e, i) {
    let s;
    e.id ? s = "id" : e.tag ? s = "tag" : e.name && (s = "name"), s && i.forEach((a) => {
      let o = a.plugin;
      o.uninstall(e, a.options);
      let r = this.penPluginMap.get(o), l = r.findIndex((n) => n[s] === e[s]);
      l !== -1 && (r.splice(l, 1), r.length === 0 && this.penPluginMap.delete(o));
    });
  }
  setVisible(e, i, s = !0) {
    if (this.onSizeUpdate(), this.setValue({ id: e.id, visible: i }, { render: !1, doEvent: !1 }), e.children)
      for (const o of e.children) {
        const r = this.store.pens[o];
        r && this.setVisible(r, i, !1);
      }
    let a = je(e, this.store);
    a.push(e), this.initImageCanvas(a), s && this.render();
  }
  clearHover() {
    this.canvas.clearHover();
  }
  closeSocket() {
    this.closeWebsocket(), this.closeMqtt(), this.closeHttp();
  }
  destroy(e) {
    if (this.clear(!1), this.stopDataMock(), this.closeSocket(), this.closeNetwork(), this.closeAll(), this.store.emitter.all.clear(), this.canvas.destroy(), this.canvas = void 0, re[this.store.id] = void 0, !e) {
      for (const i in re)
        delete re[i];
      re.path2dDraws = {}, re.canvasDraws = {}, re.anchors = {}, re.htmlElements = {};
    }
  }
}
const Xl = [
  {
    元件类型: "C",
    释义: "电容",
    类型: "27",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-13)",
    右下角坐标: "(30,13)",
    "宽度(X向)": "60",
    "高度(Y向)": "26",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "R",
    释义: "电阻",
    类型: "27",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-11)",
    右下角坐标: "(30,11)",
    "宽度(X向)": "60",
    "高度(Y向)": "22",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "TerminalsXT",
    释义: "端子",
    类型: "27",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "(-22,-12)",
    右下角坐标: "(22,12)",
    "宽度(X向)": "44",
    "高度(Y向)": "24",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "IProbe",
    释义: "电流表",
    类型: "4",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-35,-15)",
    右下角坐标: "(35,15)",
    "宽度(X向)": "70",
    "高度(Y向)": "30",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "GND",
    释义: "接地",
    类型: "2",
    接线盘1: "0, 0",
    接线盘2: "",
    左上角坐标: "(-12，0)",
    右下角坐标: "(12，25)",
    "宽度(X向)": "24",
    "高度(Y向)": "25",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "DoubleCoil",
    释义: "双位置继电器",
    类型: "30",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Coil",
    释义: "中间继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "CoilOffDelay",
    释义: "失电延时继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "CoilOnDelay",
    释义: "得电延时继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Contact",
    释义: "继电器常闭触电",
    类型: "18",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(20,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Contactk",
    释义: "继电器常开触电",
    类型: "17",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(20,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Switch",
    释义: "开关",
    类型: "28",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-32,-17)",
    右下角坐标: "(30,7)",
    "宽度(X向)": "62",
    "高度(Y向)": "24",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Vdc",
    释义: "电源",
    类型: "1",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-14)",
    右下角坐标: "(30,14)",
    "宽度(X向)": "60",
    "高度(Y向)": "28",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Lamp",
    释义: "灯",
    类型: "5",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-15，-30)",
    右下角坐标: "(15，30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "MultipleContact",
    释义: "多位置开关",
    类型: "28",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "80",
    "高度(Y向)": "40",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "IOput",
    释义: "IO端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "",
    "高度(Y向)": "",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "TransformerNew",
    释义: "变压器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-10，-30)",
    右下角坐标: "(10，30)",
    "宽度(X向)": "20",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Breaker",
    释义: "断路器",
    类型: "28",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(10,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Input",
    释义: "输出端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "30",
    "高度(Y向)": "20",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "Output",
    释义: "输入端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "30",
    "高度(Y向)": "20",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "RectangularNoteBox",
    释义: "注释矩形框",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "",
    "高度(Y向)": "",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "Diode",
    释义: "二极管",
    类型: "26",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-11)",
    右下角坐标: "(30,11)",
    "宽度(X向)": "60",
    "高度(Y向)": "22",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Btn_SelfReset",
    释义: "自复位按钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30,-35)",
    右下角坐标: "(30,35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Btn_SelfLock",
    释义: "自锁按钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Knob_SelfReset",
    释义: "自复位旋钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Knob_SelfLock",
    释义: "自锁旋钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "VProbe",
    释义: "电压表",
    类型: "4",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-35，-15)",
    右下角坐标: "(35，15)",
    "宽度(X向)": "70",
    "高度(Y向)": "30",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "ElectromagneticValve",
    释义: "电磁阀",
    类型: "无",
    接线盘1: "(-10, -30)",
    接线盘2: "(-10, 30)",
    左上角坐标: "(-25，-30)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "55",
    "高度(Y向)": "65",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "duanluqi_wx",
    释义: "微型断路器",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(2，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "32",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  }
], Kl = [
  {
    name: "二极管",
    icon: "svg/二极管.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/二极管.svg",
      tags: ["Diode"],
      electricTypeCode: "Diode",
      electricName: ""
    }
  },
  {
    name: "半圆-封口",
    icon: "svg/半圆-封口.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/半圆-封口.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "半圆-开口",
    icon: "svg/半圆-开口.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/半圆-开口.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "声音-扬声器",
    icon: "svg/声音-扬声器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/声音-扬声器.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "声音-蜂鸣器",
    icon: "svg/声音-蜂鸣器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/声音-蜂鸣器.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-1位",
    icon: "svg/开关-三位置-1位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-1位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-2位",
    icon: "svg/开关-三位置-2位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-2位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-3位",
    icon: "svg/开关-三位置-3位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-3位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-中间位",
    icon: "svg/开关-单刀双掷-中间位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-中间位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-右位",
    icon: "svg/开关-单刀双掷-右位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-右位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-左位",
    icon: "svg/开关-单刀双掷-左位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-左位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-惯性开关-断开",
    icon: "svg/开关-惯性开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-惯性开关-断开.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-惯性开关-闭合",
    icon: "svg/开关-惯性开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-惯性开关-闭合.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-按钮-断开",
    icon: "svg/开关-按钮-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-按钮-断开.svg",
      tags: ["Btn_SelfReset"],
      electricTypeCode: "Btn_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-按钮-闭合",
    icon: "svg/开关-按钮-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-按钮-闭合.svg",
      tags: ["Btn_SelfReset"],
      electricTypeCode: "Btn_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-断路器-断开",
    icon: "svg/开关-断路器-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-断路器-断开.svg",
      tags: ["duanluqi_wx"],
      electricTypeCode: "duanluqi_wx",
      electricName: ""
    }
  },
  {
    name: "开关-断路器-闭合",
    icon: "svg/开关-断路器-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-断路器-闭合.svg",
      tags: ["duanluqi_wx"],
      electricTypeCode: "duanluqi_wx",
      electricName: ""
    }
  },
  {
    name: "开关-自复旋转开关-断开",
    icon: "svg/开关-自复旋转开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自复旋转开关-断开.svg",
      tags: ["Knob_SelfReset"],
      electricTypeCode: "Knob_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-自复旋转开关-闭合",
    icon: "svg/开关-自复旋转开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自复旋转开关-闭合.svg",
      tags: ["Knob_SelfReset"],
      electricTypeCode: "Knob_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-自锁按钮-断开",
    icon: "svg/开关-自锁按钮-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁按钮-断开.svg",
      tags: ["Btn_SelfLock"],
      electricTypeCode: "Btn_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁按钮-闭合",
    icon: "svg/开关-自锁按钮-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁按钮-闭合.svg",
      tags: ["Btn_SelfLock"],
      electricTypeCode: "Btn_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁旋转开关-断开",
    icon: "svg/开关-自锁旋转开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁旋转开关-断开.svg",
      tags: ["Knob_SelfLock"],
      electricTypeCode: "Knob_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁旋转开关-闭合",
    icon: "svg/开关-自锁旋转开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁旋转开关-闭合.svg",
      tags: ["Knob_SelfLock"],
      electricTypeCode: "Knob_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-通用开关-断开",
    icon: "svg/开关-通用开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-通用开关-断开.svg",
      tags: ["Switch", "Contactk"],
      electricTypeCode: "Switch",
      electricName: ""
    }
  },
  {
    name: "开关-通用开关-闭合",
    icon: "svg/开关-通用开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-通用开关-闭合.svg",
      tags: ["Switch", "Contact"],
      electricTypeCode: "Switch",
      electricName: ""
    }
  },
  {
    name: "指示灯",
    icon: "svg/指示灯.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/指示灯.svg",
      tags: ["Lamp"],
      electricTypeCode: "Lamp",
      electricName: ""
    }
  },
  {
    name: "测量-电压表",
    icon: "svg/测量-电压表.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/测量-电压表.svg",
      tags: ["VProbe"],
      electricTypeCode: "VProbe",
      electricName: ""
    }
  },
  {
    name: "测量-电流表",
    icon: "svg/测量-电流表.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/测量-电流表.svg",
      tags: ["IProbe"],
      electricTypeCode: "IProbe",
      electricName: ""
    }
  },
  {
    name: "电动机-三相",
    icon: "svg/电动机-三相.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电动机-三相.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电容器",
    icon: "svg/电容器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电容器.svg",
      tags: ["C"],
      electricTypeCode: "C",
      electricName: ""
    }
  },
  {
    name: "电感-变压器",
    icon: "svg/电感-变压器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-变压器.svg",
      tags: ["TransformerNew"],
      electricTypeCode: "TransformerNew",
      electricName: ""
    }
  },
  {
    name: "电感-绕组-短",
    icon: "svg/电感-绕组-短.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-绕组-短.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电感-绕组-长",
    icon: "svg/电感-绕组-长.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-绕组-长.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电源-接地",
    icon: "svg/电源-接地.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-接地.svg",
      tags: ["GND"],
      electricTypeCode: "GND",
      electricName: ""
    }
  },
  {
    name: "电源-电池组",
    icon: "svg/电源-电池组.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-电池组.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电源-直流电源",
    icon: "svg/电源-直流电源.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-直流电源.svg",
      tags: ["Vdc"],
      electricTypeCode: "Vdc",
      electricName: ""
    }
  },
  {
    name: "电磁阀",
    icon: "svg/电磁阀.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电磁阀.svg",
      tags: ["ElectromagneticValve"],
      electricTypeCode: "ElectromagneticValve",
      electricName: ""
    }
  },
  {
    name: "电阻",
    icon: "svg/电阻.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电阻.svg",
      tags: ["R"],
      electricTypeCode: "R",
      electricName: ""
    }
  },
  {
    name: "端子-环形",
    icon: "svg/端子-环形.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/端子-环形.svg",
      tags: ["TerminalsXT"],
      electricTypeCode: "TerminalsXT",
      electricName: ""
    }
  },
  {
    name: "端子-实心",
    icon: "svg/端子-实心.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/端子-实心.svg",
      tags: ["TerminalsXT"],
      electricTypeCode: "TerminalsXT",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器-折线连接二极管",
    icon: "svg/继电器-中间继电器-折线连接二极管.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器-折线连接二极管.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器-折线连接电阻",
    icon: "svg/继电器-中间继电器-折线连接电阻.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器-折线连接电阻.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器",
    icon: "svg/继电器-中间继电器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器.svg",
      tags: ["Coil"],
      electricTypeCode: "Coil",
      electricName: ""
    }
  },
  {
    name: "继电器-双位置",
    icon: "svg/继电器-双位置.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-双位置.svg",
      tags: ["DoubleCoil"],
      electricTypeCode: "DoubleCoil",
      electricName: ""
    }
  },
  {
    name: "继电器-失电延时",
    icon: "svg/继电器-失电延时.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-失电延时.svg",
      tags: ["CoilOffDelay"],
      electricTypeCode: "CoilOffDelay",
      electricName: ""
    }
  },
  {
    name: "继电器-得电延时",
    icon: "svg/继电器-得电延时.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-得电延时.svg",
      tags: ["CoilOnDelay"],
      electricTypeCode: "CoilOnDelay",
      electricName: ""
    }
  },
  {
    name: "跨接线",
    icon: "svg/跨接线.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/跨接线.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "输出",
    icon: "svg/输入输出.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/输入输出.svg",
      tags: ["Output"],
      anchors: [
        {
          x: 0,
          y: 0.5
        }
      ],
      electricTypeCode: "Output",
      electricName: ""
    }
  },
  {
    name: "输入",
    icon: "svg/输入输出.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/输入输出.svg",
      tags: ["Input"],
      anchors: [
        {
          x: 1,
          y: 0.5
        }
      ],
      electricTypeCode: "Input",
      electricName: ""
    }
  },
  {
    name: "连接端子-插针针孔",
    icon: "svg/连接端子-插针针孔.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/连接端子-插针针孔.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "避雷器",
    icon: "svg/避雷器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/避雷器.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  }
], If = [
  {
    name: "开关",
    children: [
      {
        name: "开关-三位置",
        icon: "svg/开关-三位置-1位.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-三位置-1位.svg",
          tags: ["MultipleContact"],
          electricTypeCode: "MultipleContact",
          electricName: "",
          showChild: 0
        }
      },
      {
        name: "开关-单刀双掷",
        icon: "svg/开关-单刀双掷-中间位.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-单刀双掷-中间位.svg",
          tags: ["MultipleContact"],
          electricTypeCode: "MultipleContact",
          electricName: ""
        }
      },
      {
        name: "开关-惯性开关",
        icon: "svg/开关-惯性开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-惯性开关-断开.svg",
          tags: [""],
          electricTypeCode: "",
          electricName: ""
        }
      },
      {
        name: "开关-按钮",
        icon: "svg/开关-按钮-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-按钮-断开.svg",
          tags: ["Btn_SelfReset"],
          electricTypeCode: "Btn_SelfReset",
          electricName: ""
        }
      },
      {
        name: "开关-断路器",
        icon: "svg/开关-断路器-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-断路器-断开.svg",
          tags: ["duanluqi_wx"],
          electricTypeCode: "duanluqi_wx",
          electricName: ""
        }
      },
      {
        name: "开关-自复旋转开关",
        icon: "svg/开关-自复旋转开关-闭合.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自复旋转开关-闭合.svg",
          tags: ["Knob_SelfReset"],
          electricTypeCode: "Knob_SelfReset",
          electricName: ""
        }
      },
      {
        name: "开关-自锁按钮",
        icon: "svg/开关-自锁按钮-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自锁按钮-断开.svg",
          tags: ["Btn_SelfLock"],
          electricTypeCode: "Btn_SelfLock",
          electricName: ""
        }
      },
      {
        name: "开关-自锁旋转开关",
        icon: "svg/开关-自锁旋转开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自锁旋转开关-断开.svg",
          tags: ["Knob_SelfLock"],
          electricTypeCode: "Knob_SelfLock",
          electricName: ""
        }
      },
      {
        name: "开关-通用开关",
        icon: "svg/开关-通用开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-通用开关-断开.svg",
          tags: ["Switch"],
          electricTypeCode: "Switch",
          electricName: ""
        }
      }
    ]
  }
];
var As = {}, Ni = {};
(function(t) {
  const e = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i = e + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s = "[" + e + "][" + i + "]*", a = new RegExp("^" + s + "$"), o = function(l, n) {
    const h = [];
    let c = n.exec(l);
    for (; c; ) {
      const d = [];
      d.startIndex = n.lastIndex - c[0].length;
      const f = c.length;
      for (let u = 0; u < f; u++)
        d.push(c[u]);
      h.push(d), c = n.exec(l);
    }
    return h;
  }, r = function(l) {
    const n = a.exec(l);
    return !(n === null || typeof n > "u");
  };
  t.isExist = function(l) {
    return typeof l < "u";
  }, t.isEmptyObject = function(l) {
    return Object.keys(l).length === 0;
  }, t.merge = function(l, n, h) {
    if (n) {
      const c = Object.keys(n), d = c.length;
      for (let f = 0; f < d; f++)
        h === "strict" ? l[c[f]] = [n[c[f]]] : l[c[f]] = n[c[f]];
    }
  }, t.getValue = function(l) {
    return t.isExist(l) ? l : "";
  }, t.isName = r, t.getAllMatches = o, t.nameRegexp = s;
})(Ni);
const Ts = Ni, Gl = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
As.validate = function(t, e) {
  e = Object.assign({}, Gl, e);
  const i = [];
  let s = !1, a = !1;
  t[0] === "\uFEFF" && (t = t.substr(1));
  for (let o = 0; o < t.length; o++)
    if (t[o] === "<" && t[o + 1] === "?") {
      if (o += 2, o = ua(t, o), o.err) return o;
    } else if (t[o] === "<") {
      let r = o;
      if (o++, t[o] === "!") {
        o = fa(t, o);
        continue;
      } else {
        let l = !1;
        t[o] === "/" && (l = !0, o++);
        let n = "";
        for (; o < t.length && t[o] !== ">" && t[o] !== " " && t[o] !== "	" && t[o] !== `
` && t[o] !== "\r"; o++)
          n += t[o];
        if (n = n.trim(), n[n.length - 1] === "/" && (n = n.substring(0, n.length - 1), o--), !ac(n)) {
          let d;
          return n.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + n + "' is an invalid name.", ke("InvalidTag", d, Pe(t, o));
        }
        const h = Zl(t, o);
        if (h === !1)
          return ke("InvalidAttr", "Attributes for '" + n + "' have open quote.", Pe(t, o));
        let c = h.value;
        if (o = h.index, c[c.length - 1] === "/") {
          const d = o - c.length;
          c = c.substring(0, c.length - 1);
          const f = ga(c, e);
          if (f === !0)
            s = !0;
          else
            return ke(f.err.code, f.err.msg, Pe(t, d + f.err.line));
        } else if (l)
          if (h.tagClosed) {
            if (c.trim().length > 0)
              return ke("InvalidTag", "Closing tag '" + n + "' can't have attributes or invalid starting.", Pe(t, r));
            if (i.length === 0)
              return ke("InvalidTag", "Closing tag '" + n + "' has not been opened.", Pe(t, r));
            {
              const d = i.pop();
              if (n !== d.tagName) {
                let f = Pe(t, d.tagStartPos);
                return ke(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + f.line + ", col " + f.col + ") instead of closing tag '" + n + "'.",
                  Pe(t, r)
                );
              }
              i.length == 0 && (a = !0);
            }
          } else return ke("InvalidTag", "Closing tag '" + n + "' doesn't have proper closing.", Pe(t, o));
        else {
          const d = ga(c, e);
          if (d !== !0)
            return ke(d.err.code, d.err.msg, Pe(t, o - c.length + d.err.line));
          if (a === !0)
            return ke("InvalidXml", "Multiple possible root nodes found.", Pe(t, o));
          e.unpairedTags.indexOf(n) !== -1 || i.push({ tagName: n, tagStartPos: r }), s = !0;
        }
        for (o++; o < t.length; o++)
          if (t[o] === "<")
            if (t[o + 1] === "!") {
              o++, o = fa(t, o);
              continue;
            } else if (t[o + 1] === "?") {
              if (o = ua(t, ++o), o.err) return o;
            } else
              break;
          else if (t[o] === "&") {
            const d = ic(t, o);
            if (d == -1)
              return ke("InvalidChar", "char '&' is not expected.", Pe(t, o));
            o = d;
          } else if (a === !0 && !da(t[o]))
            return ke("InvalidXml", "Extra text at the end", Pe(t, o));
        t[o] === "<" && o--;
      }
    } else {
      if (da(t[o]))
        continue;
      return ke("InvalidChar", "char '" + t[o] + "' is not expected.", Pe(t, o));
    }
  if (s) {
    if (i.length == 1)
      return ke("InvalidTag", "Unclosed tag '" + i[0].tagName + "'.", Pe(t, i[0].tagStartPos));
    if (i.length > 0)
      return ke("InvalidXml", "Invalid '" + JSON.stringify(i.map((o) => o.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else return ke("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function da(t) {
  return t === " " || t === "	" || t === `
` || t === "\r";
}
function ua(t, e) {
  const i = e;
  for (; e < t.length; e++)
    if (t[e] == "?" || t[e] == " ") {
      const s = t.substr(i, e - i);
      if (e > 5 && s === "xml")
        return ke("InvalidXml", "XML declaration allowed only at the start of the document.", Pe(t, e));
      if (t[e] == "?" && t[e + 1] == ">") {
        e++;
        break;
      } else
        continue;
    }
  return e;
}
function fa(t, e) {
  if (t.length > e + 5 && t[e + 1] === "-" && t[e + 2] === "-") {
    for (e += 3; e < t.length; e++)
      if (t[e] === "-" && t[e + 1] === "-" && t[e + 2] === ">") {
        e += 2;
        break;
      }
  } else if (t.length > e + 8 && t[e + 1] === "D" && t[e + 2] === "O" && t[e + 3] === "C" && t[e + 4] === "T" && t[e + 5] === "Y" && t[e + 6] === "P" && t[e + 7] === "E") {
    let i = 1;
    for (e += 8; e < t.length; e++)
      if (t[e] === "<")
        i++;
      else if (t[e] === ">" && (i--, i === 0))
        break;
  } else if (t.length > e + 9 && t[e + 1] === "[" && t[e + 2] === "C" && t[e + 3] === "D" && t[e + 4] === "A" && t[e + 5] === "T" && t[e + 6] === "A" && t[e + 7] === "[") {
    for (e += 8; e < t.length; e++)
      if (t[e] === "]" && t[e + 1] === "]" && t[e + 2] === ">") {
        e += 2;
        break;
      }
  }
  return e;
}
const Jl = '"', Ql = "'";
function Zl(t, e) {
  let i = "", s = "", a = !1;
  for (; e < t.length; e++) {
    if (t[e] === Jl || t[e] === Ql)
      s === "" ? s = t[e] : s !== t[e] || (s = "");
    else if (t[e] === ">" && s === "") {
      a = !0;
      break;
    }
    i += t[e];
  }
  return s !== "" ? !1 : {
    value: i,
    index: e,
    tagClosed: a
  };
}
const ec = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function ga(t, e) {
  const i = Ts.getAllMatches(t, ec), s = {};
  for (let a = 0; a < i.length; a++) {
    if (i[a][1].length === 0)
      return ke("InvalidAttr", "Attribute '" + i[a][2] + "' has no space in starting.", Yt(i[a]));
    if (i[a][3] !== void 0 && i[a][4] === void 0)
      return ke("InvalidAttr", "Attribute '" + i[a][2] + "' is without value.", Yt(i[a]));
    if (i[a][3] === void 0 && !e.allowBooleanAttributes)
      return ke("InvalidAttr", "boolean attribute '" + i[a][2] + "' is not allowed.", Yt(i[a]));
    const o = i[a][2];
    if (!sc(o))
      return ke("InvalidAttr", "Attribute '" + o + "' is an invalid name.", Yt(i[a]));
    if (!s.hasOwnProperty(o))
      s[o] = 1;
    else
      return ke("InvalidAttr", "Attribute '" + o + "' is repeated.", Yt(i[a]));
  }
  return !0;
}
function tc(t, e) {
  let i = /\d/;
  for (t[e] === "x" && (e++, i = /[\da-fA-F]/); e < t.length; e++) {
    if (t[e] === ";")
      return e;
    if (!t[e].match(i))
      break;
  }
  return -1;
}
function ic(t, e) {
  if (e++, t[e] === ";")
    return -1;
  if (t[e] === "#")
    return e++, tc(t, e);
  let i = 0;
  for (; e < t.length; e++, i++)
    if (!(t[e].match(/\w/) && i < 20)) {
      if (t[e] === ";")
        break;
      return -1;
    }
  return e;
}
function ke(t, e, i) {
  return {
    err: {
      code: t,
      msg: e,
      line: i.line || i,
      col: i.col
    }
  };
}
function sc(t) {
  return Ts.isName(t);
}
function ac(t) {
  return Ts.isName(t);
}
function Pe(t, e) {
  const i = t.substring(0, e).split(/\r?\n/);
  return {
    line: i.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: i[i.length - 1].length + 1
  };
}
function Yt(t) {
  return t.startIndex + t[1].length;
}
var Cs = {};
const bo = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(t, e) {
    return e;
  },
  attributeValueProcessor: function(t, e) {
    return e;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(t, e, i) {
    return t;
  }
  // skipEmptyListItem: false
}, oc = function(t) {
  return Object.assign({}, bo, t);
};
Cs.buildOptions = oc;
Cs.defaultOptions = bo;
class rc {
  constructor(e) {
    this.tagname = e, this.child = [], this[":@"] = {};
  }
  add(e, i) {
    e === "__proto__" && (e = "#__proto__"), this.child.push({ [e]: i });
  }
  addChild(e) {
    e.tagname === "__proto__" && (e.tagname = "#__proto__"), e[":@"] && Object.keys(e[":@"]).length > 0 ? this.child.push({ [e.tagname]: e.child, ":@": e[":@"] }) : this.child.push({ [e.tagname]: e.child });
  }
}
var nc = rc;
const lc = Ni;
function cc(t, e) {
  const i = {};
  if (t[e + 3] === "O" && t[e + 4] === "C" && t[e + 5] === "T" && t[e + 6] === "Y" && t[e + 7] === "P" && t[e + 8] === "E") {
    e = e + 9;
    let s = 1, a = !1, o = !1, r = "";
    for (; e < t.length; e++)
      if (t[e] === "<" && !o) {
        if (a && uc(t, e)) {
          e += 7;
          let l, n;
          [l, n, e] = hc(t, e + 1), n.indexOf("&") === -1 && (i[yc(l)] = {
            regx: RegExp(`&${l};`, "g"),
            val: n
          });
        } else if (a && fc(t, e)) e += 8;
        else if (a && gc(t, e)) e += 8;
        else if (a && vc(t, e)) e += 9;
        else if (dc) o = !0;
        else throw new Error("Invalid DOCTYPE");
        s++, r = "";
      } else if (t[e] === ">") {
        if (o ? t[e - 1] === "-" && t[e - 2] === "-" && (o = !1, s--) : s--, s === 0)
          break;
      } else t[e] === "[" ? a = !0 : r += t[e];
    if (s !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: i, i: e };
}
function hc(t, e) {
  let i = "";
  for (; e < t.length && t[e] !== "'" && t[e] !== '"'; e++)
    i += t[e];
  if (i = i.trim(), i.indexOf(" ") !== -1) throw new Error("External entites are not supported");
  const s = t[e++];
  let a = "";
  for (; e < t.length && t[e] !== s; e++)
    a += t[e];
  return [i, a, e];
}
function dc(t, e) {
  return t[e + 1] === "!" && t[e + 2] === "-" && t[e + 3] === "-";
}
function uc(t, e) {
  return t[e + 1] === "!" && t[e + 2] === "E" && t[e + 3] === "N" && t[e + 4] === "T" && t[e + 5] === "I" && t[e + 6] === "T" && t[e + 7] === "Y";
}
function fc(t, e) {
  return t[e + 1] === "!" && t[e + 2] === "E" && t[e + 3] === "L" && t[e + 4] === "E" && t[e + 5] === "M" && t[e + 6] === "E" && t[e + 7] === "N" && t[e + 8] === "T";
}
function gc(t, e) {
  return t[e + 1] === "!" && t[e + 2] === "A" && t[e + 3] === "T" && t[e + 4] === "T" && t[e + 5] === "L" && t[e + 6] === "I" && t[e + 7] === "S" && t[e + 8] === "T";
}
function vc(t, e) {
  return t[e + 1] === "!" && t[e + 2] === "N" && t[e + 3] === "O" && t[e + 4] === "T" && t[e + 5] === "A" && t[e + 6] === "T" && t[e + 7] === "I" && t[e + 8] === "O" && t[e + 9] === "N";
}
function yc(t) {
  if (lc.isName(t))
    return t;
  throw new Error(`Invalid entity name ${t}`);
}
var mc = cc;
const pc = /^[-+]?0x[a-fA-F0-9]+$/, bc = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const wc = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function xc(t, e = {}) {
  if (e = Object.assign({}, wc, e), !t || typeof t != "string") return t;
  let i = t.trim();
  if (e.skipLike !== void 0 && e.skipLike.test(i)) return t;
  if (e.hex && pc.test(i))
    return Number.parseInt(i, 16);
  {
    const s = bc.exec(i);
    if (s) {
      const a = s[1], o = s[2];
      let r = kc(s[3]);
      const l = s[4] || s[6];
      if (!e.leadingZeros && o.length > 0 && a && i[2] !== ".") return t;
      if (!e.leadingZeros && o.length > 0 && !a && i[1] !== ".") return t;
      {
        const n = Number(i), h = "" + n;
        return h.search(/[eE]/) !== -1 || l ? e.eNotation ? n : t : i.indexOf(".") !== -1 ? h === "0" && r === "" || h === r || a && h === "-" + r ? n : t : o ? r === h || a + r === h ? n : t : i === h || i === a + h ? n : t;
      }
    } else
      return t;
  }
}
function kc(t) {
  return t && t.indexOf(".") !== -1 && (t = t.replace(/0+$/, ""), t === "." ? t = "0" : t[0] === "." ? t = "0" + t : t[t.length - 1] === "." && (t = t.substr(0, t.length - 1))), t;
}
var Ic = xc;
function Sc(t) {
  return typeof t == "function" ? t : Array.isArray(t) ? (e) => {
    for (const i of t)
      if (typeof i == "string" && e === i || i instanceof RegExp && i.test(e))
        return !0;
  } : () => !1;
}
var wo = Sc;
const xo = Ni, $t = nc, Ac = mc, Tc = Ic, Cc = wo;
let Rc = class {
  constructor(e) {
    this.options = e, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "¢" },
      pound: { regex: /&(pound|#163);/g, val: "£" },
      yen: { regex: /&(yen|#165);/g, val: "¥" },
      euro: { regex: /&(euro|#8364);/g, val: "€" },
      copyright: { regex: /&(copy|#169);/g, val: "©" },
      reg: { regex: /&(reg|#174);/g, val: "®" },
      inr: { regex: /&(inr|#8377);/g, val: "₹" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (i, s) => String.fromCharCode(Number.parseInt(s, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (i, s) => String.fromCharCode(Number.parseInt(s, 16)) }
    }, this.addExternalEntities = Pc, this.parseXml = Nc, this.parseTextData = Ec, this.resolveNameSpace = _c, this.buildAttributesMap = Mc, this.isItStopNode = zc, this.replaceEntitiesValue = Dc, this.readStopNodeData = Fc, this.saveTextToParentTag = Bc, this.addChild = Oc, this.ignoreAttributesFn = Cc(this.options.ignoreAttributes);
  }
};
function Pc(t) {
  const e = Object.keys(t);
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    this.lastEntities[s] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: t[s]
    };
  }
}
function Ec(t, e, i, s, a, o, r) {
  if (t !== void 0 && (this.options.trimValues && !s && (t = t.trim()), t.length > 0)) {
    r || (t = this.replaceEntitiesValue(t));
    const l = this.options.tagValueProcessor(e, t, i, a, o);
    return l == null ? t : typeof l != typeof t || l !== t ? l : this.options.trimValues ? ds(t, this.options.parseTagValue, this.options.numberParseOptions) : t.trim() === t ? ds(t, this.options.parseTagValue, this.options.numberParseOptions) : t;
  }
}
function _c(t) {
  if (this.options.removeNSPrefix) {
    const e = t.split(":"), i = t.charAt(0) === "/" ? "/" : "";
    if (e[0] === "xmlns")
      return "";
    e.length === 2 && (t = i + e[1]);
  }
  return t;
}
const Lc = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Mc(t, e, i) {
  if (this.options.ignoreAttributes !== !0 && typeof t == "string") {
    const s = xo.getAllMatches(t, Lc), a = s.length, o = {};
    for (let r = 0; r < a; r++) {
      const l = this.resolveNameSpace(s[r][1]);
      if (this.ignoreAttributesFn(l, e))
        continue;
      let n = s[r][4], h = this.options.attributeNamePrefix + l;
      if (l.length)
        if (this.options.transformAttributeName && (h = this.options.transformAttributeName(h)), h === "__proto__" && (h = "#__proto__"), n !== void 0) {
          this.options.trimValues && (n = n.trim()), n = this.replaceEntitiesValue(n);
          const c = this.options.attributeValueProcessor(l, n, e);
          c == null ? o[h] = n : typeof c != typeof n || c !== n ? o[h] = c : o[h] = ds(
            n,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else this.options.allowBooleanAttributes && (o[h] = !0);
    }
    if (!Object.keys(o).length)
      return;
    if (this.options.attributesGroupName) {
      const r = {};
      return r[this.options.attributesGroupName] = o, r;
    }
    return o;
  }
}
const Nc = function(t) {
  t = t.replace(/\r\n?/g, `
`);
  const e = new $t("!xml");
  let i = e, s = "", a = "";
  for (let o = 0; o < t.length; o++)
    if (t[o] === "<")
      if (t[o + 1] === "/") {
        const l = St(t, ">", o, "Closing Tag is not closed.");
        let n = t.substring(o + 2, l).trim();
        if (this.options.removeNSPrefix) {
          const d = n.indexOf(":");
          d !== -1 && (n = n.substr(d + 1));
        }
        this.options.transformTagName && (n = this.options.transformTagName(n)), i && (s = this.saveTextToParentTag(s, i, a));
        const h = a.substring(a.lastIndexOf(".") + 1);
        if (n && this.options.unpairedTags.indexOf(n) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${n}>`);
        let c = 0;
        h && this.options.unpairedTags.indexOf(h) !== -1 ? (c = a.lastIndexOf(".", a.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : c = a.lastIndexOf("."), a = a.substring(0, c), i = this.tagsNodeStack.pop(), s = "", o = l;
      } else if (t[o + 1] === "?") {
        let l = hs(t, o, !1, "?>");
        if (!l) throw new Error("Pi Tag is not closed.");
        if (s = this.saveTextToParentTag(s, i, a), !(this.options.ignoreDeclaration && l.tagName === "?xml" || this.options.ignorePiTags)) {
          const n = new $t(l.tagName);
          n.add(this.options.textNodeName, ""), l.tagName !== l.tagExp && l.attrExpPresent && (n[":@"] = this.buildAttributesMap(l.tagExp, a, l.tagName)), this.addChild(i, n, a);
        }
        o = l.closeIndex + 1;
      } else if (t.substr(o + 1, 3) === "!--") {
        const l = St(t, "-->", o + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const n = t.substring(o + 4, l - 2);
          s = this.saveTextToParentTag(s, i, a), i.add(this.options.commentPropName, [{ [this.options.textNodeName]: n }]);
        }
        o = l;
      } else if (t.substr(o + 1, 2) === "!D") {
        const l = Ac(t, o);
        this.docTypeEntities = l.entities, o = l.i;
      } else if (t.substr(o + 1, 2) === "![") {
        const l = St(t, "]]>", o, "CDATA is not closed.") - 2, n = t.substring(o + 9, l);
        s = this.saveTextToParentTag(s, i, a);
        let h = this.parseTextData(n, i.tagname, a, !0, !1, !0, !0);
        h == null && (h = ""), this.options.cdataPropName ? i.add(this.options.cdataPropName, [{ [this.options.textNodeName]: n }]) : i.add(this.options.textNodeName, h), o = l + 2;
      } else {
        let l = hs(t, o, this.options.removeNSPrefix), n = l.tagName;
        const h = l.rawTagName;
        let c = l.tagExp, d = l.attrExpPresent, f = l.closeIndex;
        this.options.transformTagName && (n = this.options.transformTagName(n)), i && s && i.tagname !== "!xml" && (s = this.saveTextToParentTag(s, i, a, !1));
        const u = i;
        if (u && this.options.unpairedTags.indexOf(u.tagname) !== -1 && (i = this.tagsNodeStack.pop(), a = a.substring(0, a.lastIndexOf("."))), n !== e.tagname && (a += a ? "." + n : n), this.isItStopNode(this.options.stopNodes, a, n)) {
          let g = "";
          if (c.length > 0 && c.lastIndexOf("/") === c.length - 1)
            n[n.length - 1] === "/" ? (n = n.substr(0, n.length - 1), a = a.substr(0, a.length - 1), c = n) : c = c.substr(0, c.length - 1), o = l.closeIndex;
          else if (this.options.unpairedTags.indexOf(n) !== -1)
            o = l.closeIndex;
          else {
            const v = this.readStopNodeData(t, h, f + 1);
            if (!v) throw new Error(`Unexpected end of ${h}`);
            o = v.i, g = v.tagContent;
          }
          const y = new $t(n);
          n !== c && d && (y[":@"] = this.buildAttributesMap(c, a, n)), g && (g = this.parseTextData(g, n, a, !0, d, !0, !0)), a = a.substr(0, a.lastIndexOf(".")), y.add(this.options.textNodeName, g), this.addChild(i, y, a);
        } else {
          if (c.length > 0 && c.lastIndexOf("/") === c.length - 1) {
            n[n.length - 1] === "/" ? (n = n.substr(0, n.length - 1), a = a.substr(0, a.length - 1), c = n) : c = c.substr(0, c.length - 1), this.options.transformTagName && (n = this.options.transformTagName(n));
            const g = new $t(n);
            n !== c && d && (g[":@"] = this.buildAttributesMap(c, a, n)), this.addChild(i, g, a), a = a.substr(0, a.lastIndexOf("."));
          } else {
            const g = new $t(n);
            this.tagsNodeStack.push(i), n !== c && d && (g[":@"] = this.buildAttributesMap(c, a, n)), this.addChild(i, g, a), i = g;
          }
          s = "", o = f;
        }
      }
    else
      s += t[o];
  return e.child;
};
function Oc(t, e, i) {
  const s = this.options.updateTag(e.tagname, i, e[":@"]);
  s === !1 || (typeof s == "string" && (e.tagname = s), t.addChild(e));
}
const Dc = function(t) {
  if (this.options.processEntities) {
    for (let e in this.docTypeEntities) {
      const i = this.docTypeEntities[e];
      t = t.replace(i.regx, i.val);
    }
    for (let e in this.lastEntities) {
      const i = this.lastEntities[e];
      t = t.replace(i.regex, i.val);
    }
    if (this.options.htmlEntities)
      for (let e in this.htmlEntities) {
        const i = this.htmlEntities[e];
        t = t.replace(i.regex, i.val);
      }
    t = t.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return t;
};
function Bc(t, e, i, s) {
  return t && (s === void 0 && (s = Object.keys(e.child).length === 0), t = this.parseTextData(
    t,
    e.tagname,
    i,
    !1,
    e[":@"] ? Object.keys(e[":@"]).length !== 0 : !1,
    s
  ), t !== void 0 && t !== "" && e.add(this.options.textNodeName, t), t = ""), t;
}
function zc(t, e, i) {
  const s = "*." + i;
  for (const a in t) {
    const o = t[a];
    if (s === o || e === o) return !0;
  }
  return !1;
}
function Hc(t, e, i = ">") {
  let s, a = "";
  for (let o = e; o < t.length; o++) {
    let r = t[o];
    if (s)
      r === s && (s = "");
    else if (r === '"' || r === "'")
      s = r;
    else if (r === i[0])
      if (i[1]) {
        if (t[o + 1] === i[1])
          return {
            data: a,
            index: o
          };
      } else
        return {
          data: a,
          index: o
        };
    else r === "	" && (r = " ");
    a += r;
  }
}
function St(t, e, i, s) {
  const a = t.indexOf(e, i);
  if (a === -1)
    throw new Error(s);
  return a + e.length - 1;
}
function hs(t, e, i, s = ">") {
  const a = Hc(t, e + 1, s);
  if (!a) return;
  let o = a.data;
  const r = a.index, l = o.search(/\s/);
  let n = o, h = !0;
  l !== -1 && (n = o.substring(0, l), o = o.substring(l + 1).trimStart());
  const c = n;
  if (i) {
    const d = n.indexOf(":");
    d !== -1 && (n = n.substr(d + 1), h = n !== a.data.substr(d + 1));
  }
  return {
    tagName: n,
    tagExp: o,
    closeIndex: r,
    attrExpPresent: h,
    rawTagName: c
  };
}
function Fc(t, e, i) {
  const s = i;
  let a = 1;
  for (; i < t.length; i++)
    if (t[i] === "<")
      if (t[i + 1] === "/") {
        const o = St(t, ">", i, `${e} is not closed`);
        if (t.substring(i + 2, o).trim() === e && (a--, a === 0))
          return {
            tagContent: t.substring(s, i),
            i: o
          };
        i = o;
      } else if (t[i + 1] === "?")
        i = St(t, "?>", i + 1, "StopNode is not closed.");
      else if (t.substr(i + 1, 3) === "!--")
        i = St(t, "-->", i + 3, "StopNode is not closed.");
      else if (t.substr(i + 1, 2) === "![")
        i = St(t, "]]>", i, "StopNode is not closed.") - 2;
      else {
        const o = hs(t, i, ">");
        o && ((o && o.tagName) === e && o.tagExp[o.tagExp.length - 1] !== "/" && a++, i = o.closeIndex);
      }
}
function ds(t, e, i) {
  if (e && typeof t == "string") {
    const s = t.trim();
    return s === "true" ? !0 : s === "false" ? !1 : Tc(t, i);
  } else
    return xo.isExist(t) ? t : "";
}
var Wc = Rc, ko = {};
function Vc(t, e) {
  return Io(t, e);
}
function Io(t, e, i) {
  let s;
  const a = {};
  for (let o = 0; o < t.length; o++) {
    const r = t[o], l = jc(r);
    let n = "";
    if (i === void 0 ? n = l : n = i + "." + l, l === e.textNodeName)
      s === void 0 ? s = r[l] : s += "" + r[l];
    else {
      if (l === void 0)
        continue;
      if (r[l]) {
        let h = Io(r[l], e, n);
        const c = qc(h, e);
        r[":@"] ? Uc(h, r[":@"], n, e) : Object.keys(h).length === 1 && h[e.textNodeName] !== void 0 && !e.alwaysCreateTextNode ? h = h[e.textNodeName] : Object.keys(h).length === 0 && (e.alwaysCreateTextNode ? h[e.textNodeName] = "" : h = ""), a[l] !== void 0 && a.hasOwnProperty(l) ? (Array.isArray(a[l]) || (a[l] = [a[l]]), a[l].push(h)) : e.isArray(l, n, c) ? a[l] = [h] : a[l] = h;
      }
    }
  }
  return typeof s == "string" ? s.length > 0 && (a[e.textNodeName] = s) : s !== void 0 && (a[e.textNodeName] = s), a;
}
function jc(t) {
  const e = Object.keys(t);
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (s !== ":@") return s;
  }
}
function Uc(t, e, i, s) {
  if (e) {
    const a = Object.keys(e), o = a.length;
    for (let r = 0; r < o; r++) {
      const l = a[r];
      s.isArray(l, i + "." + l, !0, !0) ? t[l] = [e[l]] : t[l] = e[l];
    }
  }
}
function qc(t, e) {
  const { textNodeName: i } = e, s = Object.keys(t).length;
  return !!(s === 0 || s === 1 && (t[i] || typeof t[i] == "boolean" || t[i] === 0));
}
ko.prettify = Vc;
const { buildOptions: Yc } = Cs, $c = Wc, { prettify: Xc } = ko, Kc = As;
let Gc = class {
  constructor(e) {
    this.externalEntities = {}, this.options = Yc(e);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(e, i) {
    if (typeof e != "string") if (e.toString)
      e = e.toString();
    else
      throw new Error("XML data is accepted in String or Bytes[] form.");
    if (i) {
      i === !0 && (i = {});
      const o = Kc.validate(e, i);
      if (o !== !0)
        throw Error(`${o.err.msg}:${o.err.line}:${o.err.col}`);
    }
    const s = new $c(this.options);
    s.addExternalEntities(this.externalEntities);
    const a = s.parseXml(e);
    return this.options.preserveOrder || a === void 0 ? a : Xc(a, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(e, i) {
    if (i.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (e.indexOf("&") !== -1 || e.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (i === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[e] = i;
  }
};
var Jc = Gc;
const Qc = `
`;
function Zc(t, e) {
  let i = "";
  return e.format && e.indentBy.length > 0 && (i = Qc), So(t, e, "", i);
}
function So(t, e, i, s) {
  let a = "", o = !1;
  for (let r = 0; r < t.length; r++) {
    const l = t[r], n = eh(l);
    if (n === void 0) continue;
    let h = "";
    if (i.length === 0 ? h = n : h = `${i}.${n}`, n === e.textNodeName) {
      let g = l[n];
      th(h, e) || (g = e.tagValueProcessor(n, g), g = Ao(g, e)), o && (a += s), a += g, o = !1;
      continue;
    } else if (n === e.cdataPropName) {
      o && (a += s), a += `<![CDATA[${l[n][0][e.textNodeName]}]]>`, o = !1;
      continue;
    } else if (n === e.commentPropName) {
      a += s + `<!--${l[n][0][e.textNodeName]}-->`, o = !0;
      continue;
    } else if (n[0] === "?") {
      const g = va(l[":@"], e), y = n === "?xml" ? "" : s;
      let v = l[n][0][e.textNodeName];
      v = v.length !== 0 ? " " + v : "", a += y + `<${n}${v}${g}?>`, o = !0;
      continue;
    }
    let c = s;
    c !== "" && (c += e.indentBy);
    const d = va(l[":@"], e), f = s + `<${n}${d}`, u = So(l[n], e, h, c);
    e.unpairedTags.indexOf(n) !== -1 ? e.suppressUnpairedNode ? a += f + ">" : a += f + "/>" : (!u || u.length === 0) && e.suppressEmptyNode ? a += f + "/>" : u && u.endsWith(">") ? a += f + `>${u}${s}</${n}>` : (a += f + ">", u && s !== "" && (u.includes("/>") || u.includes("</")) ? a += s + e.indentBy + u + s : a += u, a += `</${n}>`), o = !0;
  }
  return a;
}
function eh(t) {
  const e = Object.keys(t);
  for (let i = 0; i < e.length; i++) {
    const s = e[i];
    if (t.hasOwnProperty(s) && s !== ":@")
      return s;
  }
}
function va(t, e) {
  let i = "";
  if (t && !e.ignoreAttributes)
    for (let s in t) {
      if (!t.hasOwnProperty(s)) continue;
      let a = e.attributeValueProcessor(s, t[s]);
      a = Ao(a, e), a === !0 && e.suppressBooleanAttributes ? i += ` ${s.substr(e.attributeNamePrefix.length)}` : i += ` ${s.substr(e.attributeNamePrefix.length)}="${a}"`;
    }
  return i;
}
function th(t, e) {
  t = t.substr(0, t.length - e.textNodeName.length - 1);
  let i = t.substr(t.lastIndexOf(".") + 1);
  for (let s in e.stopNodes)
    if (e.stopNodes[s] === t || e.stopNodes[s] === "*." + i) return !0;
  return !1;
}
function Ao(t, e) {
  if (t && t.length > 0 && e.processEntities)
    for (let i = 0; i < e.entities.length; i++) {
      const s = e.entities[i];
      t = t.replace(s.regex, s.val);
    }
  return t;
}
var ih = Zc;
const sh = ih, ah = wo, oh = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(t, e) {
    return e;
  },
  attributeValueProcessor: function(t, e) {
    return e;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function gt(t) {
  this.options = Object.assign({}, oh, t), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.ignoreAttributesFn = ah(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = lh), this.processTextOrObjNode = rh, this.options.format ? (this.indentate = nh, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
gt.prototype.build = function(t) {
  return this.options.preserveOrder ? sh(t, this.options) : (Array.isArray(t) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (t = {
    [this.options.arrayNodeName]: t
  }), this.j2x(t, 0, []).val);
};
gt.prototype.j2x = function(t, e, i) {
  let s = "", a = "";
  const o = i.join(".");
  for (let r in t)
    if (Object.prototype.hasOwnProperty.call(t, r))
      if (typeof t[r] > "u")
        this.isAttribute(r) && (a += "");
      else if (t[r] === null)
        this.isAttribute(r) ? a += "" : r[0] === "?" ? a += this.indentate(e) + "<" + r + "?" + this.tagEndChar : a += this.indentate(e) + "<" + r + "/" + this.tagEndChar;
      else if (t[r] instanceof Date)
        a += this.buildTextValNode(t[r], r, "", e);
      else if (typeof t[r] != "object") {
        const l = this.isAttribute(r);
        if (l && !this.ignoreAttributesFn(l, o))
          s += this.buildAttrPairStr(l, "" + t[r]);
        else if (!l)
          if (r === this.options.textNodeName) {
            let n = this.options.tagValueProcessor(r, "" + t[r]);
            a += this.replaceEntitiesValue(n);
          } else
            a += this.buildTextValNode(t[r], r, "", e);
      } else if (Array.isArray(t[r])) {
        const l = t[r].length;
        let n = "", h = "";
        for (let c = 0; c < l; c++) {
          const d = t[r][c];
          if (!(typeof d > "u")) if (d === null)
            r[0] === "?" ? a += this.indentate(e) + "<" + r + "?" + this.tagEndChar : a += this.indentate(e) + "<" + r + "/" + this.tagEndChar;
          else if (typeof d == "object")
            if (this.options.oneListGroup) {
              const f = this.j2x(d, e + 1, i.concat(r));
              n += f.val, this.options.attributesGroupName && d.hasOwnProperty(this.options.attributesGroupName) && (h += f.attrStr);
            } else
              n += this.processTextOrObjNode(d, r, e, i);
          else if (this.options.oneListGroup) {
            let f = this.options.tagValueProcessor(r, d);
            f = this.replaceEntitiesValue(f), n += f;
          } else
            n += this.buildTextValNode(d, r, "", e);
        }
        this.options.oneListGroup && (n = this.buildObjectNode(n, r, h, e)), a += n;
      } else if (this.options.attributesGroupName && r === this.options.attributesGroupName) {
        const l = Object.keys(t[r]), n = l.length;
        for (let h = 0; h < n; h++)
          s += this.buildAttrPairStr(l[h], "" + t[r][l[h]]);
      } else
        a += this.processTextOrObjNode(t[r], r, e, i);
  return { attrStr: s, val: a };
};
gt.prototype.buildAttrPairStr = function(t, e) {
  return e = this.options.attributeValueProcessor(t, "" + e), e = this.replaceEntitiesValue(e), this.options.suppressBooleanAttributes && e === "true" ? " " + t : " " + t + '="' + e + '"';
};
function rh(t, e, i, s) {
  const a = this.j2x(t, i + 1, s.concat(e));
  return t[this.options.textNodeName] !== void 0 && Object.keys(t).length === 1 ? this.buildTextValNode(t[this.options.textNodeName], e, a.attrStr, i) : this.buildObjectNode(a.val, e, a.attrStr, i);
}
gt.prototype.buildObjectNode = function(t, e, i, s) {
  if (t === "")
    return e[0] === "?" ? this.indentate(s) + "<" + e + i + "?" + this.tagEndChar : this.indentate(s) + "<" + e + i + this.closeTag(e) + this.tagEndChar;
  {
    let a = "</" + e + this.tagEndChar, o = "";
    return e[0] === "?" && (o = "?", a = ""), (i || i === "") && t.indexOf("<") === -1 ? this.indentate(s) + "<" + e + i + o + ">" + t + a : this.options.commentPropName !== !1 && e === this.options.commentPropName && o.length === 0 ? this.indentate(s) + `<!--${t}-->` + this.newLine : this.indentate(s) + "<" + e + i + o + this.tagEndChar + t + this.indentate(s) + a;
  }
};
gt.prototype.closeTag = function(t) {
  let e = "";
  return this.options.unpairedTags.indexOf(t) !== -1 ? this.options.suppressUnpairedNode || (e = "/") : this.options.suppressEmptyNode ? e = "/" : e = `></${t}`, e;
};
gt.prototype.buildTextValNode = function(t, e, i, s) {
  if (this.options.cdataPropName !== !1 && e === this.options.cdataPropName)
    return this.indentate(s) + `<![CDATA[${t}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && e === this.options.commentPropName)
    return this.indentate(s) + `<!--${t}-->` + this.newLine;
  if (e[0] === "?")
    return this.indentate(s) + "<" + e + i + "?" + this.tagEndChar;
  {
    let a = this.options.tagValueProcessor(e, t);
    return a = this.replaceEntitiesValue(a), a === "" ? this.indentate(s) + "<" + e + i + this.closeTag(e) + this.tagEndChar : this.indentate(s) + "<" + e + i + ">" + a + "</" + e + this.tagEndChar;
  }
};
gt.prototype.replaceEntitiesValue = function(t) {
  if (t && t.length > 0 && this.options.processEntities)
    for (let e = 0; e < this.options.entities.length; e++) {
      const i = this.options.entities[e];
      t = t.replace(i.regex, i.val);
    }
  return t;
};
function nh(t) {
  return this.options.indentBy.repeat(t);
}
function lh(t) {
  return t.startsWith(this.options.attributeNamePrefix) && t !== this.options.textNodeName ? t.substr(this.attrPrefixLen) : !1;
}
var ch = gt;
const hh = As, dh = Jc, uh = ch;
var fh = {
  XMLParser: dh,
  XMLValidator: hh,
  XMLBuilder: uh
};
const Ge = ":@";
let ae, At, ut = [];
function To(t) {
  const s = new fh.XMLParser({
    ignoreAttributes: !1,
    attributeNamePrefix: "",
    preserveOrder: !0
  }).parse(t).filter((o) => o.svg), a = [];
  return ut = [], s.forEach((o) => {
    const r = o[Ge];
    ae = mh(r), ae.width < ae.height ? (r.height || (r.height = 40), At = r.height / ae.height, !r.width && (r.width = At * ae.width)) : (r.width || (r.width = 40), At = r.width / ae.width, !r.height && (r.height = At * ae.height));
    const n = o.svg, h = {};
    for (let d = 0; d < n.length; d++)
      n[d].g && (h[d] = Co(n[d]));
    for (let d in h)
      n.splice(Number(d), 1, ...h[d]);
    const c = Ro(r, n);
    a.push(...c);
  }), gh(a[0]), a;
}
function Co(t) {
  if (t.g && t.g.length == 1 && t.g[0][Ge]) {
    const e = Object.keys(t.g[0][Ge]);
    if (e.length == 2 && e[0] == "id" && e[1] == "data-name")
      return Co(t.g[0]);
  }
  return t.g;
}
function gh(t) {
  ut = ut.map((e, i) => ({
    id: i + "",
    penId: t.id,
    x: e.x,
    y: e.y
  })), t.anchors = ut;
}
function Ro(t, e) {
  const i = [], [s, a] = Ch(t), o = {
    id: ne(),
    name: "combine",
    x: t.x,
    // 最外层的 conbine 用不到该属性
    y: t.y,
    locked: t.locked,
    width: s,
    height: a,
    children: []
  };
  return i.push(o), e.forEach((r) => {
    let l;
    const n = r[Ge];
    if (n && n.transform && r.g && r.g.forEach((h) => {
      h[Ge] ? h[Ge].transform = n.transform : h[Ge] = {
        transform: n.transform
      };
    }), r.g)
      l = Ro(
        {
          // TODO: g 暂时认为是与父元素一样大
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          locked: 10,
          // 内层的 combine locked 10
          ...n
        },
        r.g
      );
    else if (r.defs)
      pa(r.defs.filter((h) => h.style)), Ah(r.defs.filter((h) => h.linearGradient));
    else if (r.style)
      pa([{ style: r.style }]);
    else if (n)
      if (l = ph(n, t, o.id), r.path)
        l = vh(n, l);
      else if (r.rect) {
        l = yh(n, l);
        const h = l;
        [
          {
            x: h.x + h.width * 0.5,
            y: h.y
          },
          {
            x: h.x + h.width * 1,
            y: h.y + h.height * 0.5
          },
          {
            x: h.x + h.width * 0.5,
            y: h.y + h.height * 1
          },
          {
            x: h.x,
            y: h.y + h.height * 0.5
          }
        ].forEach((d) => {
          (d.x <= 0.01 || d.x >= 0.99 || d.y <= 0.01 || d.y >= 0.99) && ut.push(d);
        });
      } else if (r.circle) {
        l = ya(n, l);
        const h = l;
        [
          {
            x: h.x + h.width * 0.5,
            y: h.y
          },
          {
            x: h.x + h.width * 1,
            y: h.y + h.height * 0.5
          },
          {
            x: h.x + h.width * 0.5,
            y: h.y + h.height * 1
          },
          {
            x: h.x,
            y: h.y + h.height * 0.5
          }
        ].forEach((d) => {
          (d.x <= 0.01 || d.x >= 0.99 || d.y <= 0.01 || d.y >= 0.99) && ut.push(d);
        });
      } else if (r.ellipse)
        l = ya(n, l);
      else if (r.line) {
        l = wh(n, l);
        const h = l;
        h.anchors.forEach((c) => {
          const d = h.x + c.x * h.width, f = h.y + c.y * h.height;
          (d < 0.01 || d > 0.99 || f < 0.01 || f > 0.99) && ut.push({
            x: d,
            y: f
          });
        });
      } else if (r.polygon)
        l = Eo(n, l);
      else if (r.polyline) {
        l = xh(n, l);
        const h = l;
        h.anchors.forEach((c) => {
          const d = h.x + c.x * h.width, f = h.y + c.y * h.height;
          (d < 0.01 || d > 0.99 || f < 0.01 || f > 0.99) && ut.push({
            x: d,
            y: f
          });
        });
      } else r.text ? l = kh(n, r.text, l) : r.image ? l = Ih(n, l) : l = void 0;
    if (l)
      if (Array.isArray(l)) {
        for (const h of l)
          h.parentId || (h.parentId = o.id, o.children.push(h.id));
        i.push(...l);
      } else
        o.children.push(l.id), i.push(l);
  }), i;
}
function Po(t) {
  let e = 0, i = 0;
  if (t) {
    let s = t.replace("translate(", "").replace(")", "").split(",");
    e = parseFloat(s[0]), i = parseFloat(s[1]);
  }
  return {
    offsetX: e,
    offsetY: i
  };
}
function vh(t, e) {
  let i = t.d;
  if (!i)
    return;
  let s = so(i), a = os(s), { offsetX: o, offsetY: r } = Po(t.transform);
  a.x += o, a.ex += o, a.y += r, a.ey += r;
  const l = (a.x + e.x - ae.x) / ae.width, n = (a.y + e.y - ae.y) / ae.height, h = a.width / ae.width <= 1 ? a.width / ae.width : 1, c = a.height / ae.height <= 1 ? a.height / ae.height : 1;
  return {
    ...e,
    name: "svgPath",
    pathId: ne(),
    // 同样的 pathId ，避免重复存储 path
    path: i,
    x: l,
    y: n,
    width: h,
    height: c,
    disableAnchor: !0
  };
}
function yh(t, e) {
  const i = (t.x || 0 - ae.x + e.x) / ae.width, s = (t.y || 0 - ae.y + e.y) / ae.height, a = t.width / ae.width <= 1 ? t.width / ae.width : 1, o = t.height / ae.height <= 1 ? t.height / ae.height : 1, r = t.rx / t.width || t.ry / t.height || 0;
  return {
    ...e,
    name: "rectangle",
    x: i,
    y: s,
    width: a,
    height: o,
    borderRadius: r
  };
}
function ya(t, e) {
  const i = t.rx || t.r, s = t.ry || t.r, a = (t.cx - i - ae.x + e.x) / ae.width, o = (t.cy - s - ae.y + e.y) / ae.height, r = 2 * i / ae.width, l = 2 * s / ae.height;
  return {
    ...e,
    name: "circle",
    x: a,
    y: o,
    width: r,
    height: l
  };
}
function mh(t) {
  if (t.viewBox) {
    const e = t.viewBox.split(" ");
    return {
      x: Number(e[0]),
      y: Number(e[1]),
      width: Number(e[2]),
      height: Number(e[3])
    };
  } else
    return {
      x: 0,
      y: 0,
      width: parseFloat(t.width),
      height: parseFloat(t.height)
    };
}
function ph(t, e, i) {
  var u;
  const s = ba(t.class), a = ba(e.class), o = us(t.style), r = us(e.style), l = {
    ...e,
    ...a,
    ...r,
    ...t,
    ...s,
    ...o
  };
  let n;
  if (l.fill !== "none") if ((u = l.fill) != null && u.includes("url")) {
    const g = l.fill.replace("url(#", "").replace(")", "");
    let y = fs.find((v) => v.id === g);
    y && !y.color && (y = fs.find(
      (v) => y.from === `#${v.id}`
    )), n = y == null ? void 0 : y.color;
  } else
    n = l.fill, !n && (n = "#000");
  let h = 0, c = 0, d = 0, f = null;
  return l.transform && l.transform.split(") ").forEach((y) => {
    const [v, b] = y.split("("), [x, p] = b.split(" ");
    v === "translate" ? (h = Number(x) || 0, c = Number(p) || 0) : v === "rotate" ? (d = parseFloat(b), h = 0, c = 0) : v === "matrix" && (f = b.split(" ").map((k) => parseFloat(k)));
  }), {
    id: ne(),
    locked: 10,
    parentId: i,
    x: h,
    y: c,
    rotate: d,
    // TODO: background 可以为空
    background: n,
    color: l.stroke,
    lineWidth: l["stroke-width"] ? parseFloat(l["stroke-width"]) * At : l.stroke ? 1 : 0,
    lineCap: l.strokeLinecap,
    lineJoin: l.strokeLinejoin,
    lineDash: l.strokeDasharray,
    // TODO: 可能不是数组类型
    lineDashOffset: l.strokeDashoffset,
    // strokeMiterlimit: path.strokeMiterlimit,
    globalAlpha: Number(l.opacity),
    // transform: path.transform,
    fontSize: l["font-size"] ? parseFloat(l["font-size"]) * At : 16,
    fontFamily: l["font-family"],
    fontWeight: l["font-weight"],
    fontStyle: l["font-style"],
    matrix: f
  };
}
function bh(t) {
  const i = t.replace(/[\'\"\\\/\b\f\n\r\t]/g, "").split(/\s|,/), s = [];
  return i.forEach((a, o) => {
    o % 2 === 0 && s.push({
      x: Number(a),
      y: Number(i[o + 1])
    });
  }), s;
}
function Eo(t, e) {
  const i = t.points, s = bh(i), a = Ut(s), o = s.map((r) => ({
    x: (r.x - a.x) / a.width,
    y: (r.y - a.y) / a.height,
    id: ne()
  }));
  return {
    ...e,
    name: "line",
    lineName: "line",
    type: 0,
    close: !0,
    anchors: o,
    x: (a.x - ae.x + e.x) / ae.width,
    y: (a.y - ae.y + e.y) / ae.height,
    width: a.width / ae.width,
    height: a.height / ae.height
  };
}
function ma(t, e) {
  const [i, s, a, o, r, l] = e, n = t.x, h = t.y, c = i * n + a * h + r, d = s * n + o * h + l;
  return [c, d];
}
function wh(t, e) {
  let i = Number(t.x1) || 0, s = Number(t.x2) || 0, a = Number(t.y1) || 0, o = Number(t.y2) || 0;
  Array.isArray(e.matrix) && ([i, a] = ma({ x: i, y: a }, e.matrix), [s, o] = ma({ x: s, y: o }, e.matrix));
  const r = Math.min(i, s), l = Math.max(i, s), n = Math.min(a, o), h = Math.max(a, o), c = (r - ae.x + e.x) / ae.width, d = (n - ae.y + e.y) / ae.height, f = (l - r) / ae.width, u = (h - n) / ae.height;
  return {
    ...e,
    name: "line",
    lineName: "line",
    type: 0,
    x: c,
    y: d,
    width: f,
    height: u,
    anchors: [
      {
        x: i < s ? 0 : 1,
        y: a < o ? 0 : 1,
        hidden: !0,
        id: ne()
      },
      {
        x: i < s ? 1 : 0,
        y: a < o ? 1 : 0,
        hidden: !0,
        id: ne()
      }
    ]
  };
}
function xh(t, e) {
  const i = Eo(t, e);
  return Object.assign(i, {
    close: !1,
    type: 1,
    anchors: i.anchors.map((s) => (s.hidden = !0, s))
  });
}
function kh(t, e, i) {
  var n;
  const s = (n = e[0]) == null ? void 0 : n[_o], a = Sh(s, i), o = 0;
  let { offsetX: r, offsetY: l } = Po(t.transform);
  return {
    ...i,
    name: "text",
    textAlign: "left",
    text: s,
    x: (parseFloat(t.x) + (r || 0) - ae.x + i.x) / ae.width,
    y: (parseFloat(t.y) + (l || 0) - ae.y + i.y - o) / ae.height,
    width: a / ae.width,
    height: o / ae.height
  };
}
function Ih(t, e) {
  const { x: i, y: s, width: a, height: o } = t;
  return {
    ...e,
    name: "image",
    x: (i - ae.x + e.x) / ae.width,
    y: (s - ae.y + e.y) / ae.height,
    width: a / ae.width,
    height: o / ae.height,
    image: t["xlink:href"]
  };
}
function Sh(t, e) {
  return (e.fontSize || 16) / At * String(t).length;
}
function us(t) {
  if (!t)
    return {};
  const e = t.split(";"), i = {};
  return e.forEach((s) => {
    const [a, o] = s.split(":");
    a && (i[a] = o);
  }), i;
}
const _o = "#text";
let Ii;
function pa(t) {
  t.forEach((e) => {
    e.style && e.style[0] && (Ii = Th(e.style[0][_o]));
  });
}
let fs = [];
function Ah(t) {
  t.forEach((e) => {
    if (e.linearGradient) {
      const i = {
        id: e[Ge].id,
        from: e[Ge]["xlink:href"],
        color: void 0
      };
      e.linearGradient.length > 0 && (i.color = e.linearGradient[0][Ge]["stop-color"]), fs.push(i);
    }
  });
}
function Th(t) {
  const e = {};
  return t.split("}").forEach((s) => {
    const [a, o] = s.split("{");
    a && (e[a.trim()] = us(o));
  }), e;
}
function ba(t) {
  const e = {};
  for (const i in Ii)
    if (Object.prototype.hasOwnProperty.call(Ii, i)) {
      const s = Ii[i];
      (i === "." + t || i.includes("." + t + ",") || i.includes(",." + t)) && Object.assign(e, s);
    }
  return e;
}
function Ch(t) {
  var s;
  if ((s = String(t.width)) != null && s.endsWith("in")) {
    const a = parseFloat(t.width) * 96, o = parseFloat(t.height) * 96;
    return [a, o];
  }
  const e = parseFloat(t.width) || 0, i = parseFloat(t.height) || 0;
  return [e, i];
}
function Rh(t, e, i = !0) {
  if (!t) return [];
  const s = To(t);
  return s.forEach((a) => {
    var o;
    a.x || (a.x = 0), a.y || (a.y = 0), a.name == "combine" && !a.parentId && (a.description = e == null ? void 0 : e.name, (o = e == null ? void 0 : e.data) != null && o.anchors && i && e.data.anchors.forEach((r) => {
      //! 报错
      if (a.anchors) {
        const l = a.anchors.length;
        r.id = l, a.anchors.push(r);
      } else
        a.anchors = [r];
    }));
  }), i && (meta2d.canvas.addCaches = G(s)), s;
}
function Ph(t, e, i = !0) {
  if (!t) return [];
  const s = To(t);
  console.log("传入的SVG===== ", s, "以前的图元数据=====", e);
  const a = s.find(
    (o) => o.name == "combine" && !o.parentId
  );
  return Object.assign(a, {
    id: e == null ? void 0 : e.id,
    x: e == null ? void 0 : e.x,
    y: e == null ? void 0 : e.y,
    description: e == null ? void 0 : e.description,
    text: e == null ? void 0 : e.text,
    withh: e == null ? void 0 : e.width,
    height: e == null ? void 0 : e.height,
    showChild: e == null ? void 0 : e.showChild,
    //rotate: rotateAngelMap[item.rotateAngel] || 0, // 跟预期不一致
    tags: e == null ? void 0 : e.tags
  }), s.forEach((o) => {
    o.name !== "combine" && (o.parentId = e == null ? void 0 : e.id);
  }), console.log("重新组装的图元数据=====", s, "以前的图元数据=====", e), i && (meta2d.canvas.addCaches = G(s)), s;
}
const Eh = (t, e, i = !0) => fetch(t).then((s) => s.text().then((o) => Rh(o, e, i))), _h = 2015, Lh = -2404, Mh = 2.2962853358150284, Nh = [
  {
    id: "251c6ba9",
    name: "combine",
    x: -1917.2818412992815,
    y: 2786.8430321398773,
    ex: -1881.4505065758517,
    ey: 2878.6944455724783,
    width: 35.83133472342976,
    height: 91.85141343260094,
    center: {
      x: -1899.3661739375666,
      y: 2832.7687388561776
    },
    children: [
      "179d2635",
      "8f6b874"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "251c6ba9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "251c6ba9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "251c6ba9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "251c6ba9"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch"
    ],
    description: "开关-通用开关"
  },
  {
    id: "179d2635",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1,
    height: 1,
    children: [
      "efe2dc1",
      "0336d6d",
      "fd8c6a3",
      "2e93e1de",
      "48940cd4",
      "7614682"
    ],
    anchors: [
      {
        id: "0",
        penId: "179d2635",
        x: 0.9069451980466631,
        y: 0
      },
      {
        id: "1",
        penId: "179d2635",
        x: 0.9069451980466631,
        y: 1
      }
    ],
    description: "开关-通用开关-断开",
    parentId: "251c6ba9",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1,
    ey: 1
  },
  {
    id: "efe2dc1",
    locked: 10,
    parentId: "179d2635",
    x: 0.9069451980466631,
    y: 0,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.2964563526361279,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d368225",
        penId: "efe2dc1"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5757269e",
        penId: "efe2dc1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0336d6d",
    locked: 10,
    parentId: "179d2635",
    x: 0.9069451980466631,
    y: 0.6666607870460198,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33333921295398017,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8156d51",
        penId: "0336d6d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5d1bd0bb",
        penId: "0336d6d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "fd8c6a3",
    locked: 10,
    parentId: "179d2635",
    x: 0.8093687827816965,
    y: 0.2952745488861059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "818f759",
    width: 0.19515283052993293,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fd8c6a3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fd8c6a3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fd8c6a3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fd8c6a3"
      }
    ]
  },
  {
    id: "2e93e1de",
    locked: 10,
    parentId: "179d2635",
    x: 0.43868692349430277,
    y: 0.30132467853174116,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46825827455236035,
    height: 0.36533610851427867,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "653d183",
        penId: "2e93e1de"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "59cb558",
        penId: "2e93e1de"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "48940cd4",
    locked: 10,
    parentId: "179d2635",
    x: 0.1861096039066739,
    y: 0.4722981673222444,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46780611322119736,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "6f687ae0",
        penId: "48940cd4"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2b7d21de",
        penId: "48940cd4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7614682",
    locked: 10,
    parentId: "179d2635",
    x: -0.004521613311629589,
    y: 0.4363854444111267,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "64c23b2",
    width: 0.19515283052993307,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7614682"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7614682"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7614682"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7614682"
      }
    ]
  },
  {
    id: "8f6b874",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1,
    height: 1,
    children: [
      "5fb70c43",
      "50b9d5d1",
      "d85f845",
      "a70f7f1",
      "a0fac3b",
      "448edcea"
    ],
    anchors: [
      {
        id: "0",
        penId: "8f6b874",
        x: 0.9069451980466631,
        y: 0
      },
      {
        id: "1",
        penId: "8f6b874",
        x: 0.9069451980466631,
        y: 1
      }
    ],
    description: "开关-通用开关-闭合",
    parentId: "251c6ba9",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1,
    ey: 1
  },
  {
    id: "5fb70c43",
    locked: 10,
    parentId: "8f6b874",
    x: 0.9069451980466631,
    y: 0,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.2964563526361279,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "a594399",
        penId: "5fb70c43"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1e80702",
        penId: "5fb70c43"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "50b9d5d1",
    locked: 10,
    parentId: "8f6b874",
    x: 0.9069451980466631,
    y: 0.6666607870460198,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33333921295398017,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "0fac3c5",
        penId: "50b9d5d1"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d17d7fd",
        penId: "50b9d5d1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d85f845",
    locked: 10,
    parentId: "8f6b874",
    x: 0.8093687827816965,
    y: 0.2952745488861059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "fb0b262",
    width: 0.19515283052993293,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d85f845"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d85f845"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d85f845"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d85f845"
      }
    ]
  },
  {
    id: "a70f7f1",
    locked: 10,
    parentId: "8f6b874",
    x: 0.7954422137818773,
    y: 0.2607552960682977,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11150298426478579,
    height: 0.4061347961829503,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "c1a1ac",
        penId: "a70f7f1"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "b22a5c5",
        penId: "a70f7f1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "a0fac3b",
    locked: 10,
    parentId: "8f6b874",
    x: 0.3850605896183758,
    y: 0.4722981673222444,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46780611322119736,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3718d05",
        penId: "a0fac3b"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "16ac617f",
        penId: "a0fac3b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "448edcea",
    locked: 10,
    parentId: "8f6b874",
    x: 0.19442937240007235,
    y: 0.4363854444111267,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "607a597",
    width: 0.19515283052993307,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "448edcea"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "448edcea"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "448edcea"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "448edcea"
      }
    ]
  },
  {
    id: "1f12a7e",
    name: "combine",
    x: -1775.3416239933122,
    y: 2786.8430321398773,
    ex: -1737.226639660149,
    ey: 2878.6944455724783,
    width: 38.114984333163285,
    height: 91.8514134326011,
    center: {
      x: -1756.2841318267306,
      y: 2832.768738856178
    },
    children: [
      "3f995752",
      "74bec5df"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1f12a7e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1f12a7e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1f12a7e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1f12a7e"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Knob_SelfLock"
    ],
    description: "开关-自锁旋转开关"
  },
  {
    id: "3f995752",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999998,
    height: 0.9999999999999997,
    children: [
      "6616a45f",
      "e73feb9",
      "18daee8",
      "b584622",
      "3e24993a",
      "646c5b85",
      "fc72299",
      "f64fd90",
      "e218fe2",
      "19e77bf0"
    ],
    anchors: [
      {
        id: "0",
        penId: "3f995752",
        x: 0.008795074758135445,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.6653284671532848
      },
      {
        id: "2",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.9963503649635037
      },
      {
        id: "3",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.6653284671532846
      },
      {
        id: "4",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.0036496350364963507
      },
      {
        id: "5",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.33467153284671536
      }
    ],
    description: "开关-自锁旋转开关-断开",
    parentId: "1f12a7e",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999998,
    ey: 0.9999999999999997
  },
  {
    id: "6616a45f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "54a5ea1b"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6616a45f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6616a45f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6616a45f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6616a45f"
      }
    ],
    rotate: 0
  },
  {
    id: "54a5ea1b",
    locked: 10,
    parentId: "6616a45f",
    x: 0.33157431838170626,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.08883025505716802,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "0dba702",
        penId: "54a5ea1b"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "10ec58a",
        penId: "54a5ea1b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e73feb9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "bb9a15d"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "e73feb9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "e73feb9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "e73feb9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "e73feb9"
      }
    ],
    rotate: 0
  },
  {
    id: "bb9a15d",
    locked: 10,
    parentId: "e73feb9",
    x: 0.4204045734388743,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.0897097625329815,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "844743",
        penId: "bb9a15d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "700e943f",
        penId: "bb9a15d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "18daee8",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a34c0e0"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "18daee8"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "18daee8"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "18daee8"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "18daee8"
      }
    ],
    rotate: 0
  },
  {
    id: "a34c0e0",
    locked: 10,
    parentId: "18daee8",
    x: 0.008795074758135445,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1996481970096746,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e50983d",
        penId: "a34c0e0"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "61365582",
        penId: "a34c0e0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b584622",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "6494b91"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "b584622"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "b584622"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "b584622"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "b584622"
      }
    ],
    rotate: 0
  },
  {
    id: "6494b91",
    locked: 10,
    parentId: "b584622",
    x: 0.20844327176781005,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19964819700967457,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "202f7e2",
        penId: "6494b91"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "53f53a",
        penId: "6494b91"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3e24993a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7ebd9e0"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3e24993a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3e24993a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3e24993a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3e24993a"
      }
    ],
    rotate: 0
  },
  {
    id: "7ebd9e0",
    locked: 10,
    parentId: "3e24993a",
    x: 0.20844327176781005,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e13f914",
        penId: "7ebd9e0"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "58acebce",
        penId: "7ebd9e0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "646c5b85",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "279e9fb8"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "646c5b85"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "646c5b85"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "646c5b85"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "646c5b85"
      }
    ],
    rotate: 0
  },
  {
    id: "279e9fb8",
    locked: 10,
    parentId: "646c5b85",
    x: 0.9912049252418645,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2acf0ff3",
        penId: "279e9fb8"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1bbfe463",
        penId: "279e9fb8"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "fc72299",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "769661e"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fc72299"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fc72299"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fc72299"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fc72299"
      }
    ],
    rotate: 0
  },
  {
    id: "769661e",
    locked: 10,
    parentId: "fc72299",
    x: 0.4335971855760774,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5576077396657871,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "a11431",
        penId: "769661e"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2a0d06b",
        penId: "769661e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f64fd90",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f83e670"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f64fd90"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f64fd90"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f64fd90"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f64fd90"
      }
    ],
    rotate: 0
  },
  {
    id: "f83e670",
    locked: 10,
    parentId: "f64fd90",
    x: 0.9912049252418645,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6aa4fb5",
        penId: "f83e670"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "34646ed3",
        penId: "f83e670"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e218fe2",
    locked: 10,
    parentId: "3f995752",
    x: 0.20844327176781005,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.12313104661389622,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5c87262",
        penId: "e218fe2"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ddfbe32",
        penId: "e218fe2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "19e77bf0",
    locked: 10,
    parentId: "3f995752",
    x: 0.5101143359718557,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2022867194371152,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "e2dee6e",
        penId: "19e77bf0"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "76eb44b9",
        penId: "19e77bf0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "74bec5df",
    name: "combine",
    x: 0.09630606860157255,
    y: 0,
    locked: 0,
    width: 0.8073878627968337,
    height: 0.9999999999999997,
    children: [
      "ff6d8d9",
      "d3109f",
      "66206ce0",
      "3620bd9",
      "7bf1eeef",
      "8e44f5e",
      "ef5ee9f",
      "20d45f8e",
      "57453965",
      "b1cfbb3",
      "6689d1"
    ],
    anchors: [
      {
        id: "0",
        penId: "74bec5df",
        x: 0.9891067538126362,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "74bec5df",
        x: 0.9891067538126362,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自锁旋转开关-闭合",
    parentId: "1f12a7e",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9036939313984063,
    ey: 0.9999999999999997
  },
  {
    id: "ff6d8d9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b9a2f9e"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ff6d8d9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ff6d8d9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ff6d8d9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ff6d8d9"
      }
    ],
    rotate: 0
  },
  {
    id: "b9a2f9e",
    locked: 10,
    parentId: "ff6d8d9",
    x: 0.7233115468409586,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26579520697167763,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3f55fdc9",
        penId: "b9a2f9e"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "d5d9a7d",
        penId: "b9a2f9e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d3109f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "373e24"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d3109f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d3109f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d3109f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d3109f"
      }
    ],
    rotate: 0
  },
  {
    id: "373e24",
    locked: 10,
    parentId: "d3109f",
    x: 0.9891067538126362,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7410e17d",
        penId: "373e24"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "14f8abf",
        penId: "373e24"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "66206ce0",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "659d77b"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "66206ce0"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "66206ce0"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "66206ce0"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "66206ce0"
      }
    ],
    rotate: 0
  },
  {
    id: "659d77b",
    locked: 10,
    parentId: "66206ce0",
    x: 0.7494553376906318,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23965141612200438,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "7158caa",
        penId: "659d77b"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "dde7ee7",
        penId: "659d77b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3620bd9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f888a55"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3620bd9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3620bd9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3620bd9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3620bd9"
      }
    ],
    rotate: 0
  },
  {
    id: "f888a55",
    locked: 10,
    parentId: "3620bd9",
    x: 0.9891067538126362,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "668291e0",
        penId: "f888a55"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "643a6891",
        penId: "f888a55"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7bf1eeef",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "8527b0"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7bf1eeef"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7bf1eeef"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7bf1eeef"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7bf1eeef"
      }
    ],
    rotate: 0
  },
  {
    id: "8527b0",
    locked: 10,
    parentId: "7bf1eeef",
    x: 0.4106753812636166,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11002178649237476,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "56a6bcd6",
        penId: "8527b0"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3d4da39c",
        penId: "8527b0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "8e44f5e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9238a84"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "8e44f5e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "8e44f5e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "8e44f5e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "8e44f5e"
      }
    ],
    rotate: 0
  },
  {
    id: "9238a84",
    locked: 10,
    parentId: "8e44f5e",
    x: 0.010893246187363835,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24727668845315906,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5c879633",
        penId: "9238a84"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "312e0e53",
        penId: "9238a84"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ef5ee9f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "757a51e"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ef5ee9f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ef5ee9f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ef5ee9f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ef5ee9f"
      }
    ],
    rotate: 0
  },
  {
    id: "757a51e",
    locked: 10,
    parentId: "ef5ee9f",
    x: 0.2581699346405229,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.247276688453159,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "17802cc",
        penId: "757a51e"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "79c02ddc",
        penId: "757a51e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20d45f8e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a1299e4"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "20d45f8e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "20d45f8e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "20d45f8e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "20d45f8e"
      }
    ],
    rotate: 0
  },
  {
    id: "a1299e4",
    locked: 10,
    parentId: "20d45f8e",
    x: 0.2581699346405229,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4b138df6",
        penId: "a1299e4"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "aaf1e91",
        penId: "a1299e4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "57453965",
    locked: 10,
    parentId: "74bec5df",
    x: 0.2581699346405229,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.15250544662309368,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "a3bc53",
        penId: "57453965"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2c12c23",
        penId: "57453965"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b1cfbb3",
    locked: 10,
    parentId: "74bec5df",
    x: 0.6318082788671024,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.25054466230936817,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "f3775bd",
        penId: "b1cfbb3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "17bf39a",
        penId: "b1cfbb3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6689d1",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5b9fcab"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6689d1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6689d1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6689d1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6689d1"
      }
    ],
    rotate: 0
  },
  {
    id: "5b9fcab",
    locked: 10,
    parentId: "6689d1",
    x: 0.5206971677559913,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11111111111111106,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3d5ddb1",
        penId: "5b9fcab"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "47d03e5b",
        penId: "5b9fcab"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6dfb",
    name: "combine",
    x: -1638.8912643068752,
    y: 2785.3727420213418,
    ex: -1600.6086679054042,
    ey: 2877.224155453943,
    width: 38.28259640147095,
    height: 91.85141343260112,
    center: {
      x: -1619.7499661061397,
      y: 2831.2984487376425
    },
    children: [
      "56ff30a0",
      "223f54a"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6dfb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6dfb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6dfb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6dfb"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Btn_SelfLock"
    ],
    description: "开关-自锁按钮"
  },
  {
    id: "56ff30a0",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000009,
    height: 0.9999999999999997,
    children: [
      "4c15a83",
      "264dc41",
      "49aad136",
      "3ee358cf",
      "20b8c6",
      "f8e1dc1",
      "4cba84b",
      "13fe1d82",
      "5a73b375"
    ],
    anchors: [
      {
        id: "0",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.594160583941606
      },
      {
        id: "2",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.6653284671532848
      },
      {
        id: "3",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.9963503649635037
      },
      {
        id: "4",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.6653284671532846
      },
      {
        id: "5",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.0036496350364963507
      },
      {
        id: "6",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.33467153284671536
      },
      {
        id: "7",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.46459854014598545
      }
    ],
    description: "开关-自锁按钮-断开",
    parentId: "6dfb",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000009,
    ey: 0.9999999999999997
  },
  {
    id: "4c15a83",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "63b23b7"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4c15a83"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4c15a83"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4c15a83"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4c15a83"
      }
    ],
    rotate: 0
  },
  {
    id: "63b23b7",
    locked: 10,
    parentId: "4c15a83",
    x: 0.24693520140105077,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.0884413309982487,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "a0126ab",
        penId: "63b23b7"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "504f5d74",
        penId: "63b23b7"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "264dc41",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7ee38676"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "264dc41"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "264dc41"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "264dc41"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "264dc41"
      }
    ],
    rotate: 0
  },
  {
    id: "7ee38676",
    locked: 10,
    parentId: "264dc41",
    x: 0.3353765323992995,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.08931698774080557,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "68b73050",
        penId: "7ee38676"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "96aad71",
        penId: "7ee38676"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "49aad136",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "106ce24f"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "49aad136"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "49aad136"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "49aad136"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "49aad136"
      }
    ],
    rotate: 0
  },
  {
    id: "106ce24f",
    locked: 10,
    parentId: "49aad136",
    x: 0.013134851138353765,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3a86dd35",
        penId: "106ce24f"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "b719e5d",
        penId: "106ce24f"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3ee358cf",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ed612e1"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3ee358cf"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3ee358cf"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3ee358cf"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3ee358cf"
      }
    ],
    rotate: 0
  },
  {
    id: "5ed612e1",
    locked: 10,
    parentId: "3ee358cf",
    x: 0.013134851138353765,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "9830253",
        penId: "5ed612e1"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "ccc420",
        penId: "5ed612e1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20b8c6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "3d69944"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "20b8c6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "20b8c6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "20b8c6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "20b8c6"
      }
    ],
    rotate: 0
  },
  {
    id: "3d69944",
    locked: 10,
    parentId: "20b8c6",
    x: 0.008756567425569177,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "17cb562",
        penId: "3d69944"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "b26beb3",
        penId: "3d69944"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f8e1dc1",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ee73d3a"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f8e1dc1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f8e1dc1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f8e1dc1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f8e1dc1"
      }
    ],
    rotate: 0
  },
  {
    id: "ee73d3a",
    locked: 10,
    parentId: "f8e1dc1",
    x: 0.9912434325744308,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2202e7b",
        penId: "ee73d3a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ea39150",
        penId: "ee73d3a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4cba84b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "686e50a5"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4cba84b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4cba84b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4cba84b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4cba84b"
      }
    ],
    rotate: 0
  },
  {
    id: "686e50a5",
    locked: 10,
    parentId: "4cba84b",
    x: 0.43607705779334505,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5551663747810858,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5259c8d8",
        penId: "686e50a5"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "4680f719",
        penId: "686e50a5"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "13fe1d82",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "6052ef"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "13fe1d82"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "13fe1d82"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "13fe1d82"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "13fe1d82"
      }
    ],
    rotate: 0
  },
  {
    id: "6052ef",
    locked: 10,
    parentId: "13fe1d82",
    x: 0.9912434325744308,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "10986749",
        penId: "6052ef"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4d11663a",
        penId: "6052ef"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5a73b375",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b7d83e5",
      "4b44534"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5a73b375"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5a73b375"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5a73b375"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5a73b375"
      }
    ],
    rotate: 0
  },
  {
    id: "b7d83e5",
    locked: 10,
    parentId: "5a73b375",
    x: 0.008756567425569177,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23817863397548159,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "4cd5fce",
        penId: "b7d83e5"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "a1f10a0",
        penId: "b7d83e5"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4b44534",
    locked: 10,
    parentId: "5a73b375",
    x: 0.42469352014010503,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2889667250437829,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6afac61b",
        penId: "4b44534"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "73b1c357",
        penId: "4b44534"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "223f54a",
    name: "combine",
    x: 0.09063047285464522,
    y: 0,
    locked: 0,
    width: 0.8187390542907186,
    height: 0.9999999999999997,
    children: [
      "27a60f5e",
      "0c5fa7b",
      "61afb2af",
      "4336ce21",
      "27bb48fc",
      "4dcffcc7",
      "9c724dd",
      "dafe703",
      "81abedc",
      "b5937fa"
    ],
    anchors: [
      {
        id: "0",
        penId: "223f54a",
        x: 0.9893048128342247,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "223f54a",
        x: 0.9893048128342247,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自锁按钮-闭合",
    parentId: "6dfb",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9093695271453638,
    ey: 0.9999999999999997
  },
  {
    id: "27a60f5e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4af889a2"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "27a60f5e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "27a60f5e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "27a60f5e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "27a60f5e"
      }
    ],
    rotate: 0
  },
  {
    id: "4af889a2",
    locked: 10,
    parentId: "27a60f5e",
    x: 0.3016042780748663,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.10802139037433157,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "734716f6",
        penId: "4af889a2"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "cd36907",
        penId: "4af889a2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0c5fa7b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "64a8107"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "0c5fa7b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "0c5fa7b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "0c5fa7b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "0c5fa7b"
      }
    ],
    rotate: 0
  },
  {
    id: "64a8107",
    locked: 10,
    parentId: "0c5fa7b",
    x: 0.4096256684491979,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.10909090909090904,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "58693a",
        penId: "64a8107"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "27554959",
        penId: "64a8107"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "61afb2af",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "328a8b96"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "61afb2af"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "61afb2af"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "61afb2af"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "61afb2af"
      }
    ],
    rotate: 0
  },
  {
    id: "328a8b96",
    locked: 10,
    parentId: "61afb2af",
    x: 0.7283422459893047,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26096256684491986,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e873dd9",
        penId: "328a8b96"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1611cf",
        penId: "328a8b96"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4336ce21",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1937d0d2"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4336ce21"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4336ce21"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4336ce21"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4336ce21"
      }
    ],
    rotate: 0
  },
  {
    id: "1937d0d2",
    locked: 10,
    parentId: "4336ce21",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "68945e83",
        penId: "1937d0d2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "564f8ff",
        penId: "1937d0d2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "27bb48fc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "93f2e70"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "27bb48fc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "27bb48fc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "27bb48fc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "27bb48fc"
      }
    ],
    rotate: 0
  },
  {
    id: "93f2e70",
    locked: 10,
    parentId: "27bb48fc",
    x: 0.9893048128342247,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4910df9f",
        penId: "93f2e70"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4bc33ae",
        penId: "93f2e70"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4dcffcc7",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ab0543d"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4dcffcc7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4dcffcc7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4dcffcc7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4dcffcc7"
      }
    ],
    rotate: 0
  },
  {
    id: "5ab0543d",
    locked: 10,
    parentId: "4dcffcc7",
    x: 0.7540106951871658,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23529411764705885,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "32b8f28b",
        penId: "5ab0543d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "7d6f792a",
        penId: "5ab0543d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9c724dd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ab2f7ad"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9c724dd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9c724dd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9c724dd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9c724dd"
      }
    ],
    rotate: 0
  },
  {
    id: "ab2f7ad",
    locked: 10,
    parentId: "9c724dd",
    x: 0.9893048128342247,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e058e22",
        penId: "ab2f7ad"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "753f8a9d",
        penId: "ab2f7ad"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "dafe703",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d64c17",
      "af3e5a8"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dafe703"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dafe703"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dafe703"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dafe703"
      }
    ],
    rotate: 0
  },
  {
    id: "d64c17",
    locked: 10,
    parentId: "dafe703",
    x: 0.010695187165775402,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2909090909090909,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "b9d7405",
        penId: "d64c17"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "8eb45ab",
        penId: "d64c17"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "af3e5a8",
    locked: 10,
    parentId: "dafe703",
    x: 0.5187165775401069,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.3529411764705883,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "096160e",
        penId: "af3e5a8"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "738a652",
        penId: "af3e5a8"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "81abedc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1c18cc7"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "81abedc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "81abedc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "81abedc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "81abedc"
      }
    ],
    rotate: 0
  },
  {
    id: "1c18cc7",
    locked: 10,
    parentId: "81abedc",
    x: 0.010695187165775402,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "11716587",
        penId: "1c18cc7"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "890f4b3",
        penId: "1c18cc7"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b5937fa",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "490327f9"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "b5937fa"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "b5937fa"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "b5937fa"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "b5937fa"
      }
    ],
    rotate: 0
  },
  {
    id: "490327f9",
    locked: 10,
    parentId: "b5937fa",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "c667fd8",
        penId: "490327f9"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "34913b61",
        penId: "490327f9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "707640bd",
    name: "combine",
    x: -1496.0187372814241,
    y: 2788.3277558237087,
    ex: -1457.903752948261,
    ey: 2880.1791692563097,
    width: 38.11498433316316,
    height: 91.85141343260112,
    center: {
      x: -1476.9612451148425,
      y: 2834.2534625400094
    },
    children: [
      "734b6268",
      "77f99e2b"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "707640bd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "707640bd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "707640bd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "707640bd"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Knob_SelfReset"
    ],
    description: "开关-自复旋转开关"
  },
  {
    id: "734b6268",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.000000000000003,
    height: 0.9999999999999997,
    children: [
      "adee920",
      "cf3c833",
      "1059b4a7",
      "418a0ea2",
      "9210dc6",
      "f2ec300",
      "3c81a07d"
    ],
    anchors: [
      {
        id: "0",
        penId: "734b6268",
        x: 0.008795074758135445,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.6653284671532848
      },
      {
        id: "2",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.9963503649635037
      },
      {
        id: "3",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.6653284671532846
      },
      {
        id: "4",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.0036496350364963507
      },
      {
        id: "5",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.33467153284671536
      }
    ],
    description: "开关-自复旋转开关-断开",
    parentId: "707640bd",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.000000000000003,
    ey: 0.9999999999999997
  },
  {
    id: "adee920",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "fb90df3"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "adee920"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "adee920"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "adee920"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "adee920"
      }
    ],
    rotate: 0
  },
  {
    id: "fb90df3",
    locked: 10,
    parentId: "adee920",
    x: 0.008795074758135445,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1996481970096746,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7c5644c3",
        penId: "fb90df3"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "da0a2eb",
        penId: "fb90df3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "cf3c833",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ff046f9"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "cf3c833"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "cf3c833"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "cf3c833"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "cf3c833"
      }
    ],
    rotate: 0
  },
  {
    id: "ff046f9",
    locked: 10,
    parentId: "cf3c833",
    x: 0.20844327176781005,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19964819700967457,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "46b60693",
        penId: "ff046f9"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "46725267",
        penId: "ff046f9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1059b4a7",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1317983"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1059b4a7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1059b4a7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1059b4a7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1059b4a7"
      }
    ],
    rotate: 0
  },
  {
    id: "1317983",
    locked: 10,
    parentId: "1059b4a7",
    x: 0.20844327176781005,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5ba7ed9c",
        penId: "1317983"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "10580a05",
        penId: "1317983"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "418a0ea2",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "44ba209"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "418a0ea2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "418a0ea2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "418a0ea2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "418a0ea2"
      }
    ],
    rotate: 0
  },
  {
    id: "44ba209",
    locked: 10,
    parentId: "418a0ea2",
    x: 0.9912049252418645,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "71a95b10",
        penId: "44ba209"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "0da5101",
        penId: "44ba209"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9210dc6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "39e956ca"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9210dc6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9210dc6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9210dc6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9210dc6"
      }
    ],
    rotate: 0
  },
  {
    id: "39e956ca",
    locked: 10,
    parentId: "9210dc6",
    x: 0.4335971855760774,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5576077396657871,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "92c92ad",
        penId: "39e956ca"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "7fb8c6b",
        penId: "39e956ca"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f2ec300",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "dba3189"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f2ec300"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f2ec300"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f2ec300"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f2ec300"
      }
    ],
    rotate: 0
  },
  {
    id: "dba3189",
    locked: 10,
    parentId: "f2ec300",
    x: 0.9912049252418645,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "42d60d96",
        penId: "dba3189"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "225e8799",
        penId: "dba3189"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3c81a07d",
    locked: 10,
    parentId: "734b6268",
    x: 0.20844327176781005,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.503957783641161,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6ab4484",
        penId: "3c81a07d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "625af93",
        penId: "3c81a07d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "77f99e2b",
    name: "combine",
    x: 0.09630606860158658,
    y: 0,
    locked: 0,
    width: 0.8073878627968365,
    height: 0.9999999999999997,
    children: [
      "bbff594",
      "52d89af3",
      "620a535a",
      "ab740cd",
      "ca9fcbe",
      "6dc1ea",
      "e8cd234",
      "b872601"
    ],
    anchors: [
      {
        id: "0",
        penId: "77f99e2b",
        x: 0.9891067538126362,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "77f99e2b",
        x: 0.9891067538126362,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自复旋转开关-闭合",
    parentId: "707640bd",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9036939313984231,
    ey: 0.9999999999999997
  },
  {
    id: "bbff594",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "06beb47"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bbff594"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bbff594"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bbff594"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bbff594"
      }
    ],
    rotate: 0
  },
  {
    id: "06beb47",
    locked: 10,
    parentId: "bbff594",
    x: 0.7233115468409586,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26579520697167763,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "6ddf9a66",
        penId: "06beb47"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "cbb1b0b",
        penId: "06beb47"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "52d89af3",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "3f3055d"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "52d89af3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "52d89af3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "52d89af3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "52d89af3"
      }
    ],
    rotate: 0
  },
  {
    id: "3f3055d",
    locked: 10,
    parentId: "52d89af3",
    x: 0.9891067538126362,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "68afaca9",
        penId: "3f3055d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "74532d0c",
        penId: "3f3055d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "620a535a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4e4bad61"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "620a535a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "620a535a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "620a535a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "620a535a"
      }
    ],
    rotate: 0
  },
  {
    id: "4e4bad61",
    locked: 10,
    parentId: "620a535a",
    x: 0.7494553376906318,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23965141612200438,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "15104d7",
        penId: "4e4bad61"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "28abb1e",
        penId: "4e4bad61"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ab740cd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9575b04"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ab740cd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ab740cd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ab740cd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ab740cd"
      }
    ],
    rotate: 0
  },
  {
    id: "9575b04",
    locked: 10,
    parentId: "ab740cd",
    x: 0.9891067538126362,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "b36217e",
        penId: "9575b04"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ab49ff1",
        penId: "9575b04"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ca9fcbe",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "687f70fc"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ca9fcbe"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ca9fcbe"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ca9fcbe"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ca9fcbe"
      }
    ],
    rotate: 0
  },
  {
    id: "687f70fc",
    locked: 10,
    parentId: "ca9fcbe",
    x: 0.010893246187363835,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24727668845315906,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "bd0b8a4",
        penId: "687f70fc"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "9d08cce",
        penId: "687f70fc"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6dc1ea",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a9b9146"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6dc1ea"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6dc1ea"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6dc1ea"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6dc1ea"
      }
    ],
    rotate: 0
  },
  {
    id: "a9b9146",
    locked: 10,
    parentId: "6dc1ea",
    x: 0.2581699346405229,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.247276688453159,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "40bd01fe",
        penId: "a9b9146"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "17d63f8d",
        penId: "a9b9146"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e8cd234",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ecc403"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "e8cd234"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "e8cd234"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "e8cd234"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "e8cd234"
      }
    ],
    rotate: 0
  },
  {
    id: "5ecc403",
    locked: 10,
    parentId: "e8cd234",
    x: 0.2581699346405229,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "acde0ef",
        penId: "5ecc403"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d0ca477",
        penId: "5ecc403"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b872601",
    locked: 10,
    parentId: "77f99e2b",
    x: 0.2581699346405229,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.6241830065359477,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "b5d8797",
        penId: "b872601"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "98d15e",
        penId: "b872601"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "504f755",
    name: "combine",
    x: -1354.11184218387,
    y: 2788.662979960327,
    ex: -1332.6140134424525,
    ey: 2880.514393392928,
    width: 21.49782874141763,
    height: 91.85141343260112,
    center: {
      x: -1343.3629278131611,
      y: 2834.5886866766277
    },
    children: [
      "9e0dfb",
      "3457cb50"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "504f755"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "504f755"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "504f755"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "504f755"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "duanluqi_wx"
    ],
    description: "开关-断路器"
  },
  {
    id: "9e0dfb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999964,
    height: 0.9999999999999997,
    children: [
      "df01e5d",
      "59bf8d4f",
      "43c3c40",
      "2b0e0ff3",
      "f59771f"
    ],
    anchors: [
      {
        id: "0",
        penId: "9e0dfb",
        x: 0.8375913784007838,
        y: 0.0015698587127158557
      },
      {
        id: "1",
        penId: "9e0dfb",
        x: 0.8375913784007838,
        y: 1.001569858712716
      }
    ],
    description: "开关-断路器-断开",
    parentId: "504f755",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999964,
    ey: 0.9999999999999997
  },
  {
    id: "df01e5d",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.8375913784007838,
    y: 0.0015698587127158557,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.29645635263612796,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "c02ac53",
        penId: "df01e5d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "cf211b7",
        penId: "df01e5d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "59bf8d4f",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.8375913784007838,
    y: 0.6682306457587357,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3333392129539804,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5c6982bf",
        penId: "59bf8d4f"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "a4f9d2c",
        penId: "59bf8d4f"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "43c3c40",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.6749566659130304,
    y: 0.2968267687368812,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "4c10c83b",
    width: 0.3252694249755068,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "43c3c40"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "43c3c40"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "43c3c40"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "43c3c40"
      }
    ]
  },
  {
    id: "2b0e0ff3",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.057125631170397165,
    y: 0.30289453724445703,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.7804657472303866,
    height: 0.36533610851427867,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "16ed797d",
        penId: "2b0e0ff3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2197e1a8",
        penId: "2b0e0ff3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f59771f",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.06556635767578566,
    y: 0.42514948935494684,
    rotate: -27.52,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "rectangle",
    width: 0.31253297158791166,
    height: 0.07314836046778263,
    borderRadius: 0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f59771f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f59771f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f59771f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f59771f"
      }
    ]
  },
  {
    id: "3457cb50",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999964,
    height: 0.9999999999999997,
    children: [
      "6b7d5b",
      "6332554e",
      "f5b393c",
      "df444e3",
      "7d9ae722"
    ],
    anchors: [
      {
        id: "0",
        penId: "3457cb50",
        x: 0.8375913784007838,
        y: 0.0015698587127158557
      },
      {
        id: "1",
        penId: "3457cb50",
        x: 0.8375913784007838,
        y: 1.001569858712716
      }
    ],
    description: "开关-断路器-闭合",
    parentId: "504f755",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999964,
    ey: 0.9999999999999997
  },
  {
    id: "6b7d5b",
    locked: 10,
    parentId: "3457cb50",
    x: 0.8375913784007838,
    y: 0.0015698587127158557,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.29645635263612796,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "885dfcc",
        penId: "6b7d5b"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1ade8799",
        penId: "6b7d5b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6332554e",
    locked: 10,
    parentId: "3457cb50",
    x: 0.8375913784007838,
    y: 0.6682306457587357,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3333392129539804,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "71e1ba",
        penId: "6332554e"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1908ce43",
        penId: "6332554e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f5b393c",
    locked: 10,
    parentId: "3457cb50",
    x: 0.6749566659130304,
    y: 0.2968267687368812,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "6b0139a9",
    width: 0.3252694249755068,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f5b393c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f5b393c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f5b393c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f5b393c"
      }
    ]
  },
  {
    id: "df444e3",
    locked: 10,
    parentId: "3457cb50",
    x: 0.6413444871505012,
    y: 0.2623604325048948,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19624689125028266,
    height: 0.4058702132538408,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3e3d1df",
        penId: "df444e3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "44bf6ff",
        penId: "df444e3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7d9ae722",
    locked: 10,
    parentId: "3457cb50",
    x: 0.40643605396035876,
    y: 0.3881784347273914,
    rotate: -7.41,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "rectangle",
    width: 0.31253297158791166,
    height: 0.07314836046778263,
    borderRadius: 0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7d9ae722"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7d9ae722"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7d9ae722"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7d9ae722"
      }
    ]
  },
  {
    id: "d5c2232",
    name: "combine",
    x: -1216.8859793252482,
    y: 2787.336883583446,
    ex: -1178.6033829237772,
    ey: 2879.188297016047,
    width: 38.28259640147095,
    height: 91.85141343260112,
    center: {
      x: -1197.7446811245127,
      y: 2833.2625902997465
    },
    children: [
      "1851cab6",
      "348aed8"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d5c2232"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d5c2232"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d5c2232"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d5c2232"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Btn_SelfReset"
    ],
    description: "开关-按钮"
  },
  {
    id: "1851cab6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000009,
    height: 0.9999999999999997,
    children: [
      "5415ea3",
      "8235341",
      "3b9f6e93",
      "7caade40",
      "2545ae",
      "6289c32",
      "da14c63"
    ],
    anchors: [
      {
        id: "0",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.594160583941606
      },
      {
        id: "2",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.6653284671532848
      },
      {
        id: "3",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.9963503649635037
      },
      {
        id: "4",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.6653284671532846
      },
      {
        id: "5",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.0036496350364963507
      },
      {
        id: "6",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.33467153284671536
      },
      {
        id: "7",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.46459854014598545
      }
    ],
    description: "开关-按钮-断开",
    parentId: "d5c2232",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000009,
    ey: 0.9999999999999997
  },
  {
    id: "5415ea3",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "52368382"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5415ea3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5415ea3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5415ea3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5415ea3"
      }
    ],
    rotate: 0
  },
  {
    id: "52368382",
    locked: 10,
    parentId: "5415ea3",
    x: 0.013134851138353765,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3ee233b",
        penId: "52368382"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "db5796d",
        penId: "52368382"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "8235341",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9a59be"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "8235341"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "8235341"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "8235341"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "8235341"
      }
    ],
    rotate: 0
  },
  {
    id: "9a59be",
    locked: 10,
    parentId: "8235341",
    x: 0.013134851138353765,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "2ed99f6d",
        penId: "9a59be"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "38603fe",
        penId: "9a59be"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3b9f6e93",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "58b79b2d"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3b9f6e93"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3b9f6e93"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3b9f6e93"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3b9f6e93"
      }
    ],
    rotate: 0
  },
  {
    id: "58b79b2d",
    locked: 10,
    parentId: "3b9f6e93",
    x: 0.008756567425569177,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "578a5708",
        penId: "58b79b2d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "2dd6465f",
        penId: "58b79b2d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7caade40",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d01d2f2"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7caade40"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7caade40"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7caade40"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7caade40"
      }
    ],
    rotate: 0
  },
  {
    id: "d01d2f2",
    locked: 10,
    parentId: "7caade40",
    x: 0.9912434325744308,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5407908d",
        penId: "d01d2f2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "25fcf84",
        penId: "d01d2f2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2545ae",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7e9aa4"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2545ae"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2545ae"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2545ae"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2545ae"
      }
    ],
    rotate: 0
  },
  {
    id: "7e9aa4",
    locked: 10,
    parentId: "2545ae",
    x: 0.43607705779334505,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5551663747810858,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "63f47920",
        penId: "7e9aa4"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2d761783",
        penId: "7e9aa4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6289c32",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "abdd075"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6289c32"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6289c32"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6289c32"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6289c32"
      }
    ],
    rotate: 0
  },
  {
    id: "abdd075",
    locked: 10,
    parentId: "6289c32",
    x: 0.9912434325744308,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4cd41f",
        penId: "abdd075"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ae23a9d",
        penId: "abdd075"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "da14c63",
    locked: 10,
    parentId: "1851cab6",
    x: 0.008756567425569177,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.7049036777583189,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "7e2187bc",
        penId: "da14c63"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "3c848649",
        penId: "da14c63"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "348aed8",
    name: "combine",
    x: 0.09063047285464522,
    y: 0,
    locked: 0,
    width: 0.8187390542907186,
    height: 0.9999999999999997,
    children: [
      "5709b5cb",
      "bb6f8a2",
      "c6a04a4",
      "23ae3733",
      "72f3febc",
      "1ed8fdd",
      "c02a701",
      "2748deb"
    ],
    anchors: [
      {
        id: "0",
        penId: "348aed8",
        x: 0.9893048128342247,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "348aed8",
        x: 0.9893048128342247,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-按钮-闭合",
    parentId: "d5c2232",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9093695271453638,
    ey: 0.9999999999999997
  },
  {
    id: "5709b5cb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7da3394d"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5709b5cb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5709b5cb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5709b5cb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5709b5cb"
      }
    ],
    rotate: 0
  },
  {
    id: "7da3394d",
    locked: 10,
    parentId: "5709b5cb",
    x: 0.7283422459893047,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26096256684491986,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "47978557",
        penId: "7da3394d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "184dd9a",
        penId: "7da3394d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "bb6f8a2",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5918d98"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bb6f8a2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bb6f8a2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bb6f8a2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bb6f8a2"
      }
    ],
    rotate: 0
  },
  {
    id: "5918d98",
    locked: 10,
    parentId: "bb6f8a2",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2238e17",
        penId: "5918d98"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "85108ed",
        penId: "5918d98"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "c6a04a4",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "59148ae2"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "c6a04a4"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "c6a04a4"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "c6a04a4"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "c6a04a4"
      }
    ],
    rotate: 0
  },
  {
    id: "59148ae2",
    locked: 10,
    parentId: "c6a04a4",
    x: 0.9893048128342247,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "34caf87",
        penId: "59148ae2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "20782110",
        penId: "59148ae2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "23ae3733",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ca4e4ed"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "23ae3733"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "23ae3733"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "23ae3733"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "23ae3733"
      }
    ],
    rotate: 0
  },
  {
    id: "ca4e4ed",
    locked: 10,
    parentId: "23ae3733",
    x: 0.7540106951871658,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23529411764705885,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "64667d",
        penId: "ca4e4ed"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "dc379db",
        penId: "ca4e4ed"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "72f3febc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "29c6c39"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "72f3febc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "72f3febc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "72f3febc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "72f3febc"
      }
    ],
    rotate: 0
  },
  {
    id: "29c6c39",
    locked: 10,
    parentId: "72f3febc",
    x: 0.9893048128342247,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "642da3a",
        penId: "29c6c39"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e8c9ba3",
        penId: "29c6c39"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1ed8fdd",
    locked: 10,
    parentId: "348aed8",
    x: 0.010695187165775402,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8545454545454546,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "2b297c",
        penId: "1ed8fdd"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "e921f1c",
        penId: "1ed8fdd"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "c02a701",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "2400598d"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "c02a701"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "c02a701"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "c02a701"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "c02a701"
      }
    ],
    rotate: 0
  },
  {
    id: "2400598d",
    locked: 10,
    parentId: "c02a701",
    x: 0.010695187165775402,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d2b80bc",
        penId: "2400598d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "ce72d63",
        penId: "2400598d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2748deb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7aa759c"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2748deb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2748deb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2748deb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2748deb"
      }
    ],
    rotate: 0
  },
  {
    id: "7aa759c",
    locked: 10,
    parentId: "2748deb",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "21e1e38b",
        penId: "7aa759c"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "3eb788df",
        penId: "7aa759c"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d0677b7",
    name: "combine",
    x: -1086.0292836927256,
    y: 2787.67210772006,
    ex: -1059.3897937013883,
    ey: 2879.523521152661,
    width: 26.639489991337413,
    height: 91.85141343260112,
    center: {
      x: -1072.7095386970568,
      y: 2833.5978144363607
    },
    children: [
      "172592a",
      "cc7f3b6"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d0677b7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d0677b7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d0677b7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d0677b7"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch"
    ],
    description: "开关-惯性开关"
  },
  {
    id: "172592a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999954,
    height: 0.9999999999999997,
    children: [
      "fa76b81",
      "bcaf08b",
      "2f7165df",
      "ca46ae8",
      "dac4035",
      "4a1b17bd"
    ],
    anchors: [
      {
        id: "0",
        penId: "172592a",
        x: 0.9887005649717514,
        y: 0.9976591760299625
      },
      {
        id: "1",
        penId: "172592a",
        x: 0.9887005649717514,
        y: 0.0023408239700374533
      }
    ],
    description: "开关-惯性开关-断开",
    parentId: "d0677b7",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999954,
    ey: 0.9999999999999997
  },
  {
    id: "fa76b81",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1ec9c5e"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fa76b81"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fa76b81"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fa76b81"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fa76b81"
      }
    ],
    rotate: 0
  },
  {
    id: "1ec9c5e",
    locked: 10,
    parentId: "fa76b81",
    x: 0.011299435028248588,
    y: 0.5063202247191011,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2857142857142857,
    height: 0.14372659176029964,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ab43420",
        penId: "1ec9c5e"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "398143e1",
        penId: "1ec9c5e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "bcaf08b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1455e2fd"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bcaf08b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bcaf08b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bcaf08b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bcaf08b"
      }
    ],
    rotate: 0
  },
  {
    id: "1455e2fd",
    locked: 10,
    parentId: "bcaf08b",
    x: 0.011299435028248588,
    y: 0.4234550561797753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.49475383373688453,
    height: 0.08286516853932582,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "832da14",
        penId: "1455e2fd"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "cbe28eb",
        penId: "1455e2fd"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2f7165df",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7b5447a"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2f7165df"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2f7165df"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2f7165df"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2f7165df"
      }
    ],
    rotate: 0
  },
  {
    id: "7b5447a",
    locked: 10,
    parentId: "2f7165df",
    x: 0.9887005649717514,
    y: 0.6659644194756554,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3316947565543071,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1fed1dd5",
        penId: "7b5447a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "62e1ccba",
        penId: "7b5447a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ca46ae8",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b0bf3df"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ca46ae8"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ca46ae8"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ca46ae8"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ca46ae8"
      }
    ],
    rotate: 0
  },
  {
    id: "b0bf3df",
    locked: 10,
    parentId: "ca46ae8",
    x: 0.9887005649717514,
    y: 0.0023408239700374533,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33169475655430714,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "142820bb",
        penId: "b0bf3df"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "37fc1daa",
        penId: "b0bf3df"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "dac4035",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "651dbbe"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dac4035"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dac4035"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dac4035"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dac4035"
      }
    ],
    rotate: 0
  },
  {
    id: "651dbbe",
    locked: 10,
    parentId: "dac4035",
    x: 0.1880548829701372,
    y: 0.26357677902621723,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8006456820016141,
    height: 0.40238764044943814,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "f13b315",
        penId: "651dbbe"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2188a6f",
        penId: "651dbbe"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4a1b17bd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d7cf5da"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4a1b17bd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4a1b17bd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4a1b17bd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4a1b17bd"
      }
    ],
    rotate: 0
  },
  {
    id: "d7cf5da",
    locked: 10,
    parentId: "4a1b17bd",
    x: 0.2397094430992736,
    y: 0.6334269662921348,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "circle",
    width: 0.11460855528652138,
    height: 0.03323970037453183,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d7cf5da"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d7cf5da"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d7cf5da"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d7cf5da"
      }
    ]
  },
  {
    id: "cc7f3b6",
    name: "combine",
    x: 0.16101694915254353,
    y: 0,
    locked: 0,
    width: 0.6779661016949121,
    height: 0.9999999999999997,
    children: [
      "9c5994f",
      "85f3ee",
      "a69020c",
      "76e6bcb",
      "cdf33e",
      "63b03a4",
      "3e70cd"
    ],
    anchors: [
      {
        id: "0",
        penId: "cc7f3b6",
        x: 0.9857142857142855,
        y: 0.9976591760299625
      },
      {
        id: "1",
        penId: "cc7f3b6",
        x: 0.9857142857142855,
        y: 0.0023408239700374533
      }
    ],
    description: "开关-惯性开关-闭合",
    parentId: "d0677b7",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.8389830508474556,
    ey: 0.9999999999999997
  },
  {
    id: "9c5994f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "12829e70"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9c5994f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9c5994f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9c5994f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9c5994f"
      }
    ],
    rotate: 0
  },
  {
    id: "12829e70",
    locked: 10,
    parentId: "9c5994f",
    x: 0.02261904761904762,
    y: 0.4014513108614232,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.07380952380952382,
    height: 0.16526217228464427,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "5df6aefc",
        penId: "12829e70"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5eae3db5",
        penId: "12829e70"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "85f3ee",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f957342"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "85f3ee"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "85f3ee"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "85f3ee"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "85f3ee"
      }
    ],
    rotate: 0
  },
  {
    id: "f957342",
    locked: 10,
    parentId: "85f3ee",
    x: 0.02261904761904762,
    y: 0.38693820224719105,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8404761904761904,
    height: 0.01451310861423215,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6678d636",
        penId: "f957342"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7cfd80c",
        penId: "f957342"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "a69020c",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "2763b646"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "a69020c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "a69020c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "a69020c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "a69020c"
      }
    ],
    rotate: 0
  },
  {
    id: "2763b646",
    locked: 10,
    parentId: "a69020c",
    x: 0.9857142857142855,
    y: 0.6659644194756554,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3316947565543071,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6970420",
        penId: "2763b646"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "70a7ada5",
        penId: "2763b646"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "76e6bcb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "103ff180"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "76e6bcb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "76e6bcb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "76e6bcb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "76e6bcb"
      }
    ],
    rotate: 0
  },
  {
    id: "103ff180",
    locked: 10,
    parentId: "76e6bcb",
    x: 0.9857142857142855,
    y: 0.0023408239700374533,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33169475655430714,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8d4d71f",
        penId: "103ff180"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "53cda15",
        penId: "103ff180"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "cdf33e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4c490749"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "cdf33e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "cdf33e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "cdf33e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "cdf33e"
      }
    ],
    rotate: 0
  },
  {
    id: "4c490749",
    locked: 10,
    parentId: "cdf33e",
    x: 0.7809523809523808,
    y: 0.20318352059925093,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2059523809523809,
    height: 0.4627808988764045,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3f497cd2",
        penId: "4c490749"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "4e390436",
        penId: "4c490749"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "63b03a4",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "dae1a6"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "63b03a4"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "63b03a4"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "63b03a4"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "63b03a4"
      }
    ],
    rotate: 0
  },
  {
    id: "dae1a6",
    locked: 10,
    parentId: "63b03a4",
    x: 0.011904761904761915,
    y: 0.5500936329588015,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "circle",
    width: 0.16904761904761903,
    height: 0.03323970037453183,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dae1a6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dae1a6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dae1a6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dae1a6"
      }
    ]
  },
  {
    id: "3e70cd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f157420"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3e70cd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3e70cd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3e70cd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3e70cd"
      }
    ],
    rotate: 0
  },
  {
    id: "f157420",
    locked: 10,
    parentId: "3e70cd",
    x: 0.6952380952380952,
    y: 0.33403558052434457,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2904761904761904,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "538c0f5",
        penId: "f157420"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d70609a",
        penId: "f157420"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ab399f5",
    name: "combine",
    x: -948.9944812432741,
    y: 2783.591358014707,
    ex: -890.9724616253116,
    ey: 2875.442771447308,
    width: 58.02201961796249,
    height: 91.85141343260112,
    center: {
      x: -919.9834714342928,
      y: 2829.517064731008
    },
    children: [
      "57971e6",
      "85cc95b",
      "43468a30"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ab399f5"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ab399f5"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ab399f5"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ab399f5"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "MultipleContact",
      "MultipleContact-2"
    ],
    description: "开关-单刀双掷"
  },
  {
    id: "57971e6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "4307c73",
      "98d918e",
      "949a86a",
      "ccfd4d",
      "7ad5a4c"
    ],
    anchors: [
      {
        id: "0",
        penId: "57971e6",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "57971e6",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "57971e6",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-中间位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "4307c73",
    locked: 10,
    parentId: "57971e6",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "7c4f510",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4307c73"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4307c73"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4307c73"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4307c73"
      }
    ]
  },
  {
    id: "98d918e",
    locked: 10,
    parentId: "57971e6",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6e6fa01",
        penId: "98d918e"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "3c8e069",
        penId: "98d918e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "949a86a",
    locked: 10,
    parentId: "57971e6",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d46f63f",
        penId: "949a86a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "500c5ac",
        penId: "949a86a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ccfd4d",
    locked: 10,
    parentId: "57971e6",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "3fb8d837",
        penId: "ccfd4d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ec176e",
        penId: "ccfd4d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7ad5a4c",
    locked: 10,
    parentId: "57971e6",
    x: 0.5,
    y: 0.19261195918023108,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.4063085097410812,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "0930080",
        penId: "7ad5a4c"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "589a943d",
        penId: "7ad5a4c"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "85cc95b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "4b53bbd",
      "fa52a46",
      "02e1616",
      "d7e2c46",
      "955cd37"
    ],
    anchors: [
      {
        id: "0",
        penId: "85cc95b",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "85cc95b",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "85cc95b",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-右位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "4b53bbd",
    locked: 10,
    parentId: "85cc95b",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "86524f3",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4b53bbd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4b53bbd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4b53bbd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4b53bbd"
      }
    ]
  },
  {
    id: "fa52a46",
    locked: 10,
    parentId: "85cc95b",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "fe24266",
        penId: "fa52a46"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "862ece6",
        penId: "fa52a46"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "02e1616",
    locked: 10,
    parentId: "85cc95b",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "18932e09",
        penId: "02e1616"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3be85b31",
        penId: "02e1616"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d7e2c46",
    locked: 10,
    parentId: "85cc95b",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "bdb07a5",
        penId: "d7e2c46"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "60b42e",
        penId: "d7e2c46"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "955cd37",
    locked: 10,
    parentId: "85cc95b",
    x: 0.5,
    y: 0.27870456270557475,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.4018958611481976,
    height: 0.3172303280762419,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7a11b2b",
        penId: "955cd37"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1d8894f0",
        penId: "955cd37"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "43468a30",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "916f56a",
      "439ca78d",
      "23b4ff4e",
      "2af47a96",
      "2f6018"
    ],
    anchors: [
      {
        id: "0",
        penId: "43468a30",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "43468a30",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "43468a30",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-左位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "916f56a",
    locked: 10,
    parentId: "43468a30",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3580bcf4",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "916f56a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "916f56a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "916f56a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "916f56a"
      }
    ]
  },
  {
    id: "439ca78d",
    locked: 10,
    parentId: "43468a30",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "13990b7",
        penId: "439ca78d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "0fadb82",
        penId: "439ca78d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "23b4ff4e",
    locked: 10,
    parentId: "43468a30",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "dbcbf67",
        penId: "23b4ff4e"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5d684b3",
        penId: "23b4ff4e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2af47a96",
    locked: 10,
    parentId: "43468a30",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1f2fe4b0",
        penId: "2af47a96"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "41b4553",
        penId: "2af47a96"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2f6018",
    locked: 10,
    parentId: "43468a30",
    x: 0.09810413885180241,
    y: 0.27870456270557475,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.4018958611481976,
    height: 0.3172303280762419,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "43b054a",
        penId: "2f6018"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "0b73ba3",
        penId: "2f6018"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0eca90c",
    name: "combine",
    x: -811.1132453099428,
    y: 2785.70796615796,
    ex: -753.0912256919803,
    ey: 2877.559379590561,
    width: 58.02201961796249,
    height: 91.85141343260112,
    center: {
      x: -782.1022355009616,
      y: 2831.633672874261
    },
    children: [
      "a50a9d",
      "107ef2a",
      "9aadb9a"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "0eca90c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "0eca90c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "0eca90c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "0eca90c"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "MultipleContact",
      "MultipleContact-3"
    ],
    description: "开关-三位置"
  },
  {
    id: "a50a9d",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "d6af092",
      "3467a0e2",
      "4ad10d99",
      "f741643",
      "5d94b170",
      "2a8895f",
      "5a704f56",
      "115c7ac",
      "20d57ad"
    ],
    anchors: [
      {
        id: "0",
        penId: "a50a9d",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "a50a9d",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "a50a9d",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "a50a9d",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      },
      {
        id: "4",
        penId: "a50a9d",
        x: 0,
        y: 0.343324618368896
      }
    ],
    description: "开关-三位置-1位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "d6af092",
    locked: 10,
    parentId: "a50a9d",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "65bdccc",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d6af092"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d6af092"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d6af092"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d6af092"
      }
    ]
  },
  {
    id: "3467a0e2",
    locked: 10,
    parentId: "a50a9d",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "c781765",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3467a0e2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3467a0e2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3467a0e2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3467a0e2"
      }
    ]
  },
  {
    id: "4ad10d99",
    locked: 10,
    parentId: "a50a9d",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "fb19b70",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4ad10d99"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4ad10d99"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4ad10d99"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4ad10d99"
      }
    ]
  },
  {
    id: "f741643",
    locked: 10,
    parentId: "a50a9d",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "8e35710",
        penId: "f741643"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2e21b8a",
        penId: "f741643"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5d94b170",
    locked: 10,
    parentId: "a50a9d",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8122d9",
        penId: "5d94b170"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7c17ab3",
        penId: "5d94b170"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2a8895f",
    locked: 10,
    parentId: "a50a9d",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "f51068",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2a8895f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2a8895f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2a8895f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2a8895f"
      }
    ]
  },
  {
    id: "5a704f56",
    locked: 10,
    parentId: "a50a9d",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "33773e33",
        penId: "5a704f56"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "59c0fe1",
        penId: "5a704f56"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "115c7ac",
    locked: 10,
    parentId: "a50a9d",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1f84dc0f",
        penId: "115c7ac"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4db08d42",
        penId: "115c7ac"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20d57ad",
    locked: 10,
    parentId: "a50a9d",
    x: 0,
    y: 0.343324618368896,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5,
    height: 0.2555958505524163,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ae696ae",
        penId: "20d57ad"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "8e1bd1",
        penId: "20d57ad"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "107ef2a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "a25934b",
      "3b89ef1",
      "fa3bc2c",
      "f7642c6",
      "645786d",
      "1051430",
      "54cf7428",
      "6d80bb9",
      "db08d80"
    ],
    anchors: [
      {
        id: "0",
        penId: "107ef2a",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "107ef2a",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "107ef2a",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "107ef2a",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-三位置-2位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "a25934b",
    locked: 10,
    parentId: "107ef2a",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "a0ecd01",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "a25934b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "a25934b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "a25934b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "a25934b"
      }
    ]
  },
  {
    id: "3b89ef1",
    locked: 10,
    parentId: "107ef2a",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "f5f5e77",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3b89ef1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3b89ef1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3b89ef1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3b89ef1"
      }
    ]
  },
  {
    id: "fa3bc2c",
    locked: 10,
    parentId: "107ef2a",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "5f71e1f6",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fa3bc2c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fa3bc2c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fa3bc2c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fa3bc2c"
      }
    ]
  },
  {
    id: "f7642c6",
    locked: 10,
    parentId: "107ef2a",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "67a13704",
        penId: "f7642c6"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "47d950be",
        penId: "f7642c6"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "645786d",
    locked: 10,
    parentId: "107ef2a",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e6fea73",
        penId: "645786d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "8f3f0e",
        penId: "645786d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1051430",
    locked: 10,
    parentId: "107ef2a",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3ae6546f",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1051430"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1051430"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1051430"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1051430"
      }
    ]
  },
  {
    id: "54cf7428",
    locked: 10,
    parentId: "107ef2a",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "40d8499d",
        penId: "54cf7428"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "76314f06",
        penId: "54cf7428"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6d80bb9",
    locked: 10,
    parentId: "107ef2a",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "41f5bfb1",
        penId: "6d80bb9"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "463311d1",
        penId: "6d80bb9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "db08d80",
    locked: 10,
    parentId: "107ef2a",
    x: 0.36443257676902535,
    y: 0.19919035169098423,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.13556742323097465,
    height: 0.39718309859154927,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "af5e575",
        penId: "db08d80"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "612cb4c5",
        penId: "db08d80"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9aadb9a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "74570835",
      "1275566",
      "4a0de302",
      "49f9637b",
      "5eb9b2bb",
      "122626c",
      "2595364",
      "68978eb",
      "ffe92b7"
    ],
    anchors: [
      {
        id: "0",
        penId: "9aadb9a",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "9aadb9a",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "9aadb9a",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "9aadb9a",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      },
      {
        id: "4",
        penId: "9aadb9a",
        x: 1,
        y: 0.343324618368896
      }
    ],
    description: "开关-三位置-3位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "74570835",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3fd48a86",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "74570835"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "74570835"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "74570835"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "74570835"
      }
    ]
  },
  {
    id: "1275566",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "9efe400",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1275566"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1275566"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1275566"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1275566"
      }
    ]
  },
  {
    id: "4a0de302",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "2208226c",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4a0de302"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4a0de302"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4a0de302"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4a0de302"
      }
    ]
  },
  {
    id: "49f9637b",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "0fc9b23",
        penId: "49f9637b"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "44b1230",
        penId: "49f9637b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5eb9b2bb",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "093fb83",
        penId: "5eb9b2bb"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "177adc9",
        penId: "5eb9b2bb"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "122626c",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "387b959b",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "122626c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "122626c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "122626c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "122626c"
      }
    ]
  },
  {
    id: "2595364",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "db4123e",
        penId: "2595364"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "778193f",
        penId: "2595364"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "68978eb",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "66888a0",
        penId: "68978eb"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e4d3552",
        penId: "68978eb"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ffe92b7",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.343324618368896,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5,
    height: 0.2555958505524163,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5cf32734",
        penId: "ffe92b7"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7e3545f",
        penId: "ffe92b7"
      }
    ],
    children: [],
    lineHeight: 1.5
  }
], Oh = {
  x: -1913.574579695493,
  y: 2785.717495189335
}, Dh = {
  x: -933,
  y: 3085
}, Bh = {
  "818f759": "M180,188.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "64c23b2": "M0,268.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58S0,280.34,0,268.98h0Z",
  fb0b262: "M180,188.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "607a597": "M44,268.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "4c10c83b": "M90.56,189.86c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "6b0139a9": "M90.56,189.86c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "7c4f510": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "86524f3": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3580bcf4": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "65bdccc": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  c781765: "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  fb19b70: "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  f51068: "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  a0ecd01: "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  f5f5e77: "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "5f71e1f6": "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3ae6546f": "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3fd48a86": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "9efe400": "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "2208226c": "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "387b959b": "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z"
}, zh = "dc171b5", Hh = "light", Fh = !0, Wh = "1.0.42", Vh = [], jh = 0, Uh = "", qh = [], Yh = !0, $h = [], Xh = [], vt = {
  x: _h,
  y: Lh,
  scale: Mh,
  pens: Nh,
  origin: Oh,
  center: Dh,
  paths: Bh,
  template: zh,
  theme: Hh,
  rule: Fh,
  version: Wh,
  dataPoints: Vh,
  locked: jh,
  name: Uh,
  msgTypes: qh,
  grid: Yh,
  wsMsgFields: $h,
  wsMsgHandlers: Xh
}, Lo = {
  0: 0,
  1: 90,
  2: 180,
  3: 270
}, Kh = [
  "Vdc",
  "MultipleContact",
  "Coil",
  "Lamp",
  "Diode",
  "TerminalsXT",
  "CoilOnDelay",
  "R",
  "VProbe",
  "IProbe",
  "CoilOffDelay",
  "CoilOnDelay",
  "DoubleCoil",
  "TransformerNew"
], Gh = [
  "Btn_SelfReset",
  "Btn_SelfLock",
  "Knob_SelfReset",
  "Knob_SelfLock"
];
function Ui(t, e, i) {
  let s = Lo[i.rotateAngel] || 0;
  if (["Switch", "MultipleContact"].includes(i.type)) {
    if (t.width > t.height) {
      const o = t.height;
      t.height = t.width, t.width = o;
    }
    s -= 90;
  }
  s && setTimeout(() => {
    meta2d.setValue({
      id: t.id,
      rotate: -s
      // 电路编辑器默认是逆时针旋转
    });
  }, 100);
  const a = (e == null ? void 0 : e.元件类型) || i.type;
  if (Kh.includes(a)) {
    t.y -= t.height / 2, t.x -= t.width / 2;
    return;
  } else if (Gh.includes(a)) {
    s ? i.rotateAngel == "1" ? (t.y -= t.height / 2 - 10, t.x -= t.width / 2) : i.rotateAngel == "2" ? (t.y -= t.height / 2, t.x -= t.width / 2 - 10) : i.rotateAngel == "3" && (t.x -= t.width / 2, t.y -= t.height / 2 + 10) : (t.x -= t.width / 1.5, t.y -= t.height / 2);
    return;
  }
  switch (a) {
    case "Input":
      s ? s === 90 ? (t.x -= t.width / 2, t.y += 5) : s === 180 ? t.y -= t.height / 2 : s === 270 && (t.y -= t.height + 5, t.x -= t.width / 2) : (t.x -= t.width, t.y -= t.height / 2);
      break;
    case "Output":
      s ? s === 90 ? (t.x -= t.width / 2, t.y += 5) : s === 180 ? t.y -= t.height / 2 : s === 270 && (t.y -= t.height + 5, t.x -= t.width / 2) : (t.y -= t.height / 2, t.x -= t.width);
      break;
    case "GND":
      s ? s === 90 ? t.y -= t.height / 2 : s === 180 ? (t.x -= t.width / 2, t.y -= t.height) : s === 270 && (t.y -= t.height / 2, t.x -= t.width) : t.x -= t.width / 2;
      break;
    case "ElectromagneticValve":
      s ? (i.rotateAngel == "1" || i.rotateAngel == "2" || i.rotateAngel == "3") && (t.x -= t.width / 2, t.y -= t.height / 2) : (t.y -= t.height / 2, t.x -= t.width / 2);
      break;
    case "duanluqi_wx":
      s ? i.rotateAngel == "1" ? (t.y -= t.height / 2 + 10, t.x -= t.width / 2) : i.rotateAngel == "2" ? (t.x -= t.width / 2 + 10, t.y -= t.height / 2) : i.rotateAngel == "3" && (t.y -= t.width - 6, t.x -= t.width / 2) : (t.x -= t.width / 4, t.y -= t.height / 2);
      break;
    case "Switch":
      i.rotateAngel == "0" ? (t.x -= t.width / 2, t.y -= t.height / 1.5) : i.rotateAngel == "1" ? (t.x -= t.width, t.y -= t.height / 2) : i.rotateAngel == "2" ? (t.x -= t.width / 2, t.y -= t.height / 3) : i.rotateAngel == "3" && (t.y -= t.height / 2);
      break;
    case "Contact":
      i.rotateAngel == "0" ? (t.x -= t.width - 3, t.y -= t.height / 2) : i.rotateAngel == "1" ? (t.x -= t.width / 2, t.y -= t.height / 4 + 2) : i.rotateAngel == "2" ? (t.y -= t.height / 2, t.x -= 2) : i.rotateAngel == "3" && (t.y -= t.height / 1.5 + 2, t.x -= t.width / 2);
      break;
    case "Contactk":
      i.rotateAngel == "0" ? (t.x -= t.width - 3, t.y -= t.height / 2) : i.rotateAngel == "1" ? (t.x -= t.width / 2, t.y -= t.height / 4 + 2) : i.rotateAngel == "2" ? (t.y -= t.height / 2, t.x -= 2) : i.rotateAngel == "3" && (t.y -= t.height / 1.5 + 2, t.x -= t.width / 2);
      break;
  }
}
const Jh = [
  "Btn_SelfLock",
  "Knob_SelfReset",
  "Switch",
  "Knob_SelfLock",
  "duanluqi_wx",
  "MultipleContact",
  "Btn_SelfReset"
];
function Qh(t) {
  if (t.type == "MultipleContact") {
    if (t.v10 > "3")
      return 0;
    if (t.v10 == "2")
      return t.v16 == "0" ? 1 : 2;
    if (t.v10 == "3")
      return Number(t.v18);
  } else {
    if (t.v10 == "off")
      return 0;
    if (t.v10 == "on")
      return 1;
  }
}
function Zh(t, e) {
  if (!t || !e) return;
  const i = [], s = [t];
  for (; s.length; ) {
    const a = s.shift();
    i.push(a);
    for (const o of e)
      o.parentId == a.id && s.push(o);
  }
  return i;
}
function ed(t) {
  const e = "-" + ne(), i = G(t);
  return i.forEach((s) => {
    s.id = s.id + e, s.children && (s.children = s.children.map((a) => a + e)), s.parentId && (s.parentId = s.parentId + e), s.anchors && s.anchors.forEach((a) => {
      a.penId = a.penId + e;
    });
  }), i;
}
const Tf = (t) => {
  sd((e) => {
    if (console.log("readJSONFile: ", e, vt), e != null && e.data) {
      if (meta2d.clear(), vt.paths) {
        const r = meta2d.data().paths || {};
        Object.assign(r, vt.paths), Object.assign(meta2d.store.data, {
          paths: r
        });
      }
      const { Components: i, Paintings: s, Wires: a } = e.data, o = [];
      i && i.forEach((r) => {
        var c;
        const l = Xl.find((d) => {
          var f, u;
          return ((f = d.元件类型) == null ? void 0 : f.toLocaleLowerCase()) == ((u = r.type) == null ? void 0 : u.toLocaleLowerCase());
        });
        if (meta2d.findOne(r.uuid))
          return;
        if (Jh.includes(r.type)) {
          let d = G(
            vt.pens.find((g) => {
              var y, v;
              if (r.type == "MultipleContact" && r.v10 >= "3")
                return ((y = g.tags) == null ? void 0 : y.includes("MultipleContact-3")) && !g.parentId;
              if ((v = g.tags) != null && v.includes(r.type) && !g.parentId)
                return !0;
            })
          );
          const f = Object.keys(r).filter((g) => g.startsWith("v"));
          f.length > 0 && (d.Ecomponents = f.map((g) => r[g])), console.log("Ecomponents=====: ", d.Ecomponents);
          const u = ed(
            Zh(d, vt.pens)
          );
          if (u) {
            d = u[0];
            const g = meta2d.getPenRect(d), y = g.width / vt.scale, v = g.height / vt.scale, b = Number((l == null ? void 0 : l["宽度(X向)"]) || y), x = Number((l == null ? void 0 : l["高度(Y向)"]) || v);
            Object.assign(d, {
              text: r.name,
              x: Number(r.posX),
              y: Number(r.posY),
              width: b,
              height: x,
              fault: 0,
              titleFnJs: "return `${pen.text}  ${pen.description}`;",
              color: "rgba(0, 0, 128, 1)"
            }), d.tags && !((c = d.tags) != null && c.includes(r.name)) && d.tags.push(r.name), Ui(d, l, r), d.showChild = Qh(r), meta2d.addPens(u);
            return;
          }
        }
        const h = Kl.find((d) => {
          var f;
          return d.data.electricTypeCode == r.type || ((f = d.data.tags) == null ? void 0 : f.includes(r.type));
        });
        if (h) {
          const d = Number(l == null ? void 0 : l["宽度(X向)"]), f = Number(l == null ? void 0 : l["高度(Y向)"]);
          Eh(h.data.image, h, !1).then((u) => {
            const g = u.find(
              (y) => y.name == "combine" && !y.parentId
            );
            Object.assign(g, {
              text: r.name,
              x: Number(r.posX),
              y: Number(r.posY),
              //rotate: rotateAngelMap[item.rotateAngel] || 0, // 跟预期不一致
              tags: [r.type, r.name],
              width: d || g.width,
              height: f || g.height,
              color: "rgba(0, 0, 128, 1)",
              fault: 0,
              titleFnJs: "return `${pen.text}  ${pen.description}`;"
            }), console.log(
              "单一 svg: ",
              h.name,
              h,
              g,
              d,
              f
            ), Ui(g, l, r), h.data.anchors && (g.anchors = h.data.anchors), meta2d.addPens(u);
          });
        } else {
          const d = {
            id: r.uuid,
            name: "rectangle",
            text: r.name,
            //   title: item.name,
            x: Number(r.posX),
            y: Number(r.posY),
            width: Number((l == null ? void 0 : l["宽度(X向)"]) || 100),
            height: Number((l == null ? void 0 : l["高度(Y向)"]) || 100),
            rotate: Lo[r.rotateAngel] || 0,
            tags: [r.type, r.name],
            color: "rgba(0, 0, 128, 1)"
            // fontSize: 10,
          };
          Ui(d, l, r), o.push(d);
        }
      }), a && a.forEach((r) => {
        if (meta2d.findOne(r.uuid))
          return;
        const { length: n = 0, anchors: h = [] } = id(r);
        let c;
        r.name.includes("CenterLineName") ? c = td(r.name) : c = r.name;
        const d = {
          type: 1,
          id: r.uuid,
          name: "line",
          lineName: "curve",
          text: c,
          //   title: item.name,
          x: Number(r.startX),
          y: Number(r.startY),
          width: n,
          height: n,
          anchors: h,
          tags: [r.name],
          fontSize: 14,
          color: "rgb(0, 0, 128)",
          textColor: "#000",
          lineAnimateType: 1,
          animateColor: "rgb(255, 0, 0)",
          textBaseline: "bottom"
        };
        console.log("连线: ", d), o.push(d);
      }), s && s.forEach((r) => {
        if (meta2d.findOne(r.uuid))
          return;
        const n = {
          id: r.uuid,
          name: "rectangle",
          text: r.text,
          //   title: item.name,
          x: Number(r.posX),
          y: Number(r.posY),
          width: 100,
          height: 50,
          color: r.color,
          textAutoAdjust: !0,
          borderWidth: 0
        };
        o.push(n);
      }), meta2d.addPens(o);
    }
  });
};
function td(t) {
  return t.includes("CenterLineName") ? t.split("_")[0] : "";
}
function id(t) {
  const { startX: e, startY: i, endX: s, endY: a } = t, o = Math.sqrt(
    Math.pow(s - e, 2) + Math.pow(a - i, 2)
  ), r = [
    { x: 0, y: 0 },
    { x: 1, y: 1 }
  ];
  return e === s ? r[1].x = 0 : r[1].y = 0, { length: o, anchors: r };
}
const sd = (t = null) => {
  const e = document.createElement("input");
  e.type = "file", e.accept = ".json", e.onchange = async () => {
    if (!e.files || !e.files.length) return;
    const i = e.files[0], { name: s, size: a, type: o } = i, r = new FileReader();
    r.onload = () => {
      try {
        const l = JSON.parse(r.result);
        t && t({ fileName: s, data: l });
      } catch (l) {
        console.error(l);
      }
    }, r.readAsText(i);
  }, e.click();
}, ad = (t = null) => {
  const e = document.createElement("input");
  e.type = "file", e.accept = ".svg", e.onchange = async () => {
    if (!e.files || !e.files.length) return;
    const i = e.files[0], { name: s } = i, a = new FileReader();
    a.onload = () => {
      try {
        const o = a.result;
        t && t({ fileName: s, data: o });
      } catch (o) {
        console.error(o);
      }
    }, a.readAsText(i);
  }, e.click();
};
function Cf(t) {
  if (navigator.clipboard && window.isSecureContext)
    return navigator.clipboard.writeText(t).then(() => !0).catch((e) => {
      console.error("复制失败：", e);
    });
  {
    const e = document.createElement("textarea");
    e.value = t, document.body.appendChild(e), e.select();
    const i = document.execCommand("copy");
    return document.body.removeChild(e), new Promise((s, a) => {
      i ? s(!0) : a(!1);
    });
  }
}
const Rf = () => {
  !document.fullscreenElement && // 没有处于全屏模式
  !document.mozFullScreenElement && // Firefox
  !document.webkitFullscreenElement && // Chrome, Safari, Opera
  !document.msFullscreenElement ? document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.mozRequestFullScreen ? document.documentElement.mozRequestFullScreen() : document.documentElement.webkitRequestFullscreen ? document.documentElement.webkitRequestFullscreen() : document.documentElement.msRequestFullscreen && document.documentElement.msRequestFullscreen() : document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
}, od = () => {
  const t = Ve([]), e = {
    limit: 1024 * 1,
    unit: "KB"
  }, i = $o(), s = {
    Authorization: i.token
  };
  return {
    uploadValue: t,
    sizeLimit: e,
    headers: s,
    handleFail: (r) => {
      console.log("upload fail: ", r);
    },
    uploadFileFn: (r) => {
      if (!i.uploadUrl) return Promise.reject("文件上传地址不存在！");
      const l = new FormData();
      return l.append("object", r), fetch(i.uploadUrl, {
        method: "POST",
        headers: s,
        body: l
      }).then((n) => n.json()).then((n) => n).catch((n) => {
        console.log(n);
      });
    }
  };
};
let qi = null;
function rd(t, e) {
  var l;
  let i = t.split(","), s = ((l = i[0].match(/:(.*\/*?);/)) == null ? void 0 : l[1]) || "image/png", a = atob(i[1]), o = a.length, r = new Uint8Array(o);
  for (; o--; )
    r[o] = a.charCodeAt(o);
  return new File([r], e, { type: s });
}
function nd(t, e) {
  const i = e ? meta2d.toPng() : meta2d.activeToPng();
  if (t != null && t.endsWith(".png") || (t += ".png"), i)
    return rd(i, t);
}
function ld(t) {
  var s;
  if (console.log("getJsonString: ", t), !t) return;
  let e;
  if (t.mode == 1)
    t.pen.name == "combine" ? e = [...t.pen.children.map((o) => meta2d.findOne(o)), t.pen] : e = t.pen;
  else if (t.mode == 2) {
    const a = t.pens;
    meta2d.combine(a);
    const o = (s = meta2d.store.active) == null ? void 0 : s[0];
    e = [...a, o];
  }
  let i = "";
  try {
    const a = G(e);
    Array.isArray(a) ? a.forEach((o) => {
      o.calculative = void 0;
    }) : a.calculative = void 0, i = JSON.stringify(a);
  } catch (a) {
    console.log("error: ", a);
  }
  return i;
}
const cd = (t) => {
  const e = Ve([]), i = Ve([]), s = Ve(!1), a = Ve(""), o = Ve(!1), r = Ve(""), l = ar(), n = Ve("");
  let h = null, c = "";
  const d = (R) => {
    o.value = !1, s.value = !0, c = R;
  }, { uploadFileFn: f } = od(), u = () => {
    if (console.log("confirm: ", a.value, h), s.value = !1, !!a.value)
      if (o.value) {
        let R;
        c != "paper" ? R = ld(h) : R = JSON.stringify(h);
        const A = nd(
          n.value || "image.png",
          c == "paper"
        ), P = (E) => l.saveComponent({
          nodeId: a.value,
          data: R,
          type: c,
          // image, component, paper,
          name: n.value,
          label: c == "paper" ? "paper" : "component",
          cover: E
        }).then((D) => {
          (D == null ? void 0 : D.code) == 200 && k(c);
        });
        if (console.log("png file: ", A), A) {
          f(A).then((E) => {
            if (console.log("upload file: ", E), (E == null ? void 0 : E.code) == 200) {
              const D = E.data.fileurl;
              P(D);
            }
          });
          return;
        }
        P();
      } else
        l.createFolder({
          dictName: a.value,
          type: c
        }).then((R) => {
          (R == null ? void 0 : R.code) == 200 && k(c);
        });
  }, g = (R, A) => {
    l.saveComponent({
      nodeId: R.id,
      data: JSON.stringify(A),
      type: "component",
      name: A.fileName,
      cover: A.image,
      label: "iamge"
    }).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k("component");
    });
  }, y = () => {
    a.value = "", n.value = "";
  }, v = (R, A) => {
    l.deleteComponent(R.id).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k(A);
    });
  }, b = (R) => {
    o.value = !0, s.value = !0, h = R, c = "component", r.value = c;
  }, x = () => {
    o.value = !0, s.value = !0, h = meta2d.data(), c = "paper", r.value = c;
  }, p = (R, A) => {
    l.deleteFolder(R.id).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k(A);
    });
  }, k = (R) => l.getTree(R).then((A) => {
    Array.isArray(A.data) && (R == "paper" ? e.value = A.data : i.value = A.data);
  });
  return t && qi ? qi : qi = {
    blueprintList: e,
    componentList: i,
    saveComponentShow: b,
    showAddFolder: d,
    deleteMyPen: v,
    visible: s,
    folderName: a,
    confirm: u,
    close: y,
    selectMode: o,
    selectType: r,
    deleteFolder: p,
    getTree: k,
    fileName: n,
    saveImageComponent: g,
    saveBlueprintShow: x
  };
}, Mo = (t, e) => {
  const i = t.__vccOpts || t;
  for (const [s, a] of e)
    i[s] = a;
  return i;
};
function hd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ey: r } = t.calculative.worldRect, l = o / 4;
  if (i.moveTo(s + l, a), i.lineTo(s, a), i.lineTo(s, r), i.lineTo(s + l, r), i instanceof Path2D) return i;
}
function dd(t) {
  const e = [
    {
      x: 0.25,
      y: 0
    },
    {
      x: 0.25,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: a + "",
    x: i,
    y: s,
    penId: t.id
  }));
}
function ud(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect, n = t.offsetX;
  let h = o / 7;
  if (n > 1 ? h = n : n > 0 && (h = o * n), i.moveTo(s + h, a), i.lineTo(r, a), i.lineTo(s + o - h, l), i.lineTo(s, l), i.closePath(), i instanceof Path2D) return i;
}
function fd(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.9285714285714286,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.07142857142857142,
      y: 0.5
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function gd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l, ey: n } = t.calculative.worldRect, h = o / 8;
  if (i.moveTo(s + h, a), i.lineTo(l - h, a), i.bezierCurveTo(
    l + h / 3,
    a,
    l + h / 3,
    n,
    l - h,
    n
  ), i.lineTo(s + h, n), i.lineTo(s, a + r / 2), i.closePath(), i instanceof Path2D) return i;
}
function vd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l, center: n } = t.calculative.worldRect, h = n.x, c = a + r * 6 / 7, d = r / 6;
  if (i.moveTo(s, a), i.lineTo(l, a), i.lineTo(l, c), i.bezierCurveTo(
    l - 20,
    c - d,
    h + o / 5,
    c - d,
    h,
    c
  ), i.bezierCurveTo(
    h - o / 5,
    c + d,
    s,
    c + d,
    s,
    c
  ), i.closePath(), i instanceof Path2D) return i;
}
function yd(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 0.8571428571428571
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function md(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 10;
  if (i.moveTo(s + n * 2, a), i.bezierCurveTo(
    s - n * 2 / 3,
    a,
    s - n * 2 / 3,
    l,
    s + n * 2,
    l
  ), i.lineTo(r, l), i.bezierCurveTo(r - n, l, r - n, a, r, a), i.closePath(), i instanceof Path2D) return i;
}
function pd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect;
  i.moveTo(s, a), i.lineTo(r, a), i.lineTo(r, l), i.lineTo(s, l), i.closePath();
  const n = o / 7;
  if (i.moveTo(s, a + n), i.lineTo(r, a + n), i.moveTo(s + n, a), i.lineTo(s + n, l), i instanceof Path2D) return i;
}
function bd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, height: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 4;
  if (i.moveTo(s, a + n), i.lineTo(r, a), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i instanceof Path2D) return i;
}
function wd(t) {
  const e = [
    {
      x: 0.5,
      y: 0.125
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function xd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, ex: o, ey: r } = t.calculative.worldRect;
  if (i.moveTo(s, a), i.lineTo(o, a), i.moveTo(s, r), i.lineTo(o, r), i instanceof Path2D) return i;
}
function kd(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: a + "",
    x: i,
    y: s,
    penId: t.id
  }));
}
function Id(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l, ey: n } = t.calculative.worldRect;
  if (i.ellipse(
    s + o / 2,
    a + r / 2,
    o / 2,
    r / 2,
    0,
    0,
    Math.PI * 2
  ), i.moveTo(s + o / 2, n), i.lineTo(l, n), i.closePath(), i instanceof Path2D) return i;
}
function Sd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 7;
  if (i.moveTo(s, a), i.lineTo(r, a), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i.moveTo(s + n, a), i.lineTo(s + n, l), i.moveTo(r - n, a), i.lineTo(r - n, l), i instanceof Path2D) return i;
}
function Ad(t, e) {
  const i = e || new Path2D(), { x: s, y: a, height: o, ex: r, ey: l } = t.calculative.worldRect, n = o / 7;
  if (i.moveTo(s, a + n), i.bezierCurveTo(
    s,
    a - n / 2 | 0,
    r,
    a - n / 2 | 0,
    r,
    a + n
  ), i.lineTo(r, l - n), i.bezierCurveTo(
    r,
    l + n / 2 | 0,
    s,
    l + n / 2 | 0,
    s,
    l - n
  ), i.closePath(), i.moveTo(s, l - n), i.bezierCurveTo(
    s,
    l - n * 2 | 0,
    r,
    l - n * 2 | 0,
    r,
    l - n
  ), i instanceof Path2D) return i;
}
function Td() {
  return {
    flowComment: hd,
    flowData: ud,
    flowDb: Ad,
    flowDisplay: gd,
    flowDocument: vd,
    flowExternStorage: md,
    flowInternalStorage: pd,
    flowManually: bd,
    flowParallel: xd,
    flowQueue: Id,
    flowSubprocess: Sd
  };
}
function Cd() {
  return {
    flowDocument: yd,
    flowManually: wd,
    flowParallel: kd,
    flowComment: dd,
    flowData: fd
  };
}
function Rd(t, e) {
  const { x: i, y: s, width: a, height: o } = e.calculative.worldRect;
  t.beginPath(), t.ellipse(
    i + a / 2,
    s + o / 2,
    a / 2,
    o / 2,
    0,
    0,
    Math.PI * 2
  ), t.stroke(), t.beginPath(), t.fillStyle = t.strokeStyle, t.ellipse(
    i + a / 2,
    s + o / 2,
    a / 4,
    o / 4,
    0,
    0,
    Math.PI * 2
  ), t.fill();
}
function Pd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ey: l } = t.calculative.worldRect, n = t.calculative.lineLeft || 0.08;
  let h = t.calculative.borderRadius || 0, c = h;
  h < 1 && (h = o * h, c = r * h);
  let d = h < c ? h : c;
  if (o < 2 * d && (d = o / 2), r < 2 * d && (d = r / 2), i.moveTo(s + d, a), i.arcTo(s + o, a, s + o, a + r, d), i.arcTo(s + o, a + r, s, a + r, d), i.arcTo(s, a + r, s, a, d), i.arcTo(s, a, s + o, a, d), i.closePath(), i.moveTo(s + n * o, a), i.lineTo(s + n * o, l), i instanceof Path2D) return i;
}
function Ed(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l } = t.calculative.worldRect, n = t.calculative.lineTop || 0.08;
  let h = t.calculative.borderRadius || 0, c = h;
  h < 1 && (h = o * h, c = r * c);
  let d = h < c ? h : c;
  if (o < 2 * d && (d = o / 2), r < 2 * d && (d = r / 2), i.moveTo(s + d, a), i.arcTo(s + o, a, s + o, a + r, d), i.arcTo(s + o, a + r, s, a + r, d), i.arcTo(s, a + r, s, a, d), i.arcTo(s, a, s + o, a, d), i.closePath(), i.moveTo(s, a + n * r), i.lineTo(l, a + n * r), i instanceof Path2D) return i;
}
function _d() {
  return {
    forkV: Tt,
    forkH: Tt,
    swimlaneH: Pd,
    swimlaneV: Ed
  };
}
function Ld() {
  return {
    activityFinal: Rd
  };
}
function Md(t, e) {
  t.onDestroy || (t.onDestroy = Od, t.onAdd = Nd);
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l } = t.calculative.worldRect;
  let n = t.calculative.borderRadius || 0, h = n;
  n < 1 && (n *= o, h *= r);
  let c = n < h ? n : h;
  o < 2 * c && (c = o / 2), r < 2 * c && (c = r / 2), i.moveTo(s + c, a), i.arcTo(s + o, a, s + o, a + r, c), i.arcTo(s + o, a + r, s, a + r, c), i.arcTo(s, a + r, s, a, c), i.arcTo(s, a, s + o, a, c);
  const d = 0.2 * r;
  i.moveTo(s, a + d), i.lineTo(l, a + d);
  const f = a + d + (r - d) / 2;
  if (i.moveTo(s, f), i.lineTo(l, f), i.closePath(), i instanceof Path2D) return i;
}
function Nd(t) {
  const { x: e, y: i, width: s, height: a } = t.calculative.worldRect, o = t.list, r = {
    name: "text",
    x: e,
    y: i + 0.2 * a,
    width: s,
    height: 0.4 * a,
    // text: list[0].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  }, l = {
    name: "text",
    x: e,
    y: i + 0.6 * a,
    width: s,
    height: 0.4 * a,
    // text: list[1].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  };
  Object.assign(r, o[0]), Object.assign(l, o[1]), t.calculative.canvas.makePen(r), t.calculative.canvas.makePen(l), t.calculative.canvas.parent.pushChildren(t, [r]), t.calculative.canvas.parent.pushChildren(t, [l]);
}
function Od(t) {
  const e = t.calculative.canvas.store;
  t.children.forEach((i) => {
    const s = e.data.pens.findIndex((a) => a.id === i);
    s > -1 && (e.data.pens.splice(s, 1), e.pens[i] = void 0);
  }), t.children = void 0;
}
function Dd(t, e) {
  t.onDestroy || (t.onDestroy = zd, t.onAdd = Bd);
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r, ex: l } = t.calculative.worldRect;
  let n = t.calculative.borderRadius || 0, h = n;
  n < 1 && (n = o * n, h = r * h);
  let c = n < h ? n : h;
  o < 2 * c && (c = o / 2), r < 2 * c && (c = r / 2), i.moveTo(s + c, a), i.arcTo(s + o, a, s + o, a + r, c), i.lineTo(s + o, a + r - c), i.arcTo(s + o, a + r, s, a + r, c), i.arcTo(s, a + r, s, a, c), i.arcTo(s, a, s + o, a, c);
  const d = 0.2 * r;
  if (i.moveTo(s, a + d), i.lineTo(l, a + d), i.closePath(), i instanceof Path2D) return i;
}
function Bd(t) {
  const { x: e, y: i, width: s, height: a } = t.calculative.worldRect, o = t.list;
  let r = {
    name: "text",
    x: e,
    y: i + 0.2 * a,
    width: s,
    height: 0.8 * a,
    // text: list[0].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  };
  Object.assign(r, o[0]), t.calculative.canvas.makePen(r), t.calculative.canvas.parent.pushChildren(t, [r]);
}
function zd(t) {
  const e = t.calculative.canvas.store;
  t.children.forEach((i) => {
    const s = e.data.pens.findIndex((a) => a.id === i);
    s > -1 && (e.data.pens.splice(s, 1), e.pens[i] = void 0);
  }), t.children = [];
}
function Hd() {
  return {
    interfaceClass: Md,
    simpleClass: Dd
  };
}
function Fd(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  if (i.rect(s, a, o, r), i.closePath(), i instanceof Path2D) return i;
}
function Wd(t, e) {
  const i = e.headHeight ?? 50, { x: s, y: a, width: o, height: r, ey: l } = e.calculative.worldRect;
  let n = e.calculative.borderRadius || 0, h = n;
  e.calculative.borderRadius < 1 && (n *= o, h *= r);
  let c = n < h ? n : h;
  o < 2 * c && (c = o / 2), i < 2 * c && (c = i / 2), t.beginPath(), t.moveTo(s + c, a), t.arcTo(s + o, a, s + o, a + i, c), t.arcTo(s + o, a + i, s, a + i, c), t.arcTo(s, a + i, s, a, c), t.arcTo(s, a, s + o, a, c), t.closePath(), t.stroke(), t.save(), t.beginPath(), t.lineWidth = 1, t.setLineDash([7, 7]);
  const d = s + o / 2;
  t.moveTo(d, a + i + 1), t.lineTo(d, l), t.stroke(), t.restore();
}
function Vd() {
  return {
    sequenceFocus: Fd
  };
}
function jd() {
  return {
    lifeline: Wd
  };
}
let gs = [
  "fontSize",
  "nameGap",
  "margin",
  "width",
  "symbolSize",
  "itemWidth",
  // 图例宽度
  "itemHeight",
  // 图例高度
  "fontWeight",
  "top",
  "left",
  "right",
  "bottom",
  "zoom",
  "edgeSymbolSize",
  "nodeWidth",
  "nodeGap",
  "distance",
  "length",
  "length2",
  "offsetCenter",
  "size",
  "symbolOffset",
  "padding",
  "barWidth",
  "symbolOffset",
  "shadowOffsetY",
  "shadowOffsetX"
];
function Ud(t) {
  var a, o;
  let e = globalThis.echarts;
  if (!t.echarts || !e)
    return;
  if (typeof t.echarts == "string")
    try {
      t.echarts = JSON.parse(t.echarts);
    } catch {
    }
  gs = ((a = t.calculative.canvas.store.options.diagramOptions.chart) == null ? void 0 : a.keyWords) || gs, t.onDestroy || (t.onDestroy = Yd, t.onMove = Yi, t.onResize = $d, t.onRotate = Yi, t.onValue = Xd, t.onBeforeValue = Kd, t.onBinds = Gd, t.onMouseEnter = Yi, t.onRenderPenRaw = $i), t.calculative.singleton || (t.calculative.singleton = {});
  const i = new Path2D(), s = t.calculative.worldRect;
  if (!t.calculative.singleton.div) {
    const r = document.createElement("div");
    r.style.position = "absolute", r.style.outline = "none", r.style.left = "-9999px", r.style.top = "-9999px", r.style.width = s.width + "px", r.style.height = s.height + "px", document.body.appendChild(r), (o = t.calculative.canvas.externalElements) == null || o.parentElement.appendChild(r), Ce(t, r), t.calculative.singleton.div = r, t.calculative.singleton.echart = e.init(r, t.echarts.theme), qd(t), t.calculative.singleton.echartsReady = !0, t.echarts.geoName && !e.getMap(t.echarts.geoName) && (t.echarts.geoJson ? e.registerMap(t.echarts.geoName, t.echarts.geoJson) : t.echarts.geoUrl && (t.calculative.singleton.echartsReady = !1, fetch(t.echarts.geoUrl).then((l) => {
      l.text().then((n) => {
        if (typeof n == "string")
          try {
            n = JSON.parse(n);
          } catch {
          }
        if (n.constructor !== Object && n.constructor !== Array) {
          console.warn("Invalid data:", n);
          return;
        }
        e.registerMap(t.echarts.geoName, n), t.calculative.singleton.echartsReady = !0, t.calculative.singleton.echart.setOption(
          Ei(
            t.echarts.option,
            t.calculative.canvas.store.data.scale
          ),
          !0
        ), t.calculative.singleton.echart.resize(), setTimeout(() => {
          $i(t);
        }, 300);
      });
    }))), t.calculative.singleton.echartsReady && setTimeout(() => {
      t.calculative.singleton.echart.setOption(
        Ei(
          t.echarts.option,
          t.calculative.canvas.store.data.scale
        ),
        !0
      ), setTimeout(() => $i(t), 300);
    });
  }
  return i;
}
function qd(t) {
  var s;
  const e = t.calculative.singleton.echart, i = ["click", "dblclick", "mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "globalout", "contextmenu"];
  i.forEach((a) => {
    e.off(a);
  }), (s = t.events) == null || s.forEach((a) => {
    a.actions && a.actions.length && i.includes(a.name) && e.on(a.name, (o) => {
      let r = !1;
      a.conditions && a.conditions.length ? a.conditionType === "and" ? r = a.conditions.every((l) => t.calculative.canvas.parent.judgeCondition(t, l.key, l)) : a.conditionType === "or" && (r = a.conditions.some((l) => t.calculative.canvas.parent.judgeCondition(t, l.key, l))) : r = !0, r && a.actions.forEach((l) => {
        if (l.timeout) {
          let n = setTimeout(() => {
            t.calculative.canvas.parent.events[l.action] && (t.calculative.canvas.parent.events[l.action](t, l, o), clearTimeout(n), n = null);
          }, l.timeout);
        } else
          t.calculative.canvas.parent.events[l.action] && t.calculative.canvas.parent.events[l.action](t, l, o);
      });
    });
  });
}
function Yd(t) {
  if (t.calculative.singleton && t.calculative.singleton.div) {
    t.calculative.singleton.div.remove();
    let e = globalThis.echarts;
    e && e.dispose(t.calculative.singleton.echart), delete t.calculative.singleton.div, delete t.calculative.singleton.echart;
  }
}
function Yi(t) {
  t.calculative.singleton.div && Ce(t, t.calculative.singleton.div);
}
function $d(t) {
  if (!t.calculative.singleton.echart)
    return;
  let e = globalThis.echarts;
  Ce(t, t.calculative.singleton.div), !(t.echarts.geoName && !e.getMap(t.echarts.geoName)) && (t.calculative.singleton.echart.setOption(
    Ei(t.echarts.option, t.calculative.canvas.store.data.scale),
    !0
  ), t.calculative.singleton.echart.resize());
}
function Xd(t) {
  if (t.calculative.singleton.echart && (Ce(t, t.calculative.singleton.div), t.calculative.singleton.echartsReady))
    if (t.calculative.partialOption) {
      const e = t.calculative.partialOption.echarts.option;
      t.calculative.singleton.echart.setOption(G(e));
    } else
      t.calculative.singleton.echart.setOption(
        Ei(
          t.echarts.option,
          t.calculative.canvas.store.data.scale
        ),
        !0
      );
}
function Kd(t, e) {
  if (t.calculative.partialOption = null, e.echarts) {
    let g = globalThis.echarts;
    return e.echarts.geoName && !g.getMap(e.echarts.geoName) && (e.echarts.geoJson ? g.registerMap(e.echarts.geoName, e.echarts.geoJson) : e.echarts.geoUrl && (t.calculative.singleton.echartsReady = !1, fetch(e.echarts.geoUrl).then((y) => {
      y.text().then((v) => {
        if (typeof v == "string")
          try {
            v = JSON.parse(v);
          } catch {
          }
        if (v.constructor !== Object && v.constructor !== Array) {
          console.warn("Invalid data:", v);
          return;
        }
        return g.registerMap(e.echarts.geoName, v), t.calculative.singleton.echartsReady = !0, t.onValue(t), !1;
      });
    }))), e;
  }
  if (t.realTimes && t.realTimes.length) {
    let g = Object.keys(e);
    const { xAxis: y, yAxis: v } = t.echarts.option, { max: b, replaceMode: x, timeFormat: p } = t.echarts;
    let k = [], R = !1;
    for (let A in e)
      if (A.includes("echarts.option")) {
        R = !0;
        let P = Bt(t, A);
        if (Array.isArray(P) && x === 0 && (P.push(e[A]), b && P.splice(0, P.length - b), e[A] = P, !g.includes("echarts.option.xAxis.data"))) {
          let E = "echarts.option.xAxis.data";
          Array.isArray(y) && y.length && (E = "echarts.option.xAxis.0.data");
          let D = Bt(t, E), q = Er(
            p || "`${hours}:${minutes}:${seconds}`"
          );
          D.push(q), b && D.splice(0, D.length - b), e[E] = D;
        }
        if (A.includes(".data.")) {
          let E = A.substring(0, A.indexOf(".data.") + 5);
          k.includes(E) || k.push(E);
        }
      }
    if (R) {
      const A = G(e);
      t.calculative.partialOption = Jd(A), k.forEach((P) => {
        let E = Bt(t, P);
        ts(t.calculative.partialOption, P, E);
      });
    }
    return e;
  }
  if (!e.dataX && !e.dataY)
    return e;
  const i = t.echarts, { max: s, replaceMode: a } = i;
  let o = e.dataX, r = e.dataY, l = [];
  r && l.push("echarts.option.series");
  const n = i.option.series, h = n.length, { xAxis: c, yAxis: d } = i.option;
  Array.isArray(c) && c.length > 1 && console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  const f = Array.isArray(c) ? c[0] : c, u = Array.isArray(d) ? d[0] : d;
  if (a)
    if (a === 1) {
      if (!f && !u)
        r && (h === 1 ? (!Array.isArray(r) && (r = [r]), r.forEach((g, y) => {
          const v = n[0].data.find((b) => b.name === g.name);
          v && (v.value = g.value);
        })) : n.forEach((g, y) => {
          Array.isArray(r[y]) || (r[y] = [r[y]]), r[y].forEach((v, b) => {
            const x = g.data.find((p) => p.name === v.name);
            x && (x.value = v.value);
          });
        }));
      else if ((f.type === "category" || u.type === "category") && o && r) {
        const g = f.type === "category" ? f.data : u.data;
        !Array.isArray(o) && (o = [o]), !Array.isArray(r) && (r = [r]), f.type === "category" ? l.push("echarts.option.xAxis") : l.push("echarts.option.yAxis"), h === 1 ? r.forEach((y, v) => {
          const b = g.indexOf(o[v]);
          n[0].data[b] = y;
        }) : n.forEach((y, v) => {
          r[v].forEach((b, x) => {
            const p = g.indexOf(o[x]);
            y.data[p] = b;
          });
        });
      }
    } else a === 2 && (o && (f.data = o, f.data.splice(0, f.data.length - s), l.push("echarts.option.xAxis")), r && (h === 1 ? (n[0].data = r, n[0].data.splice(0, n[0].data.length - s)) : n.forEach((g, y) => {
      g.data = r[y], g.data.splice(0, g.data.length - s);
    })));
  else {
    if (o) {
      !Array.isArray(o) && (o = [o]);
      const g = f.data;
      g.push(...o), g.splice(0, g.length - s), l.push("echarts.option.xAxis");
    }
    if (r)
      if (h === 1) {
        !Array.isArray(r) && (r = [r]);
        const g = n[0].data;
        g.push(...r), g.splice(0, g.length - s);
      } else
        n.forEach((g, y) => {
          Array.isArray(r[y]) || (r[y] = [r[y]]);
          const v = g.data;
          v.push(...r[y]), v.splice(0, v.length - s);
        });
  }
  return t.calculative.partialOption = {}, l.forEach((g) => {
    let y = Bt(t, g);
    ts(t.calculative.partialOption, g, y);
  }), delete e.dataX, delete e.dataY, Object.assign(e, { echarts: i });
}
function Gd(t, e, i) {
  if (i.key !== "dataY")
    return;
  const s = t.echarts, { xAxis: a, yAxis: o } = s.option;
  Array.isArray(a) && a.length > 1 && console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  const r = Array.isArray(a) ? a[0] : a, l = Array.isArray(o) ? o[0] : o, n = s.option.series;
  if (!r && !l) {
    const h = [];
    if (Array.isArray(n) && n.length === 1)
      return n[0].data.forEach((c) => {
        const { dataId: d } = i.dataIds.find(
          (f) => f.name === c.name
        );
        if (d) {
          const f = e.find((u) => u.dataId === d);
          f && h.push({
            name: c.name,
            value: f.value
          });
        }
      }), {
        id: t.id,
        dataY: h
      };
  } else if (r.type === "category" || l.type === "category") {
    const h = [], c = [], d = r.type === "category" ? r.data : l.data;
    return d == null || d.forEach((f) => {
      const { dataId: u } = i.dataIds.find(
        (g) => g.name === f
      );
      if (u) {
        const g = e.find((y) => y.dataId === u);
        g && (c.push(f), h.push(g.value));
      }
    }), {
      id: t.id,
      dataY: h,
      dataX: c
    };
  } else if (r.type === "time") {
    const h = [], c = +/* @__PURE__ */ new Date();
    let d = !1;
    if (n.forEach((f, u) => {
      const g = [], { dataId: y } = i.dataIds.find(
        (v) => v.name === f.name
      );
      if (y) {
        const v = e.find((b) => b.dataId === y);
        v && (g.push([c, v.value]), d = !0);
      }
      h[u] = g;
    }), d)
      h.forEach((f, u) => {
        if (!f || f.length === 0) {
          const g = n[u].data[n[u].data.length - 1];
          h[u] = [[c, g[1]]];
        }
      });
    else
      return;
    return {
      id: t.id,
      dataY: h.length === 1 ? h[0] : h
    };
  }
}
function $i(t) {
  var i, s;
  const e = new Image();
  e.src = (s = (i = t.calculative.singleton) == null ? void 0 : i.echart) == null ? void 0 : s.getDataURL({
    pixelRatio: 2
  }), t.calculative.img = e;
}
function Ei(t, e) {
  const i = G(t);
  if (i.dataZoom) {
    let s = ["right", "top", "width", "height", "left", "bottom"];
    for (let a = 0; a < s.length; a++)
      i.dataZoom.forEach((o) => {
        isNaN(o[s[a]]) || (o[s[a]] *= e);
      });
  }
  return Zi(i, gs, e), i;
}
function Jd(t) {
  const e = {};
  return Object.keys(t).forEach((i) => {
    const s = i.split(".");
    let a = e;
    s.forEach((o, r) => {
      const l = !isNaN(parseInt(o));
      if (r === s.length - 1)
        l ? (Array.isArray(a) || (a = []), a[parseInt(o)] = t[i]) : a[o] = t[i];
      else if (l) {
        const n = parseInt(o);
        if (Array.isArray(a) || a[s[r - 1]], a[n] || (a[n] = {}), Array.isArray(a))
          for (let h = 0; h < parseInt(o); h++)
            a[h] || (a[h] = {});
        a = a[n];
      } else
        a[o] || (o === "series" ? a[o] = [] : a[o] = {}), a = a[o];
    });
  }), e;
}
function Qd(t) {
  xt({ echarts: Ud });
}
var vs = /* @__PURE__ */ ((t) => (t[t.Add = 0] = "Add", t[t.Replace = 1] = "Replace", t[t.ReplaceAll = 2] = "ReplaceAll", t))(vs || {});
function No(t, e) {
  const i = e.calculative.worldRect.height * 14 / 16, a = (t.match(/[\u4e00-\u9fa5]/g) || "").length;
  return (t.length - a) * i * 0.6 + a * i;
}
function Oo(t) {
  if (t.direction == "horizontal") {
    const e = [];
    let i = 0;
    const s = t.height;
    t.checkboxHeight = s, t.options.forEach((o, r) => {
      e.push(r * (40 + s) + i), i += No(o.text, t);
    }), t.optionPos = e;
    const a = e.length * (40 + s) + i;
    t.checkboxWidth = a, t.width = a, t.calculative.width = a, t.calculative.worldRect = {
      x: t.x,
      y: t.y,
      height: t.height,
      width: t.width,
      center: {
        x: t.x + t.width / 2,
        y: t.y + t.height / 2
      }
    }, we(t.calculative.worldRect);
  } else if (t.direction == "vertical") {
    t.optionInterval == null && (t.optionInterval = 20), t.optionHeight || (t.optionHeight = 20);
    const e = [];
    t.options.forEach((s, a) => {
      e.push(a * (t.optionInterval + t.optionHeight));
    }), t.optionPos = e;
    const i = e[e.length - 1] + t.optionHeight;
    t.checkboxHeight = i, t.width || (t.height = i, t.calculative.height = i, t.calculative.worldRect = {
      x: t.x,
      y: t.y,
      height: t.height,
      width: t.width,
      center: {
        x: t.x + t.width / 2,
        y: t.y + t.height / 2
      }
    }, we(t.calculative.worldRect));
  }
}
function wa(t, e) {
  e.onAdd || (e.onAdd = Do, (!e.rowPos || !e.colPos || !e.calculative.maxOffsetY) && e.onAdd(e), e.onMouseMove = ou, e.onMouseLeave = ru, e.onMouseDown = nu, e.onShowInput = su, e.onInput = au, e.onValue = hu, e.onBeforeValue = du, e.onMouseEnter = yu, e.onWheel = uu, e.onDestroy = gu), e.data.length !== e.rowPos.length && (e.initWorldRect = null, e.calculative.isUpdateData = !0, e.onValue(e)), e.data[0].length !== e.colPos.length && (e.initWorldRect = null, e.calculative.isUpdateData = !0, e.onValue(e));
  const i = e.calculative.canvas.store.data, s = e.calculative.canvas.store.options;
  if (e.color = e.color || i.color || s.color, e.textColor = e.textColor || e.color || i.textColor || s.textColor, e.activeColor = e.activeColor || s.activeColor, e.hoverColor = e.hoverColor || s.hoverColor, e.activeBackground = e.activeBackground || s.activeBackground, e.hoverBackground = e.hoverBackground || s.hoverBackground, !e.hasHeader) {
    t.save(), t.beginPath();
    const { x: a, y: o, width: r, height: l } = e.calculative.worldRect;
    t.fillStyle = "#fff0", t.rect(a - 1, o - 1, r + 2, l + 2), t.fill(), t.clip();
  }
  tu(t, e), iu(t, e), Zd(t, e), t.restore(), e.isFirstTime = !1;
}
function Zd(t, e) {
  if (!e.calculative.hover || !e.calculative.hoverCell || e.calculative.isInput || !e.calculative.isHover)
    return;
  let i = e.calculative.worldRect, s = e.calculative.canvas.mousePos;
  if (!(s.x > i.x && s.x < i.x + i.width && s.y > i.y && s.y < i.y + i.height)) {
    e.calculative.hover = !1, e.calculative.isHover = !1, e.calculative.hoverCell = void 0;
    return;
  }
  const { row: a, col: o } = e.calculative.hoverCell, { x: r, y: l } = e.calculative.canvas.mousePos;
  if (!e.data[a])
    return;
  let n = e.data[a][o];
  if (typeof n == "object" || !n)
    return;
  t.save(), t.beginPath(), t.textAlign = "start", t.textBaseline = "middle", t.font = t.font = (e.calculative.fontStyle || "") + " normal " + (e.calculative.fontWeight || "") + " " + (e.calculative.fontSize || 12) + "px " + e.calculative.fontFamily;
  const h = t.measureText(n).width;
  t.beginPath(), t.fillStyle = "#fff", t.strokeStyle = "#000", t.moveTo(r, l), t.rect(r - 10, l, h + 20, 20), t.fill(), t.stroke(), t.beginPath(), t.fillStyle = "#000", t.fillText(n, r, l + 10), t.restore();
}
function eu(t) {
  const e = [], i = [], s = {};
  t.rowHeight || (t.rowHeight = 40), t.colWidth || (t.colWidth = 150);
  let a = 0;
  const o = t.styles && t.styles.filter((u) => u.col !== void 0 && u.row === void 0 && u.width);
  let r = {};
  o && o.forEach((u) => {
    r[u.col] = u.width;
  });
  for (let u = 0; u < t.data[0].length; u++) {
    a += (r[u] || t.colWidth) * t.calculative.canvas.store.data.scale, e.push(a);
    let g = t.styles && t.styles.filter((y) => y.col === u && y.row === void 0);
    g && (s[u] = g[0]);
  }
  let l = 0;
  const n = t.styles && t.styles.filter((u) => u.col === void 0 && u.row !== void 0 && u.height);
  let h = {};
  n && n.forEach((u) => {
    h[u.row] = u.height;
  });
  let c = l;
  for (let u = 0; u < t.data.length; u++)
    l += (h[u] || t.rowHeight) * t.calculative.canvas.store.data.scale, i.push(l), u < t.maxNum && (c = l);
  if (t.calculative.maxOffsetY = (l - c) / t.calculative.canvas.store.data.scale, t.initWorldRect)
    return;
  t.colPos = e, t.rowPos = i, t.colStyle = s, t.initScale = t.calculative.canvas.store.data.scale, t.tableWidth = a, t.tableHeight = c || l, t.calculative.width = a, t.calculative.height = c || l, t.calculative.width = a, t.calculative.height = c || l, t.height || (t.height = t.calculative.height), t.width || (t.width = t.calculative.width);
  let d = t.x, f = t.y;
  if (t.parentId) {
    let u = t.calculative.canvas.store.pens[t.parentId];
    d = u.calculative.worldRect.x + u.calculative.worldRect.width * t.x, f = u.calculative.worldRect.y + u.calculative.worldRect.height * t.y;
  }
  t.calculative.worldRect = {
    x: d,
    y: f,
    height: t.calculative.height,
    width: t.calculative.width,
    center: {
      x: t.x + t.calculative.width / 2,
      y: t.y + t.calculative.height / 2
    }
  }, t.width = t.calculative.width, t.height = t.calculative.height, t.initWorldRect || (t.initWorldRect = {
    width: t.calculative.worldRect.width,
    height: t.calculative.worldRect.height
  }), we(t.calculative.worldRect);
}
function tu(t, e) {
  if (!e.colPos)
    return;
  const { x: i, y: s, width: a, height: o, ex: r, ey: l } = e.calculative.worldRect;
  t.save(), t.beginPath(), t.strokeStyle = e.color;
  let n = e.calculative.borderRadius || 0, h = n;
  n < 1 && (n = a * n, h = o * h);
  let c = n < h ? n : h;
  if (a < 2 * c && (c = a / 2), o < 2 * c && (c = o / 2), t.moveTo(i + c, s), t.arcTo(r, s, r, l, c), t.arcTo(r, l, i, l, c), t.arcTo(i, l, i, s, c), t.arcTo(i, s, r, s, c), e.background && (t.fillStyle = e.background, t.fill()), e.bordered !== !1 && (t.strokeStyle = e.borderColor || "#424B61", t.stroke()), e.hLine !== !1) {
    let d = e.rowPos[e.rowPos.length - 1];
    e.hasHeader && (t.beginPath(), t.moveTo(
      e.calculative.worldRect.x,
      e.calculative.worldRect.y + e.rowPos[0] * e.calculative.worldRect.height / e.tableHeight
    ), t.lineTo(
      e.calculative.worldRect.ex,
      e.calculative.worldRect.y + e.rowPos[0] * e.calculative.worldRect.height / e.tableHeight
    ), t.strokeStyle = e.borderColor || "#424B61", t.stroke());
    for (const f of e.rowPos) {
      if (f === d)
        continue;
      const u = f * e.calculative.worldRect.height / e.tableHeight - e.offsetY * e.calculative.canvas.store.data.scale;
      if (e.hasHeader) {
        if (u < 0 + e.rowPos[0] || u > e.calculative.worldRect.height)
          continue;
      } else if (u < 0 || u > e.calculative.worldRect.height)
        continue;
      t.beginPath(), t.moveTo(e.calculative.worldRect.x, e.calculative.worldRect.y + u), t.lineTo(e.calculative.worldRect.ex, e.calculative.worldRect.y + u), t.strokeStyle = e.borderColor || "#424B61", t.stroke();
    }
  }
  if (e.vLine !== !1) {
    let d = e.colPos[e.colPos.length - 1];
    e.colPos.forEach((f, u) => {
      if (f === d)
        return;
      const g = f * e.calculative.worldRect.width / e.tableWidth;
      t.beginPath(), t.moveTo(e.calculative.worldRect.x + g, e.calculative.worldRect.y), t.lineTo(e.calculative.worldRect.x + g, e.calculative.worldRect.ey), t.strokeStyle = e.borderColor || "#424B61", t.stroke();
    });
  }
  t.restore();
}
function iu(t, e) {
  var s, a, o, r, l;
  if (!e.colPos)
    return;
  e.calculative.texts || (e.calculative.texts = []);
  const i = 1;
  for (let n = 0; n < e.rowPos.length; n++) {
    if (e.hasHeader && n === 1) {
      t.save(), t.beginPath();
      const { x: c, y: d, width: f, height: u } = e.calculative.worldRect;
      t.fillStyle = "#fff0", t.rect(
        c - 1,
        d + e.rowPos[0] * e.calculative.worldRect.height / e.tableHeight - 1,
        f + 2,
        u - e.rowPos[0] * e.calculative.worldRect.height / e.tableHeight + 2
      ), t.fill(), t.clip();
    }
    let { style: h } = lu(e, n);
    for (let c = 0; c < e.colPos.length; c++) {
      let { value: d, style: f } = zo(e, n, c), u = !0;
      if (Array.isArray(f) && f.length > 0) {
        let E = 0;
        f.forEach((D, q) => {
          D.wheres && D.wheres.every((S) => new Function(
            "attr",
            `return attr ${S.comparison} ${S.value}`
          )(d)) && (E = q);
        }), f = f[E];
      } else
        f.wheres && Array.isArray(f.wheres) && (u = !1, u = f.wheres.every(function(E) {
          return new Function(
            "attr",
            `return attr ${E.comparison} ${E.value}`
          )(d);
        }));
      let g = e.color, y = e.textColor || e.color, v = null, b = null, x = null, p = null;
      u && (g = f.color || h.color || e.color, y = f.textColor || h.textColor || e.textColor, v = f.background || h.background, b = (f.fontSize || h.fontSize || 0) * e.calculative.canvas.store.data.scale, x = f.fontWeight || h.fontWeight, p = f.fontStyle || h.fontStyle);
      let k;
      e.stripe && (e.hasHeader !== !1 ? n % 2 === 1 && (v = v || e.stripeColor || "#407FFF1F") : n % 2 === 0 && (v = v || e.stripeColor || "#407FFF1F")), e.calculative.active && ((s = e.calculative.activeCell) == null ? void 0 : s.row) === n && ((a = e.calculative.activeCell) == null ? void 0 : a.col) === c && (g = e.activeColor, v = e.activeBackground, k = g, y = e.activeTextColor || e.activeColor), e.calculative.hover && ((o = e.calculative.hoverCell) == null ? void 0 : o.row) === n && ((r = e.calculative.hoverCell) == null ? void 0 : r.col) === c && (g = e.hoverColor, v = e.hoverBackground, y = e.hoverTextColor || e.hoverColor, k = g);
      const R = Fo(e, n, c);
      if (R.y + R.height < e.calculative.worldRect.y || R.y > e.calculative.worldRect.height + e.calculative.worldRect.y)
        continue;
      v && (t.save(), t.beginPath(), t.fillStyle = v, t.fillRect(
        R.x,
        R.y,
        R.width + 0.25 * e.calculative.canvas.store.data.scale,
        R.height
      ), t.restore()), k && (t.save(), t.beginPath(), t.strokeStyle = k, t.strokeRect(R.x, R.y, R.width, R.height), t.restore()), e.calculative.worldTextRect = R;
      let A = e.calculative.texts[n];
      if (e.calculative.texts[n] || (A = [], e.calculative.texts.push(A)), A[c] == null) {
        if (typeof d == "object") {
          const E = e.styles && e.styles.filter((D) => D.col === c && D.row === void 0 && D.pens);
          if (E.length > 0) {
            if (A[c] = "", e.isFirstTime) {
              e.maxNum && e.hasHeader && n >= e.maxNum && (d.visible = !1);
              let D = JSON.parse(JSON.stringify(E[0].pens));
              D.forEach((q) => {
                Object.assign(q, { row: n, col: c }, d), q.activeBackground = q.background, q.hoverBackground = q.background, q.activeColor = q.color, q.hoverColor = q.color, q.activeTextColor = q.textColor, q.hoverTextColor = q.textColor, q.height *= e.calculative.canvas.store.data.scale, q.width *= e.calculative.canvas.store.data.scale;
              }), cu(e, R, D), e.calculative.canvas.parent.pushChildren(e, D);
            }
            continue;
          }
        } else d === void 0 ? A[c] = "" : A[c] = d.text || d + "";
        if (!A[c])
          continue;
        A[c] = ci(e, A[c]);
      }
      if (!A[c])
        continue;
      t.save(), t.beginPath(), t.fillStyle = y, t.textAlign = "center", t.textBaseline = "middle", t.font = (p || e.calculative.fontStyle || "") + " normal " + (x || e.calculative.fontWeight || "") + " " + (b || e.calculative.fontSize || 12) * i + "px " + e.calculative.fontFamily;
      let P = e.colStyle && ((l = e.colStyle[c]) == null ? void 0 : l.textAlign);
      if (P && (t.textAlign = P), A[c].length === 1)
        P === "left" ? t.fillText(A[c][0], R.x, R.y + R.height / 2) : P === "right" ? t.fillText(
          A[c][0],
          R.x + R.width,
          R.y + R.height / 2
        ) : t.fillText(
          A[c][0],
          R.x + R.width / 2,
          R.y + R.height / 2
        );
      else {
        const D = (b || e.calculative.fontSize) * e.calculative.lineHeight * i, q = A[c].length * D;
        let I = (R.height - q) / 2;
        P === "left" ? A[c].forEach((S, T) => {
          t.fillText(S, R.x, R.y + I + (T + 0.55) * D);
        }) : P === "right" ? A[c].forEach((S, T) => {
          t.fillText(
            S,
            R.x + R.width,
            R.y + I + (T + 0.55) * D
          );
        }) : A[c].forEach((S, T) => {
          t.fillText(
            S,
            R.x + R.width / 2,
            R.y + I + (T + 0.55) * D
          );
        });
      }
      t.restore();
    }
  }
}
function Do(t) {
  var e;
  Ps(t), (e = t.children) != null && e.length || (t.isFirstTime = !0), t.offsetY || (t.offsetY = 0), eu(t);
}
function su(t, e) {
  if (!t.calculative.hoverCell)
    return;
  const { value: i } = zo(
    t,
    t.calculative.hoverCell.row,
    t.calculative.hoverCell.col
  );
  if (typeof i == "object")
    return;
  t.calculative.isHover = !1, t.calculative.isInput = !0, t.calculative.canvas.render(), t.calculative.inputCell = t.calculative.hoverCell;
  const s = Fo(
    t,
    t.calculative.hoverCell.row,
    t.calculative.hoverCell.col
  );
  t.calculative.tempText = i.text || i + "", t.calculative.canvas.showInput(t, s, "#ffffff");
}
function au(t, e) {
  t.calculative.inputCell && (Ho(
    t,
    t.calculative.inputCell.row,
    t.calculative.inputCell.col,
    e
  ), t.calculative.isInput = !1, t.calculative.isHover = !0, t.calculative.canvas.render());
}
function ou(t, e) {
  t.timer && (t.calculative.isHover = !1, clearTimeout(t.timer)), t.timer = setTimeout(() => {
    t.calculative.isHover = !0, t.calculative.canvas.render();
  }, 500), t.calculative.hoverCell = Bo(t, e), t.calculative.canvas.render();
}
function ru(t, e) {
  Ps(t), t.calculative.hoverCell = void 0, t.calculative.canvas.render();
}
function nu(t, e) {
  t.calculative.activeCell = Bo(t, e), t.calculative.canvas.render();
}
function Bo(t, e) {
  const i = t.calculative.worldRect.width / t.tableWidth, s = t.calculative.worldRect.height / t.tableHeight, a = { row: 0, col: 0 };
  for (let o = 0; o < t.colPos.length; o++)
    e.x > t.calculative.worldRect.x + t.colPos[o] * i && (a.col = o + 1);
  for (let o = 0; o < t.rowPos.length; o++)
    e.y > t.calculative.worldRect.y + t.rowPos[o] * s - t.offsetY * t.calculative.canvas.store.data.scale && (a.row = o + 1);
  return a;
}
function zo(t, e, i) {
  if (!t.data || !Array.isArray(t.data))
    return;
  const s = t.data[e], a = t.styles && t.styles.filter((o) => o.row === e && o.col === i);
  if (Array.isArray(s))
    return { value: s[i], style: (a == null ? void 0 : a.length) > 0 ? a.length > 1 ? a : a[0] : {} };
  if (!s.data || !Array.isArray(s.data))
    return;
}
function lu(t, e) {
  if (!t.data || !Array.isArray(t.data))
    return;
  const i = t.data[e], s = t.styles && t.styles.filter((a) => a.row === e && a.col === void 0);
  if (Array.isArray(i))
    return { value: i, style: (s == null ? void 0 : s.length) > 0 ? s[0] : {} };
  if (!i.data || !Array.isArray(i.data))
    return;
}
function Ho(t, e, i, s) {
  if (!t.data || !Array.isArray(t.data))
    return;
  t.isFirstTime = !1, t.calculative.texts = void 0;
  let a = t.data[e];
  a && (a[i] instanceof Object || (a[i] = s), t.calculative.canvas.store.emitter.emit("valueUpdate", t));
}
function Fo(t, e, i) {
  const s = t.calculative.worldRect.width / t.tableWidth, a = t.calculative.worldRect.height / t.tableHeight;
  let o = 0, r = t.colPos[i] * s;
  i > 0 && (o = t.colPos[i - 1] * s);
  let l = 0, n = t.rowPos[e] * a;
  e > 0 && (l = t.rowPos[e - 1] * a);
  let h = t.offsetY * t.calculative.canvas.store.data.scale;
  return e === 0 && t.hasHeader && (h = 0), {
    x: t.calculative.worldRect.x + o,
    y: t.calculative.worldRect.y + l - h,
    ex: t.calculative.worldRect.x + r,
    ey: t.calculative.worldRect.y + n - h,
    width: r - o,
    height: n - l
  };
}
function cu(t, e, i) {
  if (!(i && i.length))
    return;
  const s = t.calculative.worldRect.width / t.tableWidth, a = t.calculative.worldRect.height / t.tableHeight;
  let o = 1, r = 1;
  t.initWorldRect && (t.calculative.worldRect.width !== t.initWorldRect.width && (o = t.calculative.worldRect.width / t.initWorldRect.width), t.calculative.worldRect.height !== t.initWorldRect.height && (r = t.calculative.worldRect.height / t.initWorldRect.height));
  let l = 0, n = 0, h = 0;
  const c = t.calculative.canvas.store.data.scale;
  if (i.length > 1) {
    for (const d of i)
      n + d.width * s + 20 * c * s < e.width ? (d.x = e.x + n + 10 * c * s, d.y = e.y + h + 10 * c * a, n += (d.width + 10 * c) * s, l = Math.max(l, h + (d.height + 10 * c) * a)) : (n = 0, h = l, d.x = e.x + n + 10 * c * s, d.y = e.y + h + 10 * c * a, l += (d.height + 10 * c) * a);
    if (l + 20 * c * a < e.height) {
      const d = (e.height - l - 10 * c * a) / 2;
      for (const f of i)
        f.y += d;
    }
  } else
    i[0].x = e.x + (e.width - i[0].width) / 2, i[0].y = e.y + (e.height - i[0].height) / 2;
  i.forEach((d) => {
    d.width = d.width * o, d.height = d.height * r;
  });
}
function hu(t) {
  if (t.calculative.isUpdateData) {
    delete t.calculative.isUpdateData;
    let e = G(t.children);
    t.children = [], Do(t), e && e.forEach((i) => {
      t.calculative.canvas.delForce(t.calculative.canvas.findOne(i));
    }), t.calculative.texts = void 0;
  }
}
function du(t, e) {
  if (t.calculative.isUpdateData = !1, t.swiper !== void 0 && (t.swiper ? Ps(t) : Rs(t)), e.styles && (t.initWorldRect = void 0), e.table || e.col == null && e.row == null) {
    if (e.dataY) {
      const s = t.replaceMode;
      let a = [];
      return s ? s === vs.Replace ? (a = t.data, e.dataX && e.dataX.forEach((o, r) => {
        a[o] = e.dataY[r];
      })) : s === vs.ReplaceAll && (e.dataX ? a[0] = e.dataX : a[0] = t.data[0], a = a.concat(e.dataY)) : a = t.data.concat(e.dataY), delete e.dataX, delete e.dataY, t.calculative.isUpdateData = !0, Object.assign(e, { data: a });
    }
    (e.data || e.styles || e.maxNum || e.rowHeight || e.colWidth) && (t.calculative.isUpdateData = !0, t.initWorldRect = null);
    for (let s of Object.keys(e))
      s.includes("data.") && (t.calculative.isUpdateData = !0);
    return e;
  }
  let i = t.data[e.row];
  return i && (i[e.col] instanceof Object || (i[e.col] = e.value), Ho(t, e.row, e.col, e.value), t.calculative.canvas.render(), delete e.col, delete e.row), e;
}
function uu(t, e) {
  if (!t.locked && !t.calculative.canvas.store.data.locked || !t.maxNum)
    return;
  let i = 0;
  e.deltaY > 0 ? i = 4 : i = -4, ys(t, i);
}
function ys(t, e) {
  var i;
  t.offsetY || (t.offsetY = 0), t.offsetY += e, t.offsetY > t.calculative.maxOffsetY && (t.offsetY = t.calculative.maxOffsetY), t.offsetY < 0 && (t.offsetY = 0), (i = t.children) == null || i.forEach((s) => {
    const a = t.calculative.canvas.store.pens[s];
    fu(t, a);
  }), t.calculative.canvas.render();
}
function fu(t, e) {
  if (!e)
    return;
  e.oldY || (e.oldY = e.y);
  const { y: i, height: s } = e.calculative.worldRect, { y: a, height: o } = t.calculative.worldRect, r = t.calculative.canvas.store.data.scale;
  t.calculative.worldRect.height / t.tableHeight;
  const l = t.rowHeight;
  e.y = e.oldY - t.offsetY * r / t.calculative.worldRect.height;
  const n = l * (t.initScale || 1) / t.tableHeight * t.maxNum;
  if (t.calculative.canvas.updatePenRect(e), t.hasHeader)
    if (e.y < t.rowPos[0] / t.tableHeight) {
      if (e.calculative.visible = !1, e.visible = !1, e.y < t.rowPos[0] / t.tableHeight / 2) {
        e.oldY += n;
        let h = e.row + t.maxNum;
        if (!t.data[h])
          return;
        let c = G(t.data[h][e.col]);
        c.background && (c.activeBackground = c.background, c.hoverBackground = c.background), c.color && (c.hoverColor = c.color, c.activeColor = c.color), c.textColor && (c.activeTextColor = c.textColor, c.hoverTextColor = c.textColor), Object.assign(e, c, { row: h }), Object.assign(e.calculative, c, { row: h });
      }
    } else if (e.y + e.height > 1) {
      if (e.calculative.visible = !1, e.visible = !1, e.y + e.height / 2 > 1) {
        e.oldY -= n;
        let h = e.row - t.maxNum;
        if (!t.data[h])
          return;
        let c = G(t.data[h][e.col]);
        c.background && (c.activeBackground = c.background, c.hoverBackground = c.background), c.color && (c.hoverColor = c.color, c.activeColor = c.color), c.textColor && (c.activeTextColor = c.textColor, c.hoverTextColor = c.textColor), Object.assign(e, c, { row: h }), Object.assign(e.calculative, c, { row: h });
      }
    } else
      e.visible = !0, e.calculative.visible = !0;
  else if (e.y < 0) {
    if (e.calculative.visible = !1, e.visible = !1, e.y < -l / t.tableHeight / 2) {
      e.oldY += n;
      let h = e.row + t.maxNum;
      if (!t.data[h])
        return;
      let c = G(t.data[h][e.col]);
      c.background && (c.activeBackground = c.background, c.hoverBackground = c.background), c.color && (c.hoverColor = c.color, c.activeColor = c.color), c.textColor && (c.activeTextColor = c.textColor, c.hoverTextColor = c.textColor), Object.assign(e, c, { row: h }), Object.assign(e.calculative, c, { row: h });
    }
  } else if (e.y + e.height > 1) {
    if (e.calculative.visible = !1, e.visible = !1, e.y + e.height / 2 > 1) {
      e.oldY -= n;
      let h = e.row - t.maxNum;
      if (!t.data[h])
        return;
      let c = G(t.data[h][e.col]);
      c.background && (c.activeBackground = c.background, c.hoverBackground = c.background), c.color && (c.hoverColor = c.color, c.activeColor = c.color), c.textColor && (c.activeTextColor = c.textColor, c.hoverTextColor = c.textColor), Object.assign(e, c, { row: h }), Object.assign(e.calculative, c, { row: h });
    }
  } else
    e.calculative.visible = !0, e.visible = !0;
}
function gu(t) {
  Rs(t);
}
function Rs(t) {
  t.interval && (globalThis.clearInterval(t.interval), t.interval = null);
}
function Ps(t) {
  if (t.maxNum && t.swiper) {
    if (t.interval)
      return;
    t.interval = globalThis.setInterval(() => {
      t.offsetY >= t.calculative.maxOffsetY ? (t.offsetY = 0, vu(t)) : t.offsetY % t.rowHeight ? ys(t, 1) : (t.calculative.stap || (t.calculative.stap = 0), t.calculative.stap += 1, t.calculative.stap == 12 && (t.calculative.stap = 0, ys(t, 1)));
    }, 50);
  }
}
function vu(t) {
  var e;
  (e = t.children) == null || e.forEach((i) => {
    const s = t.rowHeight, a = t.calculative.canvas.store.pens[i];
    if (!a)
      return;
    const o = s * (t.initScale || 1) / t.tableHeight * t.maxNum;
    a.oldY -= o;
    const r = a.row - t.maxNum;
    if (!t.data[r])
      return;
    let l = G(t.data[r][a.col]);
    l.background && (l.activeBackground = l.background, l.hoverBackground = l.background), l.color && (l.hoverColor = l.color, l.activeColor = l.color), l.textColor && (l.activeTextColor = l.textColor, l.hoverTextColor = l.textColor), a.calculative.visible = !0, a.visible = !0, Object.assign(a, l, { row: r }), Object.assign(a.calculative, l, { row: r });
  }), t.calculative.canvas.render();
}
function yu(t) {
  Rs(t);
}
function mu(t, e) {
  e.onClick || (e.onClick = pu);
  let i = e.calculative.worldRect.x, s = e.calculative.worldRect.y, a = e.calculative.worldRect.width, o = e.calculative.worldRect.height;
  a < o * 1.5 && (a = 1.5 * o), t.beginPath(), t.arc(i + o / 2, s + o / 2, o / 2, Math.PI / 2, Math.PI * 3 / 2), t.lineTo(i + a - o / 2, s), t.arc(i + a - o / 2, s + o / 2, o / 2, -Math.PI / 2, Math.PI / 2), t.lineTo(i + o / 2, s + o), e.checked ? (t.fillStyle = e.onColor, (e.disabled || e.disable) && (t.fillStyle = e.disableOnColor || Te(0.6, e.onColor)), e.lineWidth && (t.strokeStyle = e.onStrokeColor, t.stroke()), t.fill(), t.closePath(), t.beginPath(), t.fillStyle = "#ffffff", t.moveTo(i + o * 2, s + o / 2), t.arc(
    i + a - o / 2,
    s + o / 2,
    o / 2 > 2 ? o / 2 - 2 : 1,
    0,
    Math.PI * 2
  ), t.fill()) : (t.fillStyle = e.offColor, (e.disabled || e.disable) && (t.fillStyle = e.disableOffColor || Te(0.6, e.offColor)), e.lineWidth && (t.strokeStyle = e.offStrokeColor, t.stroke()), t.fill(), t.closePath(), t.beginPath(), t.fillStyle = "#ffffff", t.moveTo(i + o, s + o / 2), t.arc(i + o / 2, s + o / 2, o / 2 > 2 ? o / 2 - 2 : 1, 0, Math.PI * 2), t.fill()), t.closePath();
}
function pu(t) {
  t.disabled || t.disable || (t.checked = !t.checked, t.calculative.canvas.store.emitter.emit("valueUpdate", t), t.calculative.canvas.render());
}
function bu(t, e) {
  e.onAdd || (e.onAdd = Gt, e.onResize = Gt, e.onMove = Gt, e.onMouseMove = wu, e.onMouseDown = Wo, e.onValue = xu, e.onBeforeValue = ku), e.calculative.barRect || Gt(e), e.calculative.canvas.store.data;
  const i = e.calculative.canvas.store.options;
  let s = e.background;
  e.disabled && (s = e.disabledBackground || Te(0.6, s)), t.fillStyle = s, t.beginPath();
  let a = e.calculative.worldRect.x + e.calculative.barRect.x, o = e.calculative.worldRect.y + e.calculative.barRect.y, r = e.calculative.barRect.width, l = e.calculative.barRect.height, n = l / 2;
  t.moveTo(a + n, o), t.arcTo(a + r, o, a + r, o + l, n), t.arcTo(a + r, o + l, a, o + l, n), t.arcTo(a, o + l, e.x, e.y, n), t.arcTo(a, o, a + r, o, n), t.fill();
  let h = e.activeColor || i.activeColor;
  e.disabled && (h = e.disabledColor || Te(0.6, h)), t.fillStyle = h, t.beginPath(), r = e.calculative.ballRect.x, t.moveTo(a + n, o), t.arcTo(a + r, o, a + r, o + l, n), t.arcTo(a + r, o + l, a, o + l, n), t.arcTo(a, o + l, e.x, e.y, n), t.arcTo(a, o, a + r, o, n), t.fill(), t.fillStyle = e.btnBackground || "#fff", t.strokeStyle = h, t.lineWidth = 2, t.beginPath(), a = e.calculative.worldRect.x + e.calculative.ballRect.x, o = e.calculative.worldRect.y + e.calculative.ballRect.y + e.calculative.ballRect.height / 2, t.lineWidth = e.calculative.ballRect.width / 10, t.arc(a, o, e.calculative.ballRect.width / 2, 0, Math.PI * 2), t.fill(), t.stroke();
}
function Gt(t) {
  if (t._textWidth || (t._textWidth = t.textWidth || 50, t._fontSize = t.fontSize || 12), t.textWidth = t.calculative.worldRect.width, t.calculative.textWidth = t.textWidth, t.unit || (t.unit = "%"), t.sliderWidth || (t.sliderWidth = t.width), t.sliderHeight || (t.sliderHeight = t.height), !t.calculative.worldRect)
    return;
  const e = t.calculative.worldRect.width / t.sliderWidth, i = t.calculative.worldRect.height / t.sliderHeight, s = Math.min(e, i);
  t.fontSize = t._fontSize * s;
  const a = t.calculative.worldRect.width - t._textWidth * s;
  t.textLeft = a + 10 * s, t.calculative.textLeft = t.textLeft, t.calculative.barRect = {
    x: 0,
    y: (t.calculative.worldRect.height - t.barHeight * i) / 2,
    width: a,
    height: t.barHeight * i
  }, we(t.calculative.barRect), Es(t);
}
function Es(t) {
  const e = t.calculative.barRect.height * 3.5, i = t.calculative.barRect.width * t.value / 100;
  t.calculative.ballRect = {
    x: i,
    y: (t.calculative.worldRect.height - e) / 2,
    width: e,
    height: e
  }, we(t.calculative.ballRect), t.calculative.text = t.value + t.unit, Xe(t);
}
function Wo(t, e) {
  if (t.disabled)
    return;
  const i = e.x - t.calculative.worldRect.x;
  if (i > t.calculative.barRect.width)
    return;
  let s = Math.round(i / t.calculative.barRect.width * 100);
  s < t.min || s > t.max || s < 0 || s > 100 || (t.value = s, Es(t), t.calculative.text = t.value + t.unit, Xe(t), t.calculative.canvas.store.emitter.emit("valueUpdate", t), t.calculative.canvas.render());
}
function wu(t, e) {
  t.calculative.canvas.mouseDown && Wo(t, e);
}
function xu(t) {
  t.calculative.isUpdateData && (delete t.calculative.isUpdateData, Gt(t)), Es(t);
}
function ku(t, e) {
  return t.calculative.isUpdateData = !1, (e.textWidth || e.barHeight) && (e.textWidth && (t._textWidth = 0), t.calculative.isUpdateData = !0), e;
}
function Iu(t, e) {
  e.onMouseDown || (e.onMouseDown = Su), e.options || (e.options = e.data);
  let i = e.calculative.worldRect.x, s = e.calculative.worldRect.y, a = e.calculative.worldRect.height;
  e.calculative.worldRect.width;
  const { fontStyle: o, fontWeight: r, fontSize: l, fontFamily: n, lineHeight: h } = e.calculative;
  let c = 2;
  t.beginPath(), t.moveTo(i, s), t.arcTo(i + a, s, i + a, s + a, c), t.arcTo(i + a, s + a, i, s + a, c), t.arcTo(i, s + a, i, s, c), t.arcTo(i, s, i + a, s, c), t.strokeStyle = "#d9d9d9", t.fillStyle = "#ffffff00", e.checked && (t.fillStyle = e.background || "#1890ff", t.strokeStyle = e.background || "#1890ff"), (e.isForbidden || e.disabled) && (t.fillStyle = e.disabledBackground || Te(0.6, e.background) || "#ebebeb", t.strokeStyle = e.disabledColor || Te(0.6, e.color) || "#d9d9d9"), t.closePath(), t.fill(), t.stroke(), t.save(), e.checked && (t.beginPath(), t.lineWidth = a / 10, t.strokeStyle = "#ffffff", t.moveTo(i + 102 / 506 * a, s + a / 2), t.lineTo(i + 220 / 506 * a, s + 346 / 460 * a), t.lineTo(i + 404 / 506 * a, s + 142 / 460 * a), t.stroke()), t.restore(), t.save(), t.fillStyle = e.disabled || e.isForbidden ? e.disabledTextColor || Te(0.6, e.textColor || e.color) || "#00000040" : ft(e, e.calculative.canvas.parent.store) || "#000000d9", t.textAlign = "start", t.textBaseline = "middle", t.font = De({
    fontStyle: o,
    fontWeight: r,
    fontFamily: n || e.calculative.canvas.parent.store.options.fontFamily,
    fontSize: l,
    lineHeight: h
  }), t.fillText(e.value + "", i + a + 10, s + a / 2), t.restore();
}
function Su(t, e) {
  t.isForbidden || (t.checked = !t.checked, t.calculative.canvas.store.emitter.emit("valueUpdate", t), t.calculative.canvas.render());
}
function Au(t, e) {
  e.options || (e.options = e.data), e.onAdd || (e.onAdd = Tu, e.optionPos || (e.onAdd(e), e.calculative.canvas.parent.active([e])), e.onMouseDown = Cu, e.onValue = Ru);
  let i = e.calculative.worldRect.x, s = e.calculative.worldRect.y, a = e.calculative.worldRect.height, o = e.calculative.worldRect.width;
  if (!e.optionPos)
    return;
  const { fontStyle: r, fontWeight: l, fontSize: n, fontFamily: h, lineHeight: c } = e.calculative;
  if (e.direction == "horizontal")
    for (let d = 0; d < e.optionPos.length; d++) {
      const f = e.optionPos[d] * o / e.checkboxWidth, u = e.options[d].isForbidden || e.disabled;
      t.beginPath(), t.arc(i + f + a / 2, s + a / 2, a / 2, 0, Math.PI * 2), t.strokeStyle = "#d9d9d9", t.fillStyle = "#ffffff00", e.options[d].text === e.checked && (t.strokeStyle = e.options[d].background || e.background || "#1890ff"), u && (t.fillStyle = e.disabledBackground || Te(0.6, e.background) || "#ebebeb", t.strokeStyle = e.disabledColor || Te(0.6, e.color) || "#d9d9d9", e.options[d].text === e.checked && (t.fillStyle = "#ffffff00")), t.closePath(), t.fill(), t.stroke(), t.save(), e.options[d].text === e.checked && (t.beginPath(), t.strokeStyle = e.options[d].background ? e.options[d].background + "20" : e.background || "#1890ff20", u && (t.strokeStyle = e.disabledBackground || Te(0.6, e.background) || "#ebebeb"), t.arc(i + a / 2 + f, s + a / 2, a / 2 + 1.5, 0, Math.PI * 2), t.stroke(), t.closePath(), t.beginPath(), t.fillStyle = e.options[d].background || e.background || "#1890ff", u && (t.fillStyle = e.disabledBackground || Te(0.6, e.background) || "#ebebeb"), t.arc(i + a / 2 + f, s + a / 2, a / 4, 0, Math.PI * 2), t.fill(), t.closePath()), t.restore(), t.save(), t.fillStyle = u ? e.disabledTextColor || "#00000040" : ft(e, e.calculative.canvas.parent.store) || "#000000d9";
      const g = e.calculative.worldRect.height * 14 / 16;
      t.textAlign = "start", t.textBaseline = "middle", t.font = De({
        fontStyle: r,
        fontWeight: l,
        fontFamily: h || e.calculative.canvas.parent.store.options.fontFamily,
        fontSize: g,
        lineHeight: c
      }), t.fillText(
        e.options[d].text,
        i + a + f + 10 / e.checkboxWidth * o,
        s + a / 2
      ), t.restore();
    }
  else if (e.direction == "vertical") {
    const d = e.optionHeight * a / e.checkboxHeight;
    for (let f = 0; f < e.optionPos.length; f++) {
      const u = e.optionPos[f] * a / e.checkboxHeight, g = e.options[f].isForbidden;
      t.beginPath(), t.arc(
        i + d / 2,
        s + d / 2 + u,
        d / 2,
        0,
        Math.PI * 2
      ), t.strokeStyle = "#d9d9d9", t.fillStyle = "#ffffff00", e.options[f].text === e.checked && (t.strokeStyle = e.options[f].background || "#1890ff"), g && (t.fillStyle = "#ebebeb", t.strokeStyle = "#d9d9d9"), t.closePath(), t.fill(), t.stroke(), t.save(), !g && e.options[f].text === e.checked && (t.beginPath(), t.strokeStyle = e.options[f].background ? e.options[f].background + "20" : "#1890ff20", t.arc(
        i + d / 2,
        s + d / 2 + u,
        d / 2 + 1.5,
        0,
        Math.PI * 2
      ), t.stroke(), t.closePath(), t.beginPath(), t.fillStyle = e.options[f].background || "#1890ff", t.arc(
        i + d / 2,
        s + d / 2 + u,
        d / 4,
        0,
        Math.PI * 2
      ), t.fill(), t.closePath()), t.restore(), t.save(), t.fillStyle = g ? "#00000040" : ft(e, e.calculative.canvas.parent.store) || "#000000d9";
      const y = 14 * e.calculative.worldRect.height / e.checkboxHeight;
      t.textAlign = "start", t.textBaseline = "middle", t.font = De({
        fontStyle: r,
        fontWeight: l,
        fontFamily: h || e.calculative.canvas.parent.store.options.fontFamily,
        fontSize: y,
        lineHeight: c
      }), t.fillText(
        e.options[f].text,
        i + d + 10,
        s + d / 2 + u
      ), t.restore();
    }
  }
}
function Tu(t) {
  Oo(t);
}
function Cu(t, e) {
  if (t.direction == "horizontal")
    for (let i = 0; i < t.optionPos.length; i++)
      !t.options[i].isForbidden && e.x > t.calculative.worldRect.x + t.optionPos[i] * t.calculative.worldRect.width / t.checkboxWidth && e.x < t.calculative.worldRect.x + (t.optionPos[i] + t.height) / t.checkboxWidth * t.calculative.worldRect.width + No(t.options[i].text, t) + 10 / t.checkboxWidth * t.calculative.worldRect.width && (t.checked = t.options[i].text, t.calculative.canvas.store.emitter.emit("valueUpdate", t));
  else if (t.direction == "vertical") {
    const i = t.calculative.worldRect.height / t.checkboxHeight;
    for (let s = 0; s < t.optionPos.length; s++)
      !t.options[s].isForbidden && e.y > t.calculative.worldRect.y + t.optionPos[s] * i && e.y < t.calculative.worldRect.y + (t.optionPos[s] + t.optionHeight) * i && (t.checked = t.options[s].text, t.calculative.canvas.store.emitter.emit("valueUpdate", t));
  }
  t.calculative.canvas.render();
}
function Ru(t) {
  Oo(t);
}
function Pu() {
  return {
    radio: Au,
    switch: mu,
    slider: bu,
    checkbox: Iu,
    table: wa,
    table2: wa
  };
}
const Eu = 15;
function yt(t, e = Eu) {
  let i = "" + t;
  return i.indexOf(".") >= 0 && (i = Number.parseFloat(i).toFixed(e)), Number.parseFloat(i);
}
function Xi(t) {
  return typeof t == "number" && Number.isFinite(t);
}
function _u(t) {
  t = {
    max: null,
    min: null,
    splitNumber: 4,
    // splitNumber建议取4或者5等这种容易被整除的数字
    symmetrical: !1,
    deviation: !1,
    preferZero: !1,
    ...t
  };
  const e = [
    10,
    15,
    20,
    25,
    30,
    40,
    50,
    60,
    70,
    80,
    90,
    100,
    150
  ];
  let {
    max: i,
    min: s,
    splitNumber: a,
    symmetrical: o,
    deviation: r,
    preferZero: l
  } = t;
  if (!Xi(i) || !Xi(s) || i < s)
    return { splitNumber: a };
  if (i === s && i === 0)
    return {
      max: yt(e[0] * a),
      min: s,
      interval: e[0],
      splitNumber: a
    };
  i === s && (l = !0), (!Xi(a) || a <= 0) && (a = 4), l && i * s > 0 && (i < 0 ? i = 0 : s = 0);
  const n = (i - s) / a;
  let h = Math.floor(Math.log10(n) - 1);
  h = Math.pow(10, h);
  const c = n / h;
  let d = e[0] * h, f = -1, u;
  for (u = 0; u < e.length; u++)
    if (e[u] > c) {
      d = e[u] * h;
      break;
    }
  let g = i, y = s;
  function v(x) {
    if (g = parseInt("" + (i / x + 1)) * x, y = parseInt("" + (s / x - 1)) * x, i === 0 && (g = 0), s === 0 && (y = 0), o && g * y < 0) {
      const p = Math.max(Math.abs(g), Math.abs(y));
      g = p, y = -p;
    }
  }
  if (v(d), r)
    return {
      max: yt(g),
      min: yt(y),
      interval: yt(d),
      splitNumber: Math.round((g - y) / d)
    };
  if (!o || g * y > 0) {
    let x;
    e: do {
      if (x = Math.round((g - y) / d), (u - f) * (x - a) < 0) {
        for (; x < a; )
          if (y - s <= g - i && y !== 0 || g === 0 ? y -= d : g += d, x++, x === a) break e;
      }
      if (u >= e.length - 1 || u <= 0 || x === a)
        break;
      f = u, x > a ? d = e[++u] * h : d = e[--u] * h, v(d);
    } while (x !== a);
  }
  g = yt(g), y = yt(y);
  const b = yt((g - y) / a);
  return {
    max: g,
    min: y,
    interval: b,
    splitNumber: a
  };
}
function Vo(t, e) {
  var v, b, x, p, k, R, A, P, E, D, q, I, S, T, _, z, V, X, H, M, B, W, N, U, Y, $, Z, Q;
  const i = e.calculative.worldRect.x, s = e.calculative.worldRect.y, a = e.calculative.worldRect.width, o = e.calculative.worldRect.height;
  let r = e.calculative.canvas.store.data.scale, l = [];
  if (e.echarts)
    for (let J = 0; J < e.echarts.option.series.length; J++)
      l.push(e.echarts.option.series[J].data);
  else
    l = e.data;
  let n = [];
  for (let J = 0; J < l.length; J++)
    n = n.concat(l[J]);
  let h = {
    max: Math.max.apply(null, n),
    min: Math.min.apply(null, n),
    splitNumber: 5
  }, c = _u(h), d = e.echarts ? e.echarts.option.xAxis.data.length : e.xAxisData.length;
  t.beginPath(), t.strokeStyle = "#BFBFBF", t.lineWidth = 6 * r, t.lineCap = "butt";
  let f = (a - 1 * (d + 1)) / d;
  t.setLineDash([1, f]), t.moveTo(i, s + o + 3 * r), t.lineTo(i + a, s + o + 3 * r), t.stroke(), t.closePath(), t.beginPath(), t.lineWidth = 1 * r, t.setLineDash([]), t.moveTo(i, s + o), t.lineTo(i + a, s + o), t.stroke(), t.closePath(), t.beginPath(), t.fillStyle = "#BFBFBF", t.strokeStyle = "#E9E9E9", t.setLineDash([2, 2]);
  let u = {
    fontStyle: ((b = (v = e.yAxis) == null ? void 0 : v.axisLabel) == null ? void 0 : b.fontStyle) || e.fontStyle,
    textDecoration: (p = (x = e.yAxis) == null ? void 0 : x.axisLabel) == null ? void 0 : p.textDecoration,
    fontWeight: ((R = (k = e.yAxis) == null ? void 0 : k.axisLabel) == null ? void 0 : R.fontWeight) || e.fontWeight,
    fontFamily: ((P = (A = e.yAxis) == null ? void 0 : A.axisLabel) == null ? void 0 : P.fontFamily) || e.fontFamily,
    fontSize: ((D = (E = e.yAxis) == null ? void 0 : E.axisLabel) == null ? void 0 : D.fontSize) || e.fontSize,
    lineHeight: ((I = (q = e.yAxis) == null ? void 0 : q.axisLabel) == null ? void 0 : I.lineHeight) || e.lineHeight
  };
  t.fillStyle = ((T = (S = e.yAxis) == null ? void 0 : S.axisLabel) == null ? void 0 : T.fontColor) || e.color;
  for (let J = 0; J < c.splitNumber + 1; J++) {
    let m = J * o / c.splitNumber;
    t.textAlign = "right", t.textBaseline = "middle", t.font = De(u), t.fillText(
      c.max - J * c.interval + "",
      i - 10 * r,
      s + m
    ), t.fill(), J < c.splitNumber && (t.beginPath(), t.moveTo(i, s + m), t.lineTo(i + a, s + m), t.stroke());
  }
  t.closePath(), t.beginPath(), t.strokeStyle = "#BFBFBF";
  let g = e.echarts ? e.echarts.option.xAxis.data : e.xAxisData, y = 0;
  for (let J = 0; J < g.length; J++) {
    y = i + (1 + f / 2) + (f + 1) * J, t.textAlign = "center", t.textBaseline = "top";
    let m = {
      fontStyle: ((z = (_ = e.xAxis) == null ? void 0 : _.axisLabel) == null ? void 0 : z.fontStyle) || e.calculative.fontStyle,
      textDecoration: (X = (V = e.xAxis) == null ? void 0 : V.axisLabel) == null ? void 0 : X.textDecoration,
      fontWeight: ((M = (H = e.xAxis) == null ? void 0 : H.axisLabel) == null ? void 0 : M.fontWeight) || e.calculative.fontWeight,
      fontFamily: ((W = (B = e.xAxis) == null ? void 0 : B.axisLabel) == null ? void 0 : W.fontFamily) || e.calculative.fontFamily,
      fontSize: ((U = (N = e.xAxis) == null ? void 0 : N.axisLabel) == null ? void 0 : U.fontSize) || e.calculative.fontSize,
      lineHeight: (($ = (Y = e.xAxis) == null ? void 0 : Y.axisLabel) == null ? void 0 : $.lineHeight) || e.calculative.lineHeight
    };
    t.font = De(m), t.fillStyle = ((Q = (Z = e.xAxis) == null ? void 0 : Z.axisLabel) == null ? void 0 : Q.fontColor) || e.calculative.color, t.fillText(g[J], y, s + o + 10 * r), t.fill();
  }
  return t.closePath(), t.setLineDash([]), { dash: f, normalizedOption: c };
}
function Lu(t, e) {
  if (!isNaN(t))
    return Math.round(Number(t) * 1e3) / 1e3;
}
var li = /* @__PURE__ */ ((t) => (t[t.Add = 0] = "Add", t[t.Replace = 1] = "Replace", t[t.ReplaceAll = 2] = "ReplaceAll", t))(li || {});
function Mu(t, e) {
  e.onBeforeValue || (e.onBeforeValue = jo);
  const i = e.calculative.worldRect.x, s = e.calculative.worldRect.y;
  e.calculative.worldRect.width;
  const a = e.calculative.worldRect.height;
  let o = e.calculative.canvas.store.data.scale, r = [];
  e.echarts && !e.echarts.option.color && (e.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]);
  let l = Vo(t, e), n = l.dash, h = l.normalizedOption;
  const c = !!(e.echarts ? e.echarts.option.series[0].smooth : e.smooth);
  let d = [];
  if (e.echarts)
    for (let f = 0; f < e.echarts.option.series.length; f++)
      r.push(e.echarts.option.series[f].data);
  else
    r = e.data;
  for (let f = 0; f < r.length; f++) {
    t.beginPath();
    let u = r[f];
    t.strokeStyle = e.echarts ? e.echarts.option.color[f] : e.chartsColor[f], t.fillStyle = e.echarts ? e.echarts.option.color[f] : e.chartsColor[f];
    let g = i + (1 + n / 2), y = s + a - (u[0] - h.min) / (h.max - h.min) * a;
    if (t.moveTo(g, y), d.push({ x: g, y }), c)
      if (u.length <= 2)
        for (let v = 1; v < u.length; v++)
          g = i + (1 + n / 2) + (n + 1) * v, y = s + a - (u[v] - h.min) / (h.max - h.min) * a, t.lineTo(g, y), d.push({ x: g, y });
      else {
        let v, b, x, p;
        u.forEach((k, R) => {
          g = i + (1 + n / 2) + (n + 1) * R, y = s + a - (u[R] - h.min) / (h.max - h.min) * a;
          let A = i + (1 + n / 2) + (n + 1) * (R + 1), P = s + a - (u[R + 1] - h.min) / (h.max - h.min) * a, E = i + (1 + n / 2) + (n + 1) * (R - 1), D = s + a - (u[R - 1] - h.min) / (h.max - h.min) * a, q = i + (1 + n / 2) + (n + 1) * (R + 2), I = s + a - (u[R + 2] - h.min) / (h.max - h.min) * a;
          R === 0 ? (E = i + (1 + n / 2) + (n + 1) * R, D = s + a - (u[R] - h.min) / (h.max - h.min) * a) : R === u.length - 2 && (q = i + (1 + n / 2) + (n + 1) * (R + 1), I = s + a - (u[R + 1] - h.min) / (h.max - h.min) * a), d.push({ x: g, y }), v = g + (A - E) / 4, b = y + (P - D) / 4, x = A - (q - g) / 4, p = P - (I - y) / 4, t.bezierCurveTo(v, b, x, p, A, P);
        });
      }
    else
      for (let v = 1; v < u.length; v++)
        g = i + (1 + n / 2) + (n + 1) * v, y = s + a - (u[v] - h.min) / (h.max - h.min) * a, t.lineTo(g, y), d.push({ x: g, y });
    t.stroke(), t.closePath(), t.save(), d.forEach((v, b) => {
      t.beginPath(), t.strokeStyle = "#fff", t.lineWidth = 2 * o, t.arc(v.x, v.y, 4 * o, 0, Math.PI * 2), t.stroke(), t.fill(), t.closePath();
    }), t.restore(), d = [];
  }
}
function jo(t, e) {
  if (e.xAxisData || e.data || !e.dataX && !e.dataY)
    return e;
  const i = t.xAxisData, s = t.data, a = t.replaceMode;
  let o = [], r = [];
  return a ? a === li.Replace ? (e.dataX.forEach((l, n) => {
    let h = i.indexOf(l);
    s.forEach((c, d) => {
      c[h] = e.dataY[d][n];
    });
  }), o = i, r = s) : a === li.ReplaceAll && (o = e.dataX, r = e.dataY) : (o = [...i, ...e.dataX], s.forEach((l, n) => {
    let h = [...l, ...e.dataY[n]];
    r.push(h);
  })), delete e.dataX, delete e.dataY, Object.assign(e, { xAxisData: o, data: r });
}
function Nu(t, e) {
  var c, d;
  e.onBeforeValue || (e.onBeforeValue = Ou);
  let i = e.calculative.canvas.store.data.scale;
  const s = e.calculative.worldRect.x, a = e.calculative.worldRect.y, o = e.calculative.worldRect.width, r = e.calculative.worldRect.height, l = !!e.echarts;
  e.echarts ? (e.echarts.option.color || (e.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]), e.chartsColor = e.echarts.option.color) : e.chartsColor || (e.chartsColor = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]);
  const n = l ? e.echarts.option.series : e.data;
  let h = 0;
  for (let f = 0; f < n.length; f++) {
    let u = n[f], g = o / 2;
    r < o && (g = r / 2);
    const y = s + o / 2, v = a + r / 2;
    let b = 0;
    l ? b = u.data.reduce((P, E) => P + E.value, 0) : b = u.reduce((P, E) => P + E.value, 0);
    const x = g * parseFloat(l ? u.radius[0] : e.chartsRadius[f][0]) / 100, p = g * parseFloat(l ? u.radius[1] : e.chartsRadius[f][1]) / 100;
    if (x > p)
      return;
    let k = 0, R = 0;
    t.strokeStyle = l && ((c = u.itemStyle) == null ? void 0 : c.borderColor) || "#fff", t.lineWidth = (l && ((d = u.itemStyle) == null ? void 0 : d.borderWidth) || 2) * i;
    const A = l ? u.data : u;
    A.forEach((P, E) => {
      var z, V, X, H, M, B, W, N, U, Y;
      R += Math.PI * 2 * P.value / b, t.beginPath();
      let D = h + E;
      D >= e.chartsColor.length && (D = D % e.chartsColor.length), t.fillStyle = l ? e.echarts.option.color[D] : e.chartsColor[D], t.moveTo(
        y + x * Math.sin(R),
        v - x * Math.cos(R)
      ), t.arc(
        y,
        v,
        x,
        -Math.PI / 2 + R,
        -Math.PI / 2 + k,
        !0
      ), t.lineTo(
        y + p * Math.sin(k),
        v - p * Math.cos(k)
      ), t.arc(
        y,
        v,
        p,
        -Math.PI / 2 + k,
        -Math.PI / 2 + R
      ), t.lineTo(
        y + x * Math.sin(R),
        v - x * Math.cos(R)
      ), t.stroke(), t.fill(), t.closePath();
      let q = (k + R) / 2, I = y + (p + 10 * i) * Math.sin(q), S = v - (p + 10 * i) * Math.cos(q), T = t.fillStyle;
      u.label || (u.label = { position: "outside", show: !0 }), l && ["inner", "inside"].includes(u.label.position) ? (t.fillStyle = "#ffffff", I = y + (p - x) / 2 * Math.sin(q), S = v - (p - x) / 2 * Math.cos(q)) : l && u.label.position == "outside", u.labelLine || (u.labelLine = { show: !0 }), (l && u.labelLine.show !== !1 || !l) && (t.beginPath(), t.strokeStyle = l ? e.echarts.option.color[h + E] : e.chartsColor[h + E], t.moveTo(
        y + p * Math.sin(q),
        v - p * Math.cos(q)
      ), t.lineTo(I, S));
      let _ = {
        fontStyle: ((z = e.tickLabel) == null ? void 0 : z.fontStyle) || e.calculative.fontStyle,
        fontWeight: ((V = e.tickLabel) == null ? void 0 : V.fontWeight) || e.calculative.fontWeight,
        fontFamily: ((X = e.tickLabel) == null ? void 0 : X.fontFamily) || e.calculative.fontFamily,
        lineHeight: ((H = e.tickLabel) == null ? void 0 : H.lineHeight) || e.calculative.lineHeight,
        fontSize: (((M = e.tickLabel) == null ? void 0 : M.fontSize) || e.calculative.fontSize) * i
      };
      t.font = De(_), t.textBaseline = "middle", t.textAlign = "center", q > Math.PI ? ((l && u.label.position === "outside" || !l) && (t.textAlign = "end"), (l && u.labelLine.show !== !1 || !l && (((W = (B = e.tickLabel) == null ? void 0 : B.labelLine) == null ? void 0 : W.show) ?? !0)) && t.lineTo(I - 5 * i, S), (l && u.label.show !== !1 || !l && (((N = e.tickLabel) == null ? void 0 : N.show) ?? !0)) && t.fillText(P.name, I - 5 * i, S)) : ((l && u.label.position === "outside" || !l) && (t.textAlign = "start"), (l && u.labelLine.show !== !1 || !l) && t.lineTo(I + 5 * i, S), (l && u.label.show !== !1 || !l && (((U = e.tickLabel) == null ? void 0 : U.show) ?? !0)) && t.fillText(P.name, I + 5 * i, S)), t.stroke(), t.closePath(), t.fillStyle = T, t.strokeStyle = l && ((Y = u.itemStyle) == null ? void 0 : Y.borderColor) || "#fff", k = R;
    }), h += A.length;
  }
}
function Ou(t, e) {
  if (e.data || !e.dataX && !e.dataY)
    return e;
  const i = t.data, s = t.replaceMode;
  let a = [];
  return s ? s === li.Replace ? (e.dataY.forEach((o, r) => {
    o.forEach((l, n) => {
      let h = i[r].filter(
        (c) => c.name === l.name
      );
      h.length > 0 && (h[0].value = l.value);
    });
  }), a = i) : s === li.ReplaceAll && (a = e.dataY) : i.forEach((o, r) => {
    let l = [...o, ...e.dataY[r]];
    a.push(l);
  }), delete e.dataX, delete e.dataY, Object.assign(e, { data: a });
}
function Du(t, e) {
  e.onBeforeValue || (e.onBeforeValue = jo);
  let i = e.calculative.canvas.store.data.scale;
  const s = e.calculative.worldRect.x, a = e.calculative.worldRect.y;
  e.calculative.worldRect.width;
  const o = e.calculative.worldRect.height;
  let r = [];
  if (e.echarts && !e.echarts.option.color && (e.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]), e.echarts)
    for (let d = 0; d < e.echarts.option.series.length; d++)
      r.push(e.echarts.option.series[d].data);
  else
    r = e.data;
  let l = Vo(t, e), n = l.dash, h = l.normalizedOption, c = n * 4 / 5 / r.length;
  for (let d = 0; d < r.length; d++) {
    t.beginPath();
    let f = r[d];
    t.fillStyle = e.echarts ? e.echarts.option.color[d] : e.chartsColor[d], t.strokeStyle = "#ffffff", t.lineWidth = 1 * i;
    let u = 0, g = 0, y = 0;
    for (let v = 0; v < f.length; v++)
      u = s + (1 + 0.1 * n) + (n + 1) * v + c * d, y = (f[v] - h.min) / (h.max - h.min) * o, g = a + o - y, t.rect(u, g, c - 1, y - 1), t.stroke(), t.fill();
    t.closePath();
  }
}
function Bu(t, e) {
  var H, M, B, W, N, U, Y, $, Z, Q, J, m, w, C;
  e.onAdd || (e.onAdd = zu, e.onDestroy = Hu, e.onClick = Fu, e.clockInterval && (e.onDestroy(e), e.onAdd(e)));
  const i = e.calculative.worldRect.x, s = e.calculative.worldRect.y, a = e.calculative.worldRect.width, o = e.calculative.worldRect.height;
  let r = e.calculative.canvas.store.data.scale, l = {
    startAngle: 225,
    endAngle: -45,
    min: 0,
    max: 100,
    splitNumber: 10
  };
  if (e.echarts && e.echarts.option) {
    let L = e.echarts.option.series[0];
    e.startAngle = L.startAngle || l.startAngle, e.endAngle = L.endAngle || l.endAngle, e.min = L.min || l.min, e.max = L.max || l.max, e.axisLine = L.axisLine.lineStyle.color, e.unit = L.detail.formatter.replace("{value}", ""), e.value = L.data[0].value, e.splitNumber = L.splitNumber || l.splitNumber;
  }
  e = { ...l, ...e };
  let n = a > o ? o / 2 * 9 / 10 : a / 2 * 9 / 10, h = i + a / 2, c = s + o / 2, d = e.echarts ? e.echarts.option.series[0].data[0].value : e.value, f, u = e.startAngle - e.endAngle, g = e.background || "#E6EBF8";
  t.strokeStyle = g;
  let y = n / 10;
  t.lineWidth = y, t.beginPath(), t.lineCap = "round", t.arc(
    h,
    c,
    n,
    -e.startAngle / 180 * Math.PI,
    -e.endAngle / 180 * Math.PI
  ), t.stroke(), t.closePath();
  let v = 0;
  if (e.axisLine && !e.isClock)
    for (let L = e.axisLine.length - 1; L >= 0; L--)
      e.axisLine[L][0] * (e.max - e.min) < d ? v = e.axisLine[L][0] : (v = (d - e.min) / (e.max - e.min), f = e.axisLine[L][1]), t.beginPath(), t.strokeStyle = e.axisLine[L][1], t.arc(
        h,
        c,
        n,
        -e.startAngle / 180 * Math.PI,
        (-e.startAngle + v * u) / 180 * Math.PI
      ), t.stroke(), t.closePath();
  t.lineCap = "butt";
  let b = 2 * r, x = n - y;
  x < 0 && (x = 0);
  let p = u / 180 * Math.PI * x, k = (p - b * e.splitNumber) / e.splitNumber, R = u / 180 * Math.PI * b / 2 / p;
  t.beginPath(), t.strokeStyle = e.color || "#999999", t.lineWidth = n / 20, t.setLineDash([b, k]), t.arc(
    h,
    c,
    x,
    -e.startAngle / 180 * Math.PI - R,
    -e.endAngle / 180 * Math.PI + R
  ), t.stroke(), t.closePath();
  let A = 1 * r, P = n - y;
  P < 0 && (P = 0);
  let E = u / 180 * Math.PI * P, D = (E - A * 5 * e.splitNumber) / 5 / e.splitNumber, q = u / 180 * Math.PI * A / 2 / E;
  t.beginPath(), t.strokeStyle = e.color || "#999999", t.lineWidth = n / 40, t.setLineDash([A, D]), t.arc(
    h,
    c,
    P,
    -e.startAngle / 180 * Math.PI - q,
    -e.endAngle / 180 * Math.PI + q
  ), t.stroke(), t.closePath(), t.beginPath();
  let I = e.max - e.min, S = I / e.splitNumber, T = {
    fontStyle: ((H = e.tickLabel) == null ? void 0 : H.fontStyle) || e.calculative.fontStyle,
    textDecoration: ((M = e.tickLabel) == null ? void 0 : M.textDecoration) || e.textDecoration,
    fontWeight: ((B = e.tickLabel) == null ? void 0 : B.fontWeight) || e.calculative.fontWeight,
    fontFamily: ((W = e.tickLabel) == null ? void 0 : W.fontFamily) || e.calculative.fontFamily,
    fontSize: (((N = e.tickLabel) == null ? void 0 : N.fontSize) || e.calculative.fontSize) * r,
    lineHeight: ((U = e.tickLabel) == null ? void 0 : U.lineHeight) || e.calculative.lineHeight
  };
  t.font = De(T);
  let _ = n - y - n / 20;
  for (let L = 0; L <= e.splitNumber; L++) {
    if (Math.abs(e.startAngle) + Math.abs(e.endAngle) === 360 && L == 0)
      continue;
    let F = e.startAngle - S * L / I * u, j = Math.cos(F / 180 * Math.PI), K = Math.sin(F / 180 * Math.PI);
    t.fillStyle = ((Y = e.tickLabel) == null ? void 0 : Y.color) || "#999999", j > 0.02 ? t.textAlign = "end" : j < -0.02 ? t.textAlign = "start" : t.textAlign = "center", K > 0.02 ? t.textBaseline = "top" : K < -0.02 ? t.textBaseline = "bottom" : t.textBaseline = "middle", t.fillText(
      Lu(S * L + e.min),
      h + _ * j,
      c - _ * K
    ), t.fill();
  }
  t.closePath();
  let z = 1, V = ["value"];
  if (e.isClock && (z = 3, V = ["hourvalue", "minutevalue", "secondvalue"]), e.isClock)
    for (let L = 0; L < z; L++) {
      let F = (e.startAngle - (e[V[L]] - e.min) / (e.max - e.min) * u) / 180 * Math.PI;
      L > 0 && (F = (e.startAngle - (e[V[L]] - e.min) / (e.max * 5 - e.min) * u) / 180 * Math.PI);
      let j = 4 / 5 * n;
      V[L] === "hourvalue" && (j = 3 / 5 * n), V[L] === "minutevalue" && (j = 3.5 / 5 * n);
      let K = n * 1 / 40;
      t.beginPath(), t.setLineDash([]), t.lineWidth = n / (L + 1) / 20, t.strokeStyle = e.color || "#999999", t.moveTo(
        h - K * 3 * Math.cos(F),
        c + K * 3 * Math.sin(F)
      ), t.lineTo(
        h + j * Math.cos(F),
        c - j * Math.sin(F)
      ), t.stroke();
    }
  else {
    let L = (e.startAngle - (d - e.min) / (e.max - e.min) * u) / 180 * Math.PI, F = 4 / 5 * n, j = n * 1 / 40;
    t.beginPath(), t.setLineDash([]), t.lineWidth = 2, t.fillStyle = f, t.moveTo(
      h - j * 3 * Math.cos(L),
      c + j * 3 * Math.sin(L)
    ), t.lineTo(
      h + j * Math.cos(L - Math.PI / 2),
      c - j * Math.sin(L - Math.PI / 2)
    ), t.lineTo(
      h + F * Math.cos(L),
      c - F * Math.sin(L)
    ), t.lineTo(
      h + j * Math.cos(L + Math.PI / 2),
      c - j * Math.sin(L + Math.PI / 2)
    ), t.lineTo(
      h - j * 3 * Math.cos(L),
      c + j * 3 * Math.sin(L)
    ), t.fill();
  }
  t.beginPath(), t.textAlign = "center", t.textBaseline = "middle";
  let X = {
    fontStyle: (($ = e.titleLabel) == null ? void 0 : $.fontStyle) || e.calculative.fontStyle,
    textDecoration: ((Z = e.titleLabel) == null ? void 0 : Z.textDecoration) || e.textDecoration,
    fontWeight: ((Q = e.titleLabel) == null ? void 0 : Q.fontWeight) || e.calculative.fontWeight,
    fontFamily: ((J = e.titleLabel) == null ? void 0 : J.fontFamily) || e.calculative.fontFamily,
    fontSize: (((m = e.titleLabel) == null ? void 0 : m.fontSize) || e.calculative.fontSize) * r,
    lineHeight: ((w = e.titleLabel) == null ? void 0 : w.lineHeight) || e.calculative.lineHeight
  };
  t.font = De(X), t.fillStyle = ((C = e.titleLabel) == null ? void 0 : C.color) || f, e.isClock ? t.fillText(
    ("0" + parseInt(e.hourvalue)).slice(-2) + ":" + ("0" + parseInt(e.minutevalue)).slice(-2) + ":" + ("0" + parseInt(e.secondvalue)).slice(-2),
    h,
    c + n / 2
  ) : t.fillText(d + " " + (e.unit || ""), h, c + n / 2), t.fill(), e.isClock && (t.beginPath(), t.fillStyle = e.color || "#999999", t.strokeStyle = "#ffffff", t.arc(h, c, n / 20, 0, Math.PI * 2), t.stroke(), t.fill(), t.closePath());
}
function zu(t) {
  if (t.isClock)
    t.clockInterval = setInterval(() => {
      let e = /* @__PURE__ */ new Date(), i = e.getSeconds(), s = e.getMinutes() + i / 60, a = e.getHours() % 12 + s / 60;
      t.calculative.canvas.parent.setValue(
        {
          id: t.id,
          hourvalue: a,
          minutevalue: s,
          secondvalue: i
        },
        {
          render: !0,
          doEvent: !1
        }
      );
    }, 1e3);
  else {
    const e = t.value;
    t.value = 0, t.frames = [
      {
        duration: 2e3,
        value: e
      }
    ], t.calculative.canvas.parent.startAnimate(t.id), setTimeout(() => {
      t.value = e;
    }, 1e3);
  }
}
function Hu(t) {
  t.clockInterval && (clearInterval(t.clockInterval), t.clockInterval = void 0);
}
function Fu(t) {
  t.isClock && (t.onDestroy(t), t.onAdd(t));
}
function Wu() {
  return {
    lineChart: Mu,
    histogram: Du,
    pieChart: Nu,
    gauge: Bu
  };
}
function Vu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 6, n = o / 4;
  if (i.moveTo(s + n * 2, a + 0), i.lineTo(s + n * 2, a + l), i.moveTo(s, a + l + n * 2), i.arc(
    s + n * 2,
    a + l + n * 2,
    n * 2,
    Math.PI * 1,
    Math.PI * 2,
    !1
  ), i.lineTo(s + n * 4, a + l * 5), i.lineTo(s, a + l * 5), i.lineTo(s, a + l + n * 2), i.moveTo(s + n, a + l * 5), i.lineTo(s + n, a + l * 6), i.moveTo(s + n * 2, a + l * 5), i.lineTo(s + n * 2, a + l * 6), i.moveTo(s + n * 3, a + l * 5), i.lineTo(s + n * 3, a + l * 6), i.closePath(), i instanceof Path2D) return i;
}
function xa(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.25,
      y: 1
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.75,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function ju(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r - o, n = 0.5 * o;
  if (i.moveTo(s + o / 2, a), i.lineTo(s + o / 2, a + l), i.moveTo(s + o, a + n + l), i.arc(s + o / 2, a + n + l, n, 0, Math.PI * 2, !1), i.closePath(), i instanceof Path2D) return i;
}
function ka(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function Uu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 2, n = o / 5;
  if (i.moveTo(s, a + l), i.lineTo(s + n, a + l), i.moveTo(s + n * 5, a + l), i.ellipse(s + n * 3, a + l, 2 * n, l, 0, 0, Math.PI * 2), i.closePath(), i instanceof Path2D) return i;
}
function qu(t) {
  const e = [
    {
      x: 0.6,
      y: 0
    },
    { x: 1, y: 0.5 },
    { x: 0.6, y: 1 },
    { x: 0, y: 0.5 }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function Yu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 4, n = 0.5 * o;
  if (i.moveTo(s + n, a), i.lineTo(s + n, a + l), i.moveTo(s, a + l), i.rect(s, a + l, n * 2, l * 2), i.moveTo(s + n, a + 3 * l), i.lineTo(s + n, a + 4 * l), i.closePath(), i instanceof Path2D) return i;
}
function $u(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 8, n = 0.25 * o;
  if (i.moveTo(s + n * 2, a), i.lineTo(s + n * 2, a + l * 2), i.lineTo(s + n * 3, a + l * 3), i.lineTo(s + n * 3, a + l * 5), i.lineTo(s + n * 2, a + l * 6), i.lineTo(s + n * 1, a + l * 5), i.lineTo(s + n * 1, a + l * 3), i.lineTo(s + n * 2, a + l * 2), i.moveTo(s + n * 3, a + l * 4), i.lineTo(s + n * 4, a + l * 4), i.moveTo(s + n * 2, a + l * 6), i.lineTo(s + n * 2, a + l * 8), i.closePath(), i instanceof Path2D) return i;
}
function Xu(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function Ku(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = o / 2, n = r / 10;
  if (i.moveTo(s + l, a), i.lineTo(s + l, a + n), i.moveTo(s + l, a + n), i.quadraticCurveTo(s + l * 2, a + n, s + l * 2, a + n * 9), i.moveTo(s + l, a + n), i.quadraticCurveTo(s, a + n, s, a + n * 9), i.quadraticCurveTo(s + l, a + n * 6, s + l * 2, a + n * 9), i.moveTo(s + l, a + r * 3 / 4), i.lineTo(s + l, a + r), i.moveTo(s + l * 2 / 5, a + r * 201 / 250), i.lineTo(s + l * 2 / 5, a + r), i.moveTo(s + l * 8 / 5, a + r * 201 / 250), i.lineTo(s + l * 8 / 5, a + r), i.closePath(), i instanceof Path2D) return i;
}
function Ia(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.8,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function Gu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 6, n = o / 4;
  if (i.moveTo(s + n * 2, a + 0), i.lineTo(s + n * 2, a + l), i.moveTo(s, a + l + n * 2), i.arc(
    s + n * 2,
    a + l + n * 2,
    n * 2,
    Math.PI * 1,
    Math.PI * 2,
    !1
  ), i.lineTo(s + n * 4, a + l * 5), i.lineTo(s, a + l * 5), i.lineTo(s, a + l + n * 2), i.moveTo(s, a + l * 5 - l / 3), i.lineTo(s + n * 4, a + l * 5 - l / 3), i.moveTo(s + n, a + l * 5), i.lineTo(s + n, a + l * 6), i.moveTo(s + n * 2, a + l * 5), i.lineTo(s + n * 2, a + l * 6), i.moveTo(s + n * 3, a + l * 5), i.lineTo(s + n * 3, a + l * 6), i.closePath(), i instanceof Path2D) return i;
}
function Ju(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 4, n = 0.5 * o;
  if (i.moveTo(s + n, a), i.lineTo(s + n, a + l), i.lineTo(s + n * 2, a + l * 2), i.lineTo(s + n * 2, a + l * 4), i.lineTo(s, a + l * 4), i.lineTo(s, a + l * 2), i.lineTo(s + n, a + l), i.closePath(), i instanceof Path2D) return i;
}
function Qu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 4, n = o / 2;
  if (i.moveTo(s + n, a), i.lineTo(s + n, a + l), i.lineTo(s + n * 2, a + l * 4), i.lineTo(s, a + l * 4), i.lineTo(s + n, a + l), i.closePath(), i instanceof Path2D) return i;
}
function Zu(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect, l = r / 3, n = 0.5 * o;
  if (i.moveTo(s + n, a), i.lineTo(s + n, a + l), i.lineTo(s + o, a + 2 * l), i.lineTo(s + n, a + r), i.lineTo(s, a + 2 * l), i.lineTo(s + n, a + l), i.closePath(), i instanceof Path2D) return i;
}
function ef(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.6666666666666666
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.6666666666666666
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function tf(t, e) {
  const i = e || new Path2D(), { x: s, y: a, width: o, height: r } = t.calculative.worldRect;
  let l = o / 2, n = r / 10;
  if (i.moveTo(s + l, a), i.lineTo(s + l, a + n), i.moveTo(s + l, a + n), i.quadraticCurveTo(s + l * 2, a + n, s + l * 2, a + n * 9), i.moveTo(s + l, a + n), i.quadraticCurveTo(s, a + n, s, a + n * 9), i.quadraticCurveTo(s + l, a + n * 6, s + l * 2, a + n * 9), i.moveTo(s, a + n * 10), i.quadraticCurveTo(s + l, a + n * 7, s + l * 2, a + n * 10), i.moveTo(s + l * 2 / 5, a + r * 201 / 250 + n), i.lineTo(s + l * 2 / 5, a + r), i.moveTo(s + l * 8 / 5, a + r * 201 / 250 + n), i.lineTo(s + l * 8 / 5, a + r), i.closePath(), i instanceof Path2D) return i;
}
function sf(t) {
  const e = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0.8,
      y: 1
    }
  ];
  t.anchors = e.map(({ x: i, y: s }, a) => ({
    id: `${a}`,
    penId: t.id,
    x: i,
    y: s
  }));
}
function af(t, e) {
  const { x: i, y: s, width: a, height: o } = e.calculative.worldRect, r = a / 2, l = o / 10;
  t.beginPath(), t.moveTo(i + r, s), t.lineTo(i + r, s + l), t.moveTo(i + r, s + l), t.quadraticCurveTo(i + r * 2, s + l, i + r * 2, s + l * 9), t.moveTo(i + r, s + l), t.quadraticCurveTo(i, s + l, i, s + l * 9), t.quadraticCurveTo(i + r, s + l * 6, i + r * 2, s + l * 9), t.moveTo(i + r, s + o * 3 / 4), t.lineTo(i + r, s + o * 9 / 10), t.moveTo(i + r * 2 / 5, s + o * 201 / 250), t.lineTo(i + r * 2 / 5, s + o * 9 / 10), t.moveTo(i + r * 8 / 5, s + o * 201 / 250), t.lineTo(i + r * 8 / 5, s + o * 9 / 10), t.stroke(), t.closePath(), t.beginPath();
  const n = r * 2 > l * 10 ? l : r / 5;
  t.fillStyle = "#333333", t.font = n + "px Arial", t.textBaseline = "bottom", t.textAlign = "center", t.fillText("o", i + r, s + o), t.fillText("m", i + r * 2 / 5, s + o), t.fillText("o", i + r * 8 / 5, s + o), t.closePath();
}
function of() {
  return {
    andGate: Vu,
    basicEvent: ju,
    conditionalEvent: Uu,
    event: Yu,
    forbiddenGate: $u,
    orGate: Ku,
    priorityAndGate: Gu,
    switchEvent: Ju,
    transferSymbol: Qu,
    unexpandedEvent: Zu,
    xorGate: tf
  };
}
function rf() {
  return {
    votingGate: af
  };
}
function nf() {
  return {
    andGate: xa,
    orGate: Ia,
    priorityAndGate: xa,
    votingGate: Ia,
    xorGate: sf,
    forbiddenGate: Xu,
    basicEvent: ka,
    unexpandedEvent: ef,
    conditionalEvent: qu,
    transferSymbol: ka
  };
}
var lf = /* @__PURE__ */ ((t) => (t[t.File = 0] = "File", t[t.Pen = 1] = "Pen", t[t.Pens = 2] = "Pens", t))(lf || {});
const mt = Gi({
  // 选中对象类型：0 - 画布；1 - 单个图元
  mode: 0,
  pen: void 0
}), Uo = () => ({
  selections: mt,
  select: (e) => {
    if (!e || e.length < 1) {
      mt.mode = 0, mt.pen = void 0;
      return;
    }
    if (console.log("select pens: ", e), e.length === 1) {
      mt.mode = 1, mt.pen = e[0];
      return;
    }
    mt.mode = 2, mt.pens = [...e];
  }
}), cf = /* @__PURE__ */ Ra({
  __name: "ContextMenu",
  props: {
    x: {
      type: Number,
      default: 0
    },
    y: {
      type: Number,
      default: 0
    },
    visible: {
      type: Boolean,
      default: !1
    },
    isPreview: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["hide", "send"],
  setup(t, { emit: e }) {
    const i = t, s = Xo(() => ({
      left: i.x + "px",
      top: i.y + "px"
    })), a = e, { selections: o } = Uo(), { saveComponentShow: r } = cd(!0), l = [
      {
        label: "锁定",
        icon: "lock",
        action: () => {
          if (console.log("lock", o), o.pen) {
            const f = { id: o.pen.id, locked: 2 };
            meta2d.setValue(f, { render: !0 });
          } else o.pens && o.pens.forEach((f) => {
            const u = { id: f.id, locked: 2 };
            meta2d.setValue(u, { render: !0 });
          });
          a("hide", !1);
        },
        show: () => {
          if (o.pen)
            return !o.pen.locked;
          if (o.pens)
            return !o.pens.some((f) => f.locked > 0);
        }
      },
      {
        label: "解锁",
        icon: "lock",
        action: () => {
          if (console.log("unlock", o), o.pen) {
            const f = { id: o.pen.id, locked: 0 };
            meta2d.setValue(f, { render: !0 });
          } else o.pens && o.pens.forEach((f) => {
            const u = { id: f.id, locked: 0 };
            meta2d.setValue(u, { render: !0 });
          });
          a("hide", !1);
        },
        show: () => {
          if (o.pen)
            return o.pen.locked;
          if (o.pens)
            return o.pens.some((f) => f.locked > 0);
        }
      },
      {
        label: "删除",
        icon: "delete",
        action: () => {
          o.pen ? meta2d.delete([o.pen]) : o.pens && meta2d.delete(o.pens), a("hide", !1);
        }
      },
      // 组合
      {
        label: "组合",
        icon: "group",
        action: () => {
          o.pens && meta2d.combine(o.pens), a("hide", !1);
        },
        show: () => o.mode == 2
      },
      {
        label: "组合为状态",
        icon: "group",
        action: () => {
          console.log("group", o), o.pens && meta2d.combine(o.pens, 0), a("hide", !1);
        },
        show: () => o.mode == 2
      },
      // 取消组合
      {
        label: "取消组合",
        icon: "group",
        action: () => {
          console.log("ungroup", o), meta2d.uncombine(o.pen), a("hide", !1);
        },
        show: () => {
          var f;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine";
        }
      },
      {
        label: "保存为组件",
        icon: "save",
        action: () => {
          r(o), a("hide", !1);
        }
      },
      {
        label: "替换svg",
        icon: "save",
        action: () => {
          c("svg"), a("hide", !1);
        },
        show: () => {
          var f;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine";
        }
      },
      {
        label: "标记",
        icon: "mark",
        action: () => {
          h(!0), a("hide", !1);
        },
        show: () => {
          var f, u, g, y;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && ((u = o.pen) == null ? void 0 : u.showChild) != null && !((y = (g = o.pen) == null ? void 0 : g.tags) != null && y.includes("mark"));
        }
      },
      {
        label: "取消标记",
        icon: "mark",
        action: () => {
          h(!1), a("hide", !1);
        },
        show: () => {
          var f, u, g, y;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && ((u = o.pen) == null ? void 0 : u.showChild) != null && ((y = (g = o.pen) == null ? void 0 : g.tags) == null ? void 0 : y.includes("mark"));
        }
      },
      {
        label: "替换为标记的图元",
        icon: "save",
        action: () => {
          c("svgs"), a("hide", !1);
        },
        show: () => {
          var f, u, g, y;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && ((u = o.pen) == null ? void 0 : u.showChild) != null && !((y = (g = o.pen) == null ? void 0 : g.tags) != null && y.includes("mark"));
        }
      }
    ], n = [
      {
        label: "设置",
        icon: "group",
        action: () => {
          o.pen && (a("send", o.pen, "setting"), a("hide", !1));
        },
        show: () => {
          var f;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && i.isPreview;
        }
      },
      {
        label: "设置故障",
        icon: "group",
        action: () => {
          if (o.pen) {
            const f = { id: o.pen.id, fault: 1 };
            meta2d.setValue(f, { render: !0 }), a("send", o.pen, "fault"), a("hide", !1);
          }
        },
        show: () => {
          var f, u;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && i.isPreview && ((u = o.pen) == null ? void 0 : u.fault) == 0;
        }
      },
      {
        label: "取消故障",
        icon: "group",
        action: () => {
          if (o.pen) {
            const f = { id: o.pen.id, fault: 0 };
            meta2d.setValue(f, { render: !0 }), a("send", o.pen, "fault"), a("hide", !1);
          }
        },
        show: () => {
          var f, u;
          return o.mode == 1 && ((f = o.pen) == null ? void 0 : f.name) == "combine" && i.isPreview && ((u = o.pen) == null ? void 0 : u.fault) == 1;
        }
      }
    ], h = (f) => {
      var u, g, y;
      if (console.log("meta2d", meta2d.data()), f) {
        let v = !1;
        if (meta2d.data().pens.forEach((b) => {
          var x;
          (x = b.tags) != null && x.includes("mark") && (Ms.error({
            title: "只能标记一个组合，请先取消标记"
          }), v = !0);
        }), v) return;
        (g = (u = o.pen) == null ? void 0 : u.tags) == null || g.push("mark");
      } else {
        let v = ((y = o.pen) == null ? void 0 : y.tags) || [];
        o.pen.tags = v.filter((b) => b !== "mark");
      }
    }, c = (f) => {
      if (f == "svg") {
        ad((u) => {
          let g = Ph(u.data, o.pen, !1);
          console.log("看看新的长啥样pens=====", g), meta2d.delete([o.pen]), meta2d.addPens(g);
        });
        return;
      }
      if (f == "svgs") {
        let u = !1;
        if (meta2d.data().pens.forEach((p) => {
          var k;
          (k = p.tags) != null && k.includes("mark") && (u = !0);
        }), !u) {
          Ms.error({
            title: "请先标记一个组合"
          });
          return;
        }
        let g = o.pen;
        meta2d.delete([g]);
        let y = [];
        meta2d.data().pens.forEach((p) => {
          var k;
          if ((k = p.tags) != null && k.includes("mark")) {
            let R = p, A = d(R, meta2d.data().pens);
            A.forEach((P) => {
              R.children.includes(P.id) && (P.parentId = g == null ? void 0 : g.id);
            }), y = [...A];
          }
        }), console.log("传入的SVG===== ", y, "以前的图元数据=====", g);
        const v = y.find((p) => p.name == "combine" && !p.parentId);
        let b = je(v, meta2d.store), x = meta2d.data().paths;
        meta2d.delete([...b, v]), Object.assign(v, {
          id: g == null ? void 0 : g.id,
          x: g == null ? void 0 : g.x,
          y: g == null ? void 0 : g.y,
          description: g == null ? void 0 : g.description,
          text: g == null ? void 0 : g.text,
          withh: g == null ? void 0 : g.width,
          height: g == null ? void 0 : g.height,
          showChild: g == null ? void 0 : g.showChild,
          //rotate: rotateAngelMap[item.rotateAngel] || 0, // 跟预期不一致
          tags: g == null ? void 0 : g.tags
        }), meta2d.store.data.paths = x, meta2d.addPens(y);
      }
    };
    function d(f, u) {
      if (!f || !u) return;
      const g = [], y = [f];
      for (; y.length; ) {
        const v = y.shift();
        g.push(v);
        for (const b of u)
          b.parentId == v.id && y.push(b);
      }
      return g;
    }
    return (f, u) => {
      const g = dt("t-button"), y = dt("t-list-item"), v = dt("t-list"), b = dt("t-card");
      return _s((ei(), Ji(b, {
        bordered: "",
        hoverShadow: "",
        class: "context-menu",
        style: Ko(s.value)
      }, {
        default: $e(() => [
          Ye(v, null, {
            default: $e(() => [
              (ei(!0), Pa(Ea, null, Go(t.isPreview ? n : l, (x) => _s((ei(), Ji(y, null, {
                default: $e(() => [
                  Ye(g, {
                    theme: "default",
                    block: "",
                    variant: "outline",
                    onClick: (p) => x.action()
                  }, {
                    default: $e(() => [
                      _a(Jo(x.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]),
                _: 2
              }, 1536)), [
                [Ls, x.show ? x.show() : !0]
              ])), 256))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["style"])), [
        [Ls, t.visible]
      ]);
    };
  }
}), hf = /* @__PURE__ */ Mo(cf, [["__scopeId", "data-v-4d2477c1"]]);
var ct = /* @__PURE__ */ ((t) => (t[t.MSG_FAMILY_SUBSCRIBE = 1] = "MSG_FAMILY_SUBSCRIBE", t[t.MSG_FAMILY_UNSUBSCRIBE = 2] = "MSG_FAMILY_UNSUBSCRIBE", t[t.MSG_FAMILY_TRANSMIT = 3] = "MSG_FAMILY_TRANSMIT", t[t.MSG_FAMILY_HEARTBEAT = 4] = "MSG_FAMILY_HEARTBEAT", t[t.MSG_FAMILY_HEARTBEAT_FEEDBACK = 5] = "MSG_FAMILY_HEARTBEAT_FEEDBACK", t[t.MSG_FAMILY_REGISTER = 6] = "MSG_FAMILY_REGISTER", t))(ct || {});
function Sa(t, e, i) {
  return {
    interMsgType: t,
    data: {
      busName: e,
      msgTypes: i
    }
  };
}
const kt = class kt {
  constructor(e, i = {}) {
    O(this, "ws", null);
    O(this, "url");
    O(this, "messageHandlers", /* @__PURE__ */ new Map());
    O(this, "cache", /* @__PURE__ */ new Map());
    // 消息缓存
    O(this, "heartbeatInterval");
    O(this, "heartbeatTimer", null);
    // 客户端主动发送心跳
    O(this, "enableHeartbeat", !1);
    O(this, "reconnectTimer", null);
    O(this, "isConnected", !1);
    // 最大重连次数
    O(this, "maxReconnectTimes", 30);
    // 重连间隔
    O(this, "reconnectInterval", 3e3);
    O(this, "wsOptions", null);
    O(this, "enableLog", !0);
    O(this, "_subscribeTasks", []);
    O(this, "manualClosed", !1);
    const { heartbeatInterval: s = 3e4 } = i;
    this.url = e, this.heartbeatInterval = s, this.maxReconnectTimes = i.maxReconnectTimes || 30, this.reconnectInterval = i.reconnectInterval || 3e3, this.wsOptions = i, this.enableLog = i.enableLog, this.enableHeartbeat = i.enableHeartbeat;
  }
  // 获取 WebSocketClient 单例实例
  static getInstance(e, i) {
    !e.startsWith("ws://") && !e.startsWith("wss://") && (e = "ws://" + e), console.log("getInstance: ", e, i);
    let s = kt.InstanceMap.get(e);
    return s ? console.log("Using existing WebSocketClient instance.") : (s = new kt(e, i), kt.InstanceMap.set(e, s)), s.connect(), s;
  }
  // 1. 初始化 WebSocket 连接并处理事件
  connect() {
    if (!this.url) {
      console.error("ws url is required");
      return;
    }
    if (this.isConnected) {
      this.wsOptions.onReady && this.wsOptions.onReady();
      return;
    }
    this.ws ? this.ws.readyState === WebSocket.OPEN ? this.wsOptions.onReady && this.wsOptions.onReady() : [WebSocket.CLOSING, WebSocket.CLOSED].includes(this.ws.readyState) ? (console.error("连接已断开：", this.url), this.ws = new WebSocket(this.url), this.ws.onopen = () => {
      this.isConnected = !0, this.register(), this.startHeartbeat(), this.subscribe(this.wsOptions.busName, this.wsOptions.msgTypes), this._subscribeTasks.forEach((e) => {
        e();
      }), this._subscribeTasks = [], this.wsOptions.onReady && this.wsOptions.onReady();
    }, this.ws.onmessage = (e) => {
      this.handleMessage(e.data);
    }, this.ws.onclose = () => {
      this.isConnected = !1, this.manualClosed || (this.stopHeartbeat(), this.reconnect()), console.log("WebSocket connection closed.");
    }, this.ws.onerror = (e) => {
      console.error("WebSocket error:", e), this.isConnected = !1, this.stopHeartbeat(), this.reconnect();
    }) : console.log("WebSocket connecting:", this.ws.readyState) : (this.ws = new WebSocket(this.url), this.ws.onopen = () => {
      this.isConnected = !0, this.register(), this.startHeartbeat(), this.subscribe(this.wsOptions.busName, this.wsOptions.msgTypes), this._subscribeTasks.forEach((e) => {
        e();
      }), this._subscribeTasks = [], this.wsOptions.onReady && this.wsOptions.onReady();
    }, this.ws.onmessage = (e) => {
      this.handleMessage(e.data);
    }, this.ws.onclose = () => {
      this.isConnected = !1, this.manualClosed || (this.stopHeartbeat(), this.reconnect()), console.log("WebSocket connection closed.");
    }, this.ws.onerror = (e) => {
      console.error("WebSocket error:", e), this.isConnected = !1, this.stopHeartbeat(), this.reconnect();
    });
  }
  /**
   * @description websocket通信建立后，应立刻发送此消息进行注册
   * @param appName 应用名称
   */
  register(e) {
    const i = {
      interMsgType: ct.MSG_FAMILY_REGISTER,
      data: {
        name: e || this.wsOptions.appName || "WebSocket Client"
      }
    };
    this.ws.send(JSON.stringify(i));
  }
  /**
   * @description TODO
   * @param appName
   */
  unRegister(e) {
  }
  // 2. 处理 WebSocket 消息
  handleMessage(e) {
    const i = JSON.parse(e);
    this.enableLog && console.log("Received message:", i);
    const { interMsgType: s, data: a } = i;
    if (s === ct.MSG_FAMILY_HEARTBEAT) {
      const l = {
        interMsgType: ct.MSG_FAMILY_HEARTBEAT_FEEDBACK,
        data: a
      };
      this.ws.send(JSON.stringify(l));
      return;
    }
    const o = a == null ? void 0 : a.busName;
    o && this.cache.set(o, a), (this.messageHandlers.get(o) || []).forEach((l) => l && l(a));
  }
  /**
   * @description 客户端如果需要收到消息，需先订阅消息，订阅后BusServer会将对应的消息转发给对应的连接
   *  当websocket通信断开了，当重新连接成功后，SDK中应再重新自动发送订阅消息。
   * @param busName
   * @param msgTypes
   * @param callback
   */
  subscribe(e, i, s) {
    var l;
    const a = e || this.wsOptions.busName, o = i || this.wsOptions.msgTypes;
    a || console.error("订阅消息需要指定 [busName] 参数！");
    const r = Sa(
      ct.MSG_FAMILY_SUBSCRIBE,
      a,
      o
    );
    if (((l = this.ws) == null ? void 0 : l.readyState) !== WebSocket.OPEN ? (console.log("WebSocket 连接尚未建立，订阅任务加入队列"), this._subscribeTasks.push(() => {
      this.ws.send(JSON.stringify(r));
    })) : this.ws.send(JSON.stringify(r)), this.cache.has(a) && s && s(this.cache.get(a)), !s) {
      console.error(`请使用 subscribe() 方法订阅消息： ${a} `);
      return;
    }
    this.messageHandlers.has(a) || this.messageHandlers.set(a, []), this.messageHandlers.get(a).push(s);
  }
  /**
   * @description 取消订阅后，BusServer 不再将对应消息转发给对应的连接
   * @param busName
   * @param msgTypes
   * @param callback
   */
  unSubscribe(e, i, s) {
    const a = e || this.wsOptions.busName, o = i || this.wsOptions.msgTypes, r = Sa(
      ct.MSG_FAMILY_UNSUBSCRIBE,
      a,
      o
    );
    this.ws.send(JSON.stringify(r));
    const l = this.messageHandlers.get(a);
    l && this.messageHandlers.set(
      a,
      l.filter((n) => n !== s)
    );
  }
  /**
   * @description 针对客户端订阅的消息，如果某个客户端发送了对应的消息，则会转发给其他所有订阅此消息的客户端
   * @param busName
   * @param data
   */
  sendMessage(e, i, s) {
    var r, l;
    const a = e || this.wsOptions.busName, o = {
      interMsgType: ct.MSG_FAMILY_TRANSMIT,
      data: {
        busName: a,
        msgType: i,
        msg: s
      }
    };
    ((r = this.ws) == null ? void 0 : r.readyState) !== WebSocket.OPEN ? (console.warn("WebSocket 连接尚未建立，sendMessage 任务加入队列"), this._subscribeTasks.push(() => {
      this.ws.send(JSON.stringify(o));
    })) : (l = this.ws) == null || l.send(JSON.stringify(o));
  }
  /**
   * @description BusServer会定时1秒对所有连接发送心跳消息，客户端收到后立刻返回心跳反馈消息
   * 当websocket通信处于连接状态时，客户端超过设定时间没有接收到心跳消息，主动断开websocket通信，然后重新连接，设定时间默认为30s。
   * BusServer内部的机制为：如果超过设定时间没有接收到连接反馈，亦会主动断开websocket连接。
   * @returns
   */
  startHeartbeat() {
    this.enableHeartbeat && (this.heartbeatTimer || (this.heartbeatTimer = setInterval(() => {
      this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(
        JSON.stringify({
          interMsgType: ct.MSG_FAMILY_HEARTBEAT,
          data: {
            version: "1.0",
            ackId: Date.now()
          }
        })
      );
    }, this.heartbeatInterval)));
  }
  // 停止心跳
  stopHeartbeat() {
    this.heartbeatTimer && (clearInterval(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  // 7. 尝试重新连接
  reconnect() {
    if (!this.reconnectTimer) {
      if (this.maxReconnectTimes <= 0) {
        console.log("Max reconnect times reached.");
        return;
      }
      this.reconnectTimer = setTimeout(() => {
        console.log("Reconnecting...", this.maxReconnectTimes), this.maxReconnectTimes--, this.connect(), this.reconnectTimer = null;
      }, this.reconnectInterval);
    }
  }
  // 8. 清除缓存
  clearCache(e) {
    e ? this.cache.delete(e) : this.cache.clear();
  }
  // 9. 关闭 WebSocket 连接并清除单例
  close() {
    var e;
    this.manualClosed = !0, this.stopHeartbeat(), (e = this.ws) == null || e.close(), this.ws = null, kt.InstanceMap.delete(this.url), this.isConnected = !1, console.log("WebSocketClient instance closed and cleared.");
  }
};
O(kt, "InstanceMap", /* @__PURE__ */ new Map());
let _i = kt;
var Jt = /* @__PURE__ */ ((t) => (t[t.Link = 0] = "Link", t[t.SetProps = 1] = "SetProps", t[t.StartAnimate = 2] = "StartAnimate", t[t.PauseAnimate = 3] = "PauseAnimate", t[t.StopAnimate = 4] = "StopAnimate", t[t.JS = 5] = "JS", t[t.GlobalFn = 6] = "GlobalFn", t[t.Emit = 7] = "Emit", t[t.StartVideo = 8] = "StartVideo", t[t.PauseVideo = 9] = "PauseVideo", t[t.StopVideo = 10] = "StopVideo", t[t.SendPropData = 11] = "SendPropData", t[t.SendVarData = 12] = "SendVarData", t[t.Dialog = 14] = "Dialog", t))(Jt || {}), Qt = /* @__PURE__ */ ((t) => (t[t.DialogClose = -14] = "DialogClose", t[t.AnimateReverse = -13] = "AnimateReverse", t[t.Video = -12] = "Video", t[t.ScriptEnd = -11] = "ScriptEnd", t[t.ShowMeta2D = -10] = "ShowMeta2D", t[t.GoToView = -9] = "GoToView", t[t.ShowText = -8] = "ShowText", t))(Qt || {});
const Aa = "__extend_event__", Pf = {
  [
    -14
    /* DialogClose */
  ]: "",
  [
    -13
    /* AnimateReverse */
  ]: "",
  [
    -11
    /* ScriptEnd */
  ]: "",
  [
    -10
    /* ShowMeta2D */
  ]: "",
  [
    -9
    /* GoToView */
  ]: "",
  [
    -12
    /* Video */
  ]: `
const fn = globalThis.$_callExtendAction;
if (fn) {
  fn(0, {
pen,
params,
context,
})
}
`,
  [
    -8
    /* ShowText */
  ]: `
const fn = globalThis.$_callExtendAction;
if (fn) {
  fn(0, {
pen,
params,
context,
})
}
`
};
var ms = /* @__PURE__ */ ((t) => (t[t.ReservedEvents = 0] = "ReservedEvents", t[t.ExternalCall = 1] = "ExternalCall", t))(ms || {}), Zt = /* @__PURE__ */ ((t) => (t.Dialog = "__extend_event_dialog__", t.CustomMessage = "__extend_event_custom_message__", t))(Zt || {}), df = /* @__PURE__ */ ((t) => (t[t.VideoEnded = 0] = "VideoEnded", t[t.ScriptEnded = 1] = "ScriptEnded", t))(df || {});
function uf(t, e) {
  if (!t) return !0;
  const { key: i, value: s, comparison: a } = t;
  if (!i || !a) return !0;
  const o = s;
  switch (a) {
    case "==":
      return e[i] == s;
    case "!=":
      return e[i] != s;
    case ">":
      return e[i] > o;
    case "<":
      return e[i] < o;
    case ">=":
      return e[i] >= o;
    case "<=":
      return e[i] <= o;
    default:
      return !0;
  }
}
function Ki(t, e, i) {
  const s = {
    0: "startAnimate",
    1: "pauseAnimate",
    2: "stopAnimate"
  }, a = [];
  e != null && e.length ? e.forEach((r) => {
    a.push(meta2d.findOne(r));
  }) : i != null && i.length && i.forEach((r) => {
    a.push(...meta2d.find(r));
  });
  const o = s[t];
  o && meta2d[o](a);
}
const Ta = (t) => ({
  resolver: (i) => {
    if (i != null && i.msg) {
      const s = t.wsMsgHandlers || [], a = i.msg;
      s.forEach((o) => {
        const { action: r, params: l, value: n, where: h } = o;
        if (!uf(h, a)) return;
        const { tags: c, ids: d } = l;
        switch (r) {
          case Jt.SetProps:
            d != null && d.length ? (d.forEach((f) => {
              meta2d.setValue(
                {
                  id: f,
                  ...n
                },
                {
                  render: !1
                }
              );
            }), meta2d.render()) : c != null && c.length && (c.forEach((f) => {
              meta2d.setValue(
                {
                  tag: f,
                  ...n
                },
                {
                  render: !1
                }
              );
            }), meta2d.render());
            break;
          case Jt.StartAnimate:
            Ki("0", d, c);
            break;
          case Jt.PauseAnimate:
            Ki("1", d, c);
            break;
          case Jt.StopAnimate:
            Ki("2", d, c);
            break;
          default:
            console.log("unknown action: ", r);
            break;
        }
      });
    }
  }
}), ff = (t, e) => {
  if (console.log("callExtendAction  ------------> ", t, e), !e) {
    console.error("自定义消息参数不存在！");
    return;
  }
  const { params: i, ...s } = e;
  switch (t == ms.ExternalCall ? i && typeof i == "object" && (i.action = e.action) : t == ms.ReservedEvents && (e.action = i == null ? void 0 : i.action), e.action) {
    case Qt.Video:
      meta2d.emit(Zt.Dialog, e);
      break;
    case Qt.DialogClose:
      meta2d.emit(Zt.Dialog, e);
      break;
    case Qt.ShowMeta2D:
      meta2d.emit(Zt.Dialog, e);
      break;
    case Qt.ShowText:
      meta2d.emit(Zt.Dialog, e);
      break;
    default:
      console.error("未知扩展能力调用: ", e.action);
      break;
  }
};
globalThis.$_callExtendAction = ff;
const Ef = () => ({
  extendOn: () => {
    meta2d ? meta2d.on(Aa, (...i) => {
      console.log("--------------", i);
    }) : console.error("meta2d is not ready");
  },
  extendOff: (i) => {
    meta2d && meta2d.off(Aa, i);
  }
}), gf = /* @__PURE__ */ Ra({
  __name: "View",
  props: {
    preview: {
      type: Boolean,
      default: !1
    },
    data: {
      type: Object
    },
    customWsHandler: {
      type: Function
    },
    isOpener: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["ready"],
  setup(t, { expose: e, emit: i }) {
    const s = t, { select: a, selections: o } = Uo(), r = {
      rule: !1,
      drawingLineName: "line",
      rotateCursor: "rotate.cur"
    }, l = Gi({
      x: 0,
      y: 0,
      visible: !1,
      isPreview: !1
    }), n = Ve(!1);
    let h = Gi({
      id: "",
      Name: "",
      fault: 0,
      State: 0
    });
    const c = (A) => {
      o.mode !== 0 && (l.x = A.e.clientX, l.y = A.e.clientY, l.visible = !0, l.isPreview = s.preview);
    }, d = () => {
      l.visible = !1;
    }, f = i;
    let u;
    Qo(() => {
      new $l("meta2d", r), xt(Td()), Qi(Cd()), xt(_d()), Ot(Ld()), xt(Hd()), xt(Vd()), Ot(jd()), Qd(), Ot(Pu()), Ot(Wu()), xt(of()), Ot(rf()), Qi(nf()), f("ready", meta2d);
      let A = localStorage.getItem("meta2d");
      if (s.data || A) {
        A = s.data || JSON.parse(A);
        const { resolver: P } = Ta(A);
        if (location.pathname === "/preview" || s.preview) {
          A.locked = 1, A.lockState && (A.locked = A.lockState);
          const E = (A.msgTypes || []).map((q) => Number(q)).filter((q) => !isNaN(q)), D = A.onMessageJsCode;
          A.wsUrl && (u = _i.getInstance(A.wsUrl, {
            busName: A.busName,
            msgTypes: E,
            enableLog: !1,
            onReady: () => {
              console.log("%c连接成功！", "color: green; font-weight: bold;"), u.subscribe(A.busName, E, (q) => {
                console.log("response: ", q);
                try {
                  D ? new Function("data", D)(q) : s.customWsHandler ? s.customWsHandler(q, meta2d) : P(q);
                } catch (I) {
                  console.log("error: ", I);
                }
              });
            }
          }), u.connect());
        } else
          A.locked = 0;
        meta2d.open(A);
      }
      meta2d.on("active", k), meta2d.on("inactive", R), meta2d.on("contextmenu", c), meta2d.on("click", d);
    });
    const g = (A) => {
      console.log("reconnectWebSocket======== ", A);
      const { resolver: P } = Ta(A);
      if (A.wsUrl) {
        A.locked = 1;
        const E = (A.msgTypes || []).map((q) => Number(q)).filter((q) => !isNaN(q)), D = A.onMessageJsCode;
        console.log("reconnectWebSocket======== ", D), u = _i.getInstance(A.wsUrl, {
          busName: A.busName,
          msgTypes: E,
          enableLog: !1,
          onReady: () => {
            console.log("%c连接成功！", "color: green; font-weight: bold;"), u.subscribe(A.busName, E, (q) => {
              try {
                D ? new Function("data", D)(q) : s.customWsHandler ? s.customWsHandler(q, meta2d) : P(q);
              } catch (I) {
                console.log("error: ", I);
              }
            });
          }
        }), u.connect();
      }
    }, y = (A, P) => {
      let E = localStorage.getItem("meta2d");
      if ((s.data || E) && (E = s.data || JSON.parse(E)), console.log("sendMessageSocket======== ", E), console.log("sendMessageSocketpen======== ", A), E.wsUrl && P === "fault") {
        u.sendMessage(E.busName, 7e3, {
          Name: A.Name,
          Type: 28,
          Code: A.fault
        });
        let D = A.fault == 0 ? "" : "#FF0000";
        meta2d.setValue(
          { id: A.id, color: D, fault: A.fault },
          { render: !1 }
        );
      }
      E.wsUrl && P === "setting" && (u.sendMessage(E.busName, 3e3, {
        Name: A.Name,
        Type: 28,
        State: A.State
      }), meta2d.setValue({ id: A.id, showChild: A.State }, { render: !1 }));
    }, v = () => {
      let A = localStorage.getItem("meta2d");
      (s.data || A) && (A = s.data || JSON.parse(A)), A.wsUrl && u.sendMessage(A.busName, 1002, {});
    }, b = (A, P) => {
      if (console.log("modelHandletype======== ", P), console.log("modelHandle======== ", A), h.id = A.id, h.Name = A.text, A.Ecomponents)
        if (A.tags.includes("Switch")) {
          const [E, D] = A.Ecomponents;
          (E === "off" || E === "on") && (E === "off" && D === "1" || E === "on" && D === "0" ? h.State = +(A == null ? void 0 : A.showChild) : h.State = +(A == null ? void 0 : A.showChild) == 0 ? 1 : 0);
        } else
          h.State = +((A == null ? void 0 : A.showChild) ?? -1);
      else
        h.State = +((A == null ? void 0 : A.showChild) ?? -1);
      h.fault = A.fault, P === "setting" ? n.value = !0 : P === "fault" && y(h, P);
    }, x = () => {
      n.value = !1;
    }, p = (A) => {
      n.value = !1, y(h, "setting");
    };
    e({
      reconnectWebSocket: g,
      Sendrequestsyn: v
    });
    const k = (A) => {
      a(A);
    }, R = () => {
      a();
    };
    return Zo(() => {
      meta2d.destroy(), u && u.close();
    }), (A, P) => {
      const E = dt("t-input"), D = dt("t-form-item"), q = dt("t-form"), I = dt("t-dialog");
      return ei(), Pa(Ea, null, [
        er("div", {
          id: "meta2d",
          class: tr({ "is--preview": t.preview, "is--opener": t.isOpener })
        }, null, 2),
        Ye(hf, ir(l, {
          onHide: d,
          onSend: b
        }), null, 16),
        Ye(I, {
          visible: n.value,
          "close-btn": !0,
          "on-confirm": p,
          "cancel-btn": "取消",
          "on-close": x
        }, {
          header: $e(() => P[3] || (P[3] = [
            _a("设置")
          ])),
          body: $e(() => [
            Ye(q, {
              ref: "form",
              data: Je(h)
            }, {
              default: $e(() => [
                Ye(D, {
                  label: "ID",
                  name: "id",
                  disabled: ""
                }, {
                  default: $e(() => [
                    Ye(E, {
                      placeholder: "请输入内容",
                      modelValue: Je(h).id,
                      "onUpdate:modelValue": P[0] || (P[0] = (S) => Je(h).id = S),
                      disabled: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  _: 1
                }),
                Ye(D, {
                  label: "名称",
                  name: "Name"
                }, {
                  default: $e(() => [
                    Ye(E, {
                      placeholder: "请输入内容",
                      modelValue: Je(h).Name,
                      "onUpdate:modelValue": P[1] || (P[1] = (S) => Je(h).Name = S),
                      disabled: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  _: 1
                }),
                Je(h).State != -1 ? (ei(), Ji(D, {
                  key: 0,
                  label: "设置状态值",
                  name: "State"
                }, {
                  default: $e(() => [
                    Ye(E, {
                      placeholder: "请输入",
                      modelValue: Je(h).State,
                      "onUpdate:modelValue": P[2] || (P[2] = (S) => Je(h).State = S),
                      disabled: Je(h).fault == 1
                    }, null, 8, ["modelValue", "disabled"])
                  ]),
                  _: 1
                })) : sr("", !0)
              ]),
              _: 1
            }, 8, ["data"])
          ]),
          _: 1
        }, 8, ["visible"])
      ], 64);
    };
  }
}), _f = /* @__PURE__ */ Mo(gf, [["__scopeId", "data-v-8ce0a804"]]);
function Lf(t, e) {
  const i = meta2d.getPenRect(t);
  let s = i.x, a = i.y, o = 0, r = 0, l = s, n = a, h = null, c = Ve(!1), d = Ve(!1), f = 0;
  function u(x) {
    if (d.value) {
      cancelAnimationFrame(h);
      return;
    }
    if (c.value) {
      o = x - f, h = requestAnimationFrame(u);
      return;
    }
    o || (o = x), f = x - o;
    const p = e[r], k = Math.min(f / p.duration, 1), R = l + (p.x || 0) * k, A = n + (p.y || 0) * k;
    meta2d.setValue({
      id: t.id,
      x: R,
      y: A
    }), k < 1 ? h = requestAnimationFrame(u) : (r++, r < e.length ? (l = R, n = A, o = null, h = requestAnimationFrame(u)) : b());
  }
  function g() {
    c.value = !1, d.value = !1, o = null, r = 0, h = requestAnimationFrame(u);
  }
  function y() {
    c.value = !0;
  }
  function v() {
    c.value && (c.value = !1, h && cancelAnimationFrame(h), h = requestAnimationFrame(u));
  }
  function b() {
    d.value = !0, l = s, n = a;
  }
  return { play: g, pause: y, resume: v, stop: b, isPaused: c, isStopped: d };
}
export {
  Ef as A,
  Rf as B,
  Xl as C,
  kf as D,
  Jt as E,
  xt as F,
  Qi as G,
  Ot as H,
  Qd as I,
  Td as J,
  Cd as K,
  _d as L,
  $l as M,
  Ld as N,
  Hd as O,
  fe as P,
  Vd as Q,
  jd as R,
  lf as S,
  Pu as T,
  Wu as U,
  _f as V,
  _i as W,
  of as X,
  rf as Y,
  nf as Z,
  Mo as _,
  cd as a,
  wf as b,
  qe as c,
  G as d,
  Qt as e,
  Zt as f,
  xf as g,
  df as h,
  od as i,
  Ta as j,
  Pf as k,
  Tf as l,
  Uo as m,
  Lf as n,
  Cf as o,
  Rh as p,
  Kl as q,
  ad as r,
  ne as s,
  If as t,
  pf as u,
  vt as v,
  Eh as w,
  ff as x,
  ms as y,
  bf as z
};
//# sourceMappingURL=pathAnimate-CGf_anjp.mjs.map
