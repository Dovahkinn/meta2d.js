var _a = Object.defineProperty;
var La = (e, t, i) => t in e ? _a(e, t, { enumerable: !0, configurable: !0, writable: !0, value: i }) : e[t] = i;
var O = (e, t, i) => La(e, typeof t != "symbol" ? t + "" : t, i);
import { ref as ee, useAttrs as Ma, reactive as yo, defineComponent as mo, computed as Na, resolveComponent as oi, withDirectives as Ss, openBlock as qi, createBlock as Oa, normalizeStyle as Da, withCtx as ai, createVNode as yi, createElementBlock as po, Fragment as bo, renderList as Ba, createTextVNode as za, toDisplayString as Ha, vShow as Ts, onMounted as Fa, onUnmounted as Wa, createElementVNode as ja, normalizeClass as Va, mergeProps as Ua } from "vue";
import { p as qa } from "./index-Bllz_Dlr.mjs";
function ke(e, t) {
  const i = t || new Path2D();
  let s = e.calculative.borderRadius || 0, o = s;
  const { x: a, y: r, width: l, height: n, ex: h, ey: c } = e.calculative.worldRect;
  s < 1 && (s = l * s, o = n * o);
  let d = s < o ? s : o;
  if (l < 2 * d && (d = l / 2), n < 2 * d && (d = n / 2), i.moveTo(a + d, r), i.arcTo(h, r, h, c, d), i.arcTo(h, c, a, c, d), i.arcTo(a, c, a, r, d), i.arcTo(a, r, h, r, d), i.closePath(), i instanceof Path2D)
    return i;
}
const Ya = ke;
function $a(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.ellipse(
    s + a / 2,
    o + r / 2,
    a / 2,
    r / 2,
    0,
    0,
    Math.PI * 2
  ), i instanceof Path2D)
    return i;
}
var ft = /* @__PURE__ */ ((e) => (e[e.Node = 0] = "Node", e[e.Line = 1] = "Line", e))(ft || {}), ht = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.DisableEdit = 1] = "DisableEdit", e[e.DisableMove = 2] = "DisableMove", e[e.DisableScale = 3] = "DisableScale", e[e.DisableMoveScale = 4] = "DisableMoveScale", e[e.Disable = 10] = "Disable", e))(ht || {}), Qe = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Linear = 1] = "Linear", e[e.Radial = 2] = "Radial", e))(Qe || {}), dt = /* @__PURE__ */ ((e) => (e[e.CanvasTemplate = 1] = "CanvasTemplate", e[e.CanvasImageBottom = 2] = "CanvasImageBottom", e[e.CanvasMain = 3] = "CanvasMain", e[e.CanvasImage = 4] = "CanvasImage", e))(dt || {});
const Xa = [
  "text",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "fontFamily",
  "fontSize",
  "lineHeight",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "whiteSpace",
  "ellipsis",
  "keepDecimal"
], Ka = ["x", "y", "width", "height", "flipX", "flipY"], Ga = [
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "flipX",
  "flipY",
  "visible",
  "showChild"
], Ja = ["iconLeft", "iconTop", "iconRotate"];
var Ht = /* @__PURE__ */ ((e) => (e[e.Normal = 0] = "Normal", e[e.Beads = 1] = "Beads", e[e.Dot = 2] = "Dot", e[e.Arrow = 3] = "Arrow", e[e.WaterDrop = 4] = "WaterDrop", e))(Ht || {});
const Qa = [
  "gif",
  "iframe",
  "video",
  "echarts",
  "highcharts",
  "lightningCharts"
], Ei = [
  "radio",
  "checkbox",
  "button",
  "inputDom",
  "slider",
  "echarts"
], We = /* @__PURE__ */ new Set([
  "borderRadius",
  // 'rotate',
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  "paddingBottom",
  "progress",
  "progressColor",
  "verticalProgress",
  "reverseProgress",
  // 'flip',
  "flipX",
  "flipY",
  "input",
  "lineDash",
  "lineCap",
  "lineJoin",
  "strokeType",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "color",
  "hoverColor",
  "activeColor",
  "lineWidth",
  "bkType",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "hoverBackground",
  "activeBackground",
  "globalAlpha",
  "anchorColor",
  "anchorRadius",
  "shadowColor",
  "shadowBlur",
  "shadowOffsetX",
  "shadowOffsetY",
  "textHasShadow",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textWidth",
  "textHeight",
  "textLeft",
  "textTop",
  "ellipsis",
  "hiddenText",
  "keepDecimal",
  "borderWidth",
  "borderColor",
  "animateLineWidth",
  "lineAnimateType",
  "frames",
  "animateColor",
  "animateType",
  "animateReverse",
  "background",
  "gradientColors",
  "lineGradientColors",
  "animateLineWidth",
  "gradientSmooth",
  "lineSmooth",
  "animations"
]);
function Za(e) {
  e.onAdd = void 0, e.onValue = void 0, e.onBeforeValue = void 0, e.onDestroy = void 0, e.onMove = void 0, e.onResize = void 0, e.onRotate = void 0, e.onClick = void 0, e.onMouseEnter = void 0, e.onMouseLeave = void 0, e.onMouseDown = void 0, e.onMouseMove = void 0, e.onMouseUp = void 0, e.onShowInput = void 0, e.onInput = void 0, e.onChangeId = void 0, e.onBinds = void 0, e.onStartVideo = void 0, e.onPauseVideo = void 0, e.onStopVideo = void 0, e.onRenderPenRaw = void 0, e.onKeyDown = void 0, e.onContextmenu = void 0, e.onScale = void 0, e.onWheel = void 0, e.onConnectLine = void 0;
}
var st = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.LineAnchor = 1] = "LineAnchor", e[e.NodeAnchor = 2] = "NodeAnchor", e[e.Line = 3] = "Line", e[e.Node = 4] = "Node", e[e.Resize = 5] = "Resize", e[e.Rotate = 6] = "Rotate", e[e.LineAnchorPrev = 7] = "LineAnchorPrev", e[e.LineAnchorNext = 8] = "LineAnchorNext", e))(st || {}), gt = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Translate = 1] = "Translate", e[e.Select = 2] = "Select", e[e.Resize = 3] = "Resize", e[e.AddAnchor = 4] = "AddAnchor", e))(gt || {}), ie = /* @__PURE__ */ ((e) => (e[e.None = 0] = "None", e[e.Down = 1] = "Down", e[e.Translate = 2] = "Translate", e))(ie || {}), ct = /* @__PURE__ */ ((e) => (e[e.None = -1] = "None", e[e.Up = 0] = "Up", e[e.Right = 1] = "Right", e[e.Bottom = 2] = "Bottom", e[e.Left = 3] = "Left", e))(ct || {});
const Cs = [
  "nw-resize",
  "ne-resize",
  "se-resize",
  "sw-resize"
], Rs = [
  "n-resize",
  "e-resize",
  "s-resize",
  "w-resize"
], tr = ["curve", "polyline", "line"], wo = [
  "dash",
  "lineWidth",
  "lineCap",
  "lineJoin",
  "strokeType",
  "color",
  "lineGradientFromColor",
  "lineGradientToColor",
  "lineGradientAngle",
  "globalAlpha",
  "bkType",
  "background",
  "gradientFromColor",
  "gradientToColor",
  "gradientAngle",
  "gradientRadius",
  "fontFamily",
  "fontSize",
  "textColor",
  "hoverTextColor",
  "activeTextColor",
  "textBackground",
  "fontStyle",
  "fontWeight",
  "textAlign",
  "textBaseline",
  "lineHeight",
  "whiteSpace",
  "textLeft",
  "textTop",
  "flipX",
  "flipY",
  "lineDash",
  "visible",
  "iconColor"
];
var De = /* @__PURE__ */ ((e) => (e[e.Mirror = 0] = "Mirror", e[e.Bilateral = 1] = "Bilateral", e[e.Free = 2] = "Free", e))(De || {}), Rt = /* @__PURE__ */ ((e) => (e[e.Default = 0] = "Default", e[e.In = 1] = "In", e[e.Out = 2] = "Out", e[e.DisableConnected = 3] = "DisableConnected", e[e.DisableConnectTo = 4] = "DisableConnectTo", e[e.Disable = 10] = "Disable", e))(Rt || {}), ge = /* @__PURE__ */ ((e) => (e[e.Default = 0] = "Default", e[e.Line = 1] = "Line", e))(ge || {});
function vt(e, t, i) {
  if (!t || t % 360 === 0)
    return;
  const s = t * Math.PI / 180, o = (e.x - i.x) * Math.cos(s) - (e.y - i.y) * Math.sin(s) + i.x, a = (e.x - i.x) * Math.sin(s) + (e.y - i.y) * Math.cos(s) + i.y;
  e.x = o, e.y = a, e.prev && vt(e.prev, t, i), e.next && vt(e.next, t, i);
}
function Ee(e, t, i = 5, s) {
  if (t.type === 1) {
    let o = s.rotate;
    s.flipX && (o *= -1), s.flipY && (o *= -1);
    let a = t.rotate + o;
    return s.flipX && (a *= -1), s.flipY && (a *= -1), oe(e, {
      x: t.x - t.length * s.calculative.canvas.store.data.scale / 2,
      y: t.y - i,
      width: t.length * s.calculative.canvas.store.data.scale,
      height: i * 2,
      rotate: a
    });
  } else
    return e.x > t.x - i && e.x < t.x + i && e.y > t.y - i && e.y < t.y + i;
}
function wi(e, t, i) {
  e.x = i.x - (i.x - e.x) * t, e.y = i.y - (i.y - e.y) * t;
}
function zt(e, t) {
  if (e.x === t.x)
    return e.y <= t.y ? 0 : 180;
  if (e.y === t.y)
    return e.x < t.x ? 270 : 90;
  const i = e.x - t.x, s = e.y - t.y;
  let o = Math.atan(Math.abs(i / s)) / (2 * Math.PI) * 360;
  return i > 0 && s > 0 ? o = 180 - o : i < 0 && s > 0 ? o += 180 : i < 0 && s < 0 && (o = 360 - o), o;
}
function Ci(e, t) {
  const i = e.x - t.x, s = e.y - t.y;
  return Math.sqrt(i * i + s * s);
}
function er(e, t) {
  let i = ct.None;
  if (!t)
    return i;
  const s = e.x - t.x, o = e.y - t.y;
  return Math.abs(s) > Math.abs(o) ? s > 0 ? i = ct.Right : i = ct.Left : o > 0 ? i = ct.Bottom : i = ct.Up, i;
}
function Xe(e, t, i) {
  e && (e.x += t, e.y += i, e.next && (e.next.x += t, e.next.y += i), e.prev && (e.prev.x += t, e.prev.y += i));
}
function Ps(e, t) {
  return e.anchorId === t.anchorId && e.connectTo === t.connectTo;
}
function ri(e, t, i) {
  let s = Math.sqrt(
    (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y)
  ) / i.data.scale;
  t.rotate === 0 ? e.x < t.x ? i.pens[t.penId].flipX || (s *= -1) : i.pens[t.penId].flipX && (s *= -1) : e.y < t.y ? i.pens[t.penId].flipY || (s *= -1) : i.pens[t.penId].flipY && (s *= -1), e.distance = s;
}
const ir = "@meta2d/core", sr = "1.0.42", or = "@meta2d/core: Powerful, Beautiful, Simple, Open - Web-Based 2D At Its Best .", ar = "index.ts", rr = "index.d.ts", nr = {
  build: "tsc"
}, lr = [
  "meta2d",
  "diagram",
  "2D",
  "canvas"
], cr = "alsmile123@qq.com", hr = "MIT", dr = {
  type: "git",
  url: "git+https://github.com/le5le-com/meta2d.js.git"
}, ur = {
  url: "https://github.com/le5le-com/meta2d.js/issues"
}, fr = "https://github.com/le5le-com/meta2d.js#readme", gr = {
  "@types/marked": "^4.0.3",
  "@types/offscreencanvas": "latest"
}, vr = {
  mitt: "^2.1.0",
  mqtt: "^4.2.6"
}, yr = {
  access: "public"
}, mr = "78f2a53ca1839c89b56e2e498d17ba4eb987ad14", xo = {
  name: ir,
  version: sr,
  description: or,
  main: ar,
  types: rr,
  scripts: nr,
  keywords: lr,
  author: cr,
  license: hr,
  repository: dr,
  bugs: ur,
  homepage: fr,
  devDependencies: gr,
  dependencies: vr,
  publishConfig: yr,
  gitHead: mr
}, rt = {
  version: xo.version,
  path2dDraws: {},
  canvasDraws: {},
  anchors: {},
  htmlElements: {}
};
function me(e) {
  Object.assign(rt.path2dDraws, e);
}
function _e(e) {
  Object.assign(rt.canvasDraws, e);
}
function Yi(e) {
  Object.assign(rt.anchors, e);
}
function pr(e) {
  return { all: e = e || /* @__PURE__ */ new Map(), on: function(t, i) {
    var s = e.get(t);
    s && s.push(i) || e.set(t, [i]);
  }, off: function(t, i) {
    var s = e.get(t);
    s && s.splice(s.indexOf(i) >>> 0, 1);
  }, emit: function(t, i) {
    (e.get(t) || []).slice().map(function(s) {
      s(i);
    }), (e.get("*") || []).slice().map(function(s) {
      s(t, i);
    });
  } };
}
var Ue = /* @__PURE__ */ ((e) => (e[e.None = -1] = "None", e[e.Document = 0] = "Document", e[e.Canvas = 1] = "Canvas", e))(Ue || {});
const br = {
  fontFamily: '"Hiragino Sans GB", "Microsoft YaHei", "Helvetica Neue", Helvetica, Arial',
  fontSize: 12,
  lineHeight: 1.5,
  textAlign: "center",
  textBaseline: "middle",
  color: "#222222",
  activeColor: "#278df8",
  hoverColor: "rgba(39,141,248,0.50)",
  anchorColor: "#278DF8",
  hoverAnchorColor: "#FF4101",
  anchorRadius: 4,
  anchorBackground: "#fff",
  dockColor: "rgba(39,141,248,0.50)",
  dockPenColor: "#1890FF",
  dragColor: "#1890ff",
  rotateCursor: "rotate.cur",
  rightCursor: "right.cur",
  downCursor: "down.cur",
  hoverCursor: "pointer",
  minScale: 0.1,
  maxScale: 10,
  keydown: 0,
  gridSize: 20,
  gridColor: "#e2e2e2",
  ruleColor: "#888888",
  drawingLineName: "curve",
  interval: 30,
  animateInterval: 30,
  autoPolyline: !0,
  autoAnchor: !0,
  autoAlignGrid: !1,
  animateColor: "#30EEDC",
  ruleLineColor: "#FF4101",
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowBlur: 64,
  shadowColor: "#00000014",
  globalAlpha: 1,
  defaultAnchors: [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ],
  measureTextWidth: !0,
  moveConnectedLine: !0,
  mouseRightActive: !0,
  disableClipboard: !1,
  drawingLineLength: 0,
  disableTouchPadScale: !1,
  cdn: "",
  polylineSpace: 10,
  domShapes: [],
  containerShapes: ["tablePlus"],
  textFlip: !0,
  textRotate: !0,
  unavailableKeys: [],
  diagramOptions: {},
  svgPathStroke: !0
}, wr = {
  dark: {
    color: "#bdc7db",
    background: "#1e2430",
    parentBackground: "#080b0f",
    ruleColor: "#222E47",
    ruleOptions: {
      background: "#121924",
      textColor: "#6E7B91"
    }
  },
  light: {
    color: "#222222",
    background: "#FFFFFF",
    parentBackground: "#F0F1F2",
    ruleColor: "#C8D0E1",
    ruleOptions: {
      background: "#F7F8FA",
      textColor: "#C8D0E1"
    }
  }
};
var it = /* @__PURE__ */ ((e) => (e[e.Add = 0] = "Add", e[e.Update = 1] = "Update", e[e.Delete = 2] = "Delete", e[e.Replace = 3] = "Replace", e))(it || {});
const xr = () => ({
  data: {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: { x: 0, y: 0 },
    center: { x: 0, y: 0 },
    paths: {},
    theme: "light"
  },
  histories: [],
  pens: {},
  path2dMap: /* @__PURE__ */ new WeakMap(),
  animateMap: /* @__PURE__ */ new WeakMap(),
  active: [],
  animates: /* @__PURE__ */ new Set(),
  options: { ...br },
  theme: { ...wr },
  emitter: pr(),
  bindDatas: {},
  bind: {},
  pensNetwork: {},
  cacheDatas: [],
  messageEvents: {},
  templatePens: {},
  globalTriggers: {}
}), kr = (e = "default") => (rt[e] || (rt[e] = xr(), rt[e].id = e), rt[e]), Ir = (e, t) => {
  const i = e.data.template === t;
  if (i)
    for (const s of e.data.pens)
      s.canvasLayer === dt.CanvasTemplate && (e.templatePens[s.id] = s);
  e.lastScale = e.data.scale, e.data = {
    x: 0,
    y: 0,
    scale: 1,
    pens: [],
    origin: { x: 0, y: 0 },
    center: { x: 0, y: 0 },
    paths: {},
    template: i ? t : null
  }, e.sameTemplate = i, e.pens = {}, e.histories = [], e.historyIndex = null, e.path2dMap = /* @__PURE__ */ new WeakMap(), e.animateMap = /* @__PURE__ */ new WeakMap(), e.bindDatas = {}, e.bind = {}, e.pensNetwork = {}, e.active = [], e.hover = void 0, e.lastHover = void 0, e.animates.clear();
};
function qt(e) {
  const {
    paddingTop: t,
    paddingBottom: i,
    paddingLeft: s,
    paddingRight: o,
    worldRect: a,
    canvas: r
  } = e.calculative;
  let { textLeft: l, textTop: n, textWidth: h, textHeight: c } = e.calculative, d = s, u = t;
  const f = a.width - s - o, g = a.height - t - i;
  h && h < 1 && (h *= a.width), c && c < 1 && (c *= a.height), h < e.calculative.fontSize && (h = e.calculative.fontSize), d += (l || 0) + a.x, u += (n || 0) + a.y;
  const y = e.textAlign || r.store.options.textAlign, v = e.textBaseline || r.store.options.textBaseline;
  switch (y) {
    case "center":
      d += (f - (h || f)) / 2;
      break;
    case "right":
      d += f - (h || f);
      break;
  }
  switch (v) {
    case "middle":
      u += (g - (c || g)) / 2;
      break;
    case "bottom":
      u += g - (c || g);
      break;
  }
  const b = {
    x: d,
    y: u,
    width: h || f,
    height: c || g
  };
  wt(b), e.calculative.worldTextRect = b, ii(e), e.calculative.textDrawRect = void 0;
}
function ko(e, t) {
  const i = t.calculative.fontSize * t.calculative.lineHeight, s = t.calculative.textLines.length * i, o = Ar(e, t), a = t.calculative.worldTextRect;
  let r = a.x + (a.width - o) / 2, l = a.y + (a.height - s) / 2;
  const n = t.calculative.canvas.store.options;
  switch (t.textAlign || n.textAlign) {
    case "left":
      r = a.x;
      break;
    case "right":
      r = a.x + a.width - o;
      break;
  }
  switch (t.textBaseline || n.textBaseline) {
    case "top":
      l = a.y;
      break;
    case "bottom":
      l = a.ey - s;
      break;
  }
  t.calculative.textDrawRect = {
    x: r,
    y: l,
    width: o,
    height: s
  }, wt(t.calculative.textDrawRect);
}
function ii(e, t = e.calculative.text) {
  if (t == null) {
    e.calculative.textLines = [];
    return;
  }
  t = t.toString();
  let i = [];
  const s = e.calculative.fontSize * e.calculative.lineHeight, o = e.calculative.worldTextRect.height, a = Math.floor(o / s), r = a > 1 ? a : 1;
  switch (e.whiteSpace) {
    case "nowrap":
      if (e.ellipsis !== !1) {
        const c = Es(t.split(""), e);
        c[0] && (i.push(c[0]), c.length > 1 && _i(i));
      } else
        i.push(t);
      break;
    case "pre-line":
      i = t.split(/[\n]/g), e.ellipsis !== !1 && i.length > r && (i = i.slice(0, r), _i(i));
      break;
    case "break-all":
    default:
      const n = t.split(/[\n]/g);
      let h = 0;
      t: for (const c of n) {
        const d = e.whiteSpace === "break-all" ? c.split("") : Io(c);
        let u = Es(d, e);
        if (u.length === 0 && (u = [""]), e.ellipsis != !1)
          for (const f of u)
            if (h++, h > r) {
              _i(i);
              break t;
            } else
              i.push(f);
        else
          i.push(...u);
      }
      break;
  }
  const l = e.calculative.keepDecimal;
  return l != null && i.forEach((n, h) => {
    const c = Number(n);
    isNaN(c) || (i[h] = c.toFixed(l));
  }), e.calculative.textLines = i, i;
}
function Io(e = "") {
  const t = [];
  let i = "";
  for (let s = 0; s < e.length; ++s) {
    const o = e.charCodeAt(s);
    o < 33 || o > 126 ? (i && (t.push(i), i = ""), t.push(e[s])) : i += e[s];
  }
  return i && t.push(i), t;
}
function Es(e, t) {
  const i = t.calculative.canvas, s = i.offscreen.getContext("2d"), { fontStyle: o, fontWeight: a, fontSize: r, fontFamily: l, lineHeight: n } = t.calculative;
  s.save();
  const h = [];
  let c = e[0] || "";
  for (let d = 1; d < e.length; ++d) {
    const u = e[d] || "", f = c + u;
    let g = 0;
    if (i.store.options.measureTextWidth)
      s.font = Dt({
        fontStyle: o,
        fontWeight: a,
        fontFamily: l || i.store.options.fontFamily,
        fontSize: r,
        lineHeight: n
      }), g = s.measureText(f).width;
    else {
      const v = f.match(/[^\x00-\xff]/g) || "", b = v.length * r, x = f.match(/\s/g) || "", p = x.length * r * 0.3, k = (f.length - v.length - x.length) * r * 0.6;
      g = b + p + k;
    }
    const y = t.calculative.worldTextRect.width;
    g <= y + 0.1 ? c += u : (c.length && h.push(c), c = u);
  }
  return c.length && h.push(c), s.restore(), h;
}
function Ar(e, t) {
  let i = 0;
  return t.calculative.textLineWidths = [], t.calculative.textLines.forEach((s) => {
    const o = e.measureText(s).width;
    t.calculative.textLineWidths.push(o), i < o && (i = o);
  }), i;
}
function _i(e) {
  e[e.length - 1] = e[e.length - 1].slice(0, -3) + "...";
}
function Sr(e) {
  let t = e.text.split(`
`);
  const i = e.calculative.canvas, s = i.offscreen.getContext("2d"), { fontStyle: o, fontWeight: a, fontSize: r, fontFamily: l, lineHeight: n } = e.calculative;
  let h = 0, c = 0;
  s.save();
  for (let u = 0; u < t.length; u++) {
    if (i.store.options.measureTextWidth)
      s.font = Dt({
        fontStyle: o,
        fontWeight: a,
        fontFamily: l || i.store.options.fontFamily,
        fontSize: r,
        lineHeight: n
      }), c = s.measureText(t[u]).width;
    else {
      const f = t[u].match(/[^\x00-\xff]/g) || "", g = f.length * r, y = t[u].match(/\s/g) || "", v = y.length * r * 0.3, b = (t[u].length - f.length - y.length) * r * 0.6;
      c = g + v + b;
    }
    c > h && (h = c);
  }
  s.restore();
  let d = t.length * r * n;
  e.textAlign === "left" || (e.textAlign === "right" ? e.x = e.x - (h - e.width) : e.x = e.x - (h - e.width) / 2), e.textBaseline === "top" || (e.textBaseline === "bottom" ? e.y = e.y - (d - e.height) : e.y = e.y - (d - e.height) / 2), e.height = d + 2, e.width = h + 2, e.calculative.canvas.updatePenRect(e), e.calculative.canvas.calcActiveRect();
}
function G(e, t = !1) {
  if (Array.isArray(e)) {
    const i = [];
    return e.forEach((s) => {
      i.push(G(s, t));
    }), i;
  } else if (typeof e == "object") {
    if (e === null)
      return null;
    if (e.constructor === RegExp)
      return e;
    const i = {};
    for (const s in e)
      if (!(["canvas", "lastFrame"].includes(s) || e[s] instanceof HTMLImageElement || e[s] instanceof HTMLMediaElement)) {
        {
          if (s === "calculative" && !t)
            continue;
          if (s === "singleton") {
            t ? i[s] = {} : i[s] = e[s];
            continue;
          }
        }
        i[s] = G(e[s], t);
      }
    return i;
  }
  return e;
}
function $i(e, t, i) {
  if (Array.isArray(e)) {
    const s = [];
    return e.forEach((o) => {
      s.push($i(o, t, i));
    }), s;
  } else if (typeof e == "object") {
    if (e === null)
      return null;
    for (const s in e)
      if (t.includes(s))
        if (Array.isArray(e[s]))
          e[s].forEach((o, a) => {
            Number.isNaN(Number(o)) || (e[s][a] = Number(o * i));
          });
        else {
          if (Number.isNaN(Number(e[s])))
            continue;
          e[s] = Number(e[s]) * i;
        }
      else
        e[s] = $i(e[s], t, i);
    return e;
  }
  return e;
}
const Ot = {};
function Ao(e, t, i) {
  if (!Ot[t.fromArrow])
    return;
  const s = xt(t), { x: o, y: a } = s, r = { x: o, y: a };
  if (r.step = (t.fromArrowSize || 10) * i.data.scale, s.next)
    r.rotate = zt(s.next, s) + 90;
  else {
    const n = t.calculative.worldAnchors[1];
    if (!n)
      return;
    n.prev ? r.rotate = zt(n.prev, s) + 90 : r.rotate = zt(n, s) + 90;
  }
  e.save(), e.beginPath(), e.setLineDash([]);
  const l = t.fromArrowColor || t.calculative.color;
  l && (e.strokeStyle = l), Ot[t.fromArrow](e, t, i, r), e.restore();
}
function So(e, t, i) {
  if (!Ot[t.toArrow] || t.calculative.worldAnchors.length < 2)
    return;
  e.save();
  const s = ut(t), { x: o, y: a } = s, r = { x: o, y: a };
  if (r.step = (t.toArrowSize || 10) * i.data.scale, s.prev)
    r.rotate = zt(s.prev, s) + 90;
  else {
    const n = t.calculative.worldAnchors[t.calculative.worldAnchors.length - 2];
    n.next ? r.rotate = zt(n.next, s) + 90 : r.rotate = zt(n, s) + 90;
  }
  e.beginPath(), e.setLineDash([]);
  const l = t.toArrowColor || t.calculative.color;
  l && (e.strokeStyle = l), Ot[t.toArrow](e, t, i, r), e.restore();
}
Ot.triangleSolid = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step;
  e.moveTo(o, s.y - s.step / 4), e.lineTo(s.x, s.y), e.lineTo(o, s.y + s.step / 4), e.closePath(), e.stroke(), e.fillStyle = e.strokeStyle, e.fill(), e.restore();
};
Ot.triangle = (e, t, i, s) => {
  e.save(), e.lineWidth < 2 && (e.lineWidth = 2), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step;
  e.moveTo(o, s.y - s.step / 4), e.lineTo(s.x, s.y), e.lineTo(o, s.y + s.step / 4), e.closePath(), e.stroke(), e.fillStyle = i.data.background || "#ffffff", e.fill(), e.restore();
};
Ot.circleSolid = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.step / 2;
  e.arc(s.x - o, s.y, o, 0, 2 * Math.PI), e.stroke(), e.fillStyle = e.strokeStyle, e.fill(), e.restore();
};
Ot.circle = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.step / 2;
  e.arc(s.x - o, s.y, o, 0, 2 * Math.PI), e.stroke(), e.fillStyle = i.data.background || "#ffffff", e.fill(), e.restore();
};
Ot.diamondSolid = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step, a = s.step / 2;
  e.moveTo(o, s.y), e.lineTo(o + a, s.y - a / 2), e.lineTo(s.x, s.y), e.lineTo(o + a, s.y + a / 2), e.closePath(), e.stroke(), e.fillStyle = e.strokeStyle, e.fill(), e.restore();
};
Ot.diamond = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step, a = s.step / 2;
  e.moveTo(o, s.y), e.lineTo(o + a, s.y - a / 2), e.lineTo(s.x, s.y), e.lineTo(o + a, s.y + a / 2), e.closePath(), e.stroke(), e.fillStyle = i.data.background || "#ffffff", e.fill(), e.restore();
};
Ot.line = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step;
  e.moveTo(o, s.y - s.step / 3), e.lineTo(s.x, s.y), e.lineTo(o, s.y + s.step / 3), e.stroke(), e.restore();
};
Ot.lineUp = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step;
  e.moveTo(o, s.y - s.step / 3), e.lineTo(s.x, s.y), e.stroke(), e.restore();
};
Ot.lineDown = (e, t, i, s) => {
  e.save(), e.translate(s.x, s.y), e.rotate(s.rotate * Math.PI / 180), e.translate(-s.x, -s.y);
  const o = s.x - s.step;
  e.moveTo(o, s.y + s.step / 3), e.lineTo(s.x, s.y), e.stroke(), e.restore();
};
function Xi(e) {
  const t = parseInt, i = Math.round;
  let s = e.length, o = {};
  if (s > 9) {
    const [a, r, l, n] = e = e.split(",");
    if (s = e.length, s < 3 || s > 4) return null;
    o.r = t(a[3] == "a" ? a.slice(5) : a.slice(4)), o.g = t(r), o.b = t(l), o.a = n ? parseFloat(n) : -1;
  } else {
    if (s == 8 || s == 6 || s < 4) return null;
    s < 6 && (e = "#" + e[1] + e[1] + e[2] + e[2] + e[3] + e[3] + (s > 4 ? e[4] + e[4] : "")), e = t(e.slice(1), 16), s == 9 || s == 5 ? (o.r = e >> 24 & 255, o.g = e >> 16 & 255, o.b = e >> 8 & 255, o.a = i((e & 255) / 0.255) / 1e3) : (o.r = e >> 16, o.g = e >> 8 & 255, o.b = e & 255, o.a = -1);
  }
  return o;
}
function Tt(e, t, i, s) {
  let o, a, r, l, n, h, c, d = Math.round, u = typeof i == "string";
  return typeof e != "number" || e < -1 || e > 1 || typeof t != "string" || t[0] != "r" && t[0] != "#" || i && !u || (c = t.length > 9, c = u ? i.length > 9 ? !0 : i == "c" ? !c : !1 : c, n = Xi(t), l = e < 0, h = i && i != "c" ? Xi(i) : l ? { r: 0, g: 0, b: 0, a: -1 } : { r: 255, g: 255, b: 255, a: -1 }, e = l ? e * -1 : e, l = 1 - e, !n || !h) ? null : (s ? (o = d(l * n.r + e * h.r), a = d(l * n.g + e * h.g), r = d(l * n.b + e * h.b)) : (o = d((l * n.r ** 2 + e * h.r ** 2) ** 0.5), a = d((l * n.g ** 2 + e * h.g ** 2) ** 0.5), r = d((l * n.b ** 2 + e * h.b ** 2) ** 0.5)), u = n.a, h = h.a, n = u >= 0 || h >= 0, u = n ? u < 0 ? h : h < 0 ? u : u * l + h * e : 0, c ? "rgb" + (n ? "a(" : "(") + o + "," + a + "," + r + (n ? "," + d(u * 1e3) / 1e3 : "") + ")" : "#" + (4294967296 + o * 16777216 + a * 65536 + r * 256 + (n ? d(u * 255) : 0)).toString(16).slice(1, n ? void 0 : -2));
}
globalThis.pSBC = Tt;
function xi(e, t) {
  const i = Xi(e) || { r: 0, g: 0, b: 0 };
  return i.a < 0 ? `rgba(${i.r},${i.g},${i.b},${t})` : `rgba(${i.r},${i.g},${i.b},${t + i.a})`;
}
function Ce(e, t) {
  if (isNaN(e)) {
    console.warn("realValue not number");
    return;
  }
  if (typeof t != "string") {
    console.warn("collection must be string");
    return;
  }
  const [i, s] = [t[0], t[t.length - 1]];
  if (!["[", "("].includes(i)) {
    console.warn('collection must start with "[" or "("');
    return;
  }
  if (!["]", ")"].includes(s)) {
    console.warn('collection must end with "]" or ")"');
    return;
  }
  const o = t.substring(1, t.length - 1).split(",");
  if (o.length !== 2) {
    console.warn("collection must have 2 numbers");
    return;
  }
  const [a, r] = [+o[0], +o[1]];
  if (a >= r) {
    console.warn("startNum must less than endNum");
    return;
  }
  return e > a || i === "[" && e === a ? e < r || s === "]" && e === r : !1;
}
function Re(e, t) {
  if (typeof t != "string") {
    console.warn("collection must be string");
    return;
  }
  const [i, s] = [t[0], t[t.length - 1]];
  if (i !== "[" || s !== "]") {
    console.warn('collection must start with "[" and end with "]"');
    return;
  }
  const o = t.substring(1, t.length - 1).split(",");
  for (const a of o)
    if (a.includes("..")) {
      const [r, l] = a.split(".."), [n, h] = [+r, +l];
      if (n >= h) {
        console.warn("startNum must less than endNum");
        return;
      }
      if (e >= n && e <= h)
        return !0;
    } else if (e == a)
      return !0;
  return !1;
}
function Tr() {
  return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
}
function nt() {
  return ((1 + Math.random()) * 4294967296 | 0).toString(16).substring(1);
}
function yf() {
  return Tr() + nt();
}
const Xt = (e) => {
  let t = 0, i = 0, s = 0, o = 0;
  return typeof e == "number" ? t = i = s = o = e : typeof e == "string" ? t = i = s = o = parseInt(e, 10) : Array.isArray(e) && (t = e[0], s = Li(e[1]) ? e[0] : e[1], o = Li(e[2]) ? e[0] : e[2], i = Li(e[3]) ? s : e[3]), [t, s, o, i];
};
function Li(e) {
  return e == null;
}
async function Cr(e) {
  return new Promise((t, i) => {
    const s = new FileReader();
    s.onload = (o) => {
      t(o.target.result);
    }, s.onerror = (o) => {
      i(o);
    }, s.readAsDataURL(e);
  });
}
async function Rr(e, t, i, s) {
  const o = new FormData();
  if (o.append("file", e), i)
    for (const r in i)
      i.hasOwnProperty(r) && o.append(r, i[r]);
  return (await (await fetch(t, {
    method: "POST",
    headers: s,
    body: o
  })).json()).url;
}
function Pr(e, t, i) {
  var s = document.createElement("link");
  s.href = e, s.rel = "stylesheet", t && (s.onload = t), document.head.appendChild(s);
}
function Mi(e) {
  let t = e || window.location.search.split("?")[1];
  const i = new URLSearchParams(t);
  return Object.fromEntries(i.entries());
}
function Me(e, t) {
  if (t == null)
    return e;
  const i = t.split(".");
  for (; i.length && (e = e[i.shift()]); ) ;
  return e;
}
function Ki(e, t, i) {
  t != null && t.split(".").reduce(
    (s, o, a) => s[o] = t.split(".").length === ++a ? i : s[o] || {},
    e
  );
}
function Er(e) {
  const t = ["天", "一", "二", "三", "四", "五", "六"], i = /* @__PURE__ */ new Date(), s = i.getFullYear(), o = i.getMonth() + 1, a = i.getDate(), r = i.getDay(), l = i.getHours(), n = i.getMinutes(), h = i.getSeconds();
  return new Function(
    "year",
    "month",
    "day",
    "week",
    "hours",
    "minutes",
    "seconds",
    e ? `return ${e}` : "return `${year}:${month}:${day} ${hours}:${minutes}:${seconds} 星期${week}`"
  )(s, o, a, t[r], l, n, h);
}
function _r(e, t) {
  if (!e || !t)
    return !1;
  let i = Nt(e);
  for (; i; ) {
    if (i.id === t.id)
      return !0;
    i = Nt(i);
  }
  return !1;
}
function Nt(e, t) {
  if (!e || !e.parentId || !e.calculative)
    return;
  const s = e.calculative.canvas.store.pens[e.parentId];
  return t && Nt(s, t) || s;
}
function Ut(e, t) {
  if (!e || !e.children)
    return [];
  const i = [];
  return e.children.forEach((s) => {
    const o = t.pens[s];
    o && (i.push(o), i.push(...Ut(o, t)));
  }), i;
}
function us(e, t) {
  if (!e || !e.followers)
    return [];
  const i = [];
  return e.followers.forEach((s) => {
    const o = t.pens[s];
    o && !o.parentId && (i.push(o), i.push(...us(o, t)));
  }), i;
}
function Lr(e, t) {
  const { worldRect: i, gradientFromColor: s, gradientToColor: o, gradientAngle: a } = t.calculative;
  return Co(
    e,
    i,
    s,
    o,
    a
  );
}
function Mr(e, t) {
  const { worldRect: i, gradientFromColor: s, gradientToColor: o, gradientRadius: a } = t.calculative;
  if (!s || !o)
    return;
  const { width: r, height: l, center: n } = i, { x: h, y: c } = n;
  let d = r;
  d < l && (d = l), d *= 0.5;
  const u = e.createRadialGradient(
    h,
    c,
    d * (a || 0),
    h,
    c,
    d
  );
  return u.addColorStop(0, s), u.addColorStop(1, o), u;
}
function Nr(e, t, i, s, o) {
  let a = 0;
  a = Math.PI / 2 - Math.atan2(s - t, i - e);
  const r = (e + i) / 2, l = (t + s) / 2, n = r + o * Math.sin(90 * Math.PI / 180 - a), h = l + o * -Math.cos(90 * Math.PI / 180 - a), c = r + o * Math.sin(270 * Math.PI / 180 - a), d = l + o * -Math.cos(270 * Math.PI / 180 - a);
  return [n, h, c, d];
}
function Or(e, t) {
  const { worldRect: i, gradientColors: s, gradientRadius: o } = t.calculative;
  if (!s)
    return;
  let a = t.calculative.gradientColors;
  t.calculative.checked && (a = t.calculative.onGradientColors);
  const { width: r, height: l, center: n } = i, { x: h, y: c } = n;
  let d = r;
  d < l && (d = l), d *= 0.5;
  const { colors: u } = Te(a), f = e.createRadialGradient(
    h,
    c,
    d * (o || 0),
    h,
    c,
    d
  );
  return u.forEach((g) => {
    f.addColorStop(g.i, g.color);
  }), f;
}
function Dr(e, t) {
  const { x: i, y: s, ex: o, width: a, height: r, center: l } = t.calculative.worldRect;
  let n = [
    { x: o, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ], h = t.calculative.gradientColors;
  t.calculative.checked && (h = t.calculative.onGradientColors);
  const { angle: c, colors: d } = Te(h);
  let u = fs(c, a, r);
  return n.forEach((f) => {
    vt(f, c, l);
  }), Ri(e, n, d, u);
}
function Br(e, t) {
  const { worldRect: i, textGradientColors: s } = t.calculative;
  if (!s)
    return;
  const { width: o, height: a, center: r } = i, { x: l, y: n } = r;
  let h = o;
  h < a && (h = a), h *= 0.5;
  const { colors: c } = Te(s), d = e.createRadialGradient(
    l,
    n,
    0,
    l,
    n,
    h
  );
  return c.forEach((u) => {
    d.addColorStop(u.i, u.color);
  }), d;
}
function zr(e, t) {
  const { x: i, y: s, ex: o, width: a, height: r, center: l } = t.calculative.worldRect;
  let n = [
    { x: o, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ];
  const { angle: h, colors: c } = Te(t.calculative.textGradientColors);
  let d = fs(h, a, r);
  return n.forEach((u) => {
    vt(u, h, l);
  }), Ri(e, n, c, d);
}
function fs(e, t, i) {
  const s = Math.atan(i / t) / Math.PI * 180;
  let o = (e - 90) % 360, a = 0;
  return o > s && o < 180 - s || o > 180 + s && o < 360 - s || o < 0 ? (o > 270 ? o = 360 - o : o > 180 ? o = o - 180 : o > 90 && (o = 180 - o), a = Math.abs(i / Math.sin(o / 180 * Math.PI) / 2)) : (o > 270 ? o = 360 - o : o > 180 ? o = o - 180 : o > 90 && (o = 180 - o), a = Math.abs(t / Math.cos(o / 180 * Math.PI) / 2)), a;
}
function Te(e) {
  if (typeof e == "string" && e.startsWith("linear-gradient")) {
    let t = e.slice(16, -2).split("deg,");
    if (t.length > 1) {
      let i = t[1].split("%,");
      const s = [];
      return i.forEach((o) => {
        if (/rgba?/.test(o)) {
          let a = o.split(") ");
          s.push({
            color: Hr(a[0] + ")"),
            i: parseFloat(a[1]) / 100
          });
        } else {
          let a = o.split(" ");
          a.length > 2 ? s.push({
            color: a[1],
            i: parseFloat(a[2]) / 100
          }) : s.push({
            color: a[0],
            i: parseFloat(a[1]) / 100
          });
        }
      }), {
        angle: parseFloat(t[0]),
        colors: s
      };
    } else
      return {
        angle: parseFloat(t[0]),
        colors: []
      };
  } else
    return {
      angle: 0,
      colors: []
    };
}
function Hr(e) {
  if (/rgba?/.test(e)) {
    let t = e.split(",");
    if (t.length < 3) return "";
    e = "#";
    for (let i = 0, s; s = t[i++]; )
      if (i < 4)
        s = parseInt(s.replace(/[^\d]/gi, ""), 10).toString(16), e += s.length == 1 ? "0" + s : s;
      else {
        s = s.replace(")", "");
        let a = parseInt(s * 255 + "").toString(16);
        a = a.length === 2 ? a : "0" + a, e += a;
      }
    e = e.toUpperCase();
  }
  return e;
}
function Fr(e, t) {
  const { x: i, y: s, ex: o, width: a, height: r, center: l } = t.calculative.worldRect;
  let n = [
    { x: o, y: s + r / 2 },
    { x: i, y: s + r / 2 }
  ];
  const { angle: h, colors: c } = Te(t.calculative.lineGradientColors);
  let d = fs(h, a, r);
  return n.forEach((u) => {
    vt(u, h, l);
  }), Ri(e, n, c, d);
}
function Ri(e, t, i, s) {
  let o = Nr(
    t[0].x,
    t[0].y,
    t[1].x,
    t[1].y,
    s
  ), a = e.createLinearGradient(o[0], o[1], o[2], o[3]);
  return i.forEach((r) => {
    a.addColorStop(r.i, r.color);
  }), a;
}
function se(e, t, i) {
  let s = [];
  t.calculative.gradientColorStop ? s = t.calculative.gradientColorStop : (s = Te(t.calculative.lineGradientColors).colors, t.calculative.gradientColorStop = s), e.strokeStyle = Ri(
    e,
    i,
    s,
    t.calculative.lineWidth / 2
  ), e.beginPath(), e.moveTo(i[0].x, i[0].y), e.lineTo(i[1].x, i[1].y), e.stroke();
}
function To(e, t) {
  const i = t.calculative.worldAnchors;
  let s = t.calculative.lineWidth * (t.calculative.gradientSmooth || t.calculative.lineSmooth || 0);
  for (let o = 0; o < i.length - 1; o++)
    if ((t.lineName === "curve" || t.lineName === "mind") && i[o].curvePoints) {
      if (o > 0) {
        let l = i[o - 1].curvePoints;
        l ? ni(
          e,
          t,
          s,
          l[l.length - 1],
          i[o],
          i[o].curvePoints[0]
        ) : ni(
          e,
          t,
          s,
          i[o - 1],
          i[o],
          i[o].curvePoints[0]
        );
        let n = Gt(
          s,
          i[o],
          i[o].curvePoints[0]
        );
        se(e, t, [n, i[o].curvePoints[1]]);
      } else
        se(e, t, [
          i[o],
          i[o].curvePoints[0]
        ]), se(e, t, [
          i[o].curvePoints[0],
          i[o].curvePoints[1]
        ]);
      let a = i[o].curvePoints.length - 1;
      for (let l = 1; l < a; l++)
        se(e, t, [
          i[o].curvePoints[l],
          i[o].curvePoints[l + 1]
        ]);
      let r = Gt(
        s,
        i[o + 1],
        i[o].curvePoints[a]
      );
      se(e, t, [i[o].curvePoints[a], r]);
    } else {
      let a = i[o], r = i[o + 1];
      if (o > 0 && o < i.length - 1) {
        let n = i[o - 1].curvePoints;
        n ? ni(
          e,
          t,
          s,
          n[n.length - 1],
          i[o],
          i[o + 1]
        ) : ni(
          e,
          t,
          s,
          i[o - 1],
          i[o],
          i[o + 1]
        );
      }
      o > 0 && o < i.length - 1 && (a = Gt(s, i[o], i[o + 1])), o < i.length - 2 && (r = Gt(s, i[o + 1], i[o]));
      let l = !1;
      if (o === 0 && t.fromLineCap && t.fromLineCap !== "butt" && (e.save(), l = !0, e.lineCap = t.fromLineCap), o !== 0 && o === i.length - 2 && t.toLineCap && t.toLineCap !== "butt" && (e.save(), l = !0, e.lineCap = t.toLineCap), se(e, t, [a, r]), l && e.restore(), i.length === 2 && o === 0) {
        e.save(), l = !0, e.lineCap = t.toLineCap;
        let n = 0.1, h = 0.1;
        a.x - r.x === 0 ? h = 0 : n = (a.y - r.y) / (a.x - r.x) * 0.1, se(e, t, [
          { x: r.x - h, y: r.y - n },
          r
        ]), e.restore();
      }
    }
}
function Gt(e, t, i) {
  let s = Math.sqrt(
    (i.x - t.x) * (i.x - t.x) + (i.y - t.y) * (i.y - t.y)
  );
  return s === 0 ? {
    x: t.x,
    y: t.y
  } : e < s ? {
    x: t.x + (i.x - t.x) * e / s,
    y: t.y + (i.y - t.y) * e / s
  } : {
    x: t.x + (i.x - t.x) / s / 2,
    y: t.y + (i.y - t.y) / s / 2
  };
}
function ni(e, t, i, s, o, a) {
  let r = Gt(i, o, s), l = Gt(i, o, a), n = { x: o.x, y: o.y }, h = Wr(
    t.calculative.canvas.store.data.smoothNum || 20,
    r,
    n,
    l
  );
  for (let c = 0; c < h.length - 1; c++)
    se(e, t, [
      {
        x: h[c].x,
        y: h[c].y
      },
      {
        x: h[c + 1].x,
        y: h[c + 1].y
      }
    ]);
}
function _s(e, t, i, s) {
  let o = Gt(t, i, s), a = { x: i.x, y: i.y };
  e.quadraticCurveTo(a.x, a.y, o.x, o.y);
}
function gs(e) {
  const t = e.calculative.worldAnchors;
  let i = e.calculative.lineWidth * (e.calculative.gradientSmooth || e.calculative.lineSmooth || 0);
  const s = new Path2D();
  for (let o = 0; o < t.length - 1; o++) {
    t[o];
    let a = t[o + 1];
    if (o == 0 && s.moveTo(t[o].x, t[o].y), o > 0 && o < t.length - 1) {
      let r = t[o - 1].curvePoints;
      _s(s, i, t[o], t[o + 1]);
    }
    o > 0 && o < t.length - 1 && Gt(i, t[o], t[o + 1]), o < t.length - 2 && (a = Gt(i, t[o + 1], t[o])), s.lineTo(a.x, a.y);
  }
  return s;
}
function Wr(e = 100, t, i, s, o) {
  let a = null;
  const r = [];
  !s && !o ? a = jr : s && !o ? a = Vr : s && o && (a = Ur);
  for (let l = 0; l < e; l++)
    r.push(a(l / e, t, i, s, o));
  return s && r.push(s), r;
}
function jr(e, t, i) {
  const { x: s, y: o } = t, { x: a, y: r } = i;
  let l = s + (a - s) * e, n = o + (r - o) * e;
  return { x: l, y: n };
}
function Vr(e, t, i, s) {
  const { x: o, y: a } = t, { x: r, y: l } = i, { x: n, y: h } = s;
  let c = (1 - e) * (1 - e) * o + 2 * e * (1 - e) * r + e * e * n, d = (1 - e) * (1 - e) * a + 2 * e * (1 - e) * l + e * e * h;
  return { x: c, y: d };
}
function Ur(e, t, i, s, o) {
  const { x: a, y: r } = t, { x: l, y: n } = o, { x: h, y: c } = i, { x: d, y: u } = s;
  let f = a * (1 - e) * (1 - e) * (1 - e) + 3 * h * e * (1 - e) * (1 - e) + 3 * d * e * e * (1 - e) + l * e * e * e, g = r * (1 - e) * (1 - e) * (1 - e) + 3 * c * e * (1 - e) * (1 - e) + 3 * u * e * e * (1 - e) + n * e * e * e;
  return { x: f, y: g };
}
function qr(e, t) {
  const {
    worldRect: i,
    lineGradientFromColor: s,
    lineGradientToColor: o,
    lineGradientAngle: a
  } = t.calculative;
  return Co(
    e,
    i,
    s,
    o,
    a
  );
}
function Co(e, t, i, s, o) {
  if (!i || !s)
    return;
  const { x: a, y: r, center: l, ex: n, ey: h } = t, c = {
    x: a,
    y: l.y
  }, d = {
    x: n,
    y: l.y
  };
  o % 90 === 0 && o % 180 ? (c.x = l.x, d.x = l.x, o % 270 ? (c.y = r, d.y = h) : (c.y = h, d.y = r)) : o && (vt(c, o, t.center), vt(d, o, t.center));
  const u = e.createLinearGradient(c.x, c.y, d.x, d.y);
  return u.addColorStop(0, i), u.addColorStop(1, s), u;
}
function Yr(e) {
  const {
    worldIconRect: t,
    iconWidth: i,
    iconHeight: s,
    imgNaturalWidth: o,
    imgNaturalHeight: a
  } = e.calculative;
  let { x: r, y: l, width: n, height: h } = t;
  if (i && (n = i), s && (h = s), o && a && e.imageRatio) {
    const c = t.width / o, d = t.height / a, u = Math.min(c, d), f = o / a;
    i ? h = i / f : s ? n = s * f : (n = u * o, h = u * a);
  }
  switch (r += (t.width - n) / 2, l += (t.height - h) / 2, e.iconAlign) {
    case "top":
      l = t.y;
      break;
    case "bottom":
      l = t.ey - h;
      break;
    case "left":
      r = t.x;
      break;
    case "right":
      r = t.ex - n;
      break;
    case "left-top":
      r = t.x, l = t.y;
      break;
    case "right-top":
      r = t.ex - n, l = t.y;
      break;
    case "left-bottom":
      r = t.x, l = t.ey - h;
      break;
    case "right-bottom":
      r = t.ex - n, l = t.ey - h;
      break;
  }
  return {
    x: r,
    y: l,
    width: n,
    height: h
  };
}
function Be(e, t) {
  const { x: i, y: s, width: o, height: a } = Yr(t), { worldIconRect: r, iconRotate: l, img: n } = t.calculative;
  if (l) {
    const { x: h, y: c } = r.center;
    e.translate(h, c), e.rotate(l * Math.PI / 180), e.translate(-h, -c);
  }
  if (t.imageRadius) {
    e.save();
    let h = t.calculative.imageRadius || 0, c = h;
    const {
      x: d,
      y: u,
      width: f,
      height: g,
      ex: y,
      ey: v
    } = t.calculative.worldRect;
    h < 1 && (h = f * h, c = g * c);
    let b = h < c ? h : c;
    f < 2 * b && (b = f / 2), g < 2 * b && (b = g / 2), e.beginPath(), e.moveTo(d + b, u), e.arcTo(y, u, y, v, b), e.arcTo(y, v, d, v, b), e.arcTo(d, v, d, u, b), e.arcTo(d, u, y, u, b), e.clip(), e.drawImage(n, i, s, o, a), e.restore();
  } else
    e.drawImage(n, i, s, o, a);
}
function ce(e, t) {
  const { textColor: i, color: s } = e.calculative, { data: o, options: a } = t;
  return i || s || o.textColor || o.color || a.textColor || a.color;
}
function Ro(e, t) {
  const {
    fontStyle: i,
    fontWeight: s,
    fontSize: o,
    fontFamily: a,
    lineHeight: r,
    text: l,
    hiddenText: n,
    canvas: h,
    textHasShadow: c,
    textBackground: d,
    textType: u
  } = t.calculative;
  if (l == null || n)
    return;
  const f = h.store;
  e.save(), c || (e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0);
  let g;
  t.calculative.disabled ? g = t.disabledTextColor || t.disabledColor || Tt(0.4, ce(t, f)) : t.calculative.hover ? g = t.hoverTextColor || t.hoverColor || f.options.hoverColor : t.calculative.active && (g = t.activeTextColor || t.activeColor || f.options.activeColor);
  let y;
  u === Qe.Linear ? y = zr(e, t) : u === Qe.Radial && (y = Br(e, t)), e.fillStyle = g || y || ce(t, f), e.font = Dt({
    fontStyle: i,
    fontWeight: s,
    fontFamily: a || f.options.fontFamily,
    fontSize: o,
    lineHeight: r
  }), !t.calculative.textDrawRect && ko(e, t);
  const {
    x: v,
    y: b,
    width: x,
    height: p
  } = t.calculative.textDrawRect;
  d && (e.save(), e.fillStyle = d, e.fillRect(v, b, x, p), e.restore());
  const k = 0.55, C = t.textAlign || f.options.textAlign, R = o * r;
  t.calculative.textLines.forEach((P, E) => {
    const H = t.calculative.textLineWidths[E];
    let $ = 0;
    C === "center" ? $ = (x - H) / 2 : C === "right" && ($ = x - H), e.fillText(P, v + $, b + (E + k) * R);
    const { textDecorationColor: A, textDecorationDash: I, textDecoration: S } = t;
    S && $r(
      e,
      {
        x: v + $,
        y: b + (E + k) * R,
        width: H
      },
      { textDecorationColor: A, textDecorationDash: I, fontSize: o }
    );
    const { textStrickoutColor: _, textStrickoutDash: B, textStrickout: j } = t;
    j && Xr(
      e,
      {
        x: v + $,
        y: b + (E + k) * R,
        width: H
      },
      { textStrickoutColor: _, textStrickoutDash: B, fontSize: o }
    );
  }), e.restore();
}
function $r(e, t, i) {
  const { textDecorationColor: s, textDecorationDash: o, fontSize: a } = i;
  let { x: r, y: l, width: n } = t;
  switch (e.textBaseline) {
    case "top":
      l += a;
      break;
    case "middle":
      l += a / 2;
      break;
  }
  e.save(), e.beginPath(), e.strokeStyle = s || e.fillStyle, e.lineWidth = 1, e.moveTo(r, l), e.setLineDash(o || []), e.lineTo(r + n, l), e.stroke(), e.restore();
}
function Xr(e, t, i) {
  const { textStrickoutColor: s, textStrickoutDash: o, fontSize: a } = i;
  let { x: r, y: l, width: n } = t;
  switch (e.textBaseline) {
    case "top":
      l += a / 2;
      break;
    case "bottom":
      l -= a / 2;
      break;
  }
  e.save(), e.beginPath(), e.strokeStyle = s || e.fillStyle, e.lineWidth = 1, e.moveTo(r, l), e.setLineDash(o || []), e.lineTo(r + n, l), e.stroke(), e.restore();
}
function Po(e, t, i) {
  if (i == null)
    return;
  const { fontStyle: s, fontWeight: o, fontSize: a, fontFamily: r, lineHeight: l, canvas: n } = t.calculative, h = n.store;
  e.save();
  let c;
  t.calculative.hover ? c = t.hoverTextColor || t.hoverColor || h.options.hoverColor : t.calculative.active && (c = t.activeTextColor || t.activeColor || h.options.activeColor), e.fillStyle = c || ce(t, h), e.font = Dt({
    fontStyle: s,
    fontWeight: o,
    fontFamily: r || h.options.fontFamily,
    fontSize: a,
    lineHeight: l
  });
  const d = e.measureText(i).width;
  let u, f;
  for (const g of t.calculative.worldAnchors) {
    if (!f) {
      f = g;
      continue;
    }
    const y = Ci(f, g), v = Math.floor(y / d);
    u = "";
    for (let x = 0; x < v; x++)
      u += i;
    const b = zt(f, g) - 270;
    if (e.save(), b % 360 !== 0) {
      const { x, y: p } = f;
      e.translate(x, p);
      let k = b * Math.PI / 180;
      e.rotate(k), e.translate(-x, -p);
    }
    e.fillText(u, f.x, f.y + l / 2), e.restore(), f = g;
  }
  e.restore();
}
function Eo(e, t) {
  const i = t.calculative.canvas.store;
  e.save(), e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0, e.textAlign = "center", e.textBaseline = "middle";
  const s = t.calculative.worldIconRect;
  let o = s.x + s.width / 2, a = s.y + s.height / 2;
  switch (t.iconAlign) {
    case "top":
      a = s.y, e.textBaseline = "top";
      break;
    case "bottom":
      a = s.ey, e.textBaseline = "bottom";
      break;
    case "left":
      o = s.x, e.textAlign = "left";
      break;
    case "right":
      o = s.ex, e.textAlign = "right";
      break;
    case "left-top":
      o = s.x, a = s.y, e.textAlign = "left", e.textBaseline = "top";
      break;
    case "right-top":
      o = s.ex, a = s.y, e.textAlign = "right", e.textBaseline = "top";
      break;
    case "left-bottom":
      o = s.x, a = s.ey, e.textAlign = "left", e.textBaseline = "bottom";
      break;
    case "right-bottom":
      o = s.ex, a = s.ey, e.textAlign = "right", e.textBaseline = "bottom";
      break;
  }
  const r = t.calculative.iconWeight;
  let l;
  const n = t.calculative.iconFamily;
  t.calculative.iconSize > 0 ? l = t.calculative.iconSize : s.width > s.height ? l = s.height : l = s.width, e.font = Dt({
    fontSize: l,
    fontWeight: r,
    fontFamily: n
  }), e.fillStyle = t.calculative.iconColor || ce(t, i), t.calculative.iconRotate && (e.translate(s.center.x, s.center.y), e.rotate(t.calculative.iconRotate * Math.PI / 180), e.translate(-s.center.x, -s.center.y)), e.beginPath(), e.fillText(t.calculative.icon, o, a), e.restore();
}
function _o(e, t) {
  const i = t.calculative.canvas.store.data.scale, s = t.calculative.canvas.inputDiv.dataset.penId, { x: o, y: a, width: r, height: l } = t.calculative.worldRect;
  e.save(), e.beginPath(), t.id === s ? (e.moveTo(o + r - 20 * i, a + l / 2 + 2 * i), e.lineTo(o + r - 14 * i, a + l / 2 - 4 * i), e.lineTo(o + r - 8 * i, a + l / 2 + 2 * i)) : (e.moveTo(o + r - 20 * i, a + l / 2 - 4 * i), e.lineTo(o + r - 14 * i, a + l / 2 + 2 * i), e.lineTo(o + r - 8 * i, a + l / 2 - 4 * i)), e.stroke(), e.restore();
}
function Dt({
  fontStyle: e = "normal",
  textDecoration: t = "normal",
  fontWeight: i = "normal",
  fontSize: s = 12,
  fontFamily: o = "Arial",
  lineHeight: a = 1
  // TODO: lineHeight 默认值待测试
} = {}) {
  return `${e} ${t} ${i} ${s}px/${a} ${o}`;
}
function Ie(e, t) {
  const { x: i, ex: s, y: o, ey: a } = t.calculative.worldRect || {};
  t.calculative.flipX && (e.translate(i + s + 0.5, 0.5), e.scale(-1, 1)), t.calculative.flipY && (e.translate(0.5, o + a + 0.5), e.scale(1, -1));
}
function Qt(e, t, i = !1) {
  const { x: s, y: o } = t.calculative.worldRect.pivot || t.calculative.worldRect.center;
  e.translate(s, o);
  let a = t.calculative.rotate * Math.PI / 180;
  i || (t.calculative.flipX && (a *= -1), t.calculative.flipY && (a *= -1)), e.rotate(a), e.translate(-s, -o);
}
function ve(e, t, i) {
  e.save(), e.translate(0.5, 0.5), e.beginPath();
  const s = t.calculative.canvas.store, o = t.textFlip || s.options.textFlip, a = t.textRotate || s.options.textRotate;
  (!o || !a) && e.save(), Ie(e, t), t.calculative.rotate && t.name !== "line" && Qt(e, t), (t.calculative.lineWidth > 1 || i) && (e.lineWidth = t.calculative.lineWidth), an(e, s, t);
  let r, l = !1, n;
  t.calculative.disabled ? (n = t.disabledColor || s.options.disabledColor || Tt(0.4, t.calculative.color || Ke(s)), r = t.disabledBackground || s.options.disabledBackground || Tt(0.4, t.calculative.background || s.data.penBackground)) : t.mouseDownValid && t.calculative.mouseDown ? (n = t.mouseDownColor || Tt(-0.4, t.calculative.color || Ke(s)), r = t.mouseDownBackground || Tt(-0.4, t.calculative.background || s.data.penBackground)) : t.switch && t.calculative.checked ? t.calculative.bkType || (r = t.onBackground) : t.calculative.hover ? (n = t.hoverColor || s.options.hoverColor, r = t.hoverBackground || s.options.hoverBackground) : t.calculative.active ? (n = t.activeColor || s.options.activeColor, r = t.activeBackground || s.options.activeBackground) : t.calculative.isDock && (t.type === ft.Line ? n = s.options.dockPenColor : r = xi(s.options.dockPenColor, 0.2));
  const h = t.calculative.strokeImg;
  if (t.calculative.strokeImage && h)
    e.strokeStyle = n || e.createPattern(h, "repeat");
  else {
    let d;
    t.calculative.strokeType ? t.calculative.lineGradientColors ? t.name === "line" ? l = !0 : t.calculative.lineGradient ? d = t.calculative.lineGradient : (d = Fr(e, t), t.calculative.lineGradient = d) : d = qr(e, t) : d = t.calculative.color || (t.type ? s.data.lineColor : "") || Ke(s), e.strokeStyle = n || d;
  }
  const c = t.calculative.backgroundImg;
  if (t.calculative.backgroundImage && c)
    e.fillStyle = r || e.createPattern(c, "repeat"), r = !0;
  else {
    let d;
    t.calculative.bkType === Qe.Linear ? t.calculative.gradientColors ? t.calculative.gradient ? d = t.calculative.gradient : (d = Dr(e, t), t.calculative.gradient = d) : d = Lr(e, t) : t.calculative.bkType === Qe.Radial ? t.calculative.gradientColors ? t.calculative.radialGradient ? d = t.calculative.radialGradient : (d = Or(e, t), t.calculative.radialGradient = d) : d = Mr(e, t) : d = t.calculative.background || s.data.penBackground, e.fillStyle = r || d, r = !!d;
  }
  if (Lo(e, t), Mo(e, t), Ae(e, t), t.calculative.lineDash && e.setLineDash(
    t.calculative.lineDash.map(
      (d) => d * t.calculative.canvas.store.data.scale
    )
  ), t.calculative.lineDashOffset && (e.lineDashOffset = t.calculative.lineDashOffset), t.calculative.shadowColor && (e.shadowColor = t.calculative.shadowColor, e.shadowOffsetX = t.calculative.shadowOffsetX, e.shadowOffsetY = t.calculative.shadowOffsetY, e.shadowBlur = t.calculative.shadowBlur), l ? (To(e, t), Oo(!0, e, t, s)) : (No(!0, e, t, s, r), jo(e, t)), !(t.image && t.calculative.img) && t.calculative.icon && Eo(e, t), t.dropdownList && _o(e, t), (!o || !a) && e.restore(), o && !a && Ie(e, t), !o && a && t.calculative.rotate && t.name !== "line" && Qt(e, t, !0), Ro(e, t), t.type === ft.Line && t.fillTexts)
    for (const d of t.fillTexts)
      Po(e, t, d);
  e.restore();
}
function Lo(e, t) {
  const i = t.lineCap || (t.type ? "round" : "square");
  i ? e.lineCap = i : t.type && (e.lineCap = "round");
}
function Mo(e, t) {
  const i = t.lineJoin;
  i ? e.lineJoin = i : t.type && (e.lineJoin = "round");
}
function ki(e, t, i, s) {
  var h;
  e.save(), i && e.translate(-i.x, -i.y), (h = e.setAttrs) == null || h.call(e, t);
  let o = !1;
  const a = t.calculative.canvas.store, r = t.textFlip || a.options.textFlip, l = t.textRotate || a.options.textRotate;
  e.beginPath(), (!r || !l) && e.save(), t.calculative.flipX && (e.translate(
    t.calculative.worldRect.x + t.calculative.worldRect.ex,
    0
  ), e.scale(-1, 1)), t.calculative.flipY && (e.translate(
    0,
    t.calculative.worldRect.y + t.calculative.worldRect.ey
  ), e.scale(1, -1)), t.calculative.rotate && t.name !== "line" && Qt(e, t), (t.calculative.lineWidth > 1 || s) && (e.lineWidth = t.calculative.lineWidth);
  let n;
  if (t.calculative.hover)
    e.strokeStyle = t.hoverColor || a.options.hoverColor, e.fillStyle = t.hoverBackground || a.options.hoverBackground, n = t.hoverBackground || a.options.hoverBackground;
  else if (t.calculative.active)
    e.strokeStyle = t.activeColor || a.options.activeColor, e.fillStyle = t.activeBackground || a.options.activeBackground, n = t.activeBackground || a.options.activeBackground;
  else {
    if (t.strokeImage)
      t.calculative.strokeImg && (e.strokeStyle = e.createPattern(
        t.calculative.strokeImg,
        "repeat"
      ), n = !0);
    else {
      let c;
      t.calculative.strokeType && t.calculative.lineGradientColors && t.name === "line" ? o = !0 : c = t.calculative.color || Ke(a), e.strokeStyle = c;
    }
    t.backgroundImage ? t.calculative.backgroundImg && (e.fillStyle = e.createPattern(
      t.calculative.backgroundImg,
      "repeat"
    ), n = !0) : (e.fillStyle = t.background, n = !!t.background);
  }
  if (Lo(e, t), Mo(e, t), Ae(e, t), t.calculative.lineDash && e.setLineDash(t.calculative.lineDash), t.calculative.lineDashOffset && (e.lineDashOffset = t.calculative.lineDashOffset), t.calculative.shadowColor && (e.shadowColor = t.calculative.shadowColor, e.shadowOffsetX = t.calculative.shadowOffsetX, e.shadowOffsetY = t.calculative.shadowOffsetY, e.shadowBlur = t.calculative.shadowBlur), o ? (To(e, t), Oo(!0, e, t, a)) : (No(!1, e, t, a, n), jo(e, t)), t.calculative.img ? (e.save(), e.shadowColor = "", e.shadowBlur = 0, e.shadowOffsetX = 0, e.shadowOffsetY = 0, Be(e, t), e.restore()) : t.calculative.icon && Eo(e, t), t.dropdownList && _o(e, t), (!r || !l) && e.restore(), r && !l && (t.calculative.flipX && (e.translate(
    t.calculative.worldRect.x + t.calculative.worldRect.ex,
    0
  ), e.scale(-1, 1)), t.calculative.flipY && (e.translate(
    0,
    t.calculative.worldRect.y + t.calculative.worldRect.ey
  ), e.scale(1, -1))), !r && l && t.calculative.rotate && t.name !== "line" && Qt(e, t, !0), Ro(e, t), t.type === ft.Line && t.fillTexts)
    for (const c of t.fillTexts)
      Po(e, t, c);
  e.restore();
}
function No(e = !0, t, i, s, o) {
  if (i.name === "drawCommand") return;
  const a = e ? s.path2dMap.get(i) : rt.path2dDraws[i.name];
  let r = null, l = null;
  if (i.type === ft.Line && (i.fromLineCap && i.fromLineCap !== "butt" && (t.lineCap = "butt", r = new Path2D(), r.moveTo(
    i.calculative.worldAnchors[0].x,
    i.calculative.worldAnchors[0].y
  ), r.lineTo(
    i.calculative.worldAnchors[0].x,
    i.calculative.worldAnchors[0].y
  )), i.toLineCap && i.toLineCap !== "butt" && (t.lineCap = "butt", l = new Path2D(), l.moveTo(
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].x,
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].y
  ), l.lineTo(
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].x,
    i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].y
  ))), a) {
    if (i.type === ft.Line && i.borderWidth) {
      t.save(), t.beginPath();
      const h = i.calculative.lineWidth + i.calculative.borderWidth;
      t.lineWidth = h, t.strokeStyle = i.borderColor, r && (t.save(), t.lineCap = i.fromLineCap, t.stroke(r), t.restore()), a instanceof Path2D ? (o && t.fill(a), h && t.stroke(a)) : (a(i, t), o && t.fill(), h && t.stroke()), l && (t.save(), t.lineCap = i.toLineCap, t.stroke(l), t.restore()), t.restore();
    }
    a instanceof Path2D ? i.type ? i.close && o && t.fill(a) : o && t.fill(a) : (t.save(), a(i, t), o && t.fill(), t.restore());
    const n = i.calculative.progress;
    if (n != null) {
      t.save();
      const { ex: h, x: c, y: d, width: u, height: f, ey: g } = i.calculative.worldRect;
      let y = null;
      if (i.calculative.verticalProgress ? y = i.reverseProgress ? t.createLinearGradient(c, d, c, d + f * n) : t.createLinearGradient(c, g, c, d + f * (1 - n)) : y = i.reverseProgress ? t.createLinearGradient(h, d, c + u * (1 - n), d) : t.createLinearGradient(c, d, c + u * n, d), i.calculative.progressGradientColors) {
        const { colors: v } = Te(
          i.calculative.progressGradientColors
        );
        v.forEach((b) => {
          y.addColorStop(b.i, b.color);
        });
      } else {
        const v = i.calculative.progressColor || i.calculative.color || s.options.activeColor;
        y.addColorStop(0, v), y.addColorStop(1, v);
      }
      y.addColorStop(1, "transparent"), t.fillStyle = y, a instanceof Path2D ? t.fill(a) : (a(i, t), t.fill()), t.restore();
    }
    if (i.calculative.lineWidth && (a instanceof Path2D ? (s.options.svgPathStroke || i.name !== "svgPath") && (r && (t.save(), t.lineCap = i.fromLineCap, t.stroke(r), t.restore()), t.stroke(a), l && (t.save(), t.lineCap = i.toLineCap, t.stroke(l), t.restore())) : (a(i, t), t.stroke())), i.type) {
      if (i.calculative.animatePos) {
        if (t.save(), Do(t, i, s), i.lineAnimateType === Ht.Arrow || i.lineAnimateType === Ht.WaterDrop) {
          let h = Go(i, t);
          h instanceof Path2D ? (t.stroke(h), t.fill(h)) : (t.stroke(), t.fill());
        } else
          a instanceof Path2D ? (r && !i.lineAnimateType && (t.save(), t.lineCap = i.fromLineCap, t.stroke(r), t.restore()), t.lineCap = i.lineCap, t.stroke(a)) : (a(i, t), t.stroke());
        t.restore();
      }
      i.fromArrow && Ao(t, i, s), i.toArrow && So(t, i, s), i.calculative.active && !i.calculative.pencil && !s.options.disableAnchor && !s.data.locked && Bo(t, i);
    }
  }
}
function Oo(e = !0, t, i, s) {
  const o = e ? s.path2dMap.get(i) : rt.path2dDraws[i.name];
  if (o && i.type) {
    if (i.calculative.animatePos) {
      if (t.save(), Do(t, i, s), t.beginPath(), o instanceof Path2D)
        if (i.lineName === "polyline" || i.lineName === "line")
          if (i.lineAnimateType === Ht.Arrow || i.lineAnimateType === Ht.WaterDrop) {
            const a = Go(i);
            t.stroke(a), t.fill(a);
          } else
            i.calculative.gradientSmooth || i.calculative.lineSmooth ? (i.calculative.gradientAnimatePath || (i.calculative.gradientAnimatePath = gs(i)), i.calculative.gradientAnimatePath instanceof Path2D && t.stroke(i.calculative.gradientAnimatePath)) : t.stroke(o);
        else
          t.stroke(o);
      else
        o(i, t), t.stroke();
      t.restore();
    }
    i.fromArrow && Ao(t, i, s), i.toArrow && So(t, i, s), i.calculative.active && !i.calculative.pencil && !s.options.disableAnchor && !s.data.locked && Bo(t, i);
  }
}
function Do(e, t, i) {
  e.strokeStyle = t.animateColor || i.options.animateColor, t.animateShadow && (e.shadowBlur = t.animateShadowBlur || t.animateLineWidth || 6, e.shadowColor = t.animateShadowColor || t.animateColor || i.options.animateColor), t.calculative.animateLineWidth && (e.lineWidth = t.calculative.animateLineWidth * i.data.scale);
  let s = 0;
  switch (t.lineAnimateType) {
    case Ht.Beads:
      t.animateReverse ? e.lineDashOffset = t.calculative.animatePos : e.lineDashOffset = t.length - t.calculative.animatePos, s = t.calculative.lineWidth || 5, s < 5 && (s = 5);
      const o = t.animateLineDash && t.animateLineDash.map((a) => a * s / 5);
      e.setLineDash(o || [s, s * 2]);
      break;
    case Ht.Dot:
      t.animateReverse ? e.lineDashOffset = t.calculative.animatePos : e.lineDashOffset = t.length - t.calculative.animatePos, s = t.calculative.animateDotSize || t.calculative.lineWidth * 2 || 6, s < 6 && (s = 6), s > 40 && (s = 40), e.lineWidth = (t.calculative.animateLineWidth || s) * i.data.scale, e.setLineDash([0.1, t.length]);
      break;
    case Ht.Arrow:
      e.fillStyle = t.animateColor || i.options.animateColor, e.lineWidth = 1;
      break;
    case Ht.WaterDrop:
      e.fillStyle = t.animateColor || i.options.animateColor, e.lineWidth = 1;
      break;
    default:
      t.animateReverse ? (e.lineDashOffset = Number.EPSILON, e.setLineDash([
        0,
        t.length - t.calculative.animatePos + 1,
        t.calculative.animatePos
      ])) : e.setLineDash([
        t.calculative.animatePos,
        t.length + 0.01 - t.calculative.animatePos
        //避免在缩放时，精度问题绘制多余圆点
      ]);
      break;
  }
}
function Ke(e) {
  const { data: t, options: i } = e;
  return t.color || i.color;
}
function Bo(e, t) {
  const i = t.calculative.canvas.store;
  e.save(), e.lineWidth = 1, e.fillStyle = t.activeColor || i.options.activeColor, t.calculative.worldAnchors.forEach((s) => {
    !s.hidden && !s.isTemp && Kr(e, s, t);
  }), e.restore();
}
function Kr(e, t, i) {
  if (!t)
    return;
  const s = i.calculative.canvas.store.activeAnchor === i.calculative.activeAnchor && i.calculative.activeAnchor === t;
  let o = 3;
  i.calculative.lineWidth > 3 && (o = i.calculative.lineWidth), i.anchorRadius && (o = i.anchorRadius), t.radius && (o = t.radius), s ? (t.prev && (e.save(), e.strokeStyle = "#4dffff", e.beginPath(), e.moveTo(t.prev.x, t.prev.y), e.lineTo(t.x, t.y), e.stroke(), e.restore(), e.save(), e.fillStyle = "#ffffff", e.beginPath(), e.arc(t.prev.x, t.prev.y, o, 0, Math.PI * 2), e.fill(), e.stroke(), e.restore()), t.next && (e.save(), e.strokeStyle = "#4dffff", e.beginPath(), e.moveTo(t.x, t.y), e.lineTo(t.next.x, t.next.y), e.stroke(), e.restore(), e.save(), e.fillStyle = "#ffffff", e.beginPath(), e.arc(t.next.x, t.next.y, o, 0, Math.PI * 2), e.fill(), e.stroke(), e.restore(), e.beginPath(), e.arc(t.x, t.y, o, 0, Math.PI * 2), e.fill(), e.stroke()), e.beginPath(), e.arc(t.x, t.y, o, 0, Math.PI * 2), e.fill(), e.stroke()) : (e.save(), e.fillStyle = "#ffffff", e.beginPath(), e.arc(t.x, t.y, o, 0, Math.PI * 2), e.fill(), e.stroke(), e.restore());
}
function zo(e) {
  const t = e.calculative.canvas.store;
  let i = {
    x: e.x,
    y: e.y
  };
  if (!e.parentId || e.parentId && !t.pens[e.parentId])
    e.parentId = void 0, i.width = e.width, i.height = e.height, i.rotate = e.rotate, wt(i), pt(i), e.pivot && Ji(i, e.pivot);
  else {
    const s = t.pens[e.parentId];
    let o = s.calculative.worldRect;
    o || (o = zo(s)), i.x = o.x + o.width * e.x, i.y = o.y + o.height * e.y, i.width = o.width * e.width, i.height = o.height * e.height, s.flipX && (i.x = o.width - (i.x - o.x + i.width) + o.x), s.flipY && (i.y = o.height - (i.y - o.y + i.height) + o.y), wt(i), i.rotate = o.rotate + e.rotate, pt(i), e.pivot && Ji(i, e.pivot);
  }
  return e.calculative.worldRect = i, vs(e, i), i;
}
function vs(e, t) {
  !e.paddingTop && (e.calculative.paddingTop = 0), !e.paddingBottom && (e.calculative.paddingBottom = 0), !e.paddingLeft && (e.calculative.paddingLeft = 0), !e.paddingRight && (e.calculative.paddingRight = 0), Math.abs(e.calculative.paddingTop) < 1 && (e.calculative.paddingTop *= t.height), Math.abs(e.calculative.paddingBottom) < 1 && (e.calculative.paddingBottom *= t.height), Math.abs(e.calculative.paddingLeft) < 1 && (e.calculative.paddingLeft *= t.width), Math.abs(e.calculative.paddingRight) < 1 && (e.calculative.paddingRight *= t.width);
}
function mi(e) {
  const t = G(e.calculative.worldRect);
  if (delete t.pivot, !e.parentId) {
    Object.assign(e, t);
    return;
  }
  const s = e.calculative.canvas.store.pens[e.parentId].calculative.worldRect;
  Object.assign(e, ae(t, s));
}
function ze(e) {
  const t = e.calculative.canvas.store;
  let i = [];
  if (e.anchors) {
    let s = G(e.anchors);
    e.flipX && s.forEach((o) => {
      o.x = 0.5 - (o.x - 0.5);
    }), e.flipY && s.forEach((o) => {
      o.y = 0.5 - (o.y - 0.5);
    }), s.forEach((o) => {
      i.push(Gr(e, o));
    });
  }
  if (!i.length && !e.type && !e.calculative.canvas.parent.isCombine(e)) {
    const { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
    i = t.options.defaultAnchors.map((l, n) => ({
      id: `${n}`,
      penId: e.id,
      x: s + a * l.x,
      y: o + r * l.y
    }));
  }
  e.calculative.rotate && i.forEach((s) => {
    vt(
      s,
      e.calculative.rotate,
      e.calculative.worldRect.pivot || e.calculative.worldRect.center
    );
  }), (!e.type || e.anchors) && (e.calculative.worldAnchors = i), e.calculative.activeAnchor && i.length && (e.calculative.activeAnchor = i.find((s) => {
    s.id, e.calculative.activeAnchor.id;
  })), e.calculative.gradientAnimatePath = void 0;
}
function Ho(e) {
  var t;
  if ((t = e.children) != null && t.length) {
    let i = e.calculative.worldRect;
    e.children.forEach((s) => {
      const o = e.calculative.canvas.store.pens[s];
      o.calculative.initRect && o.calculative.initRelativeRect && (o.calculative.initRect.x = i.x + i.width * o.calculative.initRelativeRect.x, o.calculative.initRect.y = i.y + i.height * o.calculative.initRelativeRect.y, o.calculative.initRect.ex = o.calculative.initRect.x + i.width * o.calculative.initRelativeRect.width, o.calculative.initRect.ey = o.calculative.initRect.y + i.height + o.calculative.initRelativeRect.height, pt(o.calculative.initRect)), Ho(o);
    });
  }
}
function Gr(e, t) {
  const i = { ...t }, { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  return i.x = s + a * t.x, i.y = o + r * t.y, t.prev && (i.prev = {
    penId: e.id,
    connectTo: t.prev.connectTo,
    x: s + a * t.prev.x,
    y: o + r * t.prev.y
  }), t.next && (i.next = {
    penId: e.id,
    connectTo: t.next.connectTo,
    x: s + a * t.next.x,
    y: o + r * t.next.y
  }), i;
}
function Ls(e, t) {
  const { paddingTop: i, paddingBottom: s, paddingLeft: o, paddingRight: a } = t.calculative;
  let r = o, l = i, n = t.calculative.worldRect.width - o - a, h = t.calculative.worldRect.height - i - s, c = t.calculative.iconLeft, d = t.calculative.iconTop;
  c && Math.abs(c) < 1 && (c = t.calculative.worldRect.width * c), d && Math.abs(d) < 1 && (d = t.calculative.worldRect.height * d), r += c || 0, l += d || 0, n -= c || 0, h -= d || 0;
  let u = t.calculative.iconRotate || 0;
  if (t.parentId) {
    const f = e[t.parentId].calculative;
    f && (u += f.rotate, u %= 360);
  }
  r = t.calculative.worldRect.x + r, l = t.calculative.worldRect.y + l, t.calculative.worldIconRect = {
    x: r,
    y: l,
    width: n,
    height: h,
    rotate: u
  }, wt(t.calculative.worldIconRect), pt(t.calculative.worldIconRect);
}
function Pe(e, t, i) {
  Ze(e.calculative.worldRect, t, i, e.pivot), e.calculative.initRect && Ze(e.calculative.initRect, t, i, e.pivot), Fo(e, t, i), e.calculative.x && wi(e.calculative, t, i), e.type && ze(e);
}
function Fo(e, t, i) {
  var s;
  e && (s = e.children) != null && s.length && e.children.forEach((o) => {
    const a = e.calculative.canvas.store.pens[o];
    a && (a.calculative.initRect && Ze(a.calculative.initRect, t, i), Fo(a, t, i));
  });
}
function Jr(e, t) {
  e.anchors || (e.anchors = []), e.calculative.worldAnchors || (e.calculative.worldAnchors = []);
  const i = {
    id: t.id,
    penId: e.id,
    x: t.x,
    y: t.y
  };
  if (e.calculative.worldAnchors.push(i), e.calculative.worldRect) {
    e.rotate % 360 && vt(t, -e.rotate, e.calculative.worldRect.center);
    const s = {
      id: t.id,
      penId: e.id,
      x: (t.x - e.calculative.worldRect.x) / e.calculative.worldRect.width,
      y: (t.y - e.calculative.worldRect.y) / e.calculative.worldRect.height
    };
    e.anchors.push(s);
  }
  return i;
}
function Qr(e, t, i) {
  e.anchors || (e.anchors = []), e.calculative.worldAnchors || (e.calculative.worldAnchors = []);
  const s = Xn(e, t, i);
  return e.calculative.worldAnchors.splice(i + 1, 0, s), e.anchors.splice(
    i + 1,
    0,
    Ge(s, e.calculative.worldRect)
  ), e.calculative.activeAnchor = s, s;
}
function Zr(e, t) {
  if (!e || !e.calculative.worldAnchors)
    return;
  let i = e.calculative.worldAnchors.findIndex((s) => s.id === t.id);
  i > -1 && e.calculative.worldAnchors.splice(i, 1), i = e.anchors.findIndex((s) => s.id === t.id), i > -1 && e.anchors.splice(i, 1);
}
function He(e, t) {
  if (!t || !t.calculative || !t.calculative.worldRect.center)
    return ct.None;
  if (e.anchorId) {
    let i = t.anchors.filter((s) => s.id === e.anchorId);
    if (i.length && i[0].direction > -1)
      return i[0].direction;
  }
  return er(e, t.calculative.worldRect.center);
}
function Ne(e, t) {
  let i = 1 / 0, s;
  return e.calculative.worldAnchors.forEach((o) => {
    const a = Ci(t, o);
    i > a && (i = a, s = o);
  }), s;
}
function Ms(e, t, i) {
  e.x += t, e.y += i, e.anchors && e.anchors.forEach((s) => {
    Xe(s, t, i);
  }), e.calculative.worldAnchors && e.calculative.worldAnchors.forEach((s) => {
    Xe(s, t, i);
  });
}
function ys(e) {
  if (e && e.calculative && e.calculative.worldAnchors.length) {
    let t = ut(e);
    if (!e.anchors || !e.anchors.length)
      for (; e.calculative.worldAnchors.length && t !== e.calculative.activeAnchor; )
        e.calculative.worldAnchors.pop(), t = ut(e);
    else t === e.calculative.activeAnchor ? e.calculative.worldAnchors = [e.calculative.worldAnchors[0]] : e.calculative.worldAnchors[0] === e.calculative.activeAnchor && (e.calculative.worldAnchors = [
      e.calculative.worldAnchors[e.calculative.worldAnchors.length - 1]
    ]);
  }
}
function St(e, t, i, s) {
  var l, n, h, c, d, u;
  if (!e || !t || !i || !s || t.twoWay === Rt.DisableConnected || t.twoWay === Rt.Disable || s.twoWay === Rt.DisableConnectTo || s.twoWay === Rt.Disable)
    return;
  if (t.twoWay === Rt.In) {
    if (i.calculative.worldAnchors.length === 1)
      return;
    const f = ut(i);
    if (s.id !== f.id)
      return;
  }
  if (t.twoWay === Rt.Out) {
    const f = xt(i);
    if (s.id !== f.id)
      return;
  }
  if (s.connectTo === e.id && s.anchorId === t.id)
    return;
  if (s.connectTo) {
    const f = e.calculative.canvas.store.pens[s.connectTo];
    Oe(f, ye(f, s.anchorId), i, s);
  }
  e.connectedLines || (e.connectedLines = []), e.connectedLines.findIndex(
    (f) => f.lineId === i.id && f.lineAnchor === s.id && f.anchor === t.id
  ) < 0 && e.connectedLines.push({
    lineId: i.id,
    lineAnchor: s.id,
    anchor: t.id
  }), s.connectTo = e.id, s.anchorId = t.id, e.type && St(i, s, e, t), e.calculative.canvas.store.emitter.emit("connectLine", {
    line: i,
    lineAnchor: s,
    pen: e,
    anchor: t
  });
  let a = ((l = i.calculative.worldAnchors) == null ? void 0 : l.length) >= 2 ? (n = i.calculative.worldAnchors) == null ? void 0 : n[0].connectTo : void 0, r = ((h = i.calculative.worldAnchors) == null ? void 0 : h.length) >= 2 ? (d = i.calculative.canvas.store.pens[(c = i.calculative.worldAnchors) == null ? void 0 : c[0].connectTo]) == null ? void 0 : d.anchors.find(
    (f) => {
      var g;
      return f.id === ((g = i.calculative.worldAnchors) == null ? void 0 : g[0].anchorId);
    }
  ) : void 0;
  return (u = e.onConnectLine) == null || u.call(e, e, {
    line: i,
    lineAnchor: s,
    pen: e,
    anchor: t,
    fromPen: a,
    fromAnchor: r
  }), !0;
}
function Oe(e, t, i, s) {
  if (!(!e || !t || !i || !s) && !(!e.connectedLines || !e.connectedLines.length))
    return i.lastConnected || (i.lastConnected = {}), i.lastConnected[e.id] || (i.lastConnected[e.id] = G(e.connectedLines)), e.connectedLines.forEach((o, a, r) => {
      (o.lineId === i.id || o.lineId === i.id) && o.lineAnchor === s.id && o.anchor === t.id && r.splice(a, 1);
    }), s.connectTo = void 0, s.anchorId = void 0, e.type && t.connectTo === i.id && t.anchorId === s.id && Oe(i, s, e, t), e.calculative.canvas.store.emitter.emit("disconnectLine", {
      line: i,
      lineAnchor: s,
      pen: e,
      anchor: t
    }), !0;
}
function ye(e, t) {
  var i;
  if (!(!e || !t))
    return (i = e.calculative.worldAnchors) == null ? void 0 : i.find((s) => s.id === t);
}
function xt(e) {
  if (!(!e || !e.calculative.worldAnchors))
    return e.calculative.worldAnchors[0];
}
function ut(e) {
  if (!(!e || !e.calculative.worldAnchors))
    return e.calculative.worldAnchors[e.calculative.worldAnchors.length - 1];
}
function tn(e, t) {
  var s, o;
  if (e.calculative.start === 0 || !e.frames || !e.frames.length)
    return e.calculative.start = void 0, 0;
  if (!e.calculative.duration) {
    e.calculative.duration = 0;
    for (const a of e.frames) {
      e.calculative.duration += a.duration;
      for (const r in a)
        r !== "duration" && !e[r] && r === "scale" && (e[r] = 1);
    }
  }
  if (e.animateCycle || (e.animateCycle = 1 / 0), e.calculative.start) {
    let a = 0;
    const r = Math.ceil(
      (t - e.calculative.start) / e.calculative.duration
    );
    if (r > e.animateCycle)
      return e.currentAnimation = void 0, e.calculative.start = void 0, Os(e, 1), 0;
    const l = (t - e.calculative.start) % e.calculative.duration;
    let n = 0;
    for (const d of e.frames)
      if (n += d.duration, l > n)
        ++a;
      else
        break;
    if (!e.frames[a])
      return !0;
    e.calculative.frameDuration = e.frames[a].duration, e.calculative.frameStart = e.calculative.start + e.calculative.duration * (r - 1), e.calculative.frameEnd = e.calculative.frameStart + e.calculative.frameDuration;
    const h = a !== e.calculative.frameIndex, c = r > e.calculative.cycleIndex;
    if (h && (e.calculative.frameIndex = a), c && (e.calculative.cycleIndex = r), h || c)
      if (e.calculative.x = e.calculative.initRect.x, e.calculative.y = e.calculative.initRect.y, (o = e.children) != null && o.length && !e.parentId ? e.calculative.canvas.rotatePen(
        e,
        (e.calculative.initRect.rotate || 0) - (e.calculative.rotate || 0),
        e.calculative.initRect
      ) : e.calculative.rotate = e.calculative.initRect.rotate || 0, a > 0) {
        e.prevFrame = {};
        const d = e.frames[a - 1];
        for (const u in d)
          e.prevFrame[u] = d[u];
        Object.assign(e.prevFrame, {
          rotate: d.rotate || 0,
          x: d.x || 0,
          y: d.y || 0,
          scale: d.scale || 1
        });
      } else
        Ns(e);
  } else {
    if (e.calculative.start = t, e.calculative.frameIndex = 0, e.calculative.frameStart = e.calculative.start, e.calculative.frameDuration = e.frames[0].duration, e.calculative.frameEnd = e.calculative.frameStart + e.calculative.frameDuration, e.calculative.cycleIndex = 1, e.calculative.x = e.calculative.worldRect.x, e.calculative.y = e.calculative.worldRect.y, e.calculative.initRect = G(e.calculative.worldRect), e.parentId && (e.calculative.initRelativeRect = {
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    }), (s = e.children) != null && s.length) {
      const a = e.calculative.canvas.store;
      e.calculative.childrenVisible = {}, e.children.forEach((r) => {
        e.calculative.childrenVisible[r] = a.pens[r].visible;
      });
    }
    e.calculative.initRect.rotate = e.calculative.rotate || 0, Ns(e);
  }
  const i = (t - e.calculative.frameStart) / e.calculative.frameDuration % 1;
  return Os(e, i), !0;
}
function Ns(e) {
  e.prevFrame = {};
  for (const t in e)
    (typeof e[t] != "object" || t === "lineDash") && (e.prevFrame[t] = e[t]);
  e.prevFrame.rotate = 0, e.prevFrame.x = 0, e.prevFrame.y = 0, e.prevFrame.scale = 1;
}
function Os(e, t) {
  var s, o;
  if (t < 0)
    return;
  t > 1 && (t = 1);
  const i = e.frames[e.calculative.frameIndex];
  for (const a in i)
    if (a !== "duration") {
      if (a === "scale") {
        e.calculative.worldRect = G(e.calculative.initRect), Ze(
          e.calculative.worldRect,
          e.prevFrame.scale,
          e.calculative.worldRect.center
        );
        const r = e.prevFrame.scale + (i[a] - e.prevFrame.scale) * t;
        Ze(
          e.calculative.worldRect,
          r / e.prevFrame.scale,
          e.calculative.worldRect.center
        ), e.calculative.patchFlags = !0;
      } else if (a === "x") {
        const r = Oi(e, a, e.calculative.frameIndex);
        e.calculative.worldRect.x = e.calculative.initRect.x + r, e.calculative.worldRect.ex = e.calculative.initRect.ex + r, be(
          e.calculative.worldRect,
          i[a] * t * e.calculative.canvas.store.data.scale,
          0
        ), e.calculative.patchFlags = !0;
      } else if (a === "y") {
        const r = Oi(e, a, e.calculative.frameIndex);
        e.calculative.worldRect.y = e.calculative.initRect.y + r, e.calculative.worldRect.ey = e.calculative.initRect.ey + r, be(
          e.calculative.worldRect,
          0,
          i[a] * t * e.calculative.canvas.store.data.scale
        ), e.calculative.patchFlags = !0;
      } else if (a === "rotate") {
        e.prevFrame[a] >= 360 && (e.prevFrame[a] %= 360);
        const r = Oi(e, a, e.calculative.frameIndex), l = (e.calculative.initRect.rotate + r + i[a] * t) % 360 - (e.calculative.rotate || 0);
        (s = e.children) != null && s.length ? e.calculative.canvas.rotatePen(
          e,
          l,
          e.calculative.initRect
        ) : e.calculative.rotate = (e.calculative.initRect.rotate + r + i[a] * t) % 360, e.calculative.patchFlags = !0;
      } else if (a === "image")
        e.image = i.image, e.calculative.image = void 0, e.calculative.canvas.loadImage(e), e.canvasLayer === dt.CanvasImageBottom ? e.calculative.canvas.canvasImageBottom.init() : e.canvasLayer === dt.CanvasImage && e.calculative.canvas.canvasImage.init();
      else if (en(i[a], a, e)) {
        e.prevFrame[a] == null && (a === "globalAlpha" ? e.prevFrame[a] = 1 : e.prevFrame[a] = 0);
        const r = e.prevFrame[a] + (i[a] - e.prevFrame[a]) * t;
        e.calculative[a] = Math.round(r * 100) / 100;
      } else {
        if (a === "visible") {
          if (e.calculative.image)
            e.canvasLayer === dt.CanvasImageBottom ? e.calculative.canvas.canvasImageBottom.init() : e.canvasLayer === dt.CanvasImage && e.calculative.canvas.canvasImage.init();
          else if ((o = e.children) != null && o.length) {
            const l = Ut(e, e.calculative.canvas.store);
            e.calculative.canvas.initImageCanvas(l);
          }
        }
        e.calculative[a] = i[a];
        const r = {};
        r[a] = i[a], ms(e, r);
      }
      a === "text" && ii(e);
    }
}
function en(e, t, i) {
  const s = ["strokeType", "bkType", "showChild"];
  return typeof e == "number" && i.linear !== !1 && !s.includes(t);
}
function sn(e, t) {
  if (e.calculative.start === 0)
    return e.calculative.start = void 0, 0;
  if (e.animateCycle || (e.animateCycle = 1 / 0), e.animateSpan || (e.animateSpan = 1), e.calculative.animatePos += e.animateSpan * (e.calculative.canvas.store.data.scale || 1), !e.calculative.start)
    e.calculative.start = Date.now(), e.calculative.animatePos = e.animateSpan * (e.calculative.canvas.store.data.scale || 1), e.calculative.cycleIndex = 1;
  else if (e.calculative.animatePos > e.length) {
    if (++e.calculative.cycleIndex, e.calculative.cycleIndex > e.animateCycle)
      return e.currentAnimation = void 0, e.calculative.start = void 0, 0;
    e.calculative.animatePos = e.animateSpan;
  }
  return !0;
}
function Le(e, t = !0) {
  if (!e.children || e.childActive === !1)
    return;
  const i = e.calculative.canvas.store;
  e.children.forEach((s) => {
    const o = i.pens[s];
    o && (o.calculative.active = t, Le(o, t));
  });
}
function qe(e, t = !0) {
  if (!e)
    return;
  const i = e.calculative.canvas.store;
  e.calculative.hover = t, e.childHover !== !1 && e.children && e.children.forEach((s) => {
    var o, a;
    ((o = i.pens[s]) == null ? void 0 : o.hoverColor) == null && ((a = i.pens[s]) == null ? void 0 : a.hoverBackground) == null && qe(i.pens[s], t);
  });
}
function Ct(e, t) {
  if (!t)
    return;
  const i = e.calculative.canvas.store, s = e.calculative.worldRect;
  t.style.opacity = e.globalAlpha + "", t.style.position = "absolute", t.style.outline = "none", t.style.left = s.x + i.data.x + "px", t.style.top = s.y + i.data.y + "px", t.style.width = s.width + "px", t.style.height = s.height + "px", t.style.display = e.calculative.inView != !1 ? e.calculative.cssDisplay || "inline" : "none", !e.calculative.rotate && (e.calculative.rotate = 0), t.style.transform = `rotate(${e.calculative.rotate}deg)`, e.calculative.rotate || (e.calculative.flipX && (t.style.transform = "rotateY(180deg)"), e.calculative.flipY && (t.style.transform = "rotateX(180deg)"), e.calculative.flipX && e.calculative.flipY && (t.style.transform = "rotateZ(180deg)")), t.style.zIndex = e.calculative.zIndex !== void 0 ? e.calculative.zIndex + "" : "5", e.calculative.zIndex > e.calculative.canvas.maxZindex && (e.calculative.canvas.maxZindex = e.calculative.zIndex), e.locked === ht.DisableEdit || e.locked === ht.DisableMove || i.data.locked ? (t.style.userSelect = "initial", t.style.pointerEvents = "initial", e.name === "gif" && (t.style.userSelect = "none", t.style.pointerEvents = "none")) : (t.style.userSelect = "none", t.style.pointerEvents = "none");
}
function Ni(e) {
  return e.every((t) => t.locked);
}
function Ds(e) {
  return e.every((t) => t.disableRotate);
}
function Wo(e, t, i) {
  var s;
  e.type ? (e.calculative.worldAnchors.forEach((o) => {
    vt(o, t, i.center);
  }), on(e), mi(e)) : (e.calculative.rotate ? e.calculative.rotate += t : e.calculative.rotate = t, vt(e.calculative.worldRect.center, t, i.center), e.parentId && (e.calculative.worldRect.x = e.calculative.worldRect.center.x - e.calculative.worldRect.width / 2, e.calculative.worldRect.y = e.calculative.worldRect.center.y - e.calculative.worldRect.height / 2, e.x = (e.calculative.worldRect.x - i.x) / i.width, e.y = (e.calculative.worldRect.y - i.y) / i.height)), (s = e.children) == null || s.forEach((o) => {
    const a = e.calculative.canvas.store.pens[o];
    Wo(a, t, i);
  });
}
function on(e) {
  var o;
  if (!((o = e.calculative.worldAnchors) != null && o.length) || !isFinite(e.x) || !isFinite(e.x) || e.x == null || e.y == null)
    return;
  const t = es(e);
  e.parentId || Object.assign(e, t);
  const { fontSize: i, lineHeight: s } = e.calculative.canvas.store.options;
  e.fontSize ? e.fontSize < 0 && (e.fontSize = 0, e.calculative.fontSize = 0) : (e.fontSize = i >= 0 ? i : 12, e.calculative.fontSize = e.fontSize * e.calculative.canvas.store.data.scale), e.lineHeight || (e.lineHeight = s, e.calculative.lineHeight = e.lineHeight), pt(t), e.calculative.worldRect = t, vs(e, t), qt(e), e.calculative.worldAnchors && (e.anchors = e.calculative.worldAnchors.map((a) => Ge(a, e.calculative.worldRect)));
}
function Bs(e) {
  return e.every((t) => t.disableSize || t.pivot);
}
function Oi(e, t, i) {
  if (!e.frames || !t)
    return 0;
  let s = 0;
  for (let o = 0; o < i; o++)
    e.frames[o] && (s += e.frames[o][t] || 0);
  return s;
}
function Ii(e, t) {
  var s;
  let i = e;
  for (; i && i.parentId; ) {
    const o = i;
    i = t.pens[i.parentId];
    const a = (s = i == null ? void 0 : i.calculative) == null ? void 0 : s.showChild;
    if (a != null && i.children[a] !== o.id)
      return !1;
  }
  return !0;
}
function Kt(e, t = !1) {
  var o, a;
  const { store: i, canvasRect: s } = e.calculative.canvas;
  if (t && ((o = e.children) == null || o.forEach((r) => {
    const l = i.pens[r];
    l && Kt(l, !0);
  })), e.calculative.inView = !0, !Ii(e, i) || e.visible == !1 || e.calculative.visible == !1)
    e.calculative.inView = !1;
  else {
    const { x: r, y: l, width: n, height: h, rotate: c } = e.calculative.worldRect, d = {
      x: r + i.data.x,
      y: l + i.data.y,
      width: n,
      height: h,
      rotate: c
    };
    wt(d), Jt(d, s) || (e.calculative.inView = !1);
  }
  (a = e.calculative.singleton) != null && a.div && Ct(e, e.calculative.singleton.div);
}
function an(e, t, i) {
  if (t.fillWorldTextRect) {
    e.save(), e.fillStyle = "#c3deb7";
    const { x: s, y: o, width: a, height: r } = i.calculative.worldTextRect;
    e.fillRect(s, o, a, r), e.restore();
  }
}
function Ae(e, t) {
  const i = t.calculative.globalAlpha;
  typeof i == "number" && i < 1 && !isNaN(i) && (e.globalAlpha = i);
}
function jo(e, t) {
  const i = rn(e, t) || rt.canvasDraws[t.name];
  i && (e.save(), i(e, t), e.restore());
}
function rn(e, t) {
  const i = t.drawCommand;
  if (!(!i || t.name === "line"))
    return (s, o) => {
      i.forEach((a) => {
        try {
          a.steps = a.steps.flat(1 / 0), a.steps.reduce((r, l) => {
            const n = nn(l, o, r.x, r.y);
            try {
              if (n.c) {
                if (n.c.startsWith("_")) {
                  const c = n.c.split("_")[1];
                  return typeof n.v.value == "number" && (n.v.value *= o.calculative.canvas.store.data.scale), (n.p || s)[c] = n.v.value, { x: r.x, y: r.y };
                }
                let h = [];
                for (const c in n.v)
                  h.push(n.v[c]);
                return (n.p || s)[n.c](...h), { x: n.startX || n.v.x, y: n.startY || n.v.y };
              }
              return { x: r.x, y: r.y };
            } catch {
            }
          }, {});
        } catch {
        }
      }), s.stroke();
    };
}
function nn(e, t, i, s) {
  return {
    visio: cn,
    dxf: ln
  }[t.parseType](e, t, i, s);
}
function ln(e, t, i, s) {
  const { x: o, y: a, width: r, height: l } = t.calculative.worldRect, { originWidth: n, originHeight: h } = t.dxfOrigin;
  switch (e.c) {
    case "beginPath":
      return {
        c: "beginPath",
        v: {}
      };
    case "closePath":
      return {
        c: "closePath",
        v: {}
      };
    case "moveTo":
      return {
        c: "moveTo",
        v: {
          x: e.v.x * (r / n) + o,
          y: e.v.y * (l / h) + a
        }
      };
    case "lineTo":
      return {
        c: "lineTo",
        v: {
          x: e.v.x * (r / n) + o,
          y: e.v.y * (l / h) + a
        }
      };
    case "arc":
      return {
        c: "ellipse",
        v: {
          x: e.v.x * (r / n) + o,
          y: e.v.y * (l / h) + a,
          rx: e.v.xr * (r / n),
          ry: e.v.yr * (l / h),
          rotation: e.v.rotation || 0,
          startAngle: e.v.startAngle,
          endAngle: e.v.endAngle,
          a: e.v.aclockwise ?? !0
        }
      };
    case "ellipse":
      return {
        c: "ellipse",
        v: {
          x: e.v.x * (r / n) + o,
          y: e.v.y * (l / h) + a,
          rx: e.v.xr * (r / n),
          ry: e.v.yr * (l / h),
          rotation: e.v.rotation || 0,
          startAngle: e.v.startAngle,
          endAngle: e.v.endAngle,
          a: e.v.aclockwise ?? !0
        }
      };
    case "_font":
      return {
        c: "_font",
        v: {
          value: e.v.fontSize * t.calculative.canvas.store.data.scale + "px " + (e.v.fontFamily || t.calculative.canvas.store.options.fontFamily)
        }
      };
    case "_fillStyle":
      return {
        c: "_fillStyle",
        v: {
          value: t.color || e.v.value
        }
      };
    default:
      const c = {
        c: e.c,
        v: {
          ...e.v
        }
      };
      return c.v.x !== void 0 && (c.v.x = e.v.x * (r / n) + o), c.v.y !== void 0 && (c.v.y = e.v.y * (l / h) + a), c;
  }
}
function cn(e, t, i, s) {
  const { x: o, y: a, width: r, height: l } = t.calculative.worldRect, { width: n, height: h } = t.origin;
  switch (e.c) {
    case "MoveTo":
      return {
        c: "moveTo",
        v: {
          x: +e.v.X * 100 * (r / n) + o,
          y: +e.v.Y * 100 * (l / h) + a
        }
      };
    case "RelMoveTo":
      return {
        c: "moveTo",
        v: {
          x: +e.v.X * n * (r / n) + o,
          y: +e.v.Y * h * (l / h) + a
        }
      };
    case "LineTo":
      return {
        c: "lineTo",
        v: {
          x: +e.v.X * 100 * (r / n) + o,
          y: +e.v.Y * 100 * (l / h) + a
        }
      };
    case "RelLineTo":
      return {
        c: "lineTo",
        v: {
          x: +e.v.X * n * (r / n) + o,
          y: +e.v.Y * h * (l / h) + a
        }
      };
    case "Ellipse":
      let c = e.v.X, d = e.v.Y, u = Math.abs(e.v.A - e.v.C), f = Math.abs(e.v.B - e.v.D);
      return {
        c: "ellipse",
        v: {
          x: c * 100 * (r / n) + o,
          y: d * 100 * (l / h) + a,
          radiuX: u * 100 * (r / n),
          radiuY: f * 100 * (l / h),
          rotation: 0,
          startAngle: 0,
          endAngle: Math.PI * 2,
          anticlockwise: !0
        }
      };
    case "EllipticalArcTo":
      const g = e.v.X * 100 * (r / n) + o, y = e.v.Y * 100 * (l / h) + a, v = e.v.A * 100 * (r / n) + o, b = e.v.B * 100 * (l / h) + a;
      e.v.C;
      const x = e.v.D * (r / l) * (h / n), p = (g - i) * (b - s) - (y - s) * (v - i) > 0, k = zs(
        i,
        s,
        g,
        y,
        v,
        b,
        x
      );
      return !e.orign && (e.orign = {}), !e.orign.startA && (e.orign.startA = li(
        k.x0,
        k.y0,
        i,
        s
      )), !e.orign.endA && (e.orign.endA = li(
        k.x0,
        k.y0,
        g,
        y
      )), {
        c: "ellipse",
        v: {
          centerX: k.x0,
          centerY: k.y0,
          radiuX: k.a,
          radiuY: k.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: e.orign.startA,
          endAngle: e.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: p
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: g,
        startY: y
      };
    case "RelEllipticalArcTo":
      const C = e.v.X * n * (r / n) + o, R = e.v.Y * h * (l / h) + a, P = e.v.A * n * (r / n) + o, E = e.v.B * h * (l / h) + a;
      e.v.C;
      const H = e.v.D * (r / l) * (h / n), $ = (C - i) * (E - s) - (R - s) * (P - i) > 0, A = zs(
        i,
        s,
        C,
        R,
        P,
        E,
        H
      );
      return !e.orign && (e.orign = {}), !e.orign.startA && (e.orign.startA = li(
        A.x0,
        A.y0,
        i,
        s
      )), !e.orign.endA && (e.orign.endA = li(
        A.x0,
        A.y0,
        C,
        R
      )), {
        c: "ellipse",
        v: {
          centerX: A.x0,
          centerY: A.y0,
          radiuX: A.a,
          radiuY: A.b,
          // rotation:radiansToDegrees(angleDeg),
          rotation: 0,
          startAngle: e.orign.startA,
          endAngle: e.orign.endA,
          // startAngle: 0,
          // endAngle: Math.PI * 2,
          // anticlockwise: startA > 0 && startA>endA
          anticlockwise: $
          // anticlockwise: Math.abs(endA - startA) < Math.PI
        },
        startX: C,
        startY: R
      };
    case "ArcTo":
      let I = e.v.X * 100 * r / n + o, S = e.v.Y * 100 * l / h + a, _ = e.v.A * 100 * (r / l) * (h / n), B = (i + I) / 2, j = (s + S) / 2, X = Math.sqrt((I - i) ** 2 + (S - s) ** 2), z = X ** 2 / (8 * _) + _ / 2, M = -(S - s) / X, D = (I - i) / X, W = B + M * z, N = j + D * z, U = W, q = N, Y = Math.atan2(s - q, i - U), Z = Math.atan2(S - q, I - U);
      return {
        c: "arc",
        v: {
          x: U,
          y: q,
          radius: z,
          startAngle: Y,
          endAngle: Z,
          aclockwise: !0
        }
      };
    default:
      const Q = G(e);
      return Object.entries(Q.v).forEach(([J, m]) => {
        var w, T;
        (w = J.endsWith) != null && w.call(J, "_x") ? typeof m == "number" && (Q.v[J] = m * (r / n) + o) : (T = J.endsWith) != null && T.call(J, "_y") ? typeof m == "number" && (Q.v[J] = m * (l / h) + a) : typeof m == "number" && (Q.v[J] = m);
      }), Q;
  }
}
function ms(e, t) {
  for (const i in t)
    wo.includes(i) && (i == "fontSize" && t[i] < 0 && (t[i] = 0), e[i] = t[i], ["fontSize", "lineWidth"].includes(i) ? (e.calculative[i] = t[i] * e.calculative.canvas.store.data.scale, qt(e)) : e.calculative[i] = t[i]);
  if (e.calculative.canvas.parent.isCombine(e)) {
    const i = e.children;
    i == null || i.forEach((s) => {
      let o = G(t);
      e.calculative.childrenVisible && e.calculative.childrenVisible[s] === !1 && delete o.visible;
      const a = e.calculative.canvas.store.pens[s];
      a && ms(a, o);
    });
  }
}
function zs(e, t, i, s, o, a, r) {
  let l = (e - i) * (e + i) * (s - a) - (i - o) * (i + o) * (t - s) + r * r * (t - s) * (s - a) * (t - a), n = 2 * ((e - i) * (s - a) - (i - o) * (t - s)), h = l / n, c = (e - i) * (i - o) * (e - o) + r * r * ((i - o) * (t - s) * (t + s) - (e - i) * (s - a) * (s + a)), d = 2 * r * r * ((i - o) * (t - s) - (e - i) * (s - a)), u = c / d, f = Math.sqrt(Math.pow(e - h, 2) + Math.pow(r * (t - u), 2)), g = f / r;
  return { x0: h, y0: u, a: f, b: g };
}
function li(e, t, i, s) {
  let o = i - e, a = s - t, r = Math.atan2(a, o);
  return r < 0 && (r += 2 * Math.PI), r;
}
function Hs(e, t, i) {
  let s, o, a = 1 / 0, r = 1 / 0;
  const l = 8;
  for (const n of e.data.pens) {
    if (n.calculative.inView === !1)
      continue;
    ps(n).forEach((c) => {
      if (c === t || c === i)
        return;
      let d = (n.calculative.worldRect.center.x - t.x) * (n.calculative.worldRect.center.x - t.x) + (n.calculative.worldRect.center.y - t.y) * (n.calculative.worldRect.center.y - t.y);
      const u = Math.abs(c.x - t.x);
      u > 0 && u < l && d < a && (s = {
        x: Math.round(c.x) + 0.5,
        y: Math.round(c.y) + 0.5,
        prev: {
          x: Math.round(t.x) + 0.5,
          y: Math.round(t.y) + 0.5
        },
        step: c.x - t.x
      }, a = d);
      const f = Math.abs(c.y - t.y);
      f > 0 && f < l && d < r && (o = {
        x: Math.round(c.x) + 0.5,
        y: Math.round(c.y) + 0.5,
        prev: {
          x: Math.round(t.x) + 0.5,
          y: Math.round(t.y) + 0.5
        },
        step: c.y - t.y
      }, r = d);
    });
  }
  return {
    xDock: s,
    yDock: o
  };
}
function hn(e, t, i, s) {
  let o = [];
  return i.length === 1 ? (o = G(ps(i[0])), o.forEach((a) => {
    a.x += s.x, a.y += s.y;
  })) : (pt(t), o = [t.center, ...Zt(t)]), Vo(e, o, t, !0);
}
function ps(e) {
  if (e.type) {
    if (e.type === ft.Line)
      return e.calculative.worldAnchors;
  } else {
    const t = Zt(e.calculative.worldRect);
    return pt(e.calculative.worldRect), [
      ...e.calculative.worldAnchors,
      ...t,
      e.calculative.worldRect.center
    ];
  }
}
function dn(e, t, i, s) {
  const o = Zt(t);
  return Vo(e, o, t);
}
function Vo(e, t, i, s = !1) {
  let o, a, r = 1 / 0, l = 1 / 0;
  const n = 10, h = mn(i, n);
  return e.data.pens.forEach((c) => {
    const { inView: d, worldRect: u, active: f } = c.calculative;
    if (d === !1 || !s && f || // 如果不计算活动层，则过滤掉活动层
    yn(h, u) || // 水平和垂直方向 无重合
    c.type && e.active.some((y) => Uo(e, y, c)))
      return;
    const g = ps(c);
    if (g)
      for (const y of g)
        for (const v of t) {
          const b = y.x - v.x, x = y.y - v.y, p = Math.abs(b), k = Math.abs(x);
          i.center || (i.center = {
            x: i.x + i.width / 2,
            y: i.y + i.height / 2
          }), p < n && p < r && (o = {
            x: Math.round(y.x) + 0.5,
            y: Math.round(y.y) + 0.5,
            step: b,
            prev: {
              x: Math.round(v.x) + 0.5,
              y: Math.round(v.y) + 0.5
            },
            penId: c.id,
            anchorId: v.id,
            dockAnchorId: y.id
          }, r = p), k < n && k < l && (a = {
            x: Math.round(y.x) + 0.5,
            y: Math.round(y.y) + 0.5,
            step: x,
            prev: {
              x: Math.round(v.x) + 0.5,
              y: Math.round(v.y) + 0.5
            },
            penId: c.id,
            anchorId: v.id,
            dockAnchorId: y.id
          }, l = k);
        }
  }), {
    xDock: o,
    yDock: a
  };
}
function Uo(e, t, i) {
  if (!i.type)
    return !1;
  if (Array.isArray(t == null ? void 0 : t.connectedLines)) {
    for (const s of t == null ? void 0 : t.connectedLines)
      if (s.lineId === i.id)
        return !0;
  }
  if (Array.isArray(t == null ? void 0 : t.children))
    for (const s of t.children) {
      const o = e.pens[s];
      if (Uo(e, o, i))
        return !0;
    }
  return !1;
}
function Gi(e, t) {
  return e.toFixed(12) == t;
}
function Fs(e) {
  if (e.id = nt(), Array.isArray(e.anchors))
    for (const t of e.anchors)
      e.type && (t.id = nt()), t.penId = e.id, t.prev && (e.type && (t.prev.id = nt()), t.prev.penId = e.id), t.next && (e.type && (t.next.id = nt()), t.next.penId = e.id);
}
function un() {
  let e = null, t = /* @__PURE__ */ new Map();
  return (i, s, o, a = !1) => {
    if (t.has(i) && t.get(i) ? e = t.get(i) : t.set(i, e = /* @__PURE__ */ new Map()), typeof o != "function") return () => {
      console.warn("[rewritePenLifeCycle] warn: not a function ");
    };
    let r = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
    e.has(s) && e.get(s) ? r = e.get(s) : (l.set(s, i[s]), e.set(s, r)), a ? r.delete(o) : r.add(o);
    let n = l.get(s), h = (...c) => {
      n == null || n(...c), r.forEach((d) => {
        d(...c);
      });
    };
    i[s] = h;
  };
}
let fn = un();
function gn(e) {
  return !e.name && !e.install ? (console.error("installPenPlugin Error: Validation Failed"), !1) : !0;
}
function oe(e, t) {
  if (!t)
    return;
  if (t.ex == null && wt(t), !t.rotate || // rect.width < 20 ||
  // rect.height < 20 ||
  t.rotate % 360 === 0)
    return e.x > t.x && e.x < t.ex && e.y > t.y && e.y < t.ey;
  t.center || pt(t);
  const i = [
    { x: t.x, y: t.y },
    { x: t.ex, y: t.y },
    { x: t.ex, y: t.ey },
    { x: t.x, y: t.ey }
  ];
  return i.forEach((s) => {
    vt(s, t.rotate, t.pivot || t.center);
  }), vn(e, i);
}
function Se(e, t, i = 0) {
  const { x: s, y: o, ex: a, ey: r } = t;
  return e.x >= s - i && e.x <= a + i && e.y >= o - i && e.y <= r + i;
}
function pt(e) {
  e.center || (e.center = {}), e.center.x = e.x + e.width / 2, e.center.y = e.y + e.height / 2;
}
function wt(e) {
  e.ex = e.x + e.width, e.ey = e.y + e.height;
}
function Ji(e, t) {
  e.pivot || (e.pivot = {}), e.pivot.x = e.x + e.width * t.x, e.pivot.y = e.y + e.height * t.y;
}
function vn(e, t) {
  if (t.length < 3)
    return !1;
  let i = !1, s = t[t.length - 1];
  for (const o of t)
    s.y > e.y != o.y > e.y && o.x + (e.y - o.y) * (s.x - o.x) / (s.y - o.y) > e.x && (i = !i), s = o;
  return i;
}
function jt(e) {
  const t = [];
  e.forEach((s) => {
    if (s.isRuleLine)
      return;
    const o = s.calculative.worldRect;
    if (o) {
      const a = Zt(o);
      t.push(...a);
    }
  });
  const i = Fe(t);
  return pt(i), i;
}
function Zt(e) {
  const t = [
    { x: e.x, y: e.y },
    { x: e.ex, y: e.y },
    { x: e.ex, y: e.ey },
    { x: e.x, y: e.ey }
  ];
  return e.rotate && (e.center || pt(e), t.forEach((i) => {
    vt(i, e.rotate, e.pivot || e.center);
  })), t;
}
function Fe(e) {
  let t = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0;
  return e == null || e.forEach((a) => {
    !isFinite(a.x) || !isFinite(a.y) || (t = Math.min(t, a.x), i = Math.min(i, a.y), s = Math.max(s, a.x), o = Math.max(o, a.y));
  }), { x: t, y: i, ex: s, ey: o, width: s - t, height: o - i };
}
function Jt(e, t, i) {
  return e.rotate && (e = Fe(Zt(e))), i ? e.x > t.x && e.ex < t.ex && e.y > t.y && e.ey < t.ey : !(e.x > t.ex || e.ex < t.x || e.ey < t.y || e.y > t.ey);
}
function yn(e, t) {
  return (t.x > e.ex || t.ex < e.x) && (t.y > e.ey || t.ey < e.y);
}
function mn(e, t) {
  const i = Xt(t), s = {
    x: e.x - i[3],
    y: e.y - i[0],
    width: e.width + i[1] + i[3],
    height: e.height + i[0] + i[2]
  };
  return wt(s), s;
}
function be(e, t, i) {
  e.x += t, e.y += i, e.ex += t, e.ey += i, e.center && (e.center.x += t, e.center.y += i), e.pivot && (e.pivot.x += t, e.pivot.y += i);
}
function pn(e, t) {
  const i = (e.to.y - e.from.y) / (e.to.x - e.from.x), s = (t.to.y - t.from.y) / (t.to.x - t.from.x);
  return Qi(
    {
      k: i,
      point: e.from
    },
    {
      k: s,
      point: t.from
    }
  );
}
function Qi(e, t) {
  if (Gi(e.k, 0))
    return {
      x: t.point.x,
      y: e.point.y
    };
  if (Gi(t.k, 0))
    return {
      x: e.point.x,
      y: t.point.y
    };
  const i = e.point.y - e.k * e.point.x, o = (t.point.y - t.k * t.point.x - i) / (e.k - t.k), a = e.k * o + i;
  return {
    x: o,
    y: a
  };
}
function bn(e, t) {
  const i = pn(
    {
      from: e[0],
      to: e[2]
    },
    {
      from: e[1],
      to: e[3]
    }
  );
  for (const s of e)
    vt(s, -t, i);
  return Fe(e);
}
function Ws(e, t, i, s) {
  let o = e.rotate ? e.rotate % 360 : 0;
  if (o) {
    const a = Zt(e), r = (a[0].y - a[1].y) / (a[0].x - a[1].x), l = (a[1].y - a[2].y) / (a[1].x - a[2].x);
    if (s < 4) {
      if (a[s].x += t, e.ratio)
        if (s === 0 || s === 2) {
          let c = t * Math.tan((90 - (360 - o) - Math.atan(e.width / e.height) / Math.PI * 180) / 180 * Math.PI);
          a[s].y += c;
        } else {
          let c = t * Math.tan((90 - (360 - o) + Math.atan(e.width / e.height) / Math.PI * 180) / 180 * Math.PI);
          a[s].y += c;
        }
      else
        a[s].y += i;
      const h = a[(s + 2) % 4];
      a[(s + 1) % 4] = Qi(
        { k: s % 2 ? l : r, point: a[s] },
        { k: s % 2 ? r : l, point: h }
      ), a[(s + 4 - 1) % 4] = Qi(
        { k: s % 2 ? r : l, point: a[s] },
        { k: s % 2 ? l : r, point: h }
      );
    } else {
      const h = [4, 6].includes(s) ? l : r;
      Gi(h, 0) ? (a[s % 4].x += t, a[(s + 1) % 4].x += t) : (a[s % 4].y += i, a[s % 4].x += i / h, a[(s + 1) % 4].y += i, a[(s + 1) % 4].x += i / h);
    }
    if ((a[0].x - a[1].x) ** 2 + (a[0].y - a[1].y) ** 2 < 25 || (a[1].x - a[2].x) ** 2 + (a[1].y - a[2].y) ** 2 < 25)
      return;
    const n = bn(a, e.rotate);
    pt(n), Object.assign(e, n);
    return;
  }
  switch (s) {
    case 0:
      if (e.width - t < 5 || e.height - i < 5)
        break;
      e.x += t, e.y += i, e.width -= t, e.height -= i;
      break;
    case 1:
      if (e.width + t < 5 || e.height - i < 5)
        break;
      e.ex += t, e.y += i, e.width += t, e.height -= i;
      break;
    case 2:
      if (e.width + t < 5 || e.height + i < 5)
        break;
      e.ex += t, e.ey += i, e.width += t, e.height += i;
      break;
    case 3:
      if (e.width - t < 5 || e.height + i < 5)
        break;
      e.x += t, e.ey += i, e.width -= t, e.height += i;
      break;
    case 4:
      if (e.height - i < 5)
        break;
      e.y += i, e.height -= i;
      break;
    case 5:
      if (e.width + t < 5)
        break;
      e.ex += t, e.width += t;
      break;
    case 6:
      if (e.height + i < 5)
        break;
      e.ey += i, e.height += i;
      break;
    case 7:
      if (e.width - t < 5)
        break;
      e.x += t, e.width -= t;
      break;
  }
}
function Ze(e, t, i, s) {
  e && (e.width *= t, e.height *= t, wi(e, t, i), wt(e), pt(e), s && Ji(e, s));
}
function ae(e, t) {
  const i = {
    x: (e.x - t.x) / t.width,
    y: (e.y - t.y) / t.height,
    width: e.width / t.width,
    height: e.height / t.height
  };
  return wt(i), i;
}
function Ge(e, t) {
  const { x: i, y: s, width: o, height: a } = t, { penId: r, connectTo: l } = e, n = Object.assign({}, e, {
    x: o ? (e.x - i) / o : 0,
    y: a ? (e.y - s) / a : 0
  });
  return e.prev && (n.prev = {
    penId: r,
    connectTo: l,
    x: o ? (e.prev.x - i) / o : 0,
    y: a ? (e.prev.y - s) / a : 0
  }), e.next && (n.next = {
    penId: r,
    connectTo: l,
    x: o ? (e.next.x - i) / o : 0,
    y: a ? (e.next.y - s) / a : 0
  }), n;
}
function wn(e, t) {
  let i = !1;
  for (let s = 0, o = t.length - 1; s < t.length; o = s++) {
    let a = t[s].x, r = t[s].y, l = t[o].x, n = t[o].y;
    r > e.y != n > e.y && e.x < (l - a) * (e.y - r) / (n - r) + a && (i = !i);
  }
  return i;
}
const xn = /^[\t\n\f\r ]*([MLHVZCSQTAmlhvzcsqta])[\t\n\f\r ]*/, js = /^[01]/, yt = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, kn = /^(([\t\n\f\r ]+,?[\t\n\f\r ]*)|(,[\t\n\f\r ]*))/, In = {
  M: [yt, yt],
  L: [yt, yt],
  H: [yt],
  V: [yt],
  Z: [],
  C: [
    yt,
    yt,
    yt,
    yt,
    yt,
    yt
  ],
  S: [yt, yt, yt, yt],
  Q: [yt, yt, yt, yt],
  T: [yt, yt],
  A: [
    yt,
    yt,
    yt,
    js,
    js,
    yt,
    yt
  ]
};
function qo(e) {
  let t = 0;
  const i = [];
  for (; t < e.length; ) {
    const s = e.slice(t).match(xn);
    if (s !== null) {
      const o = s[1];
      t += s[0].length;
      const a = Cn(o, e, t);
      t = a.cursor, i.push(...a.commands);
    } else
      throw new Error("malformed path (first error at " + t + ")");
  }
  return { commands: i };
}
function Zi(e) {
  let t = 1 / 0, i = 1 / 0, s = -1 / 0, o = -1 / 0;
  return Pn(e), e.commands.forEach((a) => {
    a.worldPoints.forEach((r, l) => {
      l % 2 === 0 ? (r < t && (t = r), r > s && (s = r)) : (r < i && (i = r), r > o && (o = r));
    });
  }), --t, --i, {
    x: t,
    y: i,
    ex: s,
    ey: o,
    width: s - t + 1,
    height: o - i + 1
  };
}
function An(e, t, i) {
  i == null && (i = t), e.commands.forEach((s, o) => {
    if (!(s.relative && o))
      switch (s.key) {
        case "A":
        case "a":
          s.values[5] += t, s.values[6] += i;
          break;
        case "V":
        case "v":
          s.values[0] += i;
          break;
        default:
          s.values.forEach((a, r) => {
            s.values[r] = a + (r % 2 === 0 ? t : i);
          });
          break;
      }
  });
}
function Sn(e, t, i) {
  i == null && (i = t), e.commands.forEach((s) => {
    switch (s.key) {
      case "A":
      case "a":
        const o = s.values[0], a = s.values[1], r = Math.PI * s.values[2] / 180, l = Math.cos(r), n = Math.sin(r), h = a * a * i * i * l * l + o * o * i * i * n * n, c = 2 * t * i * l * n * (a * a - o * o), d = o * o * t * t * l * l + a * a * t * t * n * n, u = -(o * o * a * a * t * t * i * i), f = c * c - 4 * h * d, g = Math.sqrt((h - d) * (h - d) + c * c);
        s.values[2] = c !== 0 ? Math.atan((d - h - g) / c) * 180 / Math.PI : h < d ? 0 : 90, s.values[0] = -Math.sqrt(2 * f * u * (h + d + g)) / f, s.values[1] = -Math.sqrt(2 * f * u * (h + d - g)) / f, s.values[5] *= t, s.values[6] *= i, s.values[4] = t * i >= 0 ? s.values[4] : 1 - s.values[4];
        break;
      case "V":
      case "v":
        s.values[0] *= i;
        break;
      default:
        s.values.forEach((y, v) => {
          s.values[v] = y * (v % 2 === 0 ? t : i);
        });
        break;
    }
  });
}
function Tn(e) {
  let t = "";
  return e.commands.forEach((i) => {
    t += i.key + " ", i.values.forEach((s) => {
      t += s + " ";
    });
  }), t;
}
function Cn(e, t, i) {
  const s = In[e.toUpperCase()], o = [];
  for (; i <= t.length; ) {
    const a = { key: e, values: [] };
    for (const r of s) {
      const l = t.slice(i).match(r);
      if (l !== null) {
        a.values.push(+l[0]), i += l[0].length;
        const n = t.slice(i).match(kn);
        n !== null && (i += n[0].length);
      } else {
        if (a.values.length === 0)
          return { cursor: i, commands: o };
        throw new Error("malformed path (first error at " + i + ")");
      }
    }
    if (a.relative = a.key.toUpperCase() !== a.key, o.push(a), s.length === 0)
      return { cursor: i, commands: o };
    e === "m" && (e = "l"), e === "M" && (e = "L");
  }
  throw new Error("malformed path (first error at " + i + ")");
}
function Rn(e, t) {
  const i = [];
  let s = e.relative && t ? {
    x: t.worldPoints[t.worldPoints.length - 2],
    y: t.worldPoints[t.worldPoints.length - 1]
  } : { x: 0, y: 0 };
  for (let o = 0; o < e.values.length - 1; o += 2)
    i.push(s.x + e.values[o]), i.push(s.y + e.values[o + 1]);
  e.worldPoints = i;
}
function Pn(e) {
  let t, i = 0, s = 0;
  e.commands.forEach((o) => {
    switch (o.key) {
      case "Z":
      case "z":
        o.worldPoints = [i, s];
        break;
      case "H":
        o.worldPoints = [
          o.values[0],
          t.worldPoints[t.worldPoints.length - 1]
        ];
        break;
      case "h":
        o.worldPoints = [
          o.values[0] + t.worldPoints[t.worldPoints.length - 2],
          t.worldPoints[t.worldPoints.length - 1]
        ];
        break;
      case "V":
        o.worldPoints = [
          t.worldPoints[t.worldPoints.length - 2],
          o.values[0]
        ];
        break;
      case "v":
        o.worldPoints = [
          t.worldPoints[t.worldPoints.length - 2],
          o.values[0] + t.worldPoints[t.worldPoints.length - 1]
        ];
        break;
      case "A":
        o.worldPoints = [
          t.worldPoints[t.worldPoints.length - 2],
          o.values[0] + t.worldPoints[t.worldPoints.length - 1]
        ];
        break;
      default:
        Rn(o, t);
        break;
    }
    (o.key === "M" || o.key === "m" || o.key === "Z" || o.key === "z") && (i = o.worldPoints[o.worldPoints.length - 2], s = o.worldPoints[o.worldPoints.length - 1]), t = o;
  });
}
function En(e, t) {
  var n;
  const s = e.calculative.canvas.store.data.paths[e.pathId];
  if (!s)
    return new Path2D();
  const o = qo(s);
  e.calculative.svgRect = Zi(o), pt(e.calculative.svgRect), (e.calculative.svgRect.width !== e.calculative.worldRect.width || e.calculative.svgRect.height !== e.calculative.worldRect.height) && (e.calculative.worldRect.width / e.calculative.svgRect.width, e.calculative.worldRect.height / e.calculative.svgRect.height, Sn(
    o,
    e.calculative.worldRect.width / e.calculative.svgRect.width,
    e.calculative.worldRect.height / e.calculative.svgRect.height
  ));
  const a = Zi(o);
  pt(a), An(
    o,
    e.calculative.worldRect.x - a.x,
    e.calculative.worldRect.y - a.y
  );
  const r = Tn(o);
  if (t) {
    (n = t.svgPath) == null || n.call(t, r);
    return;
  }
  return new Path2D(r);
}
function _n(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s + a / 2, o), i.lineTo(s + a, o + r / 2), i.lineTo(s + a / 2, o + r), i.lineTo(s, o + r / 2), i.lineTo(s + a / 2, o), i.closePath(), i instanceof Path2D) return i;
}
function Ln(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s + a / 2, o), i.lineTo(s + a, o + r), i.lineTo(s, o + r), i.lineTo(s + a / 2, o), i.closePath(), i instanceof Path2D) return i;
}
function Mn(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.75,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.25,
      y: 0.5
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function Nn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s + a / 2, o), i.lineTo(s + a, o + r * 2 / 5), i.lineTo(s + a * 4 / 5, o + r), i.lineTo(s + a / 5, o + r), i.lineTo(s, o + r * 2 / 5), i.closePath(), i instanceof Path2D) return i;
}
function On(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.4
    },
    {
      x: 0.8,
      y: 1
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0,
      y: 0.4
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function Dn(e, t) {
  e.onResize || (e.onResize = Bn);
  const i = t || new Path2D(), { width: s, height: o, center: a } = e.calculative.worldRect, r = s > o ? o : s, l = a.x, n = a.y, h = n - r / 2, c = n - r / 4, d = -(c - n) * Math.sin(Math.PI / 180 * 324) + l, u = (c - n) * Math.cos(Math.PI / 180 * 324) + n;
  i.moveTo(d, u);
  for (let f = 0; f < 5; ++f)
    i.lineTo(
      -(h - n) * Math.sin(Math.PI / 180 * 72 * f) + l,
      (h - n) * Math.cos(Math.PI / 180 * 72 * f) + n
    ), i.lineTo(
      (d - l) * Math.cos(Math.PI / 180 * 72 * (f + 1)) - (u - n) * Math.sin(Math.PI / 180 * 72 * (f + 1)) + l,
      (d - l) * Math.sin(Math.PI / 180 * 72 * (f + 1)) + (u - n) * Math.cos(Math.PI / 180 * 72 * (f + 1)) + n
    );
  if (i.closePath(), i instanceof Path2D) return i;
}
function Yo(e) {
  const { width: t, height: i } = e, s = t > i ? i : t, o = [];
  for (let a = 0; a < 5; ++a)
    o.push({
      flag: 1,
      // 默认锚点
      id: String(a),
      penId: e.id,
      x: 0.5 + s / 2 * Math.sin(Math.PI / 180 * 72 * a) / t,
      y: -s / 2 * Math.cos(Math.PI / 180 * 72 * a) / i + 0.5
    });
  e.anchors = o;
}
function Bn(e) {
  const t = e.anchors.filter((i) => i.flag !== 1);
  Yo(e), e.anchors = e.anchors.concat(...t);
}
function zn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s + a / 4, o), i.lineTo(s + a * 3 / 4, o), i.lineTo(s + a, o + r / 2), i.lineTo(s + a * 3 / 4, o + r), i.lineTo(s + a * 1 / 4, o + r), i.lineTo(s, o + r / 2), i.lineTo(s + a / 4, o), i.closePath(), i instanceof Path2D) return i;
}
function Hn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s, o + r / 2), i.lineTo(s + r / 2, o), i.lineTo(s + r / 2, o + r / 3), i.lineTo(s + a, o + r / 3), i.lineTo(s + a, o + r * 2 / 3), i.lineTo(s + r / 2, o + r * 2 / 3), i.lineTo(s + r / 2, o + r * 2 / 3), i.lineTo(s + r / 2, o + r), i.closePath(), i instanceof Path2D) return i;
}
function Fn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s, o + r / 3), i.lineTo(s + (a - r / 2), o + r / 3), i.lineTo(s + (a - r / 2), o), i.lineTo(s + a, o + r / 2), i.lineTo(s + (a - r / 2), o + r), i.lineTo(s + (a - r / 2), o + r * 2 / 3), i.lineTo(s, o + r * 2 / 3), i.closePath(), i instanceof Path2D) return i;
}
function Wn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s, o + r / 2), i.lineTo(s + r / 2, o), i.lineTo(s + r / 2, o + r / 3), i.lineTo(s + (a - r / 2), o + r / 3), i.lineTo(s + (a - r / 2), o), i.lineTo(s + a, o + r / 2), i.lineTo(s + (a - r / 2), o + r), i.lineTo(s + (a - r / 2), o + r * 2 / 3), i.lineTo(s + r / 2, o + r * 2 / 3), i.lineTo(s + r / 2, o + r), i.closePath(), i instanceof Path2D) return i;
}
function jn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ey: l } = e.calculative.worldRect;
  if (i.moveTo(s, o), i.lineTo(s + a, o), i.lineTo(s + a, o + r * 3 / 4), i.lineTo(s + a * 8 / 16, o + r * 3 / 4), i.lineTo(s + a / 4, l), i.lineTo(s + a * 5 / 16, o + r * 3 / 4), i.lineTo(s, o + r * 3 / 4), i.closePath(), i instanceof Path2D) return i;
}
function Vn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s + a / 5, o + r * 13 / 16), i.bezierCurveTo(
    s - a / 15,
    o + r * 13 / 16,
    s - a / 15,
    o + r * 7 / 16,
    s + a / 5,
    o + r * 7 / 16
  ), i.bezierCurveTo(
    s + a / 5,
    o,
    s + a * 4 / 5,
    o,
    s + a * 4 / 5,
    o + r * 7 / 16
  ), i.bezierCurveTo(
    s + a * 16 / 15,
    o + r * 7 / 16,
    s + a * 16 / 15,
    o + r * 13 / 16,
    s + a * 4 / 5,
    o + r * 13 / 16
  ), i.closePath(), i instanceof Path2D) return i;
}
function Un(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 6;
  if (i.moveTo(s, o), i.lineTo(r - n, o), i.lineTo(r, o + n), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i.moveTo(r - n, o), i.lineTo(r - n, o + n), i.lineTo(r, o + n), i.closePath(), i instanceof Path2D) return i;
}
function qn(e, t) {
  const { x: i, y: s, width: o, ex: a, ey: r } = t.calculative.worldRect;
  let l = o * 0.25;
  const n = t.z;
  n > 1 ? l = n : n > 0 && (l = o * n);
  const h = {
    x: i,
    y: s + l
  }, c = {
    x: a - l,
    y: s + l
  }, d = {
    x: a - l,
    y: r
  };
  Di(
    e,
    [h, c, d, {
      x: i,
      y: r
    }],
    t.backgroundFront || t.background,
    t.color
  ), Di(
    e,
    [
      h,
      {
        x: i + l,
        y: s
      },
      { x: a, y: s },
      c
    ],
    t.backgroundUp || t.background,
    t.color
  ), Di(
    e,
    [
      c,
      { x: a, y: s },
      {
        x: a,
        y: r - l
      },
      d
    ],
    t.backgroundRight || t.background,
    t.color
  );
}
function Di(e, t, i = "", s = "") {
  e.save(), i && (e.fillStyle = i), s && (e.strokeStyle = s), e.beginPath();
  for (let o = 0; o < t.length; ++o)
    o ? e.lineTo(t[o].x, t[o].y) : e.moveTo(t[o].x, t[o].y);
  e.closePath(), i && e.fill(), e.stroke(), e.restore();
}
function Yn(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 4, h = s + a / 2;
  if (i.arc(h, o + n, n, 0, Math.PI * 2), i.moveTo(s, o + n * 3), i.lineTo(r, o + n * 3), i.moveTo(h, o + n * 2), i.lineTo(h, o + n * 4), i.moveTo(h, o + n * 4), i.lineTo(s, l), i.moveTo(h, o + n * 4), i.lineTo(r, l), i.closePath(), i instanceof Path2D) return i;
}
function $n(e, t, i) {
  if (t.calculative.worldAnchors || (t.calculative.worldAnchors = []), i)
    t.calculative.activeAnchor && (t.calculative.activeAnchor.next = {
      penId: t.id,
      x: i.x,
      y: i.y
    }, Ci(
      t.calculative.activeAnchor.next,
      t.calculative.activeAnchor
    ) < 5 ? t.calculative.activeAnchor.next = void 0 : (t.calculative.activeAnchor.prev = {
      ...t.calculative.activeAnchor.next
    }, vt(
      t.calculative.activeAnchor.prev,
      180,
      t.calculative.activeAnchor
    )));
  else {
    const s = t.calculative.worldAnchors[0];
    if (!s.next) {
      const a = He(s, e.pens[s.connectTo]);
      Vs(s, a, 50), s.prev = void 0;
    }
    const o = t.calculative.worldAnchors[t.calculative.worldAnchors.length - 1];
    if (o && o !== s && !o.prev) {
      const a = He(o, e.pens[o.connectTo]);
      Vs(o, a, -50), o.next = void 0;
    }
  }
}
function Vs(e, t, i) {
  switch (t) {
    case ct.Up:
      e.prev = {
        penId: e.penId,
        x: e.x,
        y: e.y + i
      }, e.next = {
        penId: e.penId,
        x: e.x,
        y: e.y - i
      };
      break;
    case ct.Right:
      e.prev = {
        penId: e.penId,
        x: e.x - i,
        y: e.y
      }, e.next = {
        penId: e.penId,
        x: e.x + i,
        y: e.y
      };
      break;
    case ct.Bottom:
      e.prev = {
        penId: e.penId,
        x: e.x,
        y: e.y - i
      }, e.next = {
        penId: e.penId,
        x: e.x,
        y: e.y + i
      };
      break;
    case ct.Left:
      e.prev = {
        penId: e.penId,
        x: e.x + i,
        y: e.y
      }, e.next = {
        penId: e.penId,
        x: e.x - i,
        y: e.y
      };
      break;
  }
}
function ts(e, t, i, s) {
  const o = 1 - e, a = o * o * t.x + 2 * o * e * i.x + e * e * s.x, r = o * o * t.y + 2 * o * e * i.y + e * e * s.y;
  return { x: a, y: r, step: e };
}
function $o(e, t, i, s, o) {
  const { x: a, y: r } = t, { x: l, y: n } = o, { x: h, y: c } = i, { x: d, y: u } = s, f = 1 - e, g = a * f * f * f + 3 * h * e * f * f + 3 * d * e * e * f + l * e * e * e, y = r * f * f * f + 3 * c * e * f * f + 3 * u * e * e * f + n * e * e * e;
  return { x: g, y, step: e };
}
function te(e, t, i) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function Xn(e, t, i) {
  let s = e.calculative.worldAnchors[i], o = e.calculative.worldAnchors[i + 1];
  !o && e.close && (o = e.calculative.worldAnchors[0]);
  const a = t.step;
  let r;
  if (s.next && o.prev) {
    const l = s, n = s.next, h = o.prev, c = o, d = te(l, n, a), u = te(n, h, a), f = te(h, c, a), g = te(d, u, a), y = te(u, f, a);
    r = te(g, y, a), g.penId = e.id, r.prev = g, y.penId = e.id, r.next = y, s.next.x = d.x, s.next.y = d.y, o.prev.x = f.x, o.prev.y = f.y;
  } else if (s.next || o.prev) {
    const l = s, n = s.next || o.prev, h = o, c = te(l, n, a), d = te(n, h, a);
    r = t, c.penId = e.id, d.penId = e.id, r.prev = c, r.next = d, s.next = void 0, o.prev = void 0;
  } else
    r = t;
  return r.penId = e.id, r.id = nt(), r.prevNextType = De.Bilateral, r;
}
function Kn(e, t, i) {
  if (t.calculative.worldAnchors || (t.calculative.worldAnchors = []), t.calculative.worldAnchors.length < 2)
    return;
  let s = t.calculative.activeAnchor, o = i || ut(t);
  if (!s || !o)
    return;
  const a = 20, r = e.pens[s.connectTo];
  let l = He(s, r);
  switch (l === ct.None && (o.x > s.x ? l = ct.Right : l = ct.Left), s.next = {
    id: nt(),
    penId: t.id,
    x: s.x,
    y: s.y,
    prevNextType: 2
  }, o.prev = { id: nt(), penId: t.id, x: o.x, y: o.y, prevNextType: 2 }, l) {
    case ct.Up:
      s.next.y -= a, o.prev.y = s.y;
      break;
    case ct.Bottom:
      s.next.y += a, o.prev.y = s.y;
      break;
    case ct.Left:
      s.next.x -= a, o.prev.x = s.x;
      break;
    default:
      s.next.x += a, o.prev.x = s.x;
      break;
  }
}
function Gn(e, t) {
  const i = t || new Path2D();
  if ((e.lineName === "line" || e.lineName === "polyline") && e.calculative.lineSmooth) {
    let o = gs(e);
    if (i.addPath(o), i instanceof Path2D) return i;
  }
  const s = e.calculative.worldAnchors;
  if (s.length > 1) {
    let o;
    s.forEach((a) => {
      o ? Us(i, o, a) : a.start = !0, o = a;
    }), e.close && (e.lineName === "curve" ? Us(i, o, s[0]) : i.closePath());
  }
  if (i instanceof Path2D) return i;
}
function Jn(e, t, i) {
  var a;
  if (t.calculative.worldAnchors || (t.calculative.worldAnchors = []), t.calculative.worldAnchors.length < 2 || ((a = t.anchors) == null ? void 0 : a.length) > 1)
    return;
  const s = xt(t), o = ut(t);
  !s || !o || !o.id || s === o || (s.next = void 0, ys(t), o.prev = void 0, t.calculative.worldAnchors.push(o));
}
function Us(e, t, i) {
  !i || i.isTemp || (t.start && e.moveTo(t.x, t.y), t.next ? i.prev ? e.bezierCurveTo(
    t.next.x,
    t.next.y,
    i.prev.x,
    i.prev.y,
    i.x,
    i.y
  ) : e.quadraticCurveTo(t.next.x, t.next.y, i.x, i.y) : i.prev ? e.quadraticCurveTo(i.prev.x, i.prev.y, i.x, i.y) : e.lineTo(i.x, i.y));
}
function es(e) {
  return is(e), Fe(Xo(e));
}
function Xo(e) {
  const t = [];
  let i;
  return e.calculative.worldAnchors.forEach((s) => {
    t.push(s), i && t.push(...qs(i, s, e)), i = s;
  }), e.close && e.calculative.worldAnchors.length > 1 && t.push(...qs(i, e.calculative.worldAnchors[0], e)), t;
}
function Ai(e) {
  return e != null && e.lineWidth ? e.lineWidth / 2 + 4 : 4;
}
function qs(e, t, i) {
  const s = [];
  if (!t)
    return s;
  let o = 0.02;
  if (e.lineLength && (o = Ai(i) / e.lineLength), e.next)
    if (t.prev)
      for (let a = o; a < 1; a += o)
        s.push($o(a, e, e.next, t.prev, t));
    else
      for (let a = o; a < 1; a += o)
        s.push(ts(a, e, e.next, t));
  else if (t.prev)
    for (let a = o; a < 1; a += o)
      s.push(ts(a, e, t.prev, t));
  else
    s.push({ x: t.x, y: t.y });
  return s.length > 1 && (e.curvePoints = s), s;
}
function Qn(e, t) {
  const i = Ai(t);
  let s = 0, o, a;
  for (const r of t.calculative.worldAnchors) {
    if (o) {
      if (a = Ys(e, o, r, i), a)
        return {
          i: s,
          point: a
        };
      ++s;
    }
    o = r;
  }
  if (t.close && t.calculative.worldAnchors.length > 1 && (a = Ys(e, o, t.calculative.worldAnchors[0], i)))
    return {
      i: s,
      point: a
    };
}
function Ys(e, t, i, s = 4) {
  if (!t.next && !i.prev) {
    const { x: o, y: a } = t, { x: r, y: l } = i, n = Math.min(o, r), h = Math.max(o, r), c = Math.min(a, l), d = Math.max(a, l);
    return e.x >= n - s && e.x <= h + s && e.y >= c - s && e.y <= d + s ? Zn(e, t, i, s) : void 0;
  } else if (t.curvePoints) {
    for (const o of t.curvePoints)
      if (Ee(e, o, s))
        return o;
  }
}
function Zn(e, t, i, s = 4) {
  if (t.x === i.x) {
    if (Math.abs(e.x - t.x) <= s)
      return {
        x: t.x,
        y: e.y
      };
  } else {
    const o = (t.y - i.y) / (t.x - i.x), a = t.y - o * t.x;
    if (Math.abs((o * e.x + a - e.y) / Math.sqrt(o * o + 1)) <= s) {
      const n = (e.x + o * e.y - o * a) / (o * o + 1);
      return {
        x: n,
        y: o * n + a
      };
    }
  }
}
function $s(e, t, i, s) {
  if (!t && !i)
    return Math.sqrt(
      Math.pow(Math.abs(e.x - s.x), 2) + Math.pow(Math.abs(e.y - s.y), 2)
    ) || 0;
  const o = document.createElementNS("http://www.w3.org/2000/svg", "path");
  return t && i ? o.setAttribute(
    "d",
    `M${e.x} ${e.y} C${t.x} ${t.y} ${i.x} ${i.y} ${s.x} ${s.y}`
  ) : t ? o.setAttribute(
    "d",
    `M${e.x} ${e.y} Q${t.x} ${t.y} ${s.x} ${s.y}`
  ) : o.setAttribute(
    "d",
    `M${e.x} ${e.y} Q${i.x} ${i.y} ${s.x} ${s.y}`
  ), o.getTotalLength() || 0;
}
function is(e) {
  if (e.calculative.worldAnchors.length < 2)
    return 0;
  let t = 0, i;
  if (e.calculative.worldAnchors.forEach((s) => {
    i && (i.lineLength = $s(i, i.next, s.prev, s), t += i.lineLength), i = s;
  }), e.close) {
    const s = xt(e);
    i.lineLength = $s(i, i.next, s.prev, s), t += i.lineLength;
  }
  return e.calculative.animatePos && (e.calculative.animatePos = t / e.length * e.calculative.animatePos), e.length = t, t;
}
function Bi(e, t) {
  const i = e.calculative.worldAnchors;
  for (let s = 0; s < i.length - 1; s++) {
    const o = i[s], a = i[s + 1];
    if (!o.next && !a.prev) {
      if (Ko(o, a, t))
        return !0;
    } else if (tl(o, a, t))
      return !0;
  }
  return !1;
}
function Ko(e, t, i) {
  if (Se(e, i) || Se(t, i))
    return !0;
  const s = e.x, o = e.y, a = t.x, r = t.y;
  let l = i.x, n = i.y, h = i.ex, c = i.ey;
  const d = o - r, u = a - s, f = s * r - a * o;
  if (d * l + u * n + f >= 0 && d * h + u * c + f <= 0 || d * l + u * n + f <= 0 && d * h + u * c + f >= 0 || d * l + u * c + f >= 0 && d * h + u * n + f <= 0 || d * l + u * c + f <= 0 && d * h + u * n + f >= 0) {
    if (l > h) {
      const g = l;
      l = h, h = g;
    }
    if (n < c) {
      const g = n;
      n = c, c = g;
    }
    return !(s < l && a < l || s > h && a > h || o > n && r > n || o < c && r < c);
  } else
    return !1;
}
function tl(e, t, i) {
  if (!e.next && !t.prev)
    return Ko(e, t, i);
  if (e.next && t.prev)
    for (let o = 0.02; o < 1; o += 0.02) {
      const a = $o(o, e, e.next, t.prev, t);
      if (Se(a, i))
        return !0;
    }
  else if (e.next || t.prev)
    for (let o = 0.02; o < 1; o += 0.02) {
      const a = ts(o, e, e.next || t.prev, t);
      if (Se(a, i))
        return !0;
    }
  return !1;
}
let _t = 10;
function el(e, t, i) {
  var y;
  if (t.calculative.worldAnchors || (t.calculative.worldAnchors = []), _t = e.options.polylineSpace || 10, t.calculative.worldAnchors.length < 2)
    return;
  let s = xt(t), o = ut(t);
  if (!s || !o)
    return;
  let a;
  if ((y = t.anchors) != null && y.length && s === t.calculative.activeAnchor ? (a = !0, s = o, o = xt(t)) : (!t.anchors || !t.anchors.length) && s !== t.calculative.activeAnchor && (s = t.calculative.activeAnchor), !s || !o)
    return;
  s.next = void 0, o.prev = void 0;
  const r = o.connectTo;
  ys(t);
  const l = [], n = e.pens[s.connectTo], h = e.pens[o.connectTo], c = He(s, n), d = He(o, h);
  let u = Xs(s, c, _t);
  u && (s = u, l.push(u)), u = Xs(o, d, _t);
  const f = o;
  let g;
  if (u && (o = u, f.connectTo && (u.y > f.y && s.y < f.y || u.y < f.y && s.y > f.y))) {
    g = u;
    let v = _t;
    s.x < u.x && (v = -v), Math.abs(s.x - u.x) < v && (v = -v), o = { x: u.x + v, y: u.y, id: nt() };
  }
  switch (c) {
    case ct.Up:
      l.push(...il(s, o, d));
      break;
    case ct.Right:
      l.push(...sl(s, o, d));
      break;
    case ct.Bottom:
      l.push(...ol(s, o, d));
      break;
    case ct.Left:
      l.push(...al(s, o, d));
      break;
    default:
      l.push(...rl(t, s, o));
      break;
  }
  if (l.forEach((v) => {
    v.id = nt(), v.penId = t.id, t.calculative.worldAnchors.push(v);
  }), t.calculative.worldAnchors.push(o), g && t.calculative.worldAnchors.push(g), u && t.calculative.worldAnchors.push(f), a && t.calculative.worldAnchors.reverse(), r) {
    const v = t.calculative.worldAnchors.length - 2;
    t.calculative.worldAnchors[v].isTemp = !1, t.calculative.worldAnchors[1].isTemp = !1;
  }
}
function Xs(e, t, i) {
  const s = { x: e.x, y: e.y, id: nt() };
  switch (t) {
    case ct.Up:
      s.y -= i;
      break;
    case ct.Right:
      s.x += i;
      break;
    case ct.Bottom:
      s.y += i;
      break;
    case ct.Left:
      s.x -= i;
      break;
    default:
      return;
  }
  return s;
}
function il(e, t, i) {
  if (e.x === t.x || e.y === t.y)
    return [];
  const s = [];
  let o, a;
  switch (i) {
    case ct.Up:
      e.y < t.y ? (o = t.x, a = e.y) : (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    case ct.Bottom:
      if (o = t.x, a = e.y, t.y > e.y)
        o = e.x + (t.x - e.x) / 2, s.push({ x: o, y: e.y }, { x: o, y: t.y });
      else {
        const r = (e.y + t.y) / 2;
        s.push({ x: e.x, y: r }, { x: t.x, y: r });
      }
      break;
    case ct.Right:
      o = t.x, a = e.y, t.x < e.x && t.y < e.y && (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    case ct.Left:
      o = t.x, a = e.y, t.x > e.x && t.y < e.y && (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    default:
      if (t.y > e.y - _t)
        o = e.x + (t.x - e.x) / 2, s.push({ x: o, y: e.y }, { x: o, y: t.y });
      else {
        const r = (e.y + t.y + _t) / 2;
        s.push({ x: e.x, y: r }, { x: t.x, y: r });
      }
      break;
  }
  return s;
}
function sl(e, t, i) {
  if (e.x === t.x || e.y === t.y)
    return [];
  const s = [];
  let o, a;
  switch (i) {
    case ct.Up:
      o = e.x, a = t.y, t.x > e.x && t.y > e.y && (o = t.x, a = e.y), s.push({ x: o, y: a });
      break;
    case ct.Bottom:
      o = e.x, a = t.y, t.x > e.x && t.y < e.y && (o = t.x, a = e.y), s.push({ x: o, y: a });
      break;
    case ct.Left:
      if (o = t.x, a = e.y, t.x < e.x)
        a = e.y + (t.y - e.y) / 2, s.push({ x: e.x, y: a }, { x: t.x, y: a });
      else {
        const r = (e.x + t.x) / 2;
        s.push({ x: r, y: a }, { x: r, y: t.y });
      }
      break;
    case ct.Right:
      t.x < e.x ? s.push({ x: e.x, y: t.y }) : s.push({ x: t.x, y: e.y });
      break;
    default:
      if (o = t.x, a = t.y, t.x < e.x + _t)
        s.push({ x: e.x, y: a });
      else {
        const r = (e.x + t.x - _t) / 2;
        s.push({ x: r, y: e.y }, { x: r, y: a });
      }
      break;
  }
  return s;
}
function ol(e, t, i) {
  if (e.x === t.x || e.y === t.y)
    return [];
  const s = [];
  let o, a;
  switch (i) {
    case ct.Up:
      if (o = e.x, a = t.y, t.y < e.y)
        o = e.x + (t.x - e.x) / 2, s.push({ x: o, y: e.y }, { x: o, y: t.y });
      else {
        const r = (e.y + t.y) / 2;
        s.push({ x: o, y: r }, { x: t.x, y: r });
      }
      break;
    case ct.Right:
      o = t.x, a = e.y, t.x < e.x && t.y > e.y && (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    case ct.Bottom:
      e.y > t.y ? (o = t.x, a = e.y) : (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    case ct.Left:
      o = t.x, a = e.y, t.x > e.x && t.y > e.y && (o = e.x, a = t.y), s.push({ x: o, y: a });
      break;
    default:
      if (o = e.x, t.y < e.y + _t)
        o = e.x + (t.x - e.x) / 2, s.push({ x: o, y: e.y }, { x: o, y: t.y });
      else {
        const r = (e.y + t.y - _t) / 2;
        s.push({ x: o, y: r }, { x: t.x, y: r });
      }
      break;
  }
  return s;
}
function al(e, t, i) {
  if (e.x === t.x || e.y === t.y)
    return [];
  const s = [];
  let o, a;
  switch (i) {
    case ct.Up:
      o = e.x, a = t.y, t.x < e.x && t.y > e.y && (o = t.x, a = e.y), s.push({ x: o, y: a });
      break;
    case ct.Bottom:
      o = e.x, a = t.y, t.x < e.x && t.y < e.y && (o = t.x, a = e.y), s.push({ x: o, y: a });
      break;
    case ct.Right:
      if (o = e.x, a = t.y, t.x > e.x)
        o = t.x, a = e.y + (t.y - e.y) / 2, s.push({ x: e.x, y: a }, { x: t.x, y: a });
      else {
        const r = (e.x + t.x) / 2;
        s.push({ x: r, y: e.y }, { x: r, y: t.y });
      }
      break;
    case ct.Left:
      t.x > e.x ? s.push({ x: e.x, y: t.y }) : s.push({ x: t.x, y: e.y });
      break;
    default:
      if (o = e.x, a = t.y, t.x < e.x - _t) {
        const r = (e.x + t.x + _t) / 2;
        s.push({ x: r, y: e.y }, { x: r, y: a });
      } else
        s.push({ x: e.x, y: a });
      break;
  }
  return s;
}
function rl(e, t, i) {
  const s = [];
  e.calculative.drawlineH == null && (e.calculative.drawlineH = Math.abs(i.x - t.x) > Math.abs(i.y - t.y));
  let o = e.calculative.worldAnchors.findIndex(
    (a) => a.id == t.id
  );
  if (o > 1) {
    let a = e.calculative.worldAnchors[o - 1];
    if (a.x === t.x && a.y !== t.y)
      return s.push({ x: i.x, y: t.y }), s;
    if (a.y === t.y && a.x !== t.x)
      return s.push({ x: t.x, y: i.y }), s;
  }
  return e.calculative.worldAnchors.length && (i.isTemp = void 0, e.calculative.drawlineH ? (s.push({ x: i.x, y: t.y }), Math.abs(i.y - t.y) < _t && (i.isTemp = !0)) : (s.push({ x: t.x, y: i.y }), Math.abs(i.x - t.x) < _t && (i.isTemp = !0))), s;
}
function ci(e, t, i = !0) {
  var o, a;
  let s = e.calculative.worldAnchors;
  i || (s = [], e.calculative.worldAnchors.forEach((r) => {
    s.unshift(r);
  }));
  for (let r = 0; r < s.length && s[r].id !== t.id; r++)
    if (s[r].y !== t.y || s[r].x === ((o = s[r + 1]) == null ? void 0 : o.x) && s[r].y !== ((a = s[r + 1]) == null ? void 0 : a.y))
      return !1;
  return !0;
}
function hi(e, t, i = !0) {
  var o, a;
  let s = e.calculative.worldAnchors;
  i || (s = [], e.calculative.worldAnchors.forEach((r) => {
    s.unshift(r);
  }));
  for (let r = 0; r < s.length && s[r].id !== t.id; r++)
    if (s[r].x !== t.x || s[r].y === ((o = s[r + 1]) == null ? void 0 : o.y) && s[r].x !== ((a = s[r + 1]) == null ? void 0 : a.x))
      return !1;
  return !0;
}
function nl(e, t, i) {
  if (!e.calculative.worldAnchors)
    return;
  const s = e.calculative.worldAnchors.findIndex(
    (n) => n.id === t.id
  ), o = xt(e), a = ut(e);
  let r = e.calculative.worldAnchors[s - 1], l = e.calculative.worldAnchors[s + 1];
  if (e.calculative.h == null && (o.connectTo && (ci(e, t, !0) ? e.calculative.h = !0 : hi(e, t, !0) && (e.calculative.h = !1)), e.calculative.h == null && a.connectTo && (ci(e, t, !1) ? e.calculative.h = !0 : hi(e, t, !1) && (e.calculative.h = !1)), e.calculative.h == null && (r ? e.calculative.h = r.y === t.y : l && (e.calculative.h = l.y === t.y))), e.calculative.h) {
    if (t.x = i.x, o.connectTo && ci(e, t, !0)) {
      l && l.y !== t.y && (l.x = t.x);
      return;
    }
    if (a.connectTo && ci(e, t, !1)) {
      r && r.y !== t.y && (r.x = t.x);
      return;
    }
    const n = e.anchors[s];
    let h;
    for (let c = s - 1; c > -1; c--)
      if (r = e.anchors[c], h == null && (h = r.y === n.y), h === !0)
        if (r.y === n.y)
          e.calculative.worldAnchors[c].y = i.y;
        else
          break;
      else if (r.x === n.x)
        e.calculative.worldAnchors[c].x = i.x;
      else
        break;
    h = void 0;
    for (let c = s + 1; c < e.calculative.worldAnchors.length && (l = e.anchors[c], l); c++)
      if (h == null && (h = l.y === n.y), h === !0)
        if (l.y === n.y)
          e.calculative.worldAnchors[c].y = i.y;
        else
          break;
      else if (l.x === n.x)
        e.calculative.worldAnchors[c].x = i.x;
      else
        break;
    t.y = i.y;
  } else {
    if (t.y = i.y, o.connectTo && hi(e, t, !0)) {
      l && l.x !== t.x && (l.y = t.y);
      return;
    }
    if (a.connectTo && hi(e, t, !1)) {
      r && r.x !== t.x && (r.y = t.y);
      return;
    }
    const n = e.anchors[s];
    let h;
    for (let c = s - 1; c > -1; c--)
      if (r = e.anchors[c], h == null && (h = r.x === n.x), h === !0)
        if (r.x === n.x)
          e.calculative.worldAnchors[c].x = i.x;
        else
          break;
      else if (r.y === n.y)
        e.calculative.worldAnchors[c].y = i.y;
      else
        break;
    h = void 0;
    for (let c = s + 1; c < e.calculative.worldAnchors.length && (l = e.anchors[c], l); c++)
      if (h == null && (h = l.x === n.x), h === !0)
        if (l.x === n.x)
          e.calculative.worldAnchors[c].x = i.x;
        else
          break;
      else if (l.y === n.y)
        e.calculative.worldAnchors[c].y = i.y;
      else
        break;
    t.x = i.x;
  }
}
function ss(e, t, i, s) {
  const o = [];
  let a, r, l, n, h, c, d, u, f, g, y, v, b, x;
  f = e[i], g = e[s], l = f.x, n = f.y, d = g.x - l, u = g.y - n, x = d * d + u * u, a = t;
  for (let p = i + 1; p < s; p++)
    y = e[p], d !== 0 || u !== 0 ? (v = ((y.x - l) * d + (y.y - n) * u) / x, v > 1 ? (h = y.x - g.x, c = y.y - g.y) : v > 0 ? (h = y.x - (l + d * v), c = y.y - (n + u * v)) : (h = y.x - l, c = y.y - n)) : (h = y.x - l, c = y.y - n), b = h * h + c * c, b > a && (r = p, a = b);
  return a > t && (r - i > 1 && o.push(...ss(e, t, i, r)), o.push({
    id: e[r].id,
    penId: e[r].penId,
    x: e[r].x,
    y: e[r].y
  }), s - r > 1 && o.push(...ss(e, t, r, s))), o;
}
function ll(e, t = 0.8, i = !1) {
  if (e.length < 3)
    return e;
  let s, o, a, r, l, n, h, c, d, u, f, g, y, v, b;
  const x = (p, k, C, R) => (r = Math.sqrt(p * p + k * k), r > 0 ? (g = p / r, v = k / r) : (g = 1, v = 0), l = Math.sqrt(C * C + R * R), l > 0 ? (y = C / l, b = R / l) : (y = 1, b = 0), Math.acos(g * y + v * b));
  u = [], f = e.length, s = e[0], e[f - 1], u.push({ ...e[0] });
  for (let p = 0; p < f - 1; p++) {
    if (o = e[p], a = e[p + 1], d = Math.abs(x(o.x - s.x, o.y - s.y, a.x - o.x, a.y - o.y)), r)
      if (d < t * 3.14)
        if (i && (r = Math.min(r, l), l = r), n = (g + y) / 2, h = (v + b) / 2, c = Math.sqrt(n * n + h * h), c === 0)
          u.push({ ...o });
        else {
          n /= c, h /= c;
          const k = { ...o };
          k.prevNextType = De.Bilateral, k.prev = {
            penId: k.penId,
            x: o.x - n * r * 0.25,
            y: o.y - h * r * 0.25
          }, k.next = {
            penId: k.penId,
            x: o.x + n * l * 0.25,
            y: o.y + h * l * 0.25
          }, u.push(k);
        }
      else
        u.push({ ...o });
    s = o;
  }
  return u.push({ ...e[e.length - 1] }), u;
}
function Go(e, t) {
  const i = t || new Path2D(), s = e.calculative.worldAnchors;
  let o = e.calculative.canvas.store.data.scale, a = (e.calculative.animateLineWidth || 6) * o, r = (e.animateLineWidth * 2 || 12) * o;
  e.lineAnimateType === Ht.WaterDrop && (r = (e.animateLineWidth * 4 || 24) * o);
  let l = (e.animateInterval || 100) * o, n = e.calculative.lineWidth * (e.calculative.lineSmooth || 0), h = (e.calculative.animateLineWidth / 2 || 3) * o;
  if (e.animateReverse && (r = -r, a = -a), s.length > 1) {
    let c, d = 0;
    for (let u = 0; u < s.length; u++) {
      let f = s[u];
      if (c) {
        let g = cl(c, f), y = {
          x: c.x + (e.calculative.animatePos - d) % l * Math.cos(g * Math.PI / 180),
          y: c.y - (e.calculative.animatePos - d) % l * Math.sin(g * Math.PI / 180)
        };
        e.animateReverse && (y = {
          x: c.x + (e.length - (e.calculative.animatePos + d)) % l * Math.cos(g * Math.PI / 180),
          y: c.y - (e.length - (e.calculative.animatePos + d)) % l * Math.sin(g * Math.PI / 180)
        });
        let v = Math.sqrt(
          (y.x - c.x) ** 2 + (y.y - c.y) ** 2
        ), b = Math.sqrt((f.x - c.x) ** 2 + (f.y - c.y) ** 2);
        for (; v < b; )
          (e.animateReverse && v - r < b || //不允许超出连线绘制
          !e.animateReverse && v > r) && v > n + r && b - v > n && (e.lineAnimateType === Ht.Arrow ? hl(i, y, a, g, h, r) : e.lineAnimateType === Ht.WaterDrop && dl(i, y, e.animateReverse, g, h, r)), y.x += l * Math.cos(g * Math.PI / 180), y.y -= l * Math.sin(g * Math.PI / 180), v = Math.sqrt(
            (y.x - c.x) ** 2 + (y.y - c.y) ** 2
          );
      }
      c = f;
    }
  }
  if (i instanceof Path2D) return i;
}
function cl(e, t) {
  let i = t.x - e.x, s = t.y - e.y, o = Math.atan(s / i) * 180 / Math.PI;
  return t.x >= e.x ? o = -o : o = 180 - o, o;
}
function ne(e, t, i) {
  let s = (180 - i) * Math.PI / 180;
  return {
    x: (e.x - t.x) * Math.cos(s) - (e.y - t.y) * Math.sin(s) + t.x,
    y: (e.x - t.x) * Math.sin(s) + (e.y - t.y) * Math.cos(s) + t.y
  };
}
function hl(e, t, i, s, o, a) {
  let r = ne(
    { x: t.x + i, y: t.y + 0.57 * i },
    { x: t.x, y: t.y },
    s
  ), l = ne(
    { x: t.x + i, y: t.y - 0.57 * i },
    { x: t.x, y: t.y },
    s
  ), n = ne(
    { x: t.x + i, y: t.y + o / 2 },
    { x: t.x, y: t.y },
    s
  ), h = ne(
    { x: t.x + a, y: t.y + o / 2 },
    { x: t.x, y: t.y },
    s
  ), c = ne(
    { x: t.x + i, y: t.y - o / 2 },
    { x: t.x, y: t.y },
    s
  ), d = ne(
    { x: t.x + a, y: t.y - o / 2 },
    { x: t.x, y: t.y },
    s
  );
  e.moveTo(r.x, r.y), e.lineTo(t.x, t.y), e.lineTo(l.x, l.y), e.lineTo(c.x, c.y), e.lineTo(d.x, d.y), e.lineTo(h.x, h.y), e.lineTo(n.x, n.y), e.lineTo(r.x, r.y);
}
function dl(e, t, i, s, o, a) {
  let r = o / 2;
  i && (r = -o / 2);
  let l = ne(
    { x: t.x, y: t.y + r },
    { x: t.x, y: t.y },
    s
  ), n = ne(
    { x: t.x + a, y: t.y },
    { x: t.x, y: t.y },
    s
  ), h = Math.PI / 2;
  i && (h = -Math.PI / 2), e.moveTo(t.x, t.y), e.arc(t.x, t.y, o / 2, -h - s / 180 * Math.PI, h - s / 180 * Math.PI, !1), e.lineTo(n.x, n.y), e.lineTo(l.x, l.y);
}
function ul(e) {
  var i;
  e.onDestroy || (e.onDestroy = fl, e.onMove = di, e.onResize = di, e.onRotate = di, e.onValue = di, e.onMouseMove = vl, e.onBeforeValue = gl, e.onRenderPenRaw = yl), e.calculative.singleton || (e.calculative.singleton = {});
  const t = e.calculative.worldRect;
  if (!e.calculative.singleton.div) {
    const s = document.createElement("div");
    s.style.position = "absolute", s.style.outline = "none", s.style.left = "-9999px", s.style.top = "-9999px", s.style.width = t.width + "px", s.style.height = t.height + "px", document.body.appendChild(s), (i = e.calculative.canvas.externalElements) == null || i.parentElement.appendChild(s), Ct(e, s), e.calculative.singleton.div = s;
    const o = document.createElement("iframe");
    o.style.width = "100%", o.style.height = "100%", o.scrolling = e.scrolling || "no", o.frameBorder = "0", o.style.border = "none", o.src = e.iframe, e.calculative.iframe = e.iframe, s.appendChild(o), Qo(e), o.onload = () => {
      o.setAttribute("document.domain", "");
    };
  }
  return e.calculative.patchFlags && Ct(e, e.calculative.singleton.div), e.onRenderPenRaw(e), new Path2D();
}
function fl(e) {
  Zo(e), e.calculative.singleton && e.calculative.singleton.div && (e.calculative.singleton.div.remove(), delete e.calculative.singleton.div);
}
function di(e) {
  e.calculative.singleton.div && Ct(e, e.calculative.singleton.div);
}
function gl(e, t) {
  if (t.iframe && e.calculative.singleton.div && (e.calculative.singleton.div.children[0].src = t.iframe, e.calculative.iframe = t.iframe), t.operationalRect || t["operationalRect.x"] !== void 0 || t["operationalRect.y"] !== void 0 || t["operationalRect.width"] !== void 0 || t["operationalRect.height"] !== void 0) {
    e.operationalRect || (e.operationalRect = {});
    let i = G(t);
    i.operationalRect || (i.operationalRect = {}), i["operationalRect.x"] !== void 0 && (i.operationalRect.x = i["operationalRect.x"]), i["operationalRect.y"] !== void 0 && (i.operationalRect.y = i["operationalRect.y"]), i["operationalRect.width"] !== void 0 && (i.operationalRect.width = i["operationalRect.width"]), i["operationalRect.height"] !== void 0 && (i.operationalRect.height = i["operationalRect.height"]), Object.assign(e.operationalRect, i.operationalRect), e.calculative.singleton.div && (e.calculative.singleton.div.children.length === 1 ? Qo(e) : (e.calculative.singleton.div.children[1].style.height = e.operationalRect.y * 100 + "%", e.calculative.singleton.div.children[1].style.left = e.operationalRect.x * 100 + "%", e.calculative.singleton.div.children[1].style.width = e.operationalRect.width * 100 + "%", e.calculative.singleton.div.children[2].style.width = (1 - e.operationalRect.x - e.operationalRect.width) * 100 + "%", e.calculative.singleton.div.children[3].style.height = (1 - e.operationalRect.y - e.operationalRect.height) * 100 + "%", e.calculative.singleton.div.children[3].style.left = e.operationalRect.x * 100 + "%", e.calculative.singleton.div.children[3].style.width = e.operationalRect.width * 100 + "%", e.calculative.singleton.div.children[4].style.width = e.operationalRect.x * 100 + "%"));
  }
  if (t.blur !== void 0)
    for (let i = 1; i < 5; i++)
      e.calculative.singleton.div.children[i].style["backdrop-filter"] = `blur(${t.blur || 2}px)`;
  if (t.blurBackground !== void 0)
    for (let i = 1; i < 5; i++)
      e.calculative.singleton.div.children[i].style.backgroundColor = t.blurBackground;
  return t;
}
function vl(e, t) {
  if (!(!e.calculative.canvas.store.data.locked && !e.locked) && Jo(e.operationalRect) && e.calculative.zIndex < 5 && t.x > e.x + e.width * e.operationalRect.x && t.x < e.x + e.width * (e.operationalRect.x + e.operationalRect.width) && t.y > e.y + e.height * e.operationalRect.y && t.y < e.y + e.height * (e.operationalRect.y + e.operationalRect.height) && e.calculative.singleton.div) {
    let i = e.calculative.singleton.div.parentNode.children;
    for (let s = 0; s < 6; s++)
      i[s].style.pointerEvents = "none";
  }
}
function Jo(e) {
  return e ? !e.width || !e.height ? !1 : (e.x === void 0 && (e.x = (1 - e.width) / 2), e.y === void 0 && (e.y = (1 - e.height) / 2), !0) : !1;
}
function Qo(e) {
  if (!Jo(e.operationalRect))
    return;
  const t = e.calculative.singleton.div;
  if (!t)
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = e.operationalRect.x * 100 + "%", i.style.top = "0px", i.style.width = e.operationalRect.width * 100 + "%", i.style.height = e.operationalRect.y * 100 + "%", i.style["backdrop-filter"] = `blur(${e.blur || 2}px)`, i.style.backgroundColor = e.blurBackground, t.appendChild(i);
  const s = document.createElement("div");
  s.style.position = "absolute", s.style.right = "0px", s.style.top = "0px", s.style.width = (1 - e.operationalRect.x - e.operationalRect.width) * 100 + "%", s.style.height = "100%", s.style["backdrop-filter"] = `blur(${e.blur || 2}px)`, s.style.backgroundColor = e.blurBackground, t.appendChild(s);
  const o = document.createElement("div");
  o.style.position = "absolute", o.style.left = e.operationalRect.x * 100 + "%", o.style.bottom = "0px", o.style.width = e.operationalRect.width * 100 + "%", o.style.height = (1 - e.operationalRect.y - e.operationalRect.height) * 100 + "%", o.style["backdrop-filter"] = `blur(${e.blur || 2}px)`, o.style.backgroundColor = e.blurBackground, t.appendChild(o);
  const a = document.createElement("div");
  a.style.position = "absolute", a.style.left = "0px", a.style.top = "0px", a.style.width = e.operationalRect.x * 100 + "%", a.style.height = "100%", a.style["backdrop-filter"] = `blur(${e.blur || 2}px)`, a.style.backgroundColor = e.blurBackground, t.appendChild(a);
  let r = () => {
    Zo(e);
  };
  i.onmouseenter = r, o.onmouseenter = r, s.onmouseenter = r, a.onmouseenter = r, t.onmouseleave = r;
}
function Zo(e) {
  if (!(!e.calculative.canvas.store.data.locked && !e.locked) && e.calculative.zIndex < 5) {
    let t = e.calculative.singleton.div.parentNode.children;
    for (let i = 1; i < 6; i++)
      t[i].style.pointerEvents = "initial";
  }
}
function yl(e) {
  if (e.thumbImg && !e.calculative.img) {
    const t = new Image();
    t.crossOrigin = e.crossOrigin === "undefined" ? void 0 : e.crossOrigin || "anonymous", e.calculative.canvas.store.options.cdn && !(e.thumbImg.startsWith("http") || e.thumbImg.startsWith("//") || e.thumbImg.startsWith("data:image")) ? t.src = e.calculative.canvas.store.options.cdn + e.thumbImg : t.src = e.thumbImg, t.onerror = (i) => {
      t.remove(), e.calculative.img = void 0;
    }, e.calculative.img = t;
  }
}
const Lt = {}, pi = ['<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M473.088 125.44L256 256H52.224C23.552 256 0 279.552 0 308.224V716.8c0 28.16 23.04 51.2 51.2 51.2h204.8l217.088 130.56c16.896 10.24 38.912-2.048 38.912-22.016V147.456c0-19.968-21.504-32.256-38.912-22.016zM699.904 320.512c-20.992-18.944-53.248-17.408-72.192 3.584-18.944 20.992-17.408 53.248 3.584 72.192 0.512 0.512 58.368 54.784 58.368 121.344 0 37.888-19.456 74.752-58.368 110.08-20.992 18.944-22.528 51.2-3.584 72.192 10.24 11.264 24.064 16.896 37.888 16.896 12.288 0 24.576-4.608 34.304-13.312 61.44-55.296 92.16-117.76 92.16-185.856 0-112.64-88.576-193.536-92.16-197.12z" fill="" p-id="2434"></path><path d="M853.504 166.4c-20.992-18.944-53.248-16.896-72.192 4.096-18.944 20.992-16.896 53.248 4.096 72.192 1.536 1.024 135.68 122.88 135.68 280.576 0 90.624-45.568 177.152-135.68 257.536-20.992 18.944-23.04 51.2-4.096 72.192 10.24 11.264 24.064 16.896 38.4 16.896 12.288 0 24.576-4.096 34.304-12.8 112.64-100.864 169.984-212.992 169.984-333.824-1.024-202.752-163.84-350.208-170.496-356.864z"></path></svg>', '<svg viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" ><path d="M256 768H51.2c-28.16 0-51.2-23.04-51.2-51.2V308.224C0 279.552 23.552 256 52.224 256H256v512zM512 147.456v728.576c0 19.968-21.504 32.256-38.912 22.016L256 768V256l217.088-130.56c17.408-10.24 38.912 2.048 38.912 22.016zM623.104 656.896c-19.968-19.968-19.968-52.224 0-72.192l217.088-217.088c19.968-19.968 52.224-19.968 72.192 0 19.968 19.968 19.968 52.224 0 72.192l-217.088 217.088c-19.456 19.968-52.224 19.968-72.192 0z" fill="" p-id="2582"></path><path d="M623.104 367.104c19.968-19.968 52.224-19.968 72.192 0l217.088 217.088c19.968 19.968 19.968 52.224 0 72.192-19.968 19.968-52.224 19.968-72.192 0l-217.088-217.088c-19.968-19.456-19.968-52.224 0-72.192z"></path></svg>'];
function ml(e) {
  var t;
  if (e.onDestroy || (e.onDestroy = pl, e.onMove = zi, e.onResize = zi, e.onRotate = zi, e.onClick = Ks, e.onValue = wl, e.onChangeId = bl), Lt[e.id])
    e.video && e.calculative.media && e.video !== e.calculative.video ? (console.warn("video 更改, 此处是否执行？"), e.calculative.media.src = e.video, e.autoPlay && (e.calculative.media.muted = !0, e.calculative.media.autoplay = !0), e.calculative.media.loop = e.playLoop, e.calculative.video = e.video) : e.audio && e.calculative.media && e.audio !== e.calculative.audio && (e.calculative.media.src = e.audio, e.autoPlay && (e.calculative.media.muted = !0, e.calculative.media.autoplay = !0), e.calculative.media.loop = e.playLoop, e.calculative.audio = e.audio);
  else {
    const i = document.createElement("div"), s = document.createElement("div");
    s.style.position = "absolute", s.style.outline = "none", s.style.left = "0", s.style.bottom = "0", s.style.width = "0", s.style.height = "2px", s.style.background = "#52c41a", s.style.zIndex = "1", e.hideProgress && (s.style.display = "none");
    const o = document.createElement("div");
    o.innerHTML = pi[1], o.style.position = "absolute", o.style.right = "0", o.style.bottom = "0", o.style.width = "20px", o.style.height = "20px", o.style.fill = "hsla(0, 0%, 100%, .8)", o.style.zIndex = "1", o.style.display = "none", i.appendChild(s), i.appendChild(o), o.onclick = (r) => {
      r.stopPropagation(), e.calculative.media.muted ? (o.innerHTML = pi[0], e.calculative.media.muted = !1) : (o.innerHTML = pi[1], e.calculative.media.muted = !0);
    }, e.calculative.singleton || (e.calculative.singleton = {}), e.calculative.singleton.muted = o, i.onmouseenter = (r) => {
      o.style.display = "block";
    }, i.onmouseleave = (r) => {
      o.style.display = "none";
    }, i.onclick = (r) => {
      r.stopPropagation(), Ks(e);
    };
    let a;
    e.video ? (a = document.createElement("video"), a.src = e.video) : e.audio && (a = document.createElement("audio"), a.src = e.audio), a.loop = e.playLoop, a.ontimeupdate = () => {
      ta(s, a, e.calculative.worldRect.width);
    }, a.onended = () => {
      e.calculative.onended && e.calculative.onended(e);
    }, e.calculative.media = a, a.style.position = "absolute", a.style.outline = "none", a.style.left = "0", a.style.top = "0", a.style.width = "100%", a.style.height = "100%", i.appendChild(a), Lt[e.id] = i, (t = e.calculative.canvas.externalElements) == null || t.parentElement.appendChild(i), Ct(e, i), e.autoPlay && (a.autoplay = !0, a.muted = !0);
  }
  return e.calculative.patchFlags && Ct(e, Lt[e.id]), new Path2D();
}
function pl(e) {
  Lt[e.id].onclick = null, Lt[e.id].remove(), Lt[e.id] = void 0;
}
function zi(e) {
  Ct(e, Lt[e.id]);
  const t = Lt[e.id].children[0], i = Lt[e.id].children[1];
  ta(
    t,
    i,
    e.calculative.worldRect.width
  );
}
function Ks(e) {
  e.calculative.media && (e.calculative.media.muted = !1, e.calculative.singleton.muted.innerHTML = pi[0], e.calculative.media.paused ? e.calculative.media.play() : e.calculative.media.pause());
}
function ta(e, t, i) {
  e.style.width = t.currentTime / t.duration * i + "px";
}
function bl(e, t, i) {
  Lt[t] && (Lt[i] = Lt[t], delete Lt[t]);
}
function wl(e) {
  const t = Lt[e.id];
  if (!t)
    return;
  Ct(e, t);
  const i = e.calculative.media.getAttribute("src");
  e.video ? i !== e.video && (e.calculative.media.src = e.video) : e.audio && i !== e.audio && (e.calculative.media.src = e.audio), e.autoPlay && (e.calculative.media.muted = !0, e.calculative.media.autoplay = !0), e.calculative.media.loop = e.playLoop;
}
function Yt() {
  try {
    const e = new OffscreenCanvas(0, 0), t = e.getContext("2d");
    return t && t.arc ? e : document.createElement("canvas");
  } catch {
    return document.createElement("canvas");
  }
}
class Je {
  // 本次 tooltip 在哪个画笔上
  constructor(t, i) {
    O(this, "box");
    O(this, "text");
    O(this, "arrowUp");
    O(this, "arrowDown");
    O(this, "x");
    O(this, "y");
    O(this, "currentPen");
    this.parentElement = t, this.store = i, this.box = document.createElement("div"), this.text = document.createElement("div"), this.arrowUp = document.createElement("div"), this.arrowDown = document.createElement("div"), this.box.className = "meta2d-tooltip", this.text.className = "text", this.arrowUp.className = "arrow", this.arrowDown.className = "arrow down", this.box.appendChild(this.text), this.box.appendChild(this.arrowUp), this.box.appendChild(this.arrowDown), t.appendChild(this.box), this.box.onmouseleave = () => {
      this.hide(), this.store.lastHover = void 0;
    };
    let s;
    for (let o = 0; o < document.styleSheets.length; o++)
      document.styleSheets[o].title === "le5le.com/tooltip" && (s = document.styleSheets[o]);
    if (!s) {
      let o = document.createElement("style");
      o.type = "text/css", o.title = "le5le.com/tooltip", document.head.appendChild(o), o = document.createElement("style"), o.type = "text/css", document.head.appendChild(o), s = o.sheet, s.insertRule(
        ".meta2d-tooltip{position:absolute;padding:8px 0;z-index:10;left: -9999px;top: -9999px;}"
      ), s.insertRule(
        ".meta2d-tooltip .text{max-width:320px;min-height:30px;max-height:400px;outline:none;padding:8px 16px;border-radius:4px;background:#777777;color:#ffffff;line-height:1.8;overflow-y:auto;}"
      ), s.insertRule(
        ".meta2d-tooltip .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-5px;left:50%;transform:translateX(-50%)}"
      ), s.insertRule(
        ".meta2d-tooltip .arrow.down{top:initial;bottom: -1px;}"
      );
    }
  }
  /**
   * 通过 pen 的 titleFn titleFnJs title 来获取 title
   * @returns 此次应该展示的 title
   */
  static getTitle(t) {
    if (t.titleFnJs && !t.titleFn)
      try {
        t.titleFn = new Function("pen", t.titleFnJs);
      } catch (i) {
        console.log("titleFnJs", i);
      }
    return t.titleFn ? t.titleFn(t) : String(t.title);
  }
  /**
   * 更改 tooltip dom 的文本
   * @returns 返回设置前的 rect
   */
  setText(t) {
    const i = this.box.getBoundingClientRect();
    let s = globalThis.marked;
    const o = Je.getTitle(t);
    if (s) {
      this.text.innerHTML = s(o);
      const a = this.text.getElementsByTagName("A");
      for (let r = 0; r < a.length; ++r)
        a[r].setAttribute("target", "_blank");
    } else
      this.text.innerHTML = o;
    return i;
  }
  /**
   * 更新文字
   */
  updateText(t) {
    var o;
    if (((o = this.currentPen) == null ? void 0 : o.id) !== t.id || Je.titleEmpty(t))
      return;
    const i = this.setText(t), s = this.box.getBoundingClientRect();
    this.changePositionByText(i, s);
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByText(t, i) {
    this.x -= (i.width - t.width) / 2, this.y -= i.height - t.height, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  static titleEmpty(t) {
    return !t.title && !t.titleFn && !t.titleFnJs;
  }
  show(t, i) {
    if (this.currentPen = t, Je.titleEmpty(t)) {
      let l = Nt(t, !0);
      l && this.show(l, i);
      return;
    }
    this.setText(t);
    const s = this.box.getBoundingClientRect(), o = t.calculative.worldRect;
    let a = t.calculative.canvas.store.data.x + i.x - s.width / 2, r = t.calculative.canvas.store.data.y + i.y - s.height;
    t.type || (a = t.calculative.canvas.store.data.x + o.x - (s.width - o.width) / 2, r = t.calculative.canvas.store.data.y + o.ey - s.height - o.height), r > 0 ? (this.arrowUp.style.borderBottomColor = "transparent", this.arrowDown.style.borderTopColor = "#777777") : (r += s.height + o.height + 5, this.arrowUp.style.borderBottomColor = "#777777", this.arrowDown.style.borderTopColor = "transparent"), this.x = a, this.y = r, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  hide() {
    this.currentPen = null, this.x = -9999, this.box.style.left = "-9999px";
  }
  translate(t, i) {
    this.x < -1e3 || (this.x += t, this.y += i, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px");
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
class ea {
  //页面模式
  constructor(t) {
    O(this, "h");
    O(this, "v");
    O(this, "isDownH");
    O(this, "isDownV");
    O(this, "x");
    O(this, "y");
    O(this, "hSize");
    O(this, "vSize");
    O(this, "scrollX");
    O(this, "scrollY");
    O(this, "lastScrollX");
    O(this, "lastScrollY");
    O(this, "rect");
    O(this, "isShow");
    O(this, "pageMode");
    O(this, "onMouseDownH", (t) => {
      t.preventDefault(), t.stopPropagation(), this.isDownH = t.x, this.x = this.parent.store.data.x || 0, this.lastScrollX = this.scrollX;
    });
    O(this, "onMouseDownV", (t) => {
      t.preventDefault(), t.stopPropagation(), this.isDownV = t.y, this.y = this.parent.store.data.y || 0, this.lastScrollY = this.scrollY;
    });
    O(this, "onMouseMove", (t) => {
      if (this.isDownH) {
        const i = t.x - this.isDownH;
        this.scrollX = this.lastScrollX + i, this.h.style.left = `${this.scrollX}px`, this.parent.store.data.x = this.x - i * this.rect.width / this.parent.parentElement.clientWidth;
      }
      if (this.isDownV) {
        const i = t.y - this.isDownV;
        if (this.pageMode && this.canMouseMove(i))
          return;
        this.scrollY = this.lastScrollY + i, this.v.style.top = `${this.scrollY}px`, this.parent.store.data.y = this.y - i * this.rect.height / this.parent.parentElement.clientHeight;
      }
      (this.isDownH || this.isDownV) && (this.parent.onMovePens(), this.parent.canvasTemplate.init(), this.parent.canvasImage.init(), this.parent.canvasImageBottom.init(), this.parent.render());
    });
    O(this, "onMouseUp", (t) => {
      !this.isDownH && !this.isDownV || (this.isDownH = void 0, this.isDownV = void 0, this.scrollX < 20 ? (this.scrollX = 20, this.h.style.left = `${this.scrollX}px`) : this.scrollX > this.parent.parentElement.clientWidth - this.hSize - 20 && (this.scrollX = this.parent.parentElement.clientWidth - this.hSize - 20, this.h.style.left = `${this.scrollX}px`), this.scrollY < 20 ? (this.scrollY = 20, this.v.style.top = `${this.scrollY}px`) : this.scrollY > this.parent.parentElement.clientHeight - this.vSize - 20 && (this.scrollY = this.parent.parentElement.clientHeight - this.vSize - 20, this.v.style.top = `${this.scrollY}px`), this.resize());
    });
    this.parent = t, this.h = document.createElement("div"), this.v = document.createElement("div"), this.parent.externalElements.appendChild(this.h), this.parent.externalElements.appendChild(this.v), this.h.className = "meta2d-scroll h", this.h.onmousedown = this.onMouseDownH, this.v.className = "meta2d-scroll v", this.v.onmousedown = this.onMouseDownV, document.addEventListener("mousemove", this.onMouseMove), document.addEventListener("mouseup", this.onMouseUp);
    let i;
    for (let s = 0; s < document.styleSheets.length; s++)
      document.styleSheets[s].title === "le5le/scroll" && (i = document.styleSheets[s]);
    if (!i) {
      let s = document.createElement("style");
      s.type = "text/css", s.title = "le5le.com/scroll", document.head.appendChild(s), s = document.createElement("style"), s.type = "text/css", document.head.appendChild(s), i = s.sheet, i.insertRule(
        ".meta2d-scroll{position:absolute;width:8px;height:200px;background:#dddddd;border-radius:10px;z-index:20;cursor:default;}"
      ), i.insertRule(
        ".meta2d-scroll:hover{background:#cccccc;cursor:pointer}"
      ), i.insertRule(".meta2d-scroll.v{right:0;top:calc(50% - 100px);}"), i.insertRule(
        ".meta2d-scroll.h{bottom:2px;left:calc(50% - 100px);width:200px;height:8px;}"
      );
    }
    this.init();
  }
  init() {
    this.isShow = !0, this.resize(), this.initPos();
  }
  canMouseMove(t) {
    const i = this.parent.parent.getRect();
    return t < 0 && i.y + this.parent.store.data.y >= 0 || t > 0 && i.ey - this.parent.height + this.parent.store.data.y <= 0;
  }
  changeMode() {
    this.pageMode = !0, this.h.style.display = "none", this.parent.parent.getRect().height < this.parent.height && (this.v.style.display = "none");
  }
  initPos() {
    this.scrollX = (this.parent.parentElement.clientWidth - this.hSize) / 2, this.scrollY = (this.parent.parentElement.clientHeight - this.vSize) / 2, this.h.style.left = `${this.scrollX}px`, this.v.style.top = `${this.scrollY}px`;
  }
  resize() {
    this.rect = jt(this.parent.store.data.pens), this.rect.width < 1400 && (this.rect.width = 1400), this.rect.height < 900 && (this.rect.height = 900), this.parent.store.data.x > 0 ? this.rect.width += this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x) : this.rect.width -= this.parent.store.data.x + (this.rect.x > 0 ? 0 : this.rect.x), this.parent.store.data.y > 0 ? this.rect.height += this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y) : this.rect.height -= this.parent.store.data.y + (this.rect.y > 0 ? 0 : this.rect.y), this.rect.width < 1400 && (this.rect.width = 1400), this.rect.height < 900 && (this.rect.height = 900), this.hSize = 1e3 * this.parent.parentElement.clientWidth / this.rect.width / 3, this.vSize = 1e3 * this.parent.parentElement.clientHeight / this.rect.height / 3, this.h.style.width = this.hSize + "px", this.v.style.height = this.vSize + "px";
  }
  show() {
    this.isShow = !0, this.h.style.display = "block", this.v.style.display = "block", document.addEventListener("mousemove", this.onMouseMove), document.addEventListener("mouseup", this.onMouseUp);
  }
  hide() {
    this.isShow = !1, this.h.style.display = "none", this.v.style.display = "none", this.destroy();
  }
  translate(t, i) {
    t && (this.scrollX -= t * this.parent.parentElement.clientWidth / this.rect.width, this.h.style.left = `${this.scrollX}px`), i && (this.scrollY -= i * this.parent.parentElement.clientHeight / this.rect.height, this.v.style.top = `${this.scrollY}px`);
  }
  wheel(t) {
    let i = 10;
    t && (i = -10), !(this.pageMode && this.canMouseMove(i)) && (this.scrollY += i, this.v.style.top = `${this.scrollY}px`, this.parent.store.data.y -= i * this.rect.height / this.parent.parentElement.clientHeight, this.parent.onMovePens(), this.parent.canvasTemplate.init(), this.parent.canvasImage.init(), this.parent.canvasImageBottom.init(), this.parent.render());
  }
  destroy() {
    document.removeEventListener("mousemove", this.onMouseMove), document.removeEventListener("mouseup", this.onMouseUp);
  }
}
class Gs {
  constructor(t, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    /**
     * 非图片的绘制
     * isBottom true 指背景颜色，背景网格
     * isBottom false 指 标尺
     */
    O(this, "otherOffsreen", Yt());
    // 非图片的
    O(this, "offscreen", Yt());
    O(this, "animateOffsScreen", Yt());
    O(this, "fitOffscreen", Yt());
    O(this, "fitFlag", !1);
    //开启自定义填充
    O(this, "currentFit");
    O(this, "activeFit");
    this.parentElement = t, this.store = i, this.isBottom = s, t.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(t, i) {
    this.canvas.style.width = t + "px", this.canvas.style.height = i + "px", t = t * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = t, this.canvas.height = i, this.otherOffsreen.width = t, this.otherOffsreen.height = i, this.offscreen.width = t, this.offscreen.height = i, this.animateOffsScreen.width = t, this.animateOffsScreen.height = i, this.fitOffscreen.width = t, this.fitOffscreen.height = i, this.otherOffsreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.otherOffsreen.getContext("2d").textBaseline = "middle", this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.animateOffsScreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.animateOffsScreen.getContext("2d").textBaseline = "middle", this.fitOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.fitOffscreen.getContext("2d").textBaseline = "middle", this.init();
  }
  init() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
    for (const t of this.store.data.pens)
      this.hasImage(t) && (t.calculative.imageDrawed = !1);
    this.isBottom ? this.store.patchFlagsBackground = !0 : this.store.patchFlagsTop = !0;
  }
  clear() {
    this.otherOffsreen.getContext("2d").clearRect(0, 0, this.otherOffsreen.width, this.otherOffsreen.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.animateOffsScreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.fitOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height);
  }
  hasImage(t) {
    return t.calculative.hasImage = t.calculative && t.calculative.inView && // !pen.isBottom == !this.isBottom && // undefined == false 结果 false
    (this.isBottom && t.canvasLayer === dt.CanvasImageBottom || !this.isBottom && t.canvasLayer === dt.CanvasImage) && t.image && t.calculative.img && t.name !== "gif", t.calculative.hasImage;
  }
  render() {
    var r;
    let t = !1, i = !1;
    for (const l of this.store.data.pens)
      this.hasImage(l) && (this.store.animates.has(l) ? i = !0 : l.calculative.imageDrawed || (t = !0), l.parentId && this.store.animates.has(Nt(l, !0)) && (i = !0));
    const s = this.store.patchFlagsBackground, o = this.store.patchFlagsTop;
    if (o && !this.isBottom) {
      const l = this.otherOffsreen.getContext("2d");
      l.clearRect(0, 0, this.canvas.width, this.canvas.height), this.renderRule(l);
    }
    if (this.store.patchFlagsLast && this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), t) {
      const l = this.offscreen.getContext("2d");
      l.save(), l.clearRect(0, 0, this.canvas.width, this.canvas.height), l.translate(this.store.data.x, this.store.data.y);
      for (const n of this.store.data.pens)
        !n.calculative.hasImage || this.store.animates.has(n) || this.store.animates.has(Nt(n, !0)) || n.canvasLayer !== dt.CanvasTemplate && (n.name === "combine" && !n.draw || (n.calculative.imageDrawed = !0, l.save(), Ie(l, n), n.calculative.rotate && Qt(l, n), Ae(l, n), Be(l, n), l.restore()));
      l.restore();
    }
    if (i) {
      const l = this.animateOffsScreen.getContext("2d");
      l.save(), l.clearRect(0, 0, this.canvas.width, this.canvas.height), l.translate(this.store.data.x, this.store.data.y);
      for (const n of this.store.animates)
        n.calculative.hasImage && n.canvasLayer !== dt.CanvasTemplate && (n.calculative.imageDrawed = !0, l.save(), Ie(l, n), n.calculative.rotate && Qt(l, n), Ae(l, n), Be(l, n), l.restore());
      for (const n of this.store.data.pens)
        !n.calculative.hasImage || !n.parentId || n.canvasLayer !== dt.CanvasTemplate && this.store.animates.has(Nt(n, !0)) && (n.calculative.imageDrawed = !0, l.save(), Ie(l, n), n.calculative.rotate && Qt(l, n), Ae(l, n), Be(l, n), l.restore());
      l.restore();
    }
    if (!this.isBottom && !this.store.data.locked && this.fitFlag) {
      const l = (this.store.data.width || this.store.options.width) * this.store.data.scale, n = (this.store.data.height || this.store.options.height) * this.store.data.scale, h = this.store.data.origin.x + this.store.data.x || this.store.options.x || 0, c = this.store.data.origin.y + this.store.data.y || this.store.options.y || 0, d = this.fitOffscreen.getContext("2d");
      d.save(), d.clearRect(0, 0, this.canvas.width, this.canvas.height), d.fillStyle = "#ffffff66", d.strokeStyle = this.store.options.activeColor, (r = this.store.data.fits) == null || r.forEach((u, f) => {
        d.fillRect(
          h + l * u.x,
          c + n * u.y,
          l * u.width,
          n * u.height
        ), u.active && d.strokeRect(
          h + l * u.x,
          c + n * u.y,
          l * u.width,
          n * u.height
        );
      }), d.restore();
    }
    if (t || i || s && this.isBottom || // this.isBottom ||
    o && !this.isBottom) {
      const l = this.canvas.getContext("2d");
      l.clearRect(0, 0, this.canvas.width, this.canvas.height), this.isBottom && (this.store.patchFlagsBackground = !1), l.drawImage(
        this.offscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), l.drawImage(
        this.animateOffsScreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.isBottom || (l.drawImage(
        this.otherOffsreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.store.patchFlagsTop = !1, !this.store.data.locked && this.fitFlag && l.drawImage(
        this.fitOffscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ));
    }
  }
  // renderGrid(
  //   ctx: CanvasRenderingContext2D | OffscreenCanvasRenderingContext2D
  // ) {
  //   const { data, options } = this.store;
  //   const { grid, gridRotate, gridColor, gridSize, scale } = data;
  //   if (!(grid ?? options.grid)) {
  //     // grid false 时不绘制, undefined 时看 options.grid
  //     return;
  //   }
  //   ctx.save();
  //   const { width, height } = this.canvas;
  //   if (gridRotate) {
  //     ctx.translate(width / 2, height / 2);
  //     ctx.rotate((gridRotate * Math.PI) / 180);
  //     ctx.translate(-width / 2, -height / 2);
  //   }
  //   ctx.lineWidth = 1;
  //   ctx.strokeStyle = gridColor || options.gridColor;
  //   ctx.beginPath();
  //   const size = (gridSize || options.gridSize) * scale;
  //   const longSide = Math.max(width, height);
  //   const count = Math.ceil(longSide / size);
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(i, -longSide);
  //     ctx.lineTo(i, longSide * 2);
  //   }
  //   for (let i = -size * count; i < longSide * 2; i += size) {
  //     ctx.moveTo(-longSide, i);
  //     ctx.lineTo(longSide * 2, i);
  //   }
  //   ctx.stroke();
  //   ctx.restore();
  // }
  renderRule(t) {
    var p, k, C, R, P, E, H, $;
    const { data: i, options: s } = this.store, { rule: o, ruleColor: a, scale: r, origin: l } = i;
    if (!(o ?? s.rule))
      return;
    const n = r * 10;
    t.save();
    const h = a || s.ruleColor;
    t.strokeStyle = xi(h, 0.7);
    const c = l.x + i.x, d = l.y + i.y, { width: u, height: f } = this.canvas;
    let g = ((p = s.ruleOptions) == null ? void 0 : p.height) || 20;
    (k = s.ruleOptions) != null && k.background && (t.beginPath(), t.fillStyle = (C = s.ruleOptions) == null ? void 0 : C.background, t.rect(0, 0, u, g), t.fill(), t.rect(0, 0, g, f), t.fill()), (R = s.ruleOptions) != null && R.underline && (t.beginPath(), t.fillStyle = xi(h, 0.7), t.moveTo(0, g), t.lineTo(u, g), t.stroke(), t.moveTo(g, 0), t.lineTo(g, f), t.stroke());
    let y = g / 4;
    ((P = s.ruleOptions) == null ? void 0 : P.baseline) === "bottom" && (y = g * 3 / 4), t.beginPath(), t.lineWidth = g / 2, t.lineDashOffset = -c % n, t.setLineDash([1, n - 1]), t.moveTo(0, y), t.lineTo(u, y), t.stroke(), t.beginPath(), t.lineDashOffset = -d % n, t.moveTo(y, 0), t.lineTo(y, f), t.stroke(), t.strokeStyle = h, t.beginPath(), t.lineWidth = g, t.lineDashOffset = -c % (n * 10), t.setLineDash([1, n * 10 - 1]), t.moveTo(0, g / 2), t.lineTo(u, g / 2), t.stroke(), t.beginPath(), t.lineDashOffset = -d % (n * 10), t.moveTo(g / 2, 0), t.lineTo(g / 2, f), t.stroke(), t.beginPath(), t.fillStyle = ((E = s.ruleOptions) == null ? void 0 : E.textColor) || t.strokeStyle;
    let v = 0 - Math.floor(c / n / 10) * 100, b = ((H = s.ruleOptions) == null ? void 0 : H.textTop) || 16, x = (($ = s.ruleOptions) == null ? void 0 : $.textLeft) || 4;
    c < 0 && (v -= 100);
    for (let A = c % (n * 10); A < u; A += 10 * n, v += 100)
      n < 3 && v % 500 || t.fillText(v.toString(), A + x, b);
    v = 0 - Math.floor(d / n / 10) * 100, d < 0 && (v -= 100);
    for (let A = d % (n * 10); A < f; A += 10 * n, v += 100)
      n < 3 && v % 500 || (t.save(), t.beginPath(), t.translate(b, A - x), t.rotate(270 * Math.PI / 180), t.fillText(v.toString(), 0, 0), t.restore());
    t.restore();
  }
}
class xl {
  constructor(t, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "magnifierScreen", Yt());
    O(this, "offscreen", Yt());
    O(this, "domOffscreen", Yt());
    O(this, "magnifierSize", 300);
    O(this, "magnifier");
    this.parentCanvas = t, this.parentElement = i, this.store = s, i.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(t, i) {
    this.canvas.style.width = t + "px", this.canvas.style.height = i + "px", t = t * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = t, this.canvas.height = i, this.offscreen.width = t, this.offscreen.height = i, this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.domOffscreen.width = t, this.domOffscreen.height = i, this.domOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.domOffscreen.getContext("2d").textBaseline = "middle", this.magnifierScreen.width = this.magnifierSize + 5, this.magnifierScreen.height = this.magnifierSize + 5;
  }
  /**
   * 绘制到 该画布的 离屏层
   */
  renderMagnifier() {
    if (!this.magnifier)
      return;
    const t = this.magnifierSize / 2, i = this.magnifierSize + 5, s = this.magnifierScreen.getContext(
      "2d"
    );
    s.clearRect(0, 0, i, i), s.lineWidth = 5, s.save(), s.translate(2.5, 2.5), s.save(), s.arc(t, t, t, 0, Math.PI * 2, !1), s.clip(), s.translate(-t, -t), s.scale(2, 2);
    const o = {
      x: (this.parentCanvas.mousePos.x + this.store.data.x) * this.store.dpiRatio,
      y: (this.parentCanvas.mousePos.y + this.store.data.y) * this.store.dpiRatio
    };
    [
      this.parentCanvas.canvasTemplate.bgOffscreen,
      this.parentCanvas.canvasTemplate.offscreen,
      this.parentCanvas.canvasImageBottom.offscreen,
      this.parentCanvas.canvasImageBottom.animateOffsScreen,
      this.parentCanvas.offscreen,
      this.parentCanvas.canvasImage.offscreen,
      this.parentCanvas.canvasImage.animateOffsScreen,
      this.domOffscreen
      //dom元素的绘制层
    ].forEach((n) => {
      s.drawImage(
        n,
        o.x - t,
        o.y - t,
        this.magnifierSize,
        this.magnifierSize,
        0,
        0,
        this.magnifierSize,
        this.magnifierSize
      );
    }), s.restore(), s.beginPath();
    const r = s.createRadialGradient(t, t, t - 5, t, t, t);
    r.addColorStop(0, "rgba(0,0,0,0.2)"), r.addColorStop(0.8, "rgb(200,200,200)"), r.addColorStop(0.9, "rgb(200,200,200)"), r.addColorStop(1, "rgba(200,200,200,0.9)"), s.strokeStyle = r, s.arc(t, t, t, 0, Math.PI * 2, !1), s.stroke(), s.restore(), this.offscreen.getContext("2d").drawImage(
      this.magnifierScreen,
      0,
      0,
      this.magnifierSize + 5,
      this.magnifierSize + 5,
      (o.x - t - 2.5) / this.store.dpiRatio,
      (o.y - t - 2.5) / this.store.dpiRatio,
      (this.magnifierSize + 5) / this.store.dpiRatio,
      (this.magnifierSize + 5) / this.store.dpiRatio
    );
  }
  updateDomOffscreen() {
    const t = this.domOffscreen.getContext("2d");
    t.clearRect(0, 0, this.domOffscreen.width, this.domOffscreen.height);
    for (const i of this.store.data.pens)
      if ((i.externElement || i.name === "gif") && i.calculative.img) {
        t.save(), t.translate(this.store.data.x, this.store.data.y);
        const { x: s, y: o, width: a, height: r } = i.calculative.worldRect;
        t.drawImage(i.calculative.img, s, o, a, r), t.restore();
      }
  }
  render() {
    this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.renderMagnifier();
    const t = this.canvas.getContext("2d");
    t.clearRect(0, 0, this.canvas.width, this.canvas.height), t.drawImage(this.offscreen, 0, 0, this.canvas.width, this.canvas.height);
  }
}
function ia(e) {
  if (e.data.locked)
    throw new Error("canvas is locked");
}
class kl {
  constructor(t) {
    O(this, "box");
    O(this, "iframe");
    O(this, "dialog");
    O(this, "close");
    O(this, "title");
    O(this, "body");
    O(this, "x");
    O(this, "y");
    O(this, "url");
    this.parentElement = t, this.box = document.createElement("div"), this.dialog = document.createElement("div");
    let i = document.createElement("div");
    this.title = document.createElement("div"), this.close = document.createElement("span"), this.close.innerHTML = `
      <svg fill="none" viewBox="0 0 16 16" width="1em" height="1em">
      <path
        fill="currentColor"
        d="M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z"
        fill-opacity="0.9"
      ></path>
    </svg>`, this.body = document.createElement("div"), this.iframe = document.createElement("iframe"), this.iframe.setAttribute("frameborder", "0"), this.box.className = "meta2d-dialog_mask", this.dialog.className = "meta2d-dialog", this.body.className = "meta2d-dialog_body", i.className = "meta2d-dialog_header", this.title.className = "meta2d-dialog-content", this.close.className = "meta2d-dialog-close", i.appendChild(this.title), i.appendChild(this.close), this.body.appendChild(this.iframe), this.dialog.appendChild(i), this.dialog.appendChild(this.body), this.box.appendChild(this.dialog), t.appendChild(this.box), this.dialog.onclick = (o) => {
      o.stopPropagation();
    }, this.box.onclick = () => {
      this.hide();
    }, this.close.onclick = () => {
      this.hide();
    };
    let s;
    for (let o = 0; o < document.styleSheets.length; o++)
      document.styleSheets[o].title === "le5le.com/dialog" && (s = document.styleSheets[o]);
    if (!s) {
      let o = document.createElement("style");
      o.type = "text/css", o.title = "le5le.com/dialog", document.head.appendChild(o), o = document.createElement("style"), o.type = "text/css", document.head.appendChild(o), s = o.sheet, s.insertRule(
        `.meta2d-dialog_mask {
        display: none;
        position: absolute;
        top: 0%;
        left: 0%;
        width: 100%;
        height: 100%;
        background-color: #0000006f;
        z-index: 9999;`
      ), s.insertRule(
        `.meta2d-dialog_mask .meta2d-dialog {
            position: absolute;
            top: 15vh;
            left: 10%;
            width: 80%;
            height:420px;
            padding: 16px 20px;
            border-radius: 9px;
            background-color: #1e2430;
            z-index: 19999;
            overflow: auto;
        }`
      ), s.insertRule(
        `.meta2d-dialog_header {
            display: flex;
        }`
      ), s.insertRule(
        `.meta2d-dialog-content {
            width: calc(100% - 20px);
            font-weight: 600;
            font-size: 14px;
            color: #bdc7db;
            padding-bottom:8px;
        }`
      ), s.insertRule(
        `.meta2d-dialog-close {
            width: 20px;
            height: 20px;
            line-height: 20px;
            text-align: center;
            color: #617b91;
            position: absolute;
            right:20px;
            top:18px;
        }`
      ), s.insertRule(
        `.meta2d-dialog-close :hover{
            cursor: pointer;
        }`
      ), s.insertRule(
        `.meta2d-dialog_body{
            // margin-top: 4px;
        } `
      ), s.insertRule(
        `.meta2d-dialog_body iframe{
            width: 100%;
            height: 100%;
        }`
      );
    }
  }
  show(t, i, s) {
    i && (i !== this.url && (this.iframe.setAttribute("src", i), this.url = i), t && (this.title.innerText = t), t ? (this.dialog.style.padding = "16px 20px", this.title.style.display = "block", this.body.style.height = "calc(100% - 26px)") : (this.dialog.style.padding = "0px", this.title.style.display = "none", this.body.style.height = "100%", this.body.style.overflow = "hidden"), s && (this.dialog.style.width = s.width ? s.width + "px" : "80%", this.dialog.style.height = s.height ? s.height + "px" : "420px", this.dialog.style.top = s.y ? s.y + "px" : "15vh", this.dialog.style.left = s.x ? s.x + "px" : `calc( 50% - ${s.width ? s.width / 2 + "px" : "40%"} )`), this.box.style.display = "block");
  }
  hide() {
    this.box.style.display = "none";
  }
  destroy() {
    this.dialog.onclick = void 0, this.box.onclick = void 0, this.close.onclick = void 0;
  }
}
class Si {
  // 本次 tooltip 在哪个画笔上
  constructor(t) {
    O(this, "box");
    O(this, "currentAnchor");
    this.parentElement = t, this.box = document.createElement("div"), this.box.className = "meta2d-title", t.appendChild(this.box);
    let i;
    for (let s = 0; s < document.styleSheets.length; s++)
      document.styleSheets[s].title === "le5le.com/title" && (i = document.styleSheets[s]);
    if (!i) {
      let s = document.createElement("style");
      s.type = "text/css", s.title = "le5le.com/title", document.head.appendChild(s), s = document.createElement("style"), s.type = "text/css", document.head.appendChild(s), i = s.sheet, i.insertRule(
        ".meta2d-title{position:absolute;padding:0;z-index:10;left: -9999px;top: -9999px;background:#fff;color:#000; cursor: crosshair;border: 1px solid black;}"
      );
    }
  }
  /**
   * @returns 此次应该展示的 title
   */
  static getTitle(t) {
  }
  /**
   * @returns 返回设置前的 rect
   */
  setText(t) {
    this.box.innerText = t.title;
  }
  /**
   * 更新文字
   */
  updateText(t) {
    var i;
    ((i = this.currentAnchor) == null ? void 0 : i.id) === t.id && (Si.titleEmpty(t) || (this.setText(t), this.changePositionByAnchor(t)));
  }
  /**
   * 改变文字会 影响 box 的大小，需要重新设置位置
   * @param oldRect 原
   * @param newRect 新
   */
  changePositionByAnchor(t) {
    this.box.style.left = t.x + 10 + "px", this.box.style.top = t.y + 10 + "px";
  }
  static titleEmpty(t) {
    return !t.title;
  }
  show(t, i) {
    if (Si.titleEmpty(t))
      return;
    this.currentAnchor = t, this.setText(t);
    let s = {
      x: i.calculative.canvas.store.data.x + t.x,
      y: i.calculative.canvas.store.data.y + t.y
    };
    this.changePositionByAnchor(s);
  }
  hide() {
    this.box.style.left = "-9999px", this.box.innerText = "", this.currentAnchor = null;
  }
  destroy() {
    this.box.onmouseleave = null;
  }
}
class Il {
  constructor(t, i) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "offscreen", Yt());
    O(this, "bgOffscreen", Yt());
    O(this, "patchFlags");
    O(this, "bgPatchFlags");
    this.parentElement = t, this.store = i, t.appendChild(this.canvas), this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.position = "absolute", this.canvas.style.top = "0", this.canvas.style.left = "0";
  }
  resize(t, i) {
    this.canvas.style.width = t + "px", this.canvas.style.height = i + "px", t = t * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = t, this.canvas.height = i, this.bgOffscreen.width = t, this.bgOffscreen.height = i, this.offscreen.width = t, this.offscreen.height = i, this.bgOffscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.bgOffscreen.getContext("2d").textBaseline = "middle", this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle", this.init();
  }
  init() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.patchFlags = !0, this.bgPatchFlags = !0;
  }
  hidden() {
    this.canvas.style.display = "none";
  }
  show() {
    this.canvas.style.display = "block";
  }
  clear() {
    this.bgOffscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.bgPatchFlags = !0, this.patchFlags = !0;
  }
  render() {
    if (this.bgPatchFlags) {
      const t = this.bgOffscreen.getContext("2d");
      t.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height, o = this.store.data.x || this.store.options.x || 0, a = this.store.data.y || this.store.options.y || 0, r = this.store.data.background || this.store.options.background;
      r && (t.save(), t.fillStyle = r, t.globalAlpha = this.store.data.globalAlpha ?? this.store.options.globalAlpha, i && s ? (t.shadowOffsetX = this.store.options.shadowOffsetX, t.shadowOffsetY = this.store.options.shadowOffsetY, t.shadowBlur = this.store.options.shadowBlur, t.shadowColor = this.store.options.shadowColor, t.fillRect(
        this.store.data.origin.x + o,
        this.store.data.origin.y + a,
        i * this.store.data.scale,
        s * this.store.data.scale
      )) : t.fillRect(0, 0, this.canvas.width, this.canvas.height), t.restore()), i && s && this.store.bkImg && (t.save(), t.drawImage(
        this.store.bkImg,
        this.store.data.origin.x + o,
        this.store.data.origin.y + a,
        i * this.store.data.scale,
        s * this.store.data.scale
      ), t.restore()), this.renderGrid(t);
    }
    if (this.patchFlags) {
      const t = this.offscreen.getContext("2d");
      t.save(), t.clearRect(0, 0, this.canvas.width, this.canvas.height), t.translate(this.store.data.x, this.store.data.y);
      for (const i of this.store.data.pens)
        if (isFinite(i.x) && // pen.template 
        i.canvasLayer === dt.CanvasTemplate && i.calculative.inView) {
          if (i.name === "combine" && !i.draw)
            continue;
          ve(t, i), i.image && i.name !== "gif" && i.calculative.img && (t.save(), Ie(t, i), i.calculative.rotate && Qt(t, i), Ae(t, i), Be(t, i), t.restore());
        }
      t.restore();
    }
    if (this.patchFlags || this.bgPatchFlags) {
      const t = this.canvas.getContext("2d");
      t.clearRect(0, 0, this.canvas.width, this.canvas.height), t.drawImage(
        this.bgOffscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), t.drawImage(
        this.offscreen,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      ), this.patchFlags = !1, this.bgPatchFlags = !1;
    }
  }
  renderGrid(t) {
    const { data: i, options: s } = this.store, { grid: o, gridRotate: a, gridColor: r, gridSize: l, scale: n, origin: h } = i;
    if (!(o ?? s.grid))
      return;
    t.save();
    const c = (i.width || s.width) * n, d = (i.height || s.height) * n, u = (i.x || s.x || 0) + h.x, f = (i.y || s.y || 0) + h.y;
    a && (t.translate(c / 2, d / 2), t.rotate(a * Math.PI / 180), t.translate(-c / 2, -d / 2)), t.lineWidth = 1, t.strokeStyle = r || s.gridColor, t.beginPath();
    let g = (l || s.gridSize) * n;
    if (g = g < 0 ? 0 : g, !c || !d) {
      const y = this.store.dpiRatio, v = this.canvas.width / y, b = this.canvas.height / y, x = u / g, p = f / g, k = g * 10, C = u - Math.ceil(x) * g, R = f - Math.ceil(p) * g, P = v + C + k, E = b + R + k;
      for (let H = C; H <= P; H += g)
        t.moveTo(H, R), t.lineTo(H, b + R + k);
      for (let H = R; H <= E; H += g)
        t.moveTo(C, H), t.lineTo(v + C + k, H);
    } else {
      const y = c + u, v = d + f;
      for (let b = u; b <= y; b += g)
        t.moveTo(b, f), t.lineTo(b, d + f);
      for (let b = f; b <= v; b += g)
        t.moveTo(u, b), t.lineTo(c + u, b);
    }
    t.stroke(), t.restore();
  }
}
const Al = {
  success: {},
  info: {
    icon: '<svg fill="none" viewBox="0 0 24 24"><path fill="#0052d9" d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  },
  warning: {},
  error: {}
};
class Sl {
  constructor(t, i) {
    O(this, "box");
    O(this, "text");
    O(this, "arrowUp");
    O(this, "arrowDown");
    O(this, "icon");
    O(this, "confirm");
    O(this, "cancel");
    O(this, "x");
    O(this, "y");
    this.parentElement = t, this.store = i, this.box = document.createElement("div"), this.text = document.createElement("div"), this.arrowUp = document.createElement("div"), this.arrowDown = document.createElement("div"), this.icon = document.createElement("div"), this.confirm = document.createElement("button"), this.cancel = document.createElement("button"), this.box.className = "meta2d-popconfirm", this.text.className = "text", this.arrowUp.className = "arrow", this.arrowDown.className = "arrow down", this.icon.className = "icon", this.confirm.className = "confirm", this.cancel.className = "cancel", this.confirm.innerHTML = "确定", this.cancel.innerHTML = "取消", this.icon.innerHTML = Al.info.icon, this.box.appendChild(this.text), this.box.appendChild(this.arrowUp), this.box.appendChild(this.arrowDown), this.box.appendChild(this.confirm), this.box.appendChild(this.cancel), this.box.appendChild(this.icon), t.appendChild(this.box);
    let s;
    for (let o = 0; o < document.styleSheets.length; o++)
      document.styleSheets[o].title === "le5le.com/popconfirm" && (s = document.styleSheets[o]);
    if (!s) {
      let o = document.createElement("style");
      o.type = "text/css", o.title = "le5le.com/popconfirm", document.head.appendChild(o), o = document.createElement("style"), o.type = "text/css", document.head.appendChild(o), s = o.sheet, s.insertRule(
        ".meta2d-popconfirm{position:absolute;z-index:999;left: -9999px;top: -9999px;padding:16px;max-width:400px;background:#fff;border-radius:6px;box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);}"
      ), s.insertRule(
        ".meta2d-popconfirm .text{outline:none;padding:0px 0px 40px 28px;border-radius:4px;color:rgba(0, 0, 0, 0.9);overflow-y:auto;line-height:22px;font-size:13px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .arrow{position:absolute;border:10px solid transparent;background:transparent;top:-18px;left:50%;transform:translateX(-50%)}"
      ), s.insertRule(
        ".meta2d-popconfirm .arrow.down{top:initial;bottom: -18px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .icon{position:absolute;width:22px;height:22px;left:16px;top:16px;}"
      ), s.insertRule(
        ".meta2d-popconfirm .confirm{position:absolute;right:16px;bottom:16px;width:40px;height:24px;text-align:center;background:#4582e6;color:#fff;border-radius:3px;border-color:transparent}"
      ), s.insertRule(
        ".meta2d-popconfirm .confirm:hover{background:#003cab;}"
      ), s.insertRule(
        ".meta2d-popconfirm .cancel{position:absolute;right:64px;bottom:16px;width:40px;height:24px;text-align:center;background:#dcdcdc;color:rgba(0, 0, 0, 0.9);border-radius:3px;border-color:transparent}"
      ), s.insertRule(
        ".meta2d-popconfirm .cancel:hover{background:#a6a6a6;}"
      );
    }
  }
  show(t, i) {
    if (!t)
      return;
    const s = this.box.getBoundingClientRect(), o = t.calculative.worldRect;
    let a = t.calculative.canvas.store.data.x + i.x - s.width / 2, r = t.calculative.canvas.store.data.y + i.y - s.height - 20;
    t.type || (a = t.calculative.canvas.store.data.x + o.x - (s.width - o.width) / 2, r = t.calculative.canvas.store.data.y + o.ey - s.height - o.height), r > 0 ? (this.arrowUp.style.borderBottomColor = "transparent", this.arrowDown.style.borderTopColor = "#fff", r -= 10) : (r += s.height + o.height + 5, r += 10, this.arrowUp.style.borderBottomColor = "#fff", this.arrowDown.style.borderTopColor = "transparent"), this.x = a, this.y = r, this.box.style.left = this.x + "px", this.box.style.top = this.y + "px";
  }
  hide() {
    this.x = -9999, this.box.style.left = "-9999px";
  }
  showModal(t, i, s) {
    return new Promise((o) => {
      this.text.innerHTML = s || "确认执行操作吗？", this.show(t, i), this.confirm.onclick = () => {
        o(!0), this.hide();
      }, this.cancel.onclick = () => {
        o(!1), this.hide();
      };
    });
  }
  destroy() {
    this.box = null;
  }
}
const Et = "-moving";
class Js {
  constructor(t, i, s) {
    O(this, "canvas", document.createElement("canvas"));
    O(this, "offscreen", Yt());
    O(this, "width");
    O(this, "height");
    O(this, "externalElements", document.createElement("div"));
    O(this, "clientRect");
    O(this, "canvasRect");
    O(this, "activeRect");
    O(this, "initActiveRect");
    O(this, "dragRect");
    O(this, "lastRotate", 0);
    O(this, "sizeCPs");
    O(this, "activeInitPos");
    O(this, "hoverType", st.None);
    O(this, "resizeIndex", 0);
    O(this, "mouseDown");
    O(this, "hotkeyType");
    O(this, "mouseRight");
    O(this, "addCaches");
    O(this, "touchCenter");
    O(this, "initTouchDis");
    O(this, "initScale");
    O(this, "touchScaling");
    O(this, "touchMoving");
    O(this, "startTouches");
    O(this, "lastOffsetX", 0);
    O(this, "lastOffsetY", 0);
    O(this, "drawingLineName");
    O(this, "drawLineFns", [...tr]);
    O(this, "drawingLine");
    O(this, "pencil");
    O(this, "pencilLine");
    O(this, "movingPens");
    O(this, "patchFlagsLines", /* @__PURE__ */ new Set());
    O(this, "dock");
    O(this, "prevAnchor");
    O(this, "nextAnchor");
    O(this, "lastMouseTime", 0);
    O(this, "hoverTimer", 0);
    O(this, "fitTimer", 0);
    // 即将取消活动状态的画笔，用于Ctrl选中/取消选中画笔
    O(this, "willInactivePen");
    O(this, "patchFlags", !1);
    O(this, "lastRender", 0);
    O(this, "touchStart", 0);
    O(this, "touchStartTimer");
    O(this, "timer");
    O(this, "lastAnimateRender", 0);
    O(this, "animateRendering", !1);
    O(this, "renderTimer");
    O(this, "initPens");
    O(this, "pointSize", 8);
    O(this, "pasteOffset", !0);
    O(this, "opening", !1);
    O(this, "maxZindex", 5);
    O(this, "canMoveLine", !1);
    //moveConnectedLine=false
    O(this, "randomIdObj");
    //记录拖拽前后id变化
    O(this, "keyOptions");
    /**
     * @deprecated 改用 beforeAddPens
     */
    O(this, "beforeAddPen");
    O(this, "beforeAddPens");
    O(this, "beforeAddAnchor");
    O(this, "beforeRemovePens");
    O(this, "beforeRemoveAnchor");
    O(this, "customResizeDock");
    O(this, "customMoveDock");
    O(this, "inputParent", document.createElement("div"));
    // input = document.createElement('textarea');
    O(this, "inputDiv", document.createElement("div"));
    // inputRight = document.createElement('div');
    O(this, "dropdown", document.createElement("ul"));
    O(this, "tooltip");
    O(this, "popconfirm");
    O(this, "title");
    O(this, "mousePos", { x: 0, y: 0 });
    O(this, "scroll");
    O(this, "movingAnchor");
    // 正在移动中的瞄点
    O(this, "canvasTemplate");
    O(this, "canvasImage");
    O(this, "canvasImageBottom");
    O(this, "magnifierCanvas");
    O(this, "dialog");
    O(this, "autoPolylineFlag", !1);
    //标记open不自动计算
    O(this, "stopPropagation", (t) => {
      t.stopPropagation();
    });
    O(this, "curve", $n);
    O(this, "polyline", el);
    O(this, "mind", Kn);
    O(this, "line", Jn);
    O(this, "onCopy", (t) => {
      this.store.options.disableClipboard || t.target !== this.externalElements && t.target !== document.body && t.target.offsetParent !== this.externalElements || this.copy();
    });
    O(this, "onCut", (t) => {
      this.store.options.disableClipboard || t.target !== this.externalElements && t.target !== document.body && t.target.offsetParent !== this.externalElements || this.cut();
    });
    O(this, "onPaste", (t) => {
      if (this.store.data.locked || this.store.options.disableClipboard || t.target !== this.externalElements && t.target !== document.body && t.target.offsetParent !== this.externalElements)
        return;
      let i;
      if (navigator.clipboard && t.clipboardData) {
        const s = t.clipboardData.items;
        if (s) {
          for (let o = 0; o < s.length; o++)
            if (s[o].type.indexOf("image") !== -1 && s[o].getAsFile()) {
              i = !0;
              break;
            }
        }
      }
      if (i) {
        const s = t.clipboardData.items;
        if (s) {
          for (let o = 0; o < s.length; o++)
            if (s[o].type.indexOf("image") !== -1 && s[o].getAsFile()) {
              const { x: a, y: r } = this.mousePos, l = s[o].getAsFile();
              let n = s[o].type.slice(6) === "gif" ? "gif" : "image";
              if (l !== null) {
                let h;
                const c = new FileReader();
                c.onload = (d) => {
                  h = d.target.result;
                  const u = new Image();
                  u.src = h, u.onload = () => {
                    const { width: f, height: g } = u, y = {
                      name: n,
                      x: a - 50 / 2,
                      y: r - g / f * 50,
                      externElement: n === "gif",
                      width: 100,
                      height: g / f * 100,
                      image: h
                    };
                    this.addPens([y]), this.active([y]), this.copy([y]);
                  };
                }, c.readAsDataURL(l);
              }
            }
        }
      } else
        this.paste();
    });
    O(this, "onMessage", (t) => {
      if (typeof t.data != "string" || !t.data || t.data.startsWith("setImmediate"))
        return;
      let i = JSON.parse(t.data);
      typeof i == "object" ? this.parent.doMessageEvent(i.name, i.value) : this.parent.doMessageEvent(i);
    });
    O(this, "onwheel", (t) => {
      if (this.inputDiv.contentEditable === "true" || this.drawingLine || this.pencil)
        return;
      if (this.store.hover && this.store.hover.onWheel) {
        this.store.hover.onWheel(this.store.hover, t);
        return;
      }
      if (this.store.data.disableScale || this.store.options.disableScale || (t.preventDefault(), t.stopPropagation(), this.mouseDown && (this.hoverType === st.Node || this.hoverType === st.Line)) || this.store.data.locked === ht.Disable || this.store.data.locked === ht.DisableScale || this.store.data.locked === ht.DisableMoveScale) return;
      if (!t.ctrlKey && Math.abs(t.wheelDelta) < 100 && t.deltaY.toString().indexOf(".") === -1) {
        if (this.store.options.scroll && !t.metaKey && this.scroll) {
          this.scroll.wheel(t.deltaY < 0);
          return;
        }
        const a = this.store.data.scale || 1;
        this.translate(-t.deltaX / a, -t.deltaY / a);
        return;
      }
      if (Math.abs(t.wheelDelta) > 100 && this.store.options.scroll && this.scroll && !this.store.options.scrollButScale && !(t.ctrlKey || t.metaKey)) {
        this.scroll.wheel(t.deltaY < 0);
        return;
      }
      if (this.store.options.disableTouchPadScale)
        return;
      let i = 0.015;
      if (this.store.options.scaleOff)
        i = this.store.options.scaleOff, t.deltaY > 0 && (i = -this.store.options.scaleOff);
      else if (/mac os /i.test(navigator.userAgent))
        t.ctrlKey ? t.deltaY > 0 && (i *= -1) : i *= t.wheelDeltaY / 240;
      else {
        let r = 0.2;
        t.deltaY.toString().indexOf(".") !== -1 && (r = 0.01), t.deltaY > 0 ? i = -r : i = r;
      }
      let { offsetX: s, offsetY: o } = t;
      this.scale(this.store.data.scale + i, { x: s, y: o }), this.externalElements.focus();
    });
    O(this, "onkeydown", (t) => {
      var a, r, l;
      if (this.store.data.locked >= ht.DisableEdit && t.target.tagName !== "INPUT" && t.target.tagName !== "TEXTAREA" && !t.target.dataset.meta2dIgnore && this.store.active.forEach((n) => {
        var h;
        (h = n.onKeyDown) == null || h.call(n, n, t.key);
      }), this.store.data.locked >= ht.DisableEdit || t.target.tagName === "INPUT" || t.target.tagName === "TEXTAREA" || t.target.dataset.meta2dIgnore || this.store.options.unavailableKeys.includes(t.key))
        return;
      this.keyOptions || (this.keyOptions = {}), this.keyOptions.altKey = t.altKey, this.keyOptions.shiftKey = t.shiftKey, this.keyOptions.ctrlKey = t.ctrlKey, this.keyOptions.metaKey = t.metaKey;
      let i = 10, s = 10, o = null;
      if (this.store.options.strictScope) {
        const n = this.store.data.width || this.store.options.width, h = this.store.data.height || this.store.options.height;
        n && h && (o = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: n * this.store.data.scale,
          height: h * this.store.data.scale
        });
      }
      switch (t.key) {
        case " ":
          this.hotkeyType = gt.Translate;
          break;
        case "Control":
          this.drawingLine ? this.drawingLine.calculative.drawlineH = !this.drawingLine.calculative.drawlineH : this.hotkeyType || (this.patchFlags = !0, this.hotkeyType = gt.Select);
          break;
        case "Meta":
          break;
        case "Shift":
          this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor ? this.toggleAnchorHand() : this.hotkeyType || (this.patchFlags = !0, this.store.options.resizeMode || (this.hotkeyType = gt.Resize));
          break;
        case "Alt":
          if (!t.ctrlKey && !t.shiftKey && this.drawingLine) {
            const n = ut(this.drawingLine);
            n !== this.drawingLine.calculative.activeAnchor ? (ys(this.drawingLine), this.drawingLine.calculative.worldAnchors.push(n)) : this.drawingLine.calculative.worldAnchors.push({
              x: n.x,
              y: n.y
            });
            const h = this.drawLineFns.indexOf(this.drawingLineName);
            this.drawingLineName = this.drawLineFns[(h + 1) % this.drawLineFns.length], this.drawingLine.lineName = this.drawingLineName, this.drawline(), this.patchFlags = !0;
          }
          t.preventDefault();
          break;
        case "a":
        case "A":
          t.ctrlKey || t.metaKey ? (this.active(
            this.store.data.pens.filter(
              (n) => !n.parentId && n.locked !== ht.Disable
            )
          ), t.preventDefault()) : this.toggleAnchorMode();
          break;
        case "Delete":
        case "Backspace":
          if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
            this.deleteFit();
            break;
          }
          !this.store.data.locked && this.delete();
          break;
        case "ArrowLeft":
          if (this.movingAnchor) {
            this.translateAnchor(-1, 0);
            break;
          }
          if (i = -1, t.shiftKey && (i = -5), (t.ctrlKey || t.metaKey) && (i = -10), i = i * this.store.data.scale, this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x + i, y: this.store.activeAnchor.y },
              {}
            );
            break;
          }
          o && this.activeRect.x + i < o.x && (i = o.x - this.activeRect.x), this.translatePens(this.store.active, i, 0);
          break;
        case "ArrowUp":
          if (this.movingAnchor) {
            this.translateAnchor(0, -1);
            break;
          }
          if (s = -1, t.shiftKey && (s = -5), (t.ctrlKey || t.metaKey) && (s = -10), s = s * this.store.data.scale, o && this.activeRect.y + s < o.y && (s = o.y - this.activeRect.y), this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + s },
              {}
            );
            break;
          }
          this.translatePens(this.store.active, 0, s);
          break;
        case "ArrowRight":
          if (this.movingAnchor) {
            this.translateAnchor(1, 0);
            break;
          }
          if (i = 1, t.shiftKey && (i = 5), (t.ctrlKey || t.metaKey) && (i = 10), i = i * this.store.data.scale, this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x + i, y: this.store.activeAnchor.y },
              {}
            );
            break;
          }
          o && this.activeRect.x + this.activeRect.width + i > o.x + o.width && (i = o.x + o.width - (this.activeRect.x + this.activeRect.width)), this.translatePens(this.store.active, i, 0);
          break;
        case "ArrowDown":
          if (this.movingAnchor) {
            this.translateAnchor(0, 1);
            break;
          }
          if (s = 1, t.shiftKey && (s = 5), (t.ctrlKey || t.metaKey) && (s = 10), s = s * this.store.data.scale, o && this.activeRect.y + this.activeRect.height + s > o.y + o.height && (s = o.y + o.height - (this.activeRect.y + this.activeRect.height)), this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
            this.moveLineAnchor(
              { x: this.store.activeAnchor.x, y: this.store.activeAnchor.y + s },
              {}
            );
            break;
          }
          this.translatePens(this.store.active, 0, s);
          break;
        case "d":
        case "D":
          (a = this.store.active[0]) != null && a.locked || this.removeAnchorHand();
          break;
        case "h":
        case "H":
          (r = this.store.active[0]) != null && r.locked || this.addAnchorHand();
          break;
        case "m":
        case "M":
          this.toggleMagnifier();
          break;
        case "g":
        case "G":
          this.hoverType === st.NodeAnchor && (this.movingAnchor = this.store.hoverAnchor, this.externalElements.style.cursor = "move");
          break;
        case "s":
        case "S":
          !this.store.data.locked && this.hoverType === st.LineAnchor && this.store.hover === this.store.active[0] && this.splitLine(this.store.active[0], this.store.hoverAnchor), (t.ctrlKey || t.metaKey) && this.store.emitter.emit("save", { event: t });
          break;
        case "c":
        case "C":
          (t.ctrlKey || t.metaKey) && this.store.options.disableClipboard && this.copy();
          break;
        case "x":
        case "X":
          (t.ctrlKey || t.metaKey) && this.store.options.disableClipboard && this.cut();
          break;
        case "√":
        case "v":
        case "V":
          !t.ctrlKey && !t.metaKey && (this.pencil && this.stopPencil(), this.drawingLineName ? (this.finishDrawline(), this.drawingLineName = "") : this.drawingLineName = this.store.options.drawingLineName), !this.store.data.locked && (t.ctrlKey || t.metaKey) && (this.store.options.disableClipboard || !this.store.options.disableClipboard && t.altKey) && this.paste();
          break;
        case "b":
        case "B":
          this.drawingLineName && (this.finishDrawline(), this.drawingLineName = ""), this.pencil ? this.stopPencil() : this.drawingPencil();
          break;
        case "y":
        case "Y":
          (t.ctrlKey || t.metaKey) && this.redo();
          break;
        case "z":
        case "Z":
          t.ctrlKey || t.metaKey ? this.undo() : t.shiftKey && this.redo();
          break;
        case "Enter":
          this.drawingLineName && (this.finishDrawline(!0), this.store.active[0].anchors[0].connectTo ? this.drawingLineName = "" : this.drawingLineName = this.store.options.drawingLineName), this.store.active && (this.store.active.forEach((n) => {
            n.type ? (n.close = !n.close, n.close && Xo(n), this.store.path2dMap.set(n, rt.path2dDraws.line(n)), is(n)) : n.calculative.focus = !0;
          }), this.render());
          break;
        case "Escape":
          this.drawingLineName && this.finishDrawline(), this.drawingLineName = void 0, this.stopPencil(), this.store.active && this.store.active.forEach((n) => {
            n.type || (n.calculative.focus = !1);
          }), this.movingPens && (this.getAllByPens(this.movingPens).forEach((n) => {
            this.store.pens[n.id] = void 0;
          }), this.movingPens = void 0, this.mouseDown = void 0, this.clearDock(), (l = this.store.active) == null || l.forEach((n) => {
            this.updateLines(n);
          }), this.calcActiveRect(), this.patchFlags = !0), this.hotkeyType = gt.None, this.movingAnchor = void 0, this.magnifierCanvas.magnifier && (this.magnifierCanvas.magnifier = !1, this.patchFlags = !0);
          break;
        case "E":
        case "e":
          this.store.options.disableAnchor = !this.store.options.disableAnchor, this.store.emitter.emit(
            "disableAnchor",
            this.store.options.disableAnchor
          );
          break;
        case "=":
          (t.ctrlKey || t.metaKey) && (this.scale(this.store.data.scale + 0.1), t.preventDefault(), t.stopPropagation());
          break;
        case "-":
          (t.ctrlKey || t.metaKey) && (this.scale(this.store.data.scale - 0.1), t.preventDefault(), t.stopPropagation());
          break;
        case "l":
        case "L":
          this.canMoveLine = !0;
          break;
        case "[":
          this.parent.down();
          break;
        case "]":
          this.parent.up();
          break;
        case "{":
          this.parent.bottom();
          break;
        case "}":
          this.parent.top();
          break;
        case "F":
        case "f":
          this.setFollowers();
          break;
      }
      this.render(!1);
    });
    O(this, "onkeyup", (t) => {
      switch (t.key) {
        case "l":
        case "L":
          this.canMoveLine = !1;
          break;
      }
      this.hotkeyType && this.render(), this.hotkeyType < gt.AddAnchor && (this.hotkeyType = gt.None);
    });
    O(this, "ondrop", async (t) => {
      if (this.store.data.locked) {
        console.warn("canvas is locked, can not drop");
        return;
      }
      t.preventDefault(), t.stopPropagation();
      const i = t.dataTransfer.getData("Meta2d") || t.dataTransfer.getData("Text");
      let s = null;
      try {
        i && (s = JSON.parse(i));
      } catch {
      }
      if (!s) {
        const { files: o } = t.dataTransfer;
        if (o.length && o[0].type.match("image.*") && !(this.addCaches && this.addCaches.length)) {
          const a = o[0].type === "image/gif";
          s = await this.fileToPen(o[0], a);
        } else if (this.addCaches && this.addCaches.length)
          s = this.addCaches, this.addCaches = [];
        else {
          this.store.emitter.emit("drop", void 0);
          return;
        }
      }
      if (s = Array.isArray(s) ? s : [s], s[0] && s[0].draggable !== !1) {
        const o = { x: t.offsetX, y: t.offsetY };
        this.calibrateMouse(o), this.dropPens(s, o), this.addCaches = [], this.getContainerHover(o), this.mousePos.x = o.x, this.mousePos.y = o.y, this.store.emitter.emit("mouseup", {
          x: o.x,
          y: o.y,
          pen: this.store.hoverContainer
        });
      }
      this.store.emitter.emit("drop", s || i);
    });
    O(this, "ontouchstart", (t) => {
      this.store.data.locked !== ht.Disable && (this.touchStartTimer && clearTimeout(this.touchStartTimer), this.touchStartTimer = setTimeout(() => {
        this.touchStart = performance.now();
        const i = t.touches[0].pageX - this.clientRect.x, s = t.touches[0].pageY - this.clientRect.y, o = { x: i, y: s };
        if (this.calibrateMouse(o), this.getHover(o), this.onMouseDown({
          x: i,
          y: s,
          clientX: t.touches[0].clientX,
          clientY: t.touches[0].clientY,
          pageX: t.touches[0].pageX,
          pageY: t.touches[0].pageY,
          ctrlKey: t.ctrlKey || t.metaKey,
          shiftKey: t.shiftKey,
          altKey: t.altKey,
          buttons: 1
        }), t.touches.length === 2) {
          this.initTouchDis = Math.hypot(
            t.touches[0].pageX - t.touches[1].pageX,
            t.touches[0].pageY - t.touches[1].pageY
          ), this.initScale = this.store.data.scale, this.startTouches = t.touches, this.touchCenter = {
            x: t.touches[0].pageX + (t.touches[1].pageX - t.touches[0].pageX) / 2 - this.clientRect.x,
            y: t.touches[0].pageY + (t.touches[1].pageY - t.touches[0].pageY) / 2 - this.clientRect.y
          };
          return;
        } else t.touches.length === 3 && (this.store.emitter.emit("contextmenu", {
          e: {
            x: i,
            y: s,
            clientX: t.touches[0].clientX,
            clientY: t.touches[0].clientY,
            pageX: t.touches[0].pageX,
            pageY: t.touches[0].pageY
          },
          clientRect: this.clientRect
        }), t.preventDefault(), t.stopPropagation());
        this.touchStartTimer = void 0;
      }, 50));
    });
    O(this, "ontouchmove", (t) => {
      var l;
      if (this.store.data.locked === ht.Disable)
        return;
      t.stopPropagation(), t.preventDefault();
      const i = performance.now();
      if (i - this.touchStart < 50)
        return;
      this.touchStart = i;
      const s = t.touches, o = s.length, a = t.touches[0].pageX - this.clientRect.x, r = t.touches[0].pageY - this.clientRect.y;
      if (o === 1)
        this.onMouseMove({
          x: a,
          y: r,
          clientX: t.changedTouches[0].clientX,
          clientY: t.changedTouches[0].clientY,
          pageX: t.changedTouches[0].pageX,
          pageY: t.changedTouches[0].pageY,
          ctrlKey: t.ctrlKey || t.metaKey,
          shiftKey: t.shiftKey,
          altKey: t.altKey,
          buttons: 1
        });
      else if (o === 2 && ((l = this.startTouches) == null ? void 0 : l.length) === 2) {
        if (!this.touchMoving && !this.touchScaling) {
          const n = this.startTouches[0].pageX - s[0].pageX, h = this.startTouches[1].pageX - s[1].pageX, c = this.startTouches[0].pageY - s[0].pageY, d = this.startTouches[1].pageY - s[1].pageY;
          (n >= 0 && h < 0 || n <= 0 && h > 0) && (c >= 0 && d < 0 || c <= 0 && d > 0) ? this.touchScaling = !0 : this.touchMoving = !0;
        }
        if (this.touchScaling) {
          if (this.store.data.disableScale || this.store.options.disableScale)
            return;
          const n = Math.hypot(
            s[0].pageX - s[1].pageX,
            s[0].pageY - s[1].pageY
          ) / this.initTouchDis;
          this.scale(this.initScale * n, G(this.touchCenter));
        }
        if (this.touchMoving) {
          if (this.store.data.locked >= ht.DisableMove && this.store.data.locked !== ht.DisableScale || this.store.data.disableScale || this.store.options.disableScale)
            return;
          if (this.lastOffsetX) {
            const { scale: n } = this.store.data;
            this.translate(
              (a - this.lastOffsetX) / n,
              (r - this.lastOffsetY) / n
            );
          }
          this.lastOffsetX = a, this.lastOffsetY = r;
        }
      }
    });
    O(this, "ontouchend", (t) => {
      if (this.store.data.locked === ht.Disable)
        return;
      this.touchCenter = void 0, this.touchScaling = void 0, this.touchMoving = void 0, this.startTouches = void 0, this.lastOffsetX = 0, this.lastOffsetY = 0;
      const i = t.changedTouches[0].pageX - this.clientRect.x, s = t.changedTouches[0].pageY - this.clientRect.y;
      this.onMouseUp({
        x: i,
        y: s,
        clientX: t.changedTouches[0].clientX,
        clientY: t.changedTouches[0].clientY,
        pageX: t.changedTouches[0].pageX,
        pageY: t.changedTouches[0].pageY,
        ctrlKey: t.ctrlKey || t.metaKey,
        shiftKey: t.shiftKey,
        altKey: t.altKey,
        buttons: 1
      }), setTimeout(() => {
        this.render();
      }, 20);
    });
    O(this, "onGesturestart", (t) => {
      t.preventDefault();
    });
    O(this, "onMouseDown", (t) => {
      var i, s, o, a, r;
      if (t.buttons === 2 && !this.drawingLine && (this.mouseRight = ie.Down), this.hideInput(), this.popconfirm.hide(), this.store.data.locked === ht.Disable || t.buttons !== 1 && t.buttons !== 2) {
        this.hoverType = st.None;
        return;
      }
      if (!this.magnifierCanvas.magnifier) {
        if (this.calibrateMouse(t), this.mousePos.x = t.x, this.mousePos.y = t.y, this.mouseDown = t, this.lastMouseTime = performance.now(), this.canvasImage.fitFlag) {
          this.canvasImage.currentFit || this.calcuActiveFit();
          return;
        }
        if (this.hotkeyType === gt.AddAnchor) {
          this.setAnchor(this.store.pointAt);
          return;
        }
        if (!this.store.options.autoAnchor && !this.drawingLine && t.shiftKey && t.ctrlKey && t.altKey) {
          this.setAnchor(this.store.pointAt), this.drawingLineName = this.store.options.drawingLineName;
          const l = this.store.activeAnchor;
          if (!l)
            return;
          const n = {
            id: nt(),
            x: l.x,
            y: l.y
          };
          this.drawingLine = this.createDrawingLine(n);
          let h = xt(this.drawingLine);
          this.drawingLine.calculative.activeAnchor = h, St(this.store.hover, l, this.drawingLine, n), this.drawline();
          return;
        }
        if (!(this.hotkeyType === gt.Translate || this.mouseRight === ie.Down && !this.store.options.mouseRightActive)) {
          if (this.drawingLine) {
            if (this.store.hoverAnchor) {
              const n = ut(this.drawingLine);
              this.store.hoverAnchor.type === ge.Line ? ri(n, this.store.hoverAnchor, this.store) : (n.x = this.store.hoverAnchor.x, n.y = this.store.hoverAnchor.y), St(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                n
              ), this.drawline(), this.finishDrawline(!0);
              return;
            }
            if (!this.store.options.autoAnchor && t.shiftKey && t.altKey && t.ctrlKey) {
              this.setAnchor(this.store.pointAt);
              const n = ut(this.drawingLine), h = this.store.activeAnchor;
              if (!h)
                return;
              n.x = h.x, n.y = h.y, St(this.store.hover, h, this.drawingLine, n), this.drawline(), this.finishDrawline(!0);
              return;
            }
            if (t.buttons === 2 || this.drawingLineName === "mind" && ((i = this.drawingLine) == null ? void 0 : i.calculative.worldAnchors.length) > 1 || this.store.options.drawingLineLength && ((s = this.drawingLine) == null ? void 0 : s.calculative.worldAnchors.length) > this.store.options.drawingLineLength) {
              this.finishDrawline(!0), (o = this.store.active[0]) != null && o.anchors[0].connectTo || this.store.active.length == 0 ? this.drawingLineName = "" : this.drawingLineName = this.store.options.drawingLineName;
              return;
            }
            if (this.store.options.autoAnchor && this.hoverType === st.Node) {
              const n = ut(this.drawingLine), h = Ne(this.store.hover, t);
              n.x = h.x, n.y = h.y, this.drawingLine.autoTo = !0, St(this.store.hover, h, this.drawingLine, n), this.drawline(), this.finishDrawline(!0);
              return;
            }
            const l = ut(this.drawingLine);
            l.isTemp ? (this.drawingLine.calculative.activeAnchor = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2], l.isTemp = void 0) : (this.drawingLine.calculative.activeAnchor = l, this.drawingLine.calculative.worldAnchors.push({
              x: l.x,
              y: l.y,
              penId: l.penId
            })), this.drawingLine.calculative.drawlineH = void 0, this.drawingLineName !== "polyline" && this.drawline();
          }
          if (this.drawingLineName) {
            if (this.hoverType === st.Node)
              if (this.store.options.autoAnchor) {
                this.inactive(!0);
                const l = Ne(this.store.hover, t);
                this.store.hoverAnchor = l;
                const n = { id: nt(), x: l.x, y: l.y };
                this.drawingLine = this.createDrawingLine(n), this.drawingLine.autoFrom = !0, St(this.store.hover, l, this.drawingLine, n);
              } else
                this.inactive(), this.hoverType = st.None;
            else if (this.hoverType === st.NodeAnchor) {
              this.drawingLineName = this.store.options.drawingLineName;
              const l = {
                id: nt(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(l), this.drawingLine.calculative.activeAnchor = l, St(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                l
              );
            } else if (!this.drawingLine && this.drawingLineName !== "curve") {
              this.inactive(!0);
              const l = { id: nt(), x: t.x, y: t.y };
              this.drawingLine = this.createDrawingLine(l), this.drawingLine.calculative.activeAnchor = l;
            }
          } else if (this.pencil) {
            this.inactive(!0);
            const l = nt(), n = { x: t.x, y: t.y, id: nt(), penId: l };
            this.pencilLine = this.getInitPencilLine(n);
          } else {
            switch (this.hoverType) {
              case st.None:
                (this.store.data.rule || this.store.options.rule) && !this.store.options.disableRuleLine && this.addRuleLine(t), this.store.options.resizeMode && (this.hotkeyType = gt.None), this.inactive();
                break;
              case st.Node:
              case st.Line:
                if (this.store.hover) {
                  if ((a = this.store.active) != null && a.length && this.store.active.length === 1 && this.store.hover.id === this.store.active[0].id) {
                    this.calcActiveRect();
                    break;
                  }
                  const l = Nt(this.store.hover, !0);
                  let n = l || this.store.hover;
                  l && (l.container || (r = this.store.options.containerShapes) != null && r.includes(l.name)) && (n = this.store.hover), t.ctrlKey && !t.shiftKey ? (n.calculative.active ? this.willInactivePen = n : this.store.active.length > 0 && (n.calculative.active = !0, Le(n), this.store.active.push(n), this.store.emitter.emit("active", this.store.active)), this.patchFlags = !0) : t.ctrlKey && t.shiftKey && this.store.hover.parentId ? this.active([this.store.hover]) : (!(this.activeRect && oe({ x: t.x, y: t.y }, this.activeRect)) || this.store.active.length == 1) && (n.calculative.active || (this.active([n]), this.store.options.resizeMode && (this.hotkeyType = gt.Resize))), this.calcActiveRect();
                }
                break;
              case st.LineAnchor:
                this.store.activeAnchor = this.store.hoverAnchor, this.store.hover.calculative.activeAnchor = this.store.hoverAnchor, this.active([this.store.hover]);
                break;
              case st.LineAnchorPrev:
              case st.LineAnchorNext:
                this.store.activeAnchor && (this.prevAnchor = { ...this.store.activeAnchor.prev }, this.nextAnchor = { ...this.store.activeAnchor.next });
                break;
              case st.Resize:
                this.activeInitPos = [], this.store.active.forEach((l) => {
                  this.activeInitPos.push({
                    x: (l.calculative.worldRect.x - this.activeRect.x) / this.activeRect.width,
                    y: (l.calculative.worldRect.y - this.activeRect.y) / this.activeRect.height
                  });
                });
                break;
            }
            this.store.hover && (this.store.hover.calculative.mouseDown = !0), this.store.emitter.emit("mousedown", {
              x: t.x,
              y: t.y,
              pen: this.store.hover
            });
          }
          this.render();
        }
      }
    });
    O(this, "onMouseMove", (t) => {
      var s, o, a, r, l, n, h, c;
      if (this.store.data.locked === ht.Disable) {
        this.hoverType = st.None;
        return;
      }
      if (this.mouseDown && !this.mouseDown.restore && t.buttons !== 1 && t.buttons !== 2) {
        this.onMouseUp(t);
        return;
      }
      if (this.lastMouseTime) {
        if (performance.now() - this.lastMouseTime < 50) {
          this.lastMouseTime = 0;
          return;
        }
        this.lastMouseTime = 0;
      }
      if (this.calibrateMouse(t), this.mousePos.x = t.x, this.mousePos.y = t.y, this.magnifierCanvas.magnifier) {
        this.render();
        return;
      }
      if (this.canvasImage.fitFlag && this.canvasImage.activeFit) {
        const d = performance.now();
        d - this.fitTimer > 100 && (this.mouseDown ? this.updateFit(t) : this.inFitBorder(this.mousePos), this.fitTimer = d);
        return;
      }
      if (this.mouseDown && !this.store.options.disableTranslate && !this.store.data.disableTranslate) {
        if (this.mouseRight === ie.Down && (this.mouseRight = ie.Translate), this.store.data.locked === ht.DisableEdit || this.store.data.locked === ht.DisableScale || this.hotkeyType === gt.Translate || this.mouseRight === ie.Translate) {
          const { scale: d } = this.store.data;
          let u = (t.x - this.mouseDown.x) / d, f = (t.y - this.mouseDown.y) / d;
          t.shiftKey && !t.ctrlKey && (f = 0), t.ctrlKey && (u = 0), this.translate(u, f);
          return;
        }
        if (this.store.data.locked)
          return;
        if (!this.drawingLine && !this.pencil) {
          if (!this.drawingLineName && !this.movingAnchor) {
            if (this.hoverType === st.NodeAnchor) {
              if (!this.store.hoverAnchor)
                return;
              this.drawingLineName = this.store.options.drawingLineName;
              const d = {
                id: nt(),
                x: this.store.hoverAnchor.x,
                y: this.store.hoverAnchor.y
              };
              this.drawingLine = this.createDrawingLine(d), this.drawingLine.calculative.activeAnchor = d, St(
                this.store.hover,
                this.store.hoverAnchor,
                this.drawingLine,
                d
              ), this.drawline();
              return;
            }
          } else if (this.drawingLineName && this.hoverType === st.None) {
            const d = { id: nt(), x: t.x, y: t.y };
            this.drawingLine = this.createDrawingLine(d), this.drawingLine.calculative.activeAnchor = d, this.drawline();
            return;
          }
          if (t.buttons === 1 && (t.ctrlKey || !this.hoverType && !this.hotkeyType) && !(t.ctrlKey && (this.store.activeAnchor || (s = this.store.active) != null && s.length))) {
            this.dragRect = {
              x: Math.min(this.mouseDown.x, t.x),
              y: Math.min(this.mouseDown.y, t.y),
              ex: Math.max(this.mouseDown.x, t.x),
              ey: Math.max(this.mouseDown.y, t.y),
              width: Math.abs(t.x - this.mouseDown.x),
              height: Math.abs(t.y - this.mouseDown.y)
            }, this.render();
            return;
          }
          if (this.movingAnchor) {
            const d = t.x - this.movingAnchor.x, u = t.y - this.movingAnchor.y;
            this.translateAnchor(d, u), this.render();
            return;
          } else if (!((o = this.store.active[0]) != null && o.locked)) {
            const d = { x: t.x, y: t.y };
            if (this.hoverType === st.LineAnchor) {
              (this.dockInAnchor(t) || ((a = this.store.active[0]) == null ? void 0 : a.lineName) === "line") && !this.store.options.disableDock && !this.store.options.disableLineDock && (this.clearDock(), this.dock = Hs(
                this.store,
                d,
                this.store.activeAnchor
              ), (r = this.dock) != null && r.xDock && (d.x += this.dock.xDock.step), (l = this.dock) != null && l.yDock && (d.y += this.dock.yDock.step)), this.moveLineAnchor(d, t);
              return;
            }
            if (this.hoverType === st.LineAnchorPrev) {
              this.moveLineAnchorPrev(t);
              return;
            }
            if (this.hoverType === st.LineAnchorNext) {
              this.moveLineAnchorNext(t);
              return;
            }
          }
          if (this.hoverType === st.Rotate) {
            this.rotatePens({ x: t.x, y: t.y });
            return;
          }
          if (this.hoverType === st.Resize) {
            this.resizePens(t);
            return;
          }
          if (this.hoverType === st.Node || this.hoverType === st.Line) {
            const d = t.x - this.mouseDown.x, u = t.y - this.mouseDown.y, f = 20;
            if (t.ctrlKey && !t.shiftKey && (Math.abs(d) >= f || Math.abs(u) >= f) && (this.willInactivePen = void 0), this.store.active.length === 1) {
              const g = this.store.active[0];
              if ((g.locked === void 0 || g.locked < ht.DisableMove) && ((n = g == null ? void 0 : g.onMouseMove) == null || n.call(g, g, this.mousePos)), g.calculative.focus)
                return;
            }
            this.movePens(t), this.getContainerHover(t);
            return;
          }
        } else if (this.pencil) {
          const { x: d, y: u } = t, f = { x: d, y: u };
          f.id = nt(), f.penId = this.pencilLine.id, this.pencilLine.calculative.worldAnchors.push(f), this.store.path2dMap.set(
            this.pencilLine,
            rt.path2dDraws[this.pencilLine.name](this.pencilLine)
          ), this.patchFlags = !0;
        }
      }
      if (this.drawingLine) {
        const { x: d, y: u } = t, f = { x: d, y: u };
        if (f.id = nt(), f.penId = this.drawingLine.id, !this.store.options.disableDock && !this.store.options.disableLineDock && (this.clearDock(), this.dock = Hs(this.store, f), (h = this.dock) != null && h.xDock && (f.x += this.dock.xDock.step), (c = this.dock) != null && c.yDock && (f.y += this.dock.yDock.step)), this.mouseDown && this.drawingLineName === "curve" && !this.drawingLine.calculative.worldAnchors[0].connectTo)
          this.drawline(f);
        else {
          let g;
          if (this.drawingLine.calculative.worldAnchors.length > 1 && (g = ut(this.drawingLine)), g ? (g.prev = void 0, g.next = void 0, g.id || (g.id = nt()), g.x = f.x, g.y = f.y, g.connectTo = void 0) : (g = { ...f }, this.drawingLine.calculative.worldAnchors.push(g)), (this.hoverType === st.NodeAnchor || this.hoverType === st.LineAnchor) && (this.store.hoverAnchor.type !== ge.Line && (g.x = this.store.hoverAnchor.x, g.y = this.store.hoverAnchor.y), g.connectTo = this.store.hoverAnchor.penId, this.drawingLineName === "polyline" && (g.isTemp = !1)), this.drawingLineName === "line") {
            if (t.ctrlKey && !t.shiftKey)
              g.x = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].x;
            else if (t.shiftKey && !t.ctrlKey)
              g.y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2].y;
            else if (t.shiftKey && t.ctrlKey) {
              let y = this.drawingLine.calculative.worldAnchors[this.drawingLine.calculative.worldAnchors.length - 2];
              this.getSpecialAngle(g, y);
            }
          }
          this.drawline();
        }
      }
      globalThis.debug && console.time("hover");
      const i = performance.now();
      i - this.hoverTimer > 50 && (this.hoverTimer = i, this.getHover(t)), globalThis.debug && console.timeEnd("hover"), this.hotkeyType === gt.AddAnchor && (this.patchFlags = !0), this.render(!1);
    });
    O(this, "onMouseUp", (t) => {
      if (this.store.data.locked === ht.Disable) {
        this.hoverType = st.None;
        return;
      }
      if (this.mouseDown) {
        if (this.mouseRight === ie.Down && (this.store.hover && this.store.hover.onContextmenu ? this.store.hover.onContextmenu(this.store.hover, t) : this.store.emitter.emit("contextmenu", {
          e: t,
          clientRect: this.clientRect,
          pen: this.store.hover
        })), this.mouseRight = ie.None, this.calibrateMouse(t), this.mousePos.x = t.x, this.mousePos.y = t.y, this.pencil && this.finishPencil(), this.drawingLine) {
          if (this.store.hoverAnchor) {
            const i = ut(this.drawingLine);
            this.store.hoverAnchor.type === ge.Line ? ri(i, this.store.hoverAnchor, this.store) : (i.x = this.store.hoverAnchor.x, i.y = this.store.hoverAnchor.y), St(
              this.store.hover,
              this.store.hoverAnchor,
              this.drawingLine,
              i
            ), this.drawline(), this.finishDrawline(!0);
            return;
          }
          if (this.store.options.autoAnchor && this.hoverType === st.Node) {
            const i = ut(this.drawingLine), s = Ne(this.store.hover, t);
            i.x = s.x, i.y = s.y, this.drawingLine.autoTo = !0, St(this.store.hover, s, this.drawingLine, i), this.drawline(), this.finishDrawline(!0);
            return;
          }
        }
        if (this.hoverType === st.LineAnchor && this.store.hover && this.store.active[0] && this.store.active[0].name === "line" && this.store.active[0] !== this.store.hover) {
          const i = this.store.active[0], s = xt(i), o = ut(i);
          if (this.store.hoverAnchor) {
            const a = this.store.hover, r = xt(a) === this.store.hoverAnchor, l = ut(a) === this.store.hoverAnchor, n = s === this.store.activeAnchor, h = o === this.store.activeAnchor;
            if ((t.ctrlKey || t.altKey) && a.type === ft.Line && (r || l) && (n || h)) {
              const c = a.calculative.worldAnchors.map(
                (d) => ({
                  ...d,
                  penId: i.id
                })
              );
              r ? c.shift() : l && c.pop(), (r && n || l && h) && c.reverse(), n ? (i.calculative.worldAnchors[0].connectTo = void 0, i.calculative.worldAnchors.unshift(...c)) : h && (i.calculative.worldAnchors[i.calculative.worldAnchors.length - 1].connectTo = void 0, i.calculative.worldAnchors.push(...c)), this.delete([a]), this.render();
            } else
              this.store.activeAnchor && (this.store.hoverAnchor.type === ge.Line ? ri(
                this.store.activeAnchor,
                this.store.hoverAnchor,
                this.store
              ) : (this.store.activeAnchor.x = this.store.hoverAnchor.x, this.store.activeAnchor.y = this.store.hoverAnchor.y), St(
                this.store.hover,
                this.store.hoverAnchor,
                i,
                this.store.activeAnchor
              ));
            this[i.lineName] && i.lineName !== "polyline" && this[i.lineName](this.store, i), this.store.path2dMap.set(i, rt.path2dDraws.line(i)), this.initLineRect(i);
          } else
            s === this.store.activeAnchor && i.autoFrom ? this.calcAutoAnchor(i, s, this.store.hover) : o === this.store.activeAnchor && i.autoTo && this.calcAutoAnchor(i, o, this.store.hover);
        }
        if (this.addCaches && this.addCaches.length) {
          if (!this.store.data.locked) {
            if (this.dragRect && this.addCaches.length === 1) {
              const i = this.addCaches[0];
              i.width = this.dragRect.width / this.store.data.scale, i.height = this.dragRect.height / this.store.data.scale, t.x = (this.dragRect.x + this.dragRect.ex) / 2, t.y = (this.dragRect.y + this.dragRect.ey) / 2;
            }
            this.dropPens(this.addCaches, t);
          }
          this.addCaches = void 0;
        }
        if (this.hoverType === st.Rotate && (this.getSizeCPs(), this.store.active.forEach((i) => {
          i.rotate = i.calculative.rotate;
        })), this.patchFlagsLines.forEach((i) => {
          i.type && this.initLineRect(i);
        }), this.patchFlagsLines.clear(), this.dragRect)
          if (this.canvasImage.fitFlag)
            this.makeFit();
          else {
            const i = this.store.data.pens.filter((s) => {
              if (s.visible === !1 || s.locked >= ht.DisableMove || s.parentId || s.isRuleLine)
                return !1;
              if (Jt(
                s.calculative.worldRect,
                this.dragRect,
                t.ctrlKey || this.store.options.dragAllIn
              ))
                return s.type === ft.Line && !this.store.options.dragAllIn ? Bi(s, this.dragRect) : !0;
            });
            this.active(i);
          }
        if (t.button !== 2 && (Ci(this.mouseDown, t) < 2 && (this.store.hover && this.store.hover.input && this.showInput(this.store.hover), this.store.emitter.emit("click", {
          x: t.x,
          y: t.y,
          pen: this.store.hover
        })), this.store.hover && (this.store.hover.calculative.mouseDown = !1), this.store.hover != this.store.hoverContainer && this.store.emitter.emit("mouseup", {
          x: t.x,
          y: t.y,
          pen: this.store.hover
        }), this.store.emitter.emit("mouseup", {
          x: t.x,
          y: t.y,
          pen: this.store.hoverContainer
        })), this.willInactivePen) {
          this.willInactivePen.calculative.active = void 0, Le(this.willInactivePen, !1);
          const i = this.store.active.findIndex((s) => s === this.willInactivePen);
          i >= 0 && this.store.active.splice(i, 1), this.calcActiveRect(), this.willInactivePen = void 0, this.store.emitter.emit("inactive", [this.willInactivePen]), this.render();
        }
        this.movingPens && (t.altKey && !t.shiftKey ? this.copyMovedPens() : this.movedActivePens(t.ctrlKey && t.shiftKey), this.getAllByPens(this.movingPens).forEach((i) => {
          this.store.pens[i.id] = void 0;
        }), this.movingPens = void 0), this.store.active && this.store.active[0] && (this.store.active[0].calculative.h = void 0), this.mouseDown = void 0, this.lastOffsetX = 0, this.lastOffsetY = 0, this.clearDock(), this.dragRect = void 0, this.initActiveRect = void 0, this.render();
      }
    });
    O(this, "clearDock", () => {
      var a, r, l, n;
      const t = (r = (a = this.dock) == null ? void 0 : a.xDock) == null ? void 0 : r.penId, i = (n = (l = this.dock) == null ? void 0 : l.yDock) == null ? void 0 : n.penId, s = this.store.pens[t];
      s && (s.calculative.isDock = !1);
      const o = this.store.pens[i];
      o && (o.calculative.isDock = !1), this.dock = void 0;
    });
    O(this, "onResize", () => {
      this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
        this.resize(), this.timer = void 0;
      }, 100);
    });
    O(this, "onScroll", () => {
      this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
        this.clientRect = this.canvas.getBoundingClientRect(), this.timer = void 0;
      }, 100);
    });
    O(this, "calibrateMouse", (t) => (t.x -= this.store.data.x, t.y -= this.store.data.y, t));
    O(this, "getContainerHover", (t) => {
      var s;
      if (this.dragRect)
        return;
      this.store.hoverContainer = void 0;
      const i = this.store.data.pens.filter((o) => {
        var a;
        return o.container || ((a = this.store.options.containerShapes) == null ? void 0 : a.includes(o.name));
      });
      if (i.length)
        for (let o = i.length - 1; o >= 0; --o) {
          const a = i[o];
          if (!(a.visible == !1 || a.calculative.inView == !1 || a.locked === ht.Disable)) {
            if (oe(t, a.calculative.worldRect))
              this.store.hoverContainer = a, (s = a == null ? void 0 : a.onMouseMove) == null || s.call(a, a, t), this.store.lastHoverContainer !== this.store.hoverContainer && (this.patchFlags = !0, this.store.lastHoverContainer && (this.store.lastHoverContainer.calculative.containerHover = !1, this.store.emitter.emit("leave", this.store.lastHoverContainer)), this.store.hoverContainer && (this.store.hoverContainer.calculative.containerHover = !0, this.store.emitter.emit("enter", this.store.hoverContainer)), this.store.lastHoverContainer = this.store.hoverContainer);
            else if (a === this.store.hoverContainer && (this.store.hoverContainer = void 0, this.store.lastHoverContainer !== this.store.hoverContainer)) {
              this.patchFlags = !0;
              const r = this.store.lastHoverContainer.calculative.canvas.store.pens[this.store.lastHoverContainer.id + Et];
              this.store.lastHoverContainer && !r && (this.store.lastHoverContainer.calculative.containerHover = !1, this.store.emitter.emit("leave", this.store.lastHoverContainer)), this.store.lastHoverContainer = this.store.hoverContainer;
            }
          }
        }
    });
    O(this, "getHover", (t) => {
      var o, a;
      if (this.dragRect || this.canvasImage.fitFlag)
        return;
      let i = st.None;
      this.store.hover = void 0, this.store.hoverAnchor = void 0, this.title.hide(), this.store.pointAt = void 0, this.store.pointAtIndex = void 0;
      const s = this.store.active.length === 1 && this.store.active[0].type;
      if (!this.drawingLineName && this.hotkeyType !== gt.AddAnchor && this.activeRect && !s && !this.store.data.locked) {
        const r = Ni(this.store.active), l = Ds(this.store.active) || this.store.options.disableRotate, n = Bs(this.store.active) || this.store.options.disableSize;
        if (!r && !l) {
          const h = {
            x: this.activeRect.center.x,
            y: this.activeRect.y - 30
          };
          this.activeRect.rotate && vt(h, this.activeRect.rotate, this.activeRect.pivot || this.activeRect.center), !this.hotkeyType && Ee(t, h, this.pointSize) && (i = st.Rotate, this.externalElements.style.cursor = `url("${this.store.options.rotateCursor}"), auto`);
        }
        if (!r && !n)
          for (let h = 0; h < 8; h++) {
            const c = h < 4;
            if ((this.hotkeyType === gt.Resize || c && !this.hotkeyType) && Ee(t, this.sizeCPs[h], this.pointSize)) {
              let u = c ? Cs : Rs, f = 0;
              Math.abs(this.activeRect.rotate % 90 - 45) < 25 ? (u = c ? Rs : Cs, f = Math.round((this.activeRect.rotate - 45) / 90) + (c ? 0 : 1)) : f = Math.round(this.activeRect.rotate / 90), i = st.Resize, this.resizeIndex = h, this.externalElements.style.cursor = u[(h + f) % 4];
              break;
            }
          }
      }
      i === st.None && (i = this.inPens(t, this.store.data.pens)), !i && !s && oe(t, this.activeRect) && (i = st.Node, this.externalElements.style.cursor = "move"), this.hoverType = i, i === st.None && (this.drawingLineName || this.pencil ? this.externalElements.style.cursor = "crosshair" : this.mouseDown || (this.externalElements.style.cursor = "default"), this.store.hover = void 0), this.store.lastHover !== this.store.hover && (this.patchFlags = !0, this.store.lastHover && (this.store.lastHover.calculative.hover = !1, qe(
        Nt(this.store.lastHover, !0) || this.store.lastHover,
        !1
      ), this.store.emitter.emit("leave", this.store.lastHover), this.tooltip.hide()), this.store.hover && (this.store.hover.calculative.hover = !0, qe(Nt(this.store.hover, !0) || this.store.hover), this.store.emitter.emit("enter", this.store.hover), this.tooltip.show(this.store.hover, t)), this.store.lastHover = this.store.hover), (a = (o = this.store.hover) == null ? void 0 : o.onMouseMove) == null || a.call(o, this.store.hover, this.mousePos);
    });
    O(this, "inPens", (t, i) => {
      var o;
      let s = st.None;
      t: for (let a = i.length - 1; a >= 0; --a) {
        const r = i[a];
        if (r.visible == !1 || r.calculative.inView == !1 || r.locked === ht.Disable)
          continue;
        const l = Ai(r);
        if (!(!r.calculative.active && !Se(t, r.calculative.worldRect, l) && !oe(t, r.calculative.worldRect))) {
          if (!this.store.data.locked && this.hotkeyType !== gt.Resize && r.calculative.worldAnchors) {
            for (const n of r.calculative.worldAnchors)
              if (s = this.inAnchor(t, r, n), s) {
                let h = G(n);
                Object.assign(h, t), this.title.show(h, r);
                break t;
              }
          }
          if (r.type) {
            if (r.isRuleLine) {
              let h = ((o = this.store.options.ruleOptions) == null ? void 0 : o.height) || 20;
              if (t.x + this.store.data.x > h && t.y + this.store.data.y > h)
                break;
            }
            const n = Qn(t, r);
            if (n) {
              !this.store.data.locked && !r.locked ? this.hotkeyType === gt.AddAnchor ? this.externalElements.style.cursor = "pointer" : this.externalElements.style.cursor = "move" : this.externalElements.style.cursor = this.store.options.hoverCursor, r.calculative.disabled && (this.externalElements.style.cursor = "not-allowed"), this.store.hover = r, this.store.pointAt = n.point, this.store.pointAtIndex = n.i, this.initTemplateCanvas([this.store.hover]), s = st.Line;
              break;
            }
          } else {
            if (r.children) {
              const h = [];
              if (r.children.forEach((c) => {
                this.store.pens[c] && h.push(this.store.pens[c]);
              }), s = this.inPens(t, h), s)
                break;
            }
            let n = !1;
            if (r.name === "line" ? n = Se(
              t,
              r.calculative.worldRect,
              r.lineWidth
            ) : n = oe(t, r.calculative.worldRect), n) {
              if (r.type === ft.Node && r.name === "line" && !wn(t, r.calculative.worldAnchors))
                continue;
              if (!this.store.data.locked && !r.locked ? this.hotkeyType === gt.AddAnchor ? this.externalElements.style.cursor = "pointer" : this.externalElements.style.cursor = "move" : this.externalElements.style.cursor = this.store.options.hoverCursor, r.calculative.disabled && (this.externalElements.style.cursor = "not-allowed"), this.store.hover = r, this.initTemplateCanvas([this.store.hover]), s = st.Node, this.store.pointAt = t, !t.ctrlKey) {
                let { x: h, y: c, ex: d, ey: u, rotate: f, center: g } = this.store.hover.calculative.worldRect;
                if (f) {
                  const y = [
                    { x: h, y: c },
                    { x: d, y: c },
                    { x: d, y: u },
                    { x: h, y: u }
                  ];
                  y.forEach((b) => {
                    vt(b, f, g);
                  });
                  let v = y[y.length - 1];
                  for (const b of y) {
                    if (v.y > t.y != b.y > t.y) {
                      const x = b.x + (t.y - b.y) * (v.x - b.x) / (v.y - b.y);
                      Math.abs(x - this.store.pointAt.x) < 10 && (this.store.pointAt.x = x);
                    }
                    v = b;
                  }
                } else
                  this.store.pointAt.x - 10 < h ? this.store.pointAt.x = h : this.store.pointAt.x + 10 > d && (this.store.pointAt.x = d), this.store.pointAt.y - 10 < c ? this.store.pointAt.y = c : this.store.pointAt.y + 10 > u && (this.store.pointAt.y = u);
              }
              break;
            }
          }
        }
      }
      return s;
    });
    O(this, "dockInAnchor", (t) => {
      var i, s;
      this.store.hover = void 0;
      for (let o = this.store.data.pens.length - 1; o >= 0; --o) {
        const a = this.store.data.pens[o];
        if (a.visible == !1 || a.locked === ht.Disable || a === this.store.active[0])
          continue;
        let r = Ai(a);
        if (r += 2 * this.store.options.anchorRadius, !!Se(t, a.calculative.worldRect, r) && (this.store.hover = a, this.hotkeyType !== gt.Resize && a.calculative.worldAnchors))
          for (const l of a.calculative.worldAnchors) {
            if (l.twoWay === Rt.In) {
              const n = ut(this.store.active[0]);
              if (this.store.activeAnchor.id !== n.id)
                continue;
            }
            if (l.twoWay === Rt.Out) {
              const n = xt(this.store.active[0]);
              if (this.store.activeAnchor.id !== n.id)
                continue;
            }
            if (!(l.twoWay === Rt.DisableConnected || l.twoWay === Rt.Disable || ((i = this.store.activeAnchor) == null ? void 0 : i.twoWay) === Rt.DisableConnectTo || ((s = this.store.activeAnchor) == null ? void 0 : s.twoWay) === Rt.Disable) && (this.title.hide(), this.inAnchor(t, a, l))) {
              let n = G(l);
              return Object.assign(n, t), this.title.show(n, a), !0;
            }
          }
      }
    });
    O(this, "imageTimer");
    O(this, "templateImageTimer");
    O(this, "render", (t) => {
      if (t && (this.opening = !1), this.opening)
        return;
      let i;
      if (t == null || t === !0 || t === 1 / 0 ? (i = performance.now(), this.patchFlags = !0) : t > 1 ? i = t : i = performance.now(), !this.patchFlags)
        return;
      if (i - this.lastRender < this.store.options.interval) {
        this.renderTimer && cancelAnimationFrame(this.renderTimer), this.renderTimer = requestAnimationFrame(this.render);
        return;
      }
      this.renderTimer = void 0, this.lastRender = i;
      const s = this.offscreen.getContext("2d");
      s.clearRect(0, 0, this.offscreen.width, this.offscreen.height), s.save(), s.translate(this.store.data.x, this.store.data.y), globalThis.debugRender && console.time("renderPens"), this.renderPens(), globalThis.debugRender && console.timeEnd("renderPens"), this.renderBorder(), this.renderHoverPoint(), s.restore(), this.magnifierCanvas.render();
      const o = this.canvas.getContext("2d");
      o.clearRect(0, 0, this.canvas.width, this.canvas.height), o.drawImage(this.offscreen, 0, 0, this.width, this.height), this.canvasTemplate.render(), this.canvasImageBottom.render(), this.canvasImage.render(), this.patchFlags = !1;
    });
    O(this, "renderPens", () => {
      const t = this.offscreen.getContext("2d");
      t.strokeStyle = Ke(this.store);
      for (const i of this.store.data.pens)
        isFinite(i.x) && i.canvasLayer !== dt.CanvasTemplate && (i.name === "combine" && !i.draw || i.calculative.inView && (i.canvasLayer === dt.CanvasMain && i.name !== "gif" && i.image && i.calculative.img && (t.save(), Ie(t, i), i.calculative.rotate && Qt(t, i), Ae(t, i), Be(t, i), t.restore()), ve(t, i)));
      this.drawingLine && ve(t, this.drawingLine), this.pencilLine && ve(t, this.pencilLine), this.movingPens && this.movingPens.forEach((i) => {
        this.renderPenContainChild(t, i);
      });
    });
    O(this, "renderPenContainChild", (t, i) => {
      var s;
      i.calculative.inView && ve(t, i), (s = i.children) == null || s.forEach((o) => {
        const a = this.store.pens[o];
        a && this.renderPenContainChild(t, a);
      });
    });
    O(this, "renderBorder", () => {
      if (!this.store.data.locked && this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !this.movingPens) {
        const t = this.offscreen.getContext("2d");
        t.save(), t.translate(0.5, 0.5);
        const i = this.activeRect.pivot || this.activeRect.center;
        if (this.activeRect.rotate && (t.translate(i.x, i.y), t.rotate(this.activeRect.rotate * Math.PI / 180), t.translate(-i.x, -i.y)), t.strokeStyle = this.store.options.activeColor, t.globalAlpha = this.store.options.activeGlobalAlpha === void 0 ? 0.3 : this.store.options.activeGlobalAlpha, t.beginPath(), t.lineWidth = this.store.options.activeLineWidth || 1, t.setLineDash(this.store.options.activeLineDash || []), t.strokeRect(
          this.activeRect.x,
          this.activeRect.y,
          this.activeRect.width,
          this.activeRect.height
        ), t.setLineDash([]), t.lineWidth = 1, t.globalAlpha = 1, Ni(this.store.active) || Ds(this.store.active) || this.store.options.disableRotate) {
          t.restore();
          return;
        }
        t.beginPath(), t.moveTo(this.activeRect.center.x, this.activeRect.y), t.lineTo(this.activeRect.center.x, this.activeRect.y - 30), t.stroke(), t.beginPath(), t.strokeStyle = this.store.options.activeColor, t.fillStyle = "#ffffff", t.arc(
          this.activeRect.center.x,
          this.activeRect.y - 30,
          5,
          0,
          Math.PI * 2
        ), t.fill(), t.stroke(), t.restore();
      }
    });
    O(this, "renderHoverPoint", () => {
      if (this.store.data.locked)
        return;
      const t = this.offscreen.getContext("2d");
      if (t.save(), t.translate(0.5, 0.5), !this.store.options.disableAnchor && this.store.hover && !this.store.hover.disableAnchor && (this.hotkeyType !== gt.Resize || this.store.active.length !== 1 || this.store.active[0] !== this.store.hover)) {
        const i = [...this.store.hover.calculative.worldAnchors];
        this.store.pointAt && this.hotkeyType === gt.AddAnchor && i.push(this.store.pointAt), i && (t.strokeStyle = this.store.hover.anchorColor || this.store.options.anchorColor, t.fillStyle = this.store.hover.anchorBackground || this.store.options.anchorBackground, i.forEach((s) => {
          if (s.hidden && s.locked > ht.DisableEdit)
            return;
          if (s === this.store.hoverAnchor) {
            t.save();
            const a = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
            t.strokeStyle = a, t.fillStyle = a;
          }
          t.beginPath();
          let o = s.radius || this.store.hover.anchorRadius || this.store.options.anchorRadius;
          if (this.store.hover.type && !s.radius && !this.store.hover.anchorRadius && (o = 3, this.store.hover.calculative.lineWidth > 3 && (o = this.store.hover.calculative.lineWidth)), s.type === ge.Line) {
            let a = this.store.pens[s.penId].rotate || 0;
            this.store.pens[s.penId].calculative.flipX && (a *= -1), this.store.pens[s.penId].calculative.flipY && (a *= -1);
            let r = s.rotate + a;
            this.store.pens[s.penId].calculative.flipX && (r *= -1), this.store.pens[s.penId].calculative.flipY && (r *= -1), t.save(), t.translate(s.x, s.y), t.rotate(r * Math.PI / 180), t.translate(-s.x, -s.y), t.rect(
              s.x - s.length * this.store.data.scale / 2,
              s.y - o,
              s.length * this.store.data.scale,
              o * 2
            ), t.restore();
          } else
            t.arc(s.x, s.y, o, 0, Math.PI * 2);
          if (this.store.hover.type && this.store.hoverAnchor === s ? (t.save(), t.strokeStyle = this.store.hover.activeColor || this.store.options.activeColor, t.fillStyle = t.strokeStyle) : (s.color || s.background) && (t.save(), t.strokeStyle = s.color, t.fillStyle = s.background), t.fill(), t.stroke(), s === this.store.hoverAnchor && t.restore(), (this.store.hover.type && this.store.hoverAnchor === s || s.color || s.background) && t.restore(), !this.store.hover.parentId && this.store.hover.children && this.store.hover.children.length > 0 && s === this.store.hoverAnchor) {
            t.save(), t.beginPath(), t.lineWidth = 3;
            const a = this.store.hover.hoverAnchorColor || this.store.options.hoverAnchorColor;
            globalThis.pSBC && (t.strokeStyle = globalThis.pSBC(
              0.5,
              a
            )), t.arc(s.x, s.y, o + 1.5, 0, Math.PI * 2), t.stroke(), t.restore();
          }
        }));
      }
      this.hotkeyType !== gt.AddAnchor && !this.movingPens && // 不在移动中
      this.activeRect && !(this.store.active.length === 1 && this.store.active[0].type) && !Ni(this.store.active) && !Bs(this.store.active) && !this.store.options.disableSize && (t.strokeStyle = this.store.options.activeColor, t.fillStyle = "#ffffff", this.sizeCPs.forEach((i, s) => {
        this.activeRect.rotate && (t.save(), t.translate(i.x, i.y), t.rotate(this.activeRect.rotate * Math.PI / 180), t.translate(-i.x, -i.y)), (s < 4 || this.hotkeyType === gt.Resize) && (t.beginPath(), t.fillRect(i.x - 4.5, i.y - 4.5, 8, 8), t.strokeRect(i.x - 5.5, i.y - 5.5, 10, 10)), this.activeRect.rotate && t.restore();
      })), !this.store.data.locked && this.dragRect && (t.save(), t.fillStyle = xi(this.store.options.dragColor, 0.2), t.strokeStyle = this.store.options.dragColor, t.beginPath(), t.strokeRect(
        this.dragRect.x,
        this.dragRect.y,
        this.dragRect.width,
        this.dragRect.height
      ), t.fillRect(
        this.dragRect.x,
        this.dragRect.y,
        this.dragRect.width,
        this.dragRect.height
      ), t.restore()), this.dock && (t.strokeStyle = this.store.options.dockColor, this.dock.xDock && (t.beginPath(), t.moveTo(this.dock.xDock.x, this.dock.xDock.y), t.lineTo(this.dock.xDock.x, this.dock.xDock.prev.y), t.stroke()), this.dock.yDock && (t.beginPath(), t.moveTo(this.dock.yDock.x, this.dock.yDock.y), t.lineTo(this.dock.yDock.prev.x, this.dock.yDock.y), t.stroke())), t.restore();
    });
    /**
     *
     * @param pen 当前复制的画笔
     * @param parentId 父节点 id
     * @param clipboard 本次复制的全部画笔，包含子节点, 以及 origin 和 scale
     * @returns 复制后的画笔
     */
    O(this, "pastePen", (t, i) => {
      const s = t.id;
      if (Fs(t), t.parentId = i, t.type === ft.Line ? this.changeNodeConnectedLine(s, t, this.store.clipboard.pens) : this.changeLineAnchors(s, t, this.store.clipboard.pens), !t.parentId) {
        const a = this.getPenRect(
          t,
          this.store.clipboard.origin,
          this.store.clipboard.scale
        ), r = this.getPenRect(
          this.store.clipboard.initRect,
          this.store.clipboard.origin,
          this.store.clipboard.scale
        ), { origin: l, scale: n } = this.store.data;
        t.x = l.x + a.x * n, t.y = l.y + a.y * n, t.width = a.width * n, t.height = a.height * n, r.x = l.x + r.x * n, r.y = l.y + r.y * n, pt(r), this.store.clipboard.pos && (t.x -= r.center.x - this.store.clipboard.pos.x, t.y -= r.center.y - this.store.clipboard.pos.y), this.keyOptions && this.keyOptions.altKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey) ? (t.x = -this.store.data.x + this.width / 2 - t.width / 2, t.y = -this.store.data.y + this.height / 2 - t.height / 2) : this.keyOptions && this.keyOptions.shiftKey && (this.keyOptions.ctrlKey || this.keyOptions.metaKey) || (t.x += this.store.clipboard.offset * this.store.data.scale, t.y += this.store.clipboard.offset * this.store.data.scale);
      }
      this.makePen(t);
      const o = [];
      if (Array.isArray(t.children))
        for (const a of t.children) {
          const r = this.store.clipboard.pens.find(
            (l) => l.id === a
          );
          r && o.push(this.pastePen(r, t.id).id);
        }
      return t.children = o, Kt(t, !0), t;
    });
    O(this, "ondblclick", (t) => {
      var i;
      this.store.hover && (!this.store.data.locked || this.store.hover.dbInput) && !this.store.options.disableInput && (this.store.hover.onShowInput ? this.store.hover.onShowInput(this.store.hover, t) : this.store.hover && this.store.hover.parentId ? ((i = this.store.active) == null ? void 0 : i.length) === 1 && this.store.active[0].id === this.store.hover.id ? this.showInput(this.store.hover) : (this.store.pens[this.store.hover.parentId].children.forEach((s) => {
        this.store.pens[s].calculative.active = !1, this.store.pens[s].calculative.hover = !1;
      }), this.active([this.store.hover])) : this.showInput(this.store.hover)), this.store.emitter.emit("dblclick", {
        x: t.x,
        y: t.y,
        pen: this.store.hover
      });
    });
    O(this, "showInput", (t, i, s = "transparent") => {
      if (!window || !this.store.hover || this.store.hover.locked || this.store.hover.externElement || this.store.hover.disableInput || this.store.hover.disabled)
        return;
      if (this.inputDiv.dataset.penId === t.id) {
        this.inputDiv.dataset.isInput = "true", this.inputDiv.contentEditable = "true", this.inputDiv.focus();
        const c = window.getSelection();
        c.selectAllChildren(this.inputDiv), c.collapseToEnd(), this.inputDiv.scrollTop = this.inputDiv.scrollHeight, this.inputDiv.scrollLeft = this.inputDiv.scrollWidth;
        return;
      }
      !i && !t.dbInput ? this.setInputStyle(t) : (this.inputDiv.style.width = "100%", this.inputDiv.style.height = "100%");
      const o = i || t.calculative.worldTextRect, l = `${(t.calculative.tempText === void 0 ? t.text + "" || "" : t.calculative.tempText).replace(/\x20/g, "&nbsp;").split(/[\s\n]/).join("</div><div>")}</div>`.replace("</div>", "").replace(/\<div\>\<\/div\>/g, "<div><br></div>");
      this.inputDiv.innerHTML = l, this.inputParent.style.left = o.x + this.store.data.x - (t.textLeft || 0) + "px", this.inputParent.style.top = o.y + this.store.data.y - (t.textTop || 0) + "px";
      let n = o.width;
      this.inputParent.style.width = (n < 0 ? 12 : n) + "px", this.inputParent.style.height = o.height + (t.textTop || 0) + "px", this.inputParent.style.zIndex = "9999", this.inputParent.style.background = s, t.rotate % 360 ? this.inputParent.style.transform = `rotate(${t.rotate}deg)` : this.inputParent.style.transform = null, this.inputParent.style.display = "flex", this.inputDiv.dataset.penId = t.id, this.inputDiv.contentEditable = t.disableInput == null ? "true" : t.disableInput.toString(), t.dropdownList && this.dropdown.style.display !== "block" && (this.dropdown.style.background = t.dropdownBackground || "#fff", this.dropdown.style.color = t.dropdownColor || "#bdc7db", this.setDropdownList()), this.inputDiv.contentEditable = "true", this.inputDiv.focus();
      const h = window.getSelection();
      h.selectAllChildren(this.inputDiv), h.collapseToEnd(), this.inputDiv.scrollTop = this.inputDiv.scrollHeight, this.inputDiv.scrollLeft = this.inputDiv.scrollWidth, t.calculative.text = void 0, this.initTemplateCanvas([t]), this.render();
    });
    O(this, "setInputStyle", (t) => {
      t.text || (t.text = "");
      let i;
      for (let n = 0; n < document.styleSheets.length; n++)
        document.styleSheets[n].title === "le5le.com" && (i = document.styleSheets[n]);
      let s = "overflow: scroll;", o = "", a = 1;
      const { scale: r } = this.store.data;
      if (t.fontSize < 12 && (a = 12 / t.fontSize), t.textAlign ? s += `text-align: ${t.textAlign};` : s += "text-align: center;", t.textAlign && t.whiteSpace === "pre-line" && (s += `align-items: ${{
        left: "start",
        center: "center",
        right: "end"
      }[t.textAlign]};`), t.textBaseline ? s += `justify-content: ${{
        top: "start",
        middle: "center",
        bottom: "end"
      }[t.textBaseline]};` : s += "justify-content: center;", t.fontFamily && (s += `font-family: ${t.fontFamily};`), t.fontSize && (t.fontSize * r < 12 ? (s += `font-size:${t.fontSize}px;`, s += `zoom:${t.fontSize / 12 * r};`) : s += `font-size:${t.fontSize * r}px;`), s += `color:${ce(t, this.store)};`, t.fontStyle && (s += `font-style: ${t.fontStyle};`), t.fontWeight && (s += `font-weight: ${t.fontWeight};`), t.textLeft && (s += `margin-left:${r > 1 ? t.textLeft * a : t.textLeft * a / r}px;`), t.textTop && (s += `margin-top:${r > 1 ? t.textTop * a : t.textTop * a / r}px;`), t.lineHeight && (s += `line-height:${r > 1 ? t.fontSize * t.lineHeight * r : t.fontSize * t.lineHeight * a}px;`), t.textHeight)
        s += `height:${r > 1 ? t.textHeight * a * r : t.textHeight * a}px;`;
      else {
        let n = t.calculative.worldRect.height / r;
        n < 0 && (n = 0);
        let h = t.fontSize * r < 12 ? n * a : n * r * a;
        h < t.fontSize * t.lineHeight * r && (h = t.fontSize * t.lineHeight * r, s += `top:-${h / 2}px;`), s += `height:${h}px;`;
      }
      let l = null;
      if (t.textWidth)
        l = t.textWidth < 1 && t.textWidth > -1 ? t.textWidth * t.calculative.worldRect.width : t.textWidth, t.whiteSpace !== "pre-line" && (l < t.fontSize ? s += `width:${t.fontSize * 1.2 * a}px;` : s += `width:${r > 1 ? l * a * r : l * a}px;`);
      else if (t.whiteSpace === void 0 || t.whiteSpace === "break-all") {
        let n = (t.calculative.worldTextRect.width || 12) / r;
        n < 0 && (n = 0), s += `width:${t.fontSize * r < 12 ? n * a : n * r}px;`;
      }
      if (t.whiteSpace && (t.whiteSpace === "pre-line" ? s += "white-space:pre;" : (s += `white-space:${t.whiteSpace};`, t.whiteSpace === "nowrap" && (o += "display:contents;"))), t.whiteSpace !== "nowrap") {
        let n = t.fontSize * 1.2 * t.text.length, h = (l || t.calculative.worldRect.width / r) * Math.floor(
          t.calculative.worldRect.height / r / (t.lineHeight * t.fontSize)
        );
        n > h && (s += "justify-content: start;");
      }
      i.deleteRule(0), i.deleteRule(0), i.insertRule(
        `.meta2d-input
      .input-div{
        resize:none;border:none;outline:none;background:transparent;position:absolute;flex-grow:1;height:100%;width: 100%;position:absolute;left:0;top:0;display:flex;flex-direction: column;cursor: text;${s}}`
      ), i.insertRule(`.input-div div{${o}}`);
    });
    O(this, "hideInput", () => {
      if (this.inputParent.style.display === "flex") {
        this.inputParent.style.display = "none";
        const t = this.store.pens[this.inputDiv.dataset.penId];
        if (!t)
          return;
        if (t.calculative.text = t.text, this.inputDiv.dataset.value = this.inputDiv.innerHTML.replace(/\<div\>/g, `
`).replace(/\<\/div\>/g, "").replace(/\<br\>/g, "").replace(/&nbsp;/g, " ").replace(/(<([^>]+)>)/gi, ""), this.inputDiv.dataset.value = this.convertSpecialCharacter(
          this.inputDiv.dataset.value
        ), t.onInput)
          t.onInput(t, this.inputDiv.dataset.value);
        else if (t.text !== this.inputDiv.dataset.value) {
          const i = [G(t, !0)];
          t.text = this.inputDiv.dataset.value, t.calculative.text = t.text, this.inputDiv.dataset.penId = void 0, t.text && t.textAutoAdjust && Sr(t), qt(t), this.patchFlags = !0, this.pushHistory({
            type: it.Update,
            pens: [G(t, !0)],
            initPens: i
          }), this.store.emitter.emit("change", t), this.store.emitter.emit("valueUpdate", t);
        } else t.text === this.inputDiv.dataset.value && t.calculative.textLines.length == 0 && qt(t);
        this.initTemplateCanvas([t]);
      }
      this.inputDiv.dataset.penId = void 0, this.dropdown.style.display = "none", this.inputDiv.dataset.isInput = "false", this.inputDiv.contentEditable = "false", this.render();
    });
    O(this, "setDropdownList", (t) => {
      this.clearDropdownList();
      const i = this.store.pens[this.inputDiv.dataset.penId];
      if (!this.store.data.locked && !["tablePlus"].includes(i.name))
        return;
      if (this.dropdown.style.display = "block", !i || !i.dropdownList) {
        this.dropdown.style.display = "none";
        return;
      }
      if (!i.dropdownList.length) {
        const a = document.createElement("div");
        a.innerText = "None", a.style.padding = "5px 12px", a.style.color = "#ddd", this.dropdown.appendChild(a);
        return;
      }
      const s = this.inputDiv.innerHTML.replace(/\<div\>/g, `
`).replace(/\<\/div\>/g, "").replace(/\<br\>/g, "");
      let o = 0;
      for (const a of i.dropdownList) {
        const r = typeof a == "string" ? a : a.text;
        t && s ? r.includes(s) && this.dropdownAppendOption(r, o) : this.dropdownAppendOption(r, o), ++o;
      }
      if (!this.dropdown.hasChildNodes()) {
        const a = document.createElement("div");
        a.innerText = "None", a.style.padding = "5px 12px", a.style.color = "#ddd", this.dropdown.appendChild(a);
      }
    });
    O(this, "selectDropdown", (t) => {
      const i = t.target, s = this.store.pens[this.inputDiv.dataset.penId];
      if (!i || !s || !s.dropdownList)
        return;
      const o = +i.dataset.i, a = s.dropdownList[o];
      if (!a)
        return;
      const r = [G(s, !0)];
      typeof a == "object" ? (this.updateValue(s, { ...a }), s.calculative.text = void 0, this.calcActiveRect()) : s.text = a + "", this.inputDiv.innerText = s.text, this.hideInput(), this.pushHistory({
        type: it.Update,
        pens: [G(s, !0)],
        initPens: r
      }), this.render(), this.store.emitter.emit("change", s), this.store.emitter.emit("valueUpdate", s);
    });
    O(this, "inFitBorder", (t) => {
      let i;
      const s = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
      let a = {
        x: (t.x - this.store.data.origin.x) / this.store.data.scale,
        y: (t.y - this.store.data.origin.y) / this.store.data.scale
      };
      const r = this.canvasImage.activeFit;
      this.externalElements.style.cursor = "default", a.y > o * r.y - 10 && a.y < o * r.y + 10 && (i = "top", this.externalElements.style.cursor = "row-resize"), a.y > o * (r.y + r.height) - 10 && a.y < o * (r.y + r.height) + 10 && (i = "bottom", this.externalElements.style.cursor = "row-resize"), a.x > s * r.x - 10 && a.x < s * r.x && (i = "left", this.externalElements.style.cursor = "col-resize"), a.x > s * (r.x + r.width) - 10 && a.x < s * (r.x + r.width) + 10 && (i = "right", this.externalElements.style.cursor = "col-resize"), this.canvasImage.currentFit = i;
    });
    this.parent = t, this.parentElement = i, this.store = s, this.canvasTemplate = new Il(i, s), this.canvasTemplate.canvas.style.zIndex = "1", this.canvasImageBottom = new Gs(i, s, !0), this.canvasImageBottom.canvas.style.zIndex = "2", i.appendChild(this.canvas), this.canvas.style.position = "absolute", this.canvas.style.backgroundRepeat = "no-repeat", this.canvas.style.backgroundSize = "100% 100%", this.canvas.style.zIndex = "3", this.canvasImage = new Gs(i, s), this.canvasImage.canvas.style.zIndex = "4", this.magnifierCanvas = new xl(this, i, s), this.magnifierCanvas.canvas.style.zIndex = "5", this.externalElements.style.position = "absolute", this.externalElements.style.left = "0", this.externalElements.style.top = "0", this.externalElements.style.outline = "none", this.externalElements.style.background = "transparent", this.externalElements.style.zIndex = "5", i.style.position = "relative", i.appendChild(this.externalElements), this.createInput(), this.tooltip = new Je(i, s), this.tooltip.box.onmouseleave = (o) => {
      this.patchFlags = !0, this.store.lastHover && (this.store.lastHover.calculative.hover = !1);
      let a = this.store.data.pens.find(
        (r) => r.calculative.hover === !0
      );
      qe(a, !1);
    }, this.popconfirm = new Sl(i, s), this.dialog = new kl(i), this.title = new Si(i), this.store.options.scroll && (this.scroll = new ea(this)), this.store.dpiRatio = globalThis.devicePixelRatio || 1, this.store.dpiRatio < 1 ? this.store.dpiRatio = 1 : this.store.dpiRatio > 1 && this.store.dpiRatio < 1.5 && (this.store.dpiRatio = 1.5), this.clientRect = this.externalElements.getBoundingClientRect(), this.listen(), window == null || window.addEventListener("resize", this.onResize), window == null || window.addEventListener("scroll", this.onScroll), window == null || window.addEventListener("message", this.onMessage);
  }
  listen() {
    switch (this.externalElements.addEventListener("gesturestart", this.onGesturestart), this.externalElements.ondragover = (t) => t.preventDefault(), this.externalElements.ondrop = this.ondrop, this.externalElements.oncontextmenu = (t) => t.preventDefault(), this.store.options.interval = 50, this.externalElements.ontouchstart = this.ontouchstart, this.externalElements.ontouchmove = this.ontouchmove, this.externalElements.ontouchend = this.ontouchend, this.externalElements.onmousedown = (t) => {
      this.onMouseDown({
        x: t.offsetX,
        y: t.offsetY,
        clientX: t.clientX,
        clientY: t.clientY,
        pageX: t.pageX,
        pageY: t.pageY,
        ctrlKey: t.ctrlKey || t.metaKey,
        shiftKey: t.shiftKey,
        altKey: t.altKey,
        buttons: t.buttons
      });
    }, this.externalElements.onmousemove = (t) => {
      t.target === this.externalElements && this.onMouseMove({
        x: t.offsetX,
        y: t.offsetY,
        clientX: t.clientX,
        clientY: t.clientY,
        pageX: t.pageX,
        pageY: t.pageY,
        ctrlKey: t.ctrlKey || t.metaKey,
        shiftKey: t.shiftKey,
        altKey: t.altKey,
        buttons: t.buttons
      });
    }, this.externalElements.onmouseup = (t) => {
      this.onMouseUp({
        x: t.offsetX,
        y: t.offsetY,
        clientX: t.clientX,
        clientY: t.clientY,
        pageX: t.pageX,
        pageY: t.pageY,
        ctrlKey: t.ctrlKey || t.metaKey,
        shiftKey: t.shiftKey,
        altKey: t.altKey,
        buttons: t.buttons,
        button: t.button
      });
    }, this.externalElements.onmouseleave = (t) => {
      this.store.data.pens.forEach((i) => {
        i.calculative.hover && (i.calculative.hover = !1);
      }), this.store.hover && (this.store.hover.calculative.hover = !1, this.store.hover = void 0), this.render(), t.toElement !== this.tooltip.box && t.toElement !== this.tooltip.arrowUp && t.toElement !== this.tooltip.arrowDown && (this.tooltip.hide(), this.store.lastHover = void 0);
    }, this.externalElements.ondblclick = this.ondblclick, this.externalElements.tabIndex = 0, this.externalElements.onblur = () => {
      this.mouseDown = void 0;
    }, this.externalElements.onwheel = this.onwheel, document.addEventListener("copy", this.onCopy), document.addEventListener("cut", this.onCut), document.addEventListener("paste", this.onPaste), this.store.options.keydown) {
      case Ue.Document:
        document.addEventListener("keydown", this.onkeydown), document.addEventListener("keyup", this.onkeyup);
        break;
      case Ue.Canvas:
        this.externalElements.addEventListener("keydown", this.onkeydown), this.externalElements.addEventListener("keyup", this.onkeyup);
        break;
    }
  }
  /**
   * 分割连线的锚点，变成两条线
   * @param line 连线
   * @param anchor 锚点，连线的某个锚点，引用相同
   */
  splitLine(t, i) {
    const s = t.calculative.worldAnchors, o = s.findIndex((c) => c === i);
    if ([-1, 0, s.length - 1].includes(o))
      return;
    const a = G(t, !0), r = G(t, !0), l = nt();
    r.id = l, r.calculative.canvas = this, r.calculative.active = !1, r.calculative.hover = !1;
    const n = G(s.slice(0, o + 1)), h = G(s.slice(o)).map((c) => (c.penId = l, c));
    t.calculative.worldAnchors = n, r.calculative.worldAnchors = h, this.initLineRect(t), this.initLineRect(r), this.store.data.pens.push(r), this.store.pens[l] = r, this.pushHistory({
      type: it.Add,
      pens: [G(r, !0)],
      step: 2
    }), this.pushHistory({
      type: it.Update,
      initPens: [a],
      pens: [G(t, !0)],
      step: 2
    });
  }
  translateAnchor(t, i) {
    this.movingAnchor.x += t, this.movingAnchor.y += i;
    const s = this.movingAnchor.penId;
    if (s) {
      const o = this.store.pens[s], a = o.calculative.worldRect;
      this.movingAnchor.x < a.x ? this.movingAnchor.x = a.x : this.movingAnchor.x > a.ex && (this.movingAnchor.x = a.ex), this.movingAnchor.y < a.y ? this.movingAnchor.y = a.y : this.movingAnchor.y > a.ey && (this.movingAnchor.y = a.ey);
      const r = Ge(this.movingAnchor, a), l = o.anchors.findIndex(
        (n) => n.id === this.movingAnchor.id
      );
      o.anchors[l] = r, this.patchFlags = !0;
    }
  }
  async fileToPen(t, i) {
    let s = "";
    return this.store.options.uploadFn ? s = await this.store.options.uploadFn(t) : this.store.options.uploadUrl ? s = await Rr(
      t,
      this.store.options.uploadUrl,
      this.store.options.uploadParams,
      this.store.options.uploadHeaders
    ) : s = await Cr(t), new Promise((o, a) => {
      const r = new Image();
      r.onload = () => {
        rt.htmlElements[s] = r, o({
          width: r.width,
          height: r.height,
          name: i ? "gif" : "image",
          image: s
        });
      }, r.onerror = (l) => {
        a(l);
      }, r.crossOrigin = "anonymous", r.src = s;
    });
  }
  async dropPens(t, i) {
    var n;
    this.randomIdObj = {};
    for (const h of t)
      !h.parentId && this.randomCombineId(h, t);
    if (Object.keys(this.randomIdObj).length !== 0)
      for (const h of t)
        h.type ? (h.anchors[0].connectTo = this.randomIdObj[h.anchors[0].connectTo], h.anchors[h.anchors.length - 1].connectTo = this.randomIdObj[h.anchors[h.anchors.length - 1].connectTo]) : (n = h.connectedLines) == null || n.forEach((c) => {
          c.lineAnchor = this.randomIdObj[c.lineAnchor], c.lineId = this.randomIdObj[c.lineId];
        });
    for (const h of t)
      h.id || (h.id = nt()), !h.calculative && (h.calculative = { canvas: this }), this.store.pens[h.id] = h;
    let s = 0, o = 0, a = 0;
    for (const h of t)
      h.parentId || (h.width *= this.store.data.scale, h.height *= this.store.data.scale, h.x = i.x - h.width / 2 + a, h.y = i.y - h.height / 2 + o, h.tags && h.tags.includes("meta3d") && (h.x = this.store.data.origin.x, h.y = this.store.data.origin.y), h.dataset && (s % 2 === 0 ? a = h.width - 40 * this.store.data.scale : a = 0, s++, s % 2 === 0 && (o += h.height + 10 * this.store.data.scale)));
    const r = this.store.data.width || this.store.options.width, l = this.store.data.height || this.store.options.height;
    if (r && l) {
      let h = {
        x: this.store.data.origin.x,
        y: this.store.data.origin.y,
        width: r * this.store.data.scale,
        height: l * this.store.data.scale
      }, c = !0;
      for (const d of t)
        if (!d.parentId) {
          let u = [
            { x: d.x, y: d.y },
            { x: d.x + d.width, y: d.y },
            { x: d.x, y: d.y + d.height },
            { x: d.x + d.width, y: d.y + d.height },
            { x: d.x + d.width / 2, y: d.y + d.height / 2 }
          ];
          if (d.x === h.x && d.y === h.y && d.width === h.width && d.height === h.height || u.some((f) => oe(f, h))) {
            c = !1, this.store.options.strictScope && (d.x < h.x && (d.x = h.x), d.y < h.y && (d.y = h.y), d.x + d.width > h.x + h.width && (d.x = h.x + h.width - d.width), d.y + d.height > h.y + h.height && (d.y = h.y + h.height - d.height));
            break;
          }
        }
      if (c) {
        console.info("画笔在大屏范围外");
        return;
      }
    }
    await this.addPens(t, !0), this.active(t.filter((h) => !h.parentId)), this.render(), this.externalElements.focus();
  }
  randomCombineId(t, i, s) {
    let o = null;
    t.type ? (t.anchors[0].connectTo || t.anchors[t.anchors.length - 1].connectTo) && (o = [
      t.id,
      t.anchors[0].id,
      t.anchors[t.anchors.length - 1].id
    ]) : t.connectedLines && t.connectedLines.length && (o = [t.id]), Fs(t), o && (o.length === 1 ? this.randomIdObj[o[0]] = t.id : (this.randomIdObj[o[0]] = t.id, this.randomIdObj[o[1]] = t.anchors[0].id, this.randomIdObj[o[2]] = t.anchors[t.anchors.length - 1].id)), t.parentId = s;
    const a = [];
    if (Array.isArray(t.children))
      for (const r of t.children) {
        const l = i.find((n) => n.id === r);
        l && a.push(this.randomCombineId(l, i, t.id).id);
      }
    return t.children = a, t;
  }
  async addPens(t, i, s) {
    if (this.beforeAddPens && await this.beforeAddPens(t) != !0)
      return [];
    const o = [];
    for (const a of t)
      this.beforeAddPen && this.beforeAddPen(a) != !0 || (s && (a.x = a.x * this.store.data.scale + this.store.data.origin.x, a.y = a.y * this.store.data.scale + this.store.data.origin.y, a.width = a.width * this.store.data.scale, a.height = a.height * this.store.data.scale), this.makePen(a), o.push(a));
    return this.render(), this.store.emitter.emit("add", o), i && this.pushHistory({ type: it.Add, pens: G(o, !0) }), o;
  }
  /**
   * 获取初始化的 pencilLine
   * @param pt 需包含 penId
   */
  getInitPencilLine(t) {
    const { data: i, options: s } = this.store, o = i.scale, a = i.lineWidth || 1;
    return {
      id: t.penId,
      name: "line",
      x: t.x,
      y: t.y,
      type: ft.Line,
      calculative: {
        canvas: this,
        pencil: !0,
        active: !0,
        worldAnchors: [t],
        lineWidth: a * o
      },
      fromArrow: i.fromArrow || s.fromArrow,
      toArrow: i.toArrow || s.toArrow,
      lineWidth: a
    };
  }
  /**
   * 获取初始化的 drawingLine
   * @param pt 需包含 penId
   */
  createDrawingLine(t) {
    this.inactive();
    const { data: i, options: s } = this.store, o = i.scale, a = i.lineWidth || 1;
    return t.penId = nt(), {
      id: t.penId,
      name: "line",
      lineName: this.drawingLineName,
      x: t.x,
      y: t.y,
      type: ft.Line,
      calculative: {
        canvas: this,
        active: !0,
        worldAnchors: [t],
        lineWidth: a * o
      },
      fromArrow: i.fromArrow || s.fromArrow,
      toArrow: i.toArrow || s.toArrow,
      lineWidth: a
    };
  }
  addRuleLine(t) {
    const { x: i, y: s, scale: o, origin: a } = this.store.data, r = t.x + i, l = t.y + s;
    let n = t.x, h = t.y, c = 0, d = 0, u = 0, f = 0;
    if (r <= l && r < 20)
      n = -i, c = this.width, u = 1, t.ctrlKey || (h = Math.round((h - a.y) / (o * 10)) * (o * 10) + a.y);
    else if (l < r && l < 20)
      h = -s, d = this.height, f = 1, t.ctrlKey || (n = Math.round((n - a.x) / (o * 10)) * (o * 10) + a.x);
    else
      return;
    this.addPen({
      isRuleLine: !0,
      // locked: LockState.DisableMove,
      type: ft.Line,
      name: "line",
      lineName: "line",
      x: n,
      y: h,
      width: c,
      height: d,
      color: this.store.options.ruleLineColor,
      anchors: [
        {
          x: 0,
          y: 0
        },
        {
          x: u,
          y: f
        }
      ]
    });
  }
  clearRuleLines() {
    this.delete(this.ruleLines);
  }
  get ruleLines() {
    return this.store.data.pens.filter((t) => t.isRuleLine);
  }
  /**
   * @description 调整pen的坐标，让pen按照网格自动对齐
   * @author Joseph Ho
   * @date 14/11/2023
   * @memberof Canvas
   */
  alignPenToGrid(t) {
    var s;
    if (this.store.options.autoAlignGrid && this.store.data.grid && !t.type) {
      const o = this.store.data.gridSize || this.store.options.gridSize, { origin: a, scale: r } = this.store.data, { x: l, y: n } = t, h = { x: l, y: n }, c = this.getPenRect(t), d = parseInt((c.x / o).toFixed()), u = parseInt((c.y / o).toFixed()), f = d * o, g = u * o;
      h.x = a.x + f * r, h.y = a.y + g * r, Object.assign(t, h), (s = t.onMove) == null || s.call(t, t), this.updatePenRect(t), this.calcActiveRect(), this.getSizeCPs();
    }
  }
  /**
   * 拖拽结束，数据更新到 active.pens
   */
  movedActivePens(t) {
    let i = this.getAllFollowersByPens(this.store.active, !1);
    const s = G(i, !0), o = this.store.data.gridSize || this.store.options.gridSize, { origin: a, scale: r } = this.store.data, l = this.store.options.autoAlignGrid && this.store.data.grid;
    if (i.forEach((u) => {
      var b;
      const f = this.movingPens.findIndex((x) => x.id === u.id + Et);
      if (f < 0)
        return;
      const { x: g, y } = this.movingPens[f], v = { x: g, y };
      if (l && !this.movingPens[f].type) {
        const x = this.getPenRect(this.movingPens[f]), p = parseInt((x.x / o).toFixed()), k = parseInt((x.y / o).toFixed()), C = p * o, R = k * o;
        v.x = a.x + C * r, v.y = a.y + R * r;
      }
      Object.assign(u, v), (b = u.onMove) == null || b.call(u, u), this.updatePenRect(u), this.updateLines(u), this.store.emitter.emit("updateLines", u), this.patchFlagsLines.forEach((x) => {
        x.type && this.initLineRect(x);
      }), this.patchFlagsLines.clear(), u.calculative.x = u.x, u.calculative.y = u.y, u.calculative.initRect && (u.calculative.initRect.x = u.calculative.x, u.calculative.initRect.y = u.calculative.y, u.calculative.initRect.ex = u.calculative.x + u.calculative.width, u.calculative.initRect.ey = u.calculative.y + u.calculative.height), Ho(u), u.parentId && this.parent.updateRectbyChild(u.calculative.worldRect, u, this.store.pens[u.parentId]);
    }), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), !this.dock) return;
    const { xDock: n, yDock: h } = this.dock;
    let c;
    n && (c = this.store.pens[n.penId]), !c && h && (c = this.store.pens[h.penId]);
    const d = G(this.store.active, !0);
    if (t && this.store.active.length === 1 && (c == null ? void 0 : c.type) === 1 && (n != null && n.anchorId || h != null && h.anchorId)) {
      const u = xt(c), f = ut(c);
      if (n != null && n.anchorId) {
        const g = this.store.pens[this.store.active[0].id + Et].calculative.worldAnchors.find((y) => y.id === n.anchorId);
        g.x === u.x && g.y === u.y ? (s.push(G(c, !0)), St(this.store.active[0], g, c, u), d.push(G(c, !0))) : g.x === f.x && g.y === f.y && (s.push(G(c, !0)), St(this.store.active[0], g, c, f), d.push(G(c, !0)));
      } else if (h != null && h.anchorId) {
        const g = this.store.pens[this.store.active[0].id + Et].calculative.worldAnchors.find((y) => y.id === h.anchorId);
        g.x === u.x && g.y === u.y ? (s.push(G(c, !0)), St(this.store.active[0], g, c, u), d.push(G(c, !0))) : g.x === f.x && g.y === f.y && (s.push(G(c, !0)), St(this.store.active[0], g, c, f), d.push(G(c, !0)));
      }
    }
    l && (this.calcActiveRect(), this.getSizeCPs()), this.pushHistory({
      type: it.Update,
      pens: d,
      initPens: s
    }), this.store.emitter.emit("translatePens", d);
  }
  /**
   * 复制移动后的笔
   */
  copyMovedPens() {
    this.copy(
      this.store.active.map((t, i) => {
        const { x: s, y: o } = this.movingPens[i];
        return this.updateLines(t), {
          ...t,
          x: s,
          y: o
        };
      })
    ), this.pasteOffset = !1, this.paste();
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(t) {
    t.some((i) => this.hasImage(i, !1)) && this.canvasImage.init(), t.some((i) => this.hasImage(i, !0)) && this.canvasImageBottom.init();
  }
  initTemplateCanvas(t) {
    t.some((i) => i.canvasLayer === dt.CanvasTemplate) && this.canvasTemplate.init();
  }
  hasImage(t, i) {
    var s;
    return t.image && t.name !== "gif" ? i ? t.canvasLayer === dt.CanvasImageBottom : t.canvasLayer === dt.CanvasImage : (s = t.children) == null ? void 0 : s.some((o) => {
      const a = this.store.pens[o];
      return a && this.hasImage(a, i);
    });
  }
  inactive(t) {
    this.store.active.length && (this.initTemplateCanvas(this.store.active), this.store.active.forEach((i) => {
      i.calculative.active = void 0, i.calculative.activeAnchor = void 0, i.calculative.hover = !1, Le(i, !1);
    }), !t && this.store.emitter.emit("inactive", this.store.active), this.store.active = [], this.activeRect = void 0, this.sizeCPs = void 0, this.store.activeAnchor = void 0, this.patchFlags = !0);
  }
  active(t, i = !0) {
    if (this.store.active) {
      i && this.store.emitter.emit("inactive", this.store.active);
      for (const s of this.store.active)
        s.calculative.active = void 0, s.calculative.hover = !1, Le(s, !1);
    }
    this.store.active = [], t.forEach((s) => {
      s.calculative.active = !0, Le(s);
    }), this.store.active.push(...t), this.activeRect = void 0, this.calcActiveRect(), this.initTemplateCanvas(t), this.patchFlags = !0, i && this.store.emitter.emit("active", this.store.active);
  }
  getSizeCPs() {
    this.sizeCPs = Zt(this.activeRect);
    const t = [
      { x: 0.5, y: 0 },
      { x: 1, y: 0.5 },
      { x: 0.5, y: 1 },
      { x: 0, y: 0.5 }
    ], { x: i, y: s, width: o, height: a, rotate: r, center: l } = this.activeRect;
    t.forEach((n) => {
      const h = {
        x: n.x * o + i,
        y: n.y * a + s
      };
      vt(h, r, l), this.sizeCPs.push(h);
    });
  }
  getSpecialAngle(t, i) {
    let s = 0;
    t.x - i.x !== 0 ? (s = Math.atan((i.y - t.y) / (t.x - i.x)) * 180 / Math.PI, t.x < i.x && (s > 0 ? s -= 180 : s += 180)) : i.y > t.y ? s = 90 : i.y < t.y && (s = -90), s = Math.round(s / 15) * 15;
    let o = Math.sqrt(
      (i.x - t.x) * (i.x - t.x) + (i.y - t.y) * (i.y - t.y)
    );
    t.x = i.x + Math.cos(s / 180 * Math.PI) * o, t.y = i.y - Math.sin(s / 180 * Math.PI) * o;
  }
  clearHover() {
    this.hoverType = st.None, this.store.hover = null, this.store.hoverAnchor = null;
  }
  inAnchor(t, i, s) {
    var o;
    if (this.store.hoverAnchor = void 0, this.movingAnchor = void 0, !s || s.locked > ht.DisableEdit || !(i.type && i.calculative.active) && this.store.options.disableAnchor || i.disableAnchor)
      return st.None;
    if ((this.mouseDown || this.drawingLine) && i.name === "line" && s.connectTo) {
      const a = this.findOne(s.connectTo);
      if (a != null && a.calculative && !(a != null && a.calculative.active)) {
        i = a;
        const r = a.calculative.worldAnchors.find(
          (l) => l.id === s.anchorId
        );
        r && (s = r);
      }
    }
    if (s.twoWay === Rt.Disable && i.name !== "line")
      return st.None;
    if (i.name === "line" && s.connectTo) {
      let a = (o = this.findOne(s.connectTo)) == null ? void 0 : o.anchors.find(
        (r) => r.id === s.anchorId
      );
      if (a && a.twoWay)
        return st.None;
    }
    if (this.drawingLine) {
      if (s.twoWay === Rt.Out)
        return st.None;
    } else if (!(this.mouseDown && this.hoverType === st.LineAnchor)) {
      if (s.twoWay === Rt.In)
        return st.None;
    }
    if (Ee(
      t,
      s,
      this.pointSize,
      s.penId ? this.store.pens[s.penId] : void 0
    ))
      return s !== this.store.hoverAnchor && (this.patchFlags = !0), this.store.hoverAnchor = s, this.store.hover = i, i.type ? s.connectTo && !i.calculative.active && (this.store.hover = this.store.pens[s.connectTo], this.store.hover) ? (this.store.hoverAnchor = this.store.hover.calculative.worldAnchors.find(
        (a) => a.id === s.anchorId
      ), this.store.hoverAnchor ? (this.externalElements.style.cursor = "crosshair", st.NodeAnchor) : st.None) : (this.hotkeyType === gt.AddAnchor ? this.externalElements.style.cursor = "vertical-text" : this.externalElements.style.cursor = "pointer", st.LineAnchor) : (this.hotkeyType === gt.AddAnchor ? this.externalElements.style.cursor = "vertical-text" : this.externalElements.style.cursor = "crosshair", st.NodeAnchor);
    if (!this.mouseDown && i.type) {
      if (i.calculative.active && s.prev && Ee(t, s.prev, this.pointSize))
        return this.store.hoverAnchor = s, this.store.hover = i, this.externalElements.style.cursor = "pointer", st.LineAnchorPrev;
      if (i.calculative.active && s.next && Ee(t, s.next, this.pointSize))
        return this.store.hoverAnchor = s, this.store.hover = i, this.externalElements.style.cursor = "pointer", st.LineAnchorNext;
    }
    return st.None;
  }
  resize(t, i) {
    t = t || this.parentElement.clientWidth, i = i || this.parentElement.clientHeight, this.width = t, this.height = i, this.canvasRect = {
      x: 0,
      y: 0,
      width: t,
      height: i
    }, wt(this.canvasRect), this.canvas.style.width = t + "px", this.canvas.style.height = i + "px", this.externalElements.style.width = t + "px", this.externalElements.style.height = i + "px", this.canvasTemplate.resize(t, i), this.canvasImage.resize(t, i), this.canvasImageBottom.resize(t, i), this.magnifierCanvas.resize(t, i), t = t * this.store.dpiRatio | 0, i = i * this.store.dpiRatio | 0, this.canvas.width = t, this.canvas.height = i, this.offscreen.width = t, this.offscreen.height = i, this.clientRect = this.externalElements.getBoundingClientRect(), this.canvas.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").scale(this.store.dpiRatio, this.store.dpiRatio), this.offscreen.getContext("2d").textBaseline = "middle";
    for (const s of this.store.data.pens)
      s.isRuleLine && (s.width ? s.height || (s.width = this.width) : s.height = this.height), Kt(s);
    this.render();
  }
  clearCanvas() {
    this.activeRect = void 0, this.sizeCPs = void 0, this.canvas.getContext("2d").clearRect(0, 0, this.canvas.width, this.canvas.height), this.offscreen.getContext("2d").clearRect(0, 0, this.offscreen.width, this.offscreen.height), this.store.data.template || this.canvasTemplate.clear(), this.canvasImage.clear(), this.canvasImageBottom.clear();
  }
  async addPen(t, i, s, o) {
    if (!(this.beforeAddPens && await this.beforeAddPens([t]) != !0) && !(this.beforeAddPen && this.beforeAddPen(t) != !0))
      return o && (t.x = t.x * this.store.data.scale + this.store.data.origin.x, t.y = t.y * this.store.data.scale + this.store.data.origin.y, t.width = t.width * this.store.data.scale, t.height = t.height * this.store.data.scale), this.makePen(t), this.active([t]), this.render(), s && this.store.emitter.emit("add", [t]), i && this.pushHistory({ type: it.Add, pens: [t] }), t;
  }
  pushHistory(t) {
    var o;
    if (this.store.data.locked)
      return;
    const { origin: i, scale: s } = this.store.data;
    t.origin = G(i), t.scale = s, t.type !== it.Update && t.pens && t.pens.forEach((a) => {
      a.calculative && (a.calculative.layer = this.store.data.pens.findIndex(
        (r) => r.id === a.id
      ));
    }), this.store.historyIndex < this.store.histories.length - 1 && this.store.histories.splice(
      this.store.historyIndex + 1,
      this.store.histories.length - this.store.historyIndex - 1
    ), (o = t.pens) == null || o.forEach((a) => {
      let r;
      if (t.initPens)
        for (const l of t.initPens)
          l.id === a.id && (r = l);
      if (r)
        for (const l in a)
          r[l] == null && (r[l] = void 0);
    }), this.store.histories.push(t), this.store.historyIndex = this.store.histories.length - 1, this.store.emitter.emit("update", {
      previous: t.initPens,
      current: t.pens
    });
  }
  undo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex < 0)
      return;
    const t = this.store.histories[this.store.historyIndex--];
    this.doEditAction(t, !0);
    let i = t.step;
    for (; i > 1; ) {
      const s = this.store.histories[this.store.historyIndex--];
      this.doEditAction(s, !0), i--;
    }
    (t.type == it.Add || t.type == it.Delete || t.type == it.Update) && this.activeHistory();
  }
  redo() {
    if (this.store.data.locked || this.store.historyIndex == null || this.store.historyIndex > this.store.histories.length - 2)
      return;
    const t = this.store.histories[++this.store.historyIndex];
    this.doEditAction(t, !1);
    let i = t.step;
    for (; i > 1; ) {
      const s = this.store.histories[++this.store.historyIndex];
      this.doEditAction(s, !1), i--;
    }
    (t.type == it.Add || t.type == it.Delete || t.type == it.Update) && this.activeHistory();
  }
  activeHistory() {
    let t = this.store.histories[this.store.historyIndex + 1];
    const i = [];
    if (t && t.type === it.Update) {
      t.pens.forEach((o) => {
        i.push(this.store.pens[o.id]);
      }), this.active(i);
      return;
    }
    let s = this.store.histories[this.store.historyIndex];
    s && (s.type === it.Add || s.type === it.Delete) && (s.pens.forEach((o) => {
      i.push(this.store.pens[o.id]);
    }), this.active(i));
  }
  doEditAction(t, i) {
    switch (this.inactive(), this.store.hoverAnchor = void 0, this.store.hover = void 0, t.type) {
      case it.Add:
        t.pens.forEach((a) => {
          var n;
          const r = G(a, !0), l = this.store.data.pens.findIndex(
            (h) => h.id === r.id
          );
          l > -1 && ((n = r.onDestroy) == null || n.call(r, this.store.pens[r.id]), this.store.data.pens.splice(l, 1), this.store.pens[r.id] = void 0, r.calculative || (r.calculative = {}), r.calculative.canvas = this, this.store.animates.delete(r), this.store.animateMap.delete(r));
        }), t.type = it.Delete;
        break;
      case it.Update:
        const s = i ? t.initPens : t.pens, o = i ? t.pens : t.initPens;
        s.forEach((a) => {
          const r = G(a, !0), l = this.store.data.pens.findIndex(
            (n) => n.id === r.id
          );
          if (l > -1) {
            if (r.calculative = this.store.data.pens[l].calculative, this.store.data.pens[l].type && this.store.data.pens[l].lastConnected) {
              for (let h in this.store.data.pens[l].lastConnected)
                if (this.store.pens[h]) {
                  let c = G(this.store.data.pens[l].lastConnected[h]);
                  this.store.pens[h].connectedLines = c, r.anchors.forEach((d) => {
                    c.forEach((u) => {
                      d.id === u.lineAnchor && (d.connectTo = h);
                    });
                  });
                }
            }
            this.store.data.pens[l] = r, this.store.pens[r.id] = r;
            for (const h in r)
              (typeof r[h] != "object" || h === "lineDash") && (r.calculative[h] = r[h]);
            r.calculative.image = void 0;
            const n = this.getPenRect(r, t.origin, t.scale);
            if (this.setPenRect(r, n, !1), this.updateLines(r, !0), r.calculative.canvas.parent.isCombine(r)) {
              let h = o.find((c) => c.id === r.id);
              wo.forEach((c) => {
                r[c] !== h[c] && this.parent.setValue(
                  { id: r.id, [c]: r[c] },
                  { render: !0, doEvent: !1 }
                );
              });
            }
          }
        });
        break;
      case it.Delete:
        t.pens.reverse().forEach((a) => {
          var l, n;
          const r = G(a, !0);
          if (r.calculative || (r.calculative = {}), this.store.data.pens.splice(
            ((l = r.calculative) == null ? void 0 : l.layer) !== -1 ? (n = r.calculative) == null ? void 0 : n.layer : this.store.data.pens.length,
            0,
            r
          ), this.store.pens[r.id] = r, r.type && r.lastConnected)
            for (let h in r.lastConnected)
              this.store.pens[h] && (this.store.pens[h].connectedLines = r.lastConnected[h]);
          r.calculative.canvas = this;
        }), t.pens.reverse().forEach((a) => {
          const r = this.store.pens[a.id], l = this.getPenRect(r, t.origin, t.scale);
          this.setPenRect(r, l, !1), r.calculative.image = void 0, r.calculative.backgroundImage = void 0, r.calculative.strokeImage = void 0, this.loadImage(r);
        }), t.type = it.Add;
        break;
      case it.Replace: {
        const a = i ? t.initPens : t.pens;
        (i ? t.pens : t.initPens).forEach((l) => {
          var c;
          const n = G(l, !0);
          if (this.store.data.pens.findIndex(
            (d) => d.id === n.id
          ) > -1) {
            (c = n.onDestroy) == null || c.call(n, this.store.data.pens.find((u) => u.id === n.id));
            const d = this.store.data.pens.findIndex(
              (u) => u.id === n.id
            );
            this.store.data.pens.splice(d, 1), this.store.pens[n.id] = void 0, n.calculative || (n.calculative = {}), n.calculative.canvas = this, this.store.animates.delete(n), this.store.animateMap.delete(n);
          }
        }), a.reverse().forEach((l) => {
          var h, c;
          const n = G(l, !0);
          if (n.calculative || (n.calculative = {}), this.store.data.pens.splice(
            ((h = n.calculative) == null ? void 0 : h.layer) !== -1 ? (c = n.calculative) == null ? void 0 : c.layer : this.store.data.pens.length,
            0,
            n
          ), this.store.pens[n.id] = n, n.type && n.lastConnected)
            for (let d in n.lastConnected)
              this.store.pens[d] && (this.store.pens[d].connectedLines = n.lastConnected[d]);
          n.calculative.canvas = this;
        }), a.reverse().forEach((l) => {
          const n = this.store.data.pens.find((c) => c.id === l.id), h = this.getPenRect(n, t.origin, t.scale);
          this.setPenRect(n, h, !1), n.calculative.image = void 0, n.calculative.backgroundImage = void 0, n.calculative.strokeImage = void 0, this.loadImage(n);
        }), t.type = it.Replace;
        break;
      }
    }
    if (t.type === it.Update) {
      let s = [...t.pens, ...t.initPens];
      this.initImageCanvas(s), this.initTemplateCanvas(s);
    } else
      this.initImageCanvas(t.pens), this.initTemplateCanvas(t.pens);
    this.parent.onSizeUpdate(), this.render(), this.store.emitter.emit(i ? "undo" : "redo", t);
  }
  makePen(t) {
    var o;
    if (t.id || (t.id = nt()), Math.abs(this.store.lastScale - this.store.data.scale) < 1e-4 && this.store.sameTemplate && this.store.templatePens[t.id] && // pen.template
    t.canvasLayer === dt.CanvasTemplate) {
      t = this.store.templatePens[t.id], this.store.data.pens.push(t), this.updatePenRect(t);
      return;
    }
    if (this.store.data.pens.push(t), this.store.pens[t.id] = t, t.path) {
      !t.pathId && (t.pathId = nt());
      const a = this.store.data.paths;
      !a[t.pathId] && (a[t.pathId] = t.path), t.path = void 0;
    }
    t.lineWidth == null && (t.lineWidth = 1);
    const { fontSize: i, lineHeight: s } = this.store.options;
    t.fontSize ? t.fontSize < 0 && (t.fontSize = 0) : t.fontSize = i >= 0 ? i : 12, t.lineHeight || (t.lineHeight = s), t.image && t.name !== "gif" && t.canvasLayer === void 0 && (t.isBottom ? t.canvasLayer = dt.CanvasImageBottom : t.canvasLayer = dt.CanvasImage, delete t.isBottom), t.template && (t.canvasLayer = dt.CanvasTemplate), t.calculative = { canvas: this, singleton: (o = t.calculative) == null ? void 0 : o.singleton }, (t.video || t.audio) && (t.calculative.onended = (a) => {
      this.nextAnimate(a);
    });
    for (const a in t)
      (typeof t[a] != "object" || a === "lineDash") && (t.calculative[a] = t[a]);
    if (t.calculative.image = void 0, t.calculative.backgroundImage = void 0, t.calculative.strokeImage = void 0, !t.anchors && rt.anchors[t.name] && (t.anchors || (t.anchors = []), rt.anchors[t.name](t)), !t.anchors) {
      const a = G(this.store.options.defaultAnchors);
      a.forEach((r, l) => {
        r.id = `${l}`, r.penId = t.id;
      }), t.anchors = a;
    }
    this.updatePenRect(t), !t.anchors && t.calculative.worldAnchors && (t.anchors = t.calculative.worldAnchors.map((a) => Ge(a, t.calculative.worldRect))), !t.rotate && (t.rotate = 0), this.loadImage(t), this.parent.penNetwork(t);
  }
  drawline(t) {
    var i;
    this.drawingLine && ((i = this[this.drawingLineName]) == null || i.call(this, this.store, this.drawingLine, t), this.store.path2dMap.set(
      this.drawingLine,
      rt.path2dDraws.line(this.drawingLine)
    ), this.patchFlags = !0);
  }
  initLineRect(t) {
    var a;
    if (!t)
      return;
    if (!((a = t.calculative.worldAnchors) != null && a.length)) {
      this._del([t]);
      return;
    }
    if (!isFinite(t.x) || !isFinite(t.x) || t.x == null || t.y == null)
      return;
    const i = es(t);
    t.parentId || Object.assign(t, i);
    const { fontSize: s, lineHeight: o } = this.store.options;
    t.fontSize || (t.fontSize = s >= 0 ? s : 12, t.calculative.fontSize = t.fontSize * this.store.data.scale), t.lineHeight || (t.lineHeight = o, t.calculative.lineHeight = t.lineHeight), pt(i), t.calculative.worldRect = i, vs(t, i), qt(t), Kt(t), t.calculative && (t.calculative.gradientAnimatePath = void 0), this.store.path2dMap.set(t, rt.path2dDraws[t.name](t)), t.calculative.worldAnchors && (t.anchors = t.calculative.worldAnchors.map((r) => Ge(r, t.calculative.worldRect)));
  }
  drawingPencil() {
    ia(this.store), this.pencil = !0, this.externalElements.style.cursor = "crosshair";
  }
  stopPencil() {
    this.pencil = !1, this.pencilLine = void 0, this.externalElements.style.cursor = "default";
  }
  async finishDrawline(t) {
    if (!this.drawingLine)
      return;
    const i = xt(this.drawingLine);
    let s = ut(this.drawingLine);
    if (s.isTemp && (this.drawingLine.calculative.worldAnchors.pop(), s = ut(this.drawingLine)), !t && (!s.connectTo && this.drawingLine.calculative.worldAnchors.pop(), xt(this.drawingLine) === this.drawingLine.calculative.activeAnchor)) {
      this.drawingLine = void 0, this.render();
      return;
    }
    if (!i.connectTo || !s.connectTo) {
      if (this.store.options.disableEmptyLine) {
        i.connectTo && (this.store.pens[i.connectTo].connectedLines = this.store.pens[i.connectTo].connectedLines.filter((r) => r.lineId !== this.drawingLine.id)), this.drawingLine = void 0, this.render();
        return;
      }
    } else if (this.store.options.disableRepeatLine && this.store.data.pens.find((l) => {
      if (l.type) {
        const n = xt(l), h = ut(l);
        return Ps(n, i) && Ps(h, s);
      }
    })) {
      this.drawingLine = void 0, this.render();
      return;
    }
    const o = es(this.drawingLine);
    Object.assign(this.drawingLine, o), this.drawingLine.calculative.worldRect = o, this.drawingLine.calculative.activeAnchor = ut(this.drawingLine), this.store.activeAnchor = this.drawingLine.calculative.activeAnchor, (!this.beforeAddPens || await this.beforeAddPens([this.drawingLine])) && (!this.beforeAddPen || this.beforeAddPen(this.drawingLine)) && (this.initLineRect(this.drawingLine), this.store.data.pens.push(this.drawingLine), this.store.pens[this.drawingLine.id] = this.drawingLine, this.store.emitter.emit("add", [this.drawingLine]), this.active([this.drawingLine]), this.pushHistory({
      type: it.Add,
      pens: G([this.drawingLine], !0)
    })), this.store.path2dMap.set(
      this.drawingLine,
      rt.path2dDraws[this.drawingLine.name](this.drawingLine)
    ), this.drawingLine = void 0, this.drawingLineName = void 0, this.render();
  }
  async finishPencil() {
    if (this.pencilLine) {
      const t = ss(
        this.pencilLine.calculative.worldAnchors,
        10,
        0,
        this.pencilLine.calculative.worldAnchors.length - 1
      );
      let i = xt(this.pencilLine);
      t.unshift({ id: i.id, penId: i.penId, x: i.x, y: i.y }), i = ut(this.pencilLine), t.push({ id: i.id, penId: i.penId, x: i.x, y: i.y }), this.pencilLine.calculative.worldAnchors = ll(t), this.pencilLine.calculative.worldAnchors.length > 1 && (this.pencilLine.calculative.pencil = !1, this.store.path2dMap.set(
        this.pencilLine,
        rt.path2dDraws[this.pencilLine.name](this.pencilLine)
      ), (!this.beforeAddPens || await this.beforeAddPens([this.pencilLine])) && (!this.beforeAddPen || this.beforeAddPen(this.pencilLine)) && (this.initLineRect(this.pencilLine), this.store.data.pens.push(this.pencilLine), this.store.pens[this.pencilLine.id] = this.pencilLine, this.store.emitter.emit("add", [this.pencilLine]), this.active([this.pencilLine]), this.pushHistory({
        type: it.Add,
        pens: G([this.pencilLine], !0)
      }))), this.pencilLine = void 0, this.render();
    }
  }
  /**
   * 火狐浏览器无法绘制 svg 不存在 width height 的问题
   * 此方法手动添加 width 和 height 解决火狐浏览器绘制 svg
   * @param pen
   */
  firefoxLoadSvg(t) {
    const i = new Image(), s = new XMLHttpRequest();
    s.open("GET", t.image, !0), s.onload = () => {
      const r = new DOMParser().parseFromString(s.responseText, "text/xml").getElementsByTagName("svg")[0], { width: l, height: n } = t.calculative.worldRect;
      r.setAttribute("width", `${l}px`), r.setAttribute("height", `${n}px`);
      const c = "data:image/svg+xml;base64," + btoa(
        unescape(
          encodeURIComponent(new XMLSerializer().serializeToString(r))
        )
      );
      i.src = c, i.onload = () => {
        t.calculative.img = i, t.calculative.imgNaturalWidth = i.naturalWidth || t.iconWidth, t.calculative.imgNaturalHeight = i.naturalHeight || t.iconHeight, rt.htmlElements[t.image] = i, this.imageLoaded(), t.canvasLayer === dt.CanvasTemplate && this.templateImageLoaded();
      };
    }, s.send();
  }
  loadImage(t) {
    if (t.image !== t.calculative.image || !t.calculative.img) {
      if (t.calculative.img = void 0, t.image)
        if (rt.htmlElements[t.image]) {
          const i = rt.htmlElements[t.image];
          t.calculative.img = i, t.calculative.imgNaturalWidth = i.naturalWidth || t.iconWidth, t.calculative.imgNaturalHeight = i.naturalHeight || t.iconHeight, this.imageLoaded(), t.canvasLayer === dt.CanvasTemplate && this.templateImageLoaded();
        } else if (navigator.userAgent.includes("Firefox") && t.image.endsWith(".svg"))
          this.firefoxLoadSvg(t);
        else {
          const i = new Image();
          i.crossOrigin = t.crossOrigin === "undefined" ? void 0 : t.crossOrigin || "anonymous", i.src = t.image, this.store.options.cdn && !(t.image.startsWith("http") || t.image.startsWith("//") || t.image.startsWith("data:image")) && (i.src = this.store.options.cdn + t.image), i.onload = () => {
            t.calculative.img = i, t.calculative.imgNaturalWidth = i.naturalWidth || t.iconWidth, t.calculative.imgNaturalHeight = i.naturalHeight || t.iconHeight, rt.htmlElements[t.image] = i, this.imageLoaded(), t.canvasLayer === dt.CanvasTemplate && this.templateImageLoaded();
          };
        }
      t.calculative.image = t.image;
    }
    if (t.backgroundImage !== t.calculative.backgroundImage) {
      if (t.calculative.backgroundImg = void 0, t.backgroundImage)
        if (rt.htmlElements[t.backgroundImage]) {
          const i = rt.htmlElements[t.backgroundImage];
          t.calculative.backgroundImg = i;
        } else {
          const i = new Image();
          i.crossOrigin = "anonymous", i.src = t.backgroundImage, this.store.options.cdn && !(t.backgroundImage.startsWith("http") || t.backgroundImage.startsWith("//") || t.backgroundImage.startsWith("data:image")) && (i.src = this.store.options.cdn + t.backgroundImage), i.onload = () => {
            t.calculative.backgroundImg = i, rt.htmlElements[t.backgroundImage] = i, this.imageLoaded(), t.canvasLayer === dt.CanvasTemplate && this.templateImageLoaded();
          };
        }
      t.calculative.backgroundImage = t.backgroundImage;
    }
    if (t.strokeImage !== t.calculative.strokeImage) {
      if (t.calculative.strokeImg = void 0, t.strokeImage)
        if (rt.htmlElements[t.strokeImage]) {
          const i = rt.htmlElements[t.strokeImage];
          t.calculative.strokeImg = i;
        } else {
          const i = new Image();
          i.crossOrigin = "anonymous", i.src = t.strokeImage, this.store.options.cdn && !(t.strokeImage.startsWith("http") || t.strokeImage.startsWith("//") || t.strokeImage.startsWith("data:image")) && (i.src = this.store.options.cdn + t.strokeImage), i.onload = () => {
            t.calculative.strokeImg = i, rt.htmlElements[t.strokeImage] = i, this.imageLoaded(), // pen.template
            t.canvasLayer === dt.CanvasTemplate && t.name !== "gif" && this.templateImageLoaded();
          };
        }
      t.calculative.strokeImage = t.strokeImage;
    }
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  imageLoaded() {
    this.imageTimer && clearTimeout(this.imageTimer), this.imageTimer = setTimeout(() => {
      this.canvasImage.init(), this.canvasImageBottom.init(), this.render();
    }, 100);
  }
  // 避免初始化图片加载重复调用 render，此处防抖
  templateImageLoaded() {
    this.templateImageTimer && clearTimeout(this.templateImageTimer), this.templateImageTimer = setTimeout(() => {
      this.canvasTemplate.init(), this.render();
    }, 100);
  }
  setCalculativeByScale(t) {
    const i = this.store.data.scale;
    t.calculative.lineWidth = t.lineWidth * i, t.calculative.fontSize = t.fontSize * i, t.fontSize < 1 && t.fontSize > 0 && (t.calculative.fontSize = t.fontSize * t.calculative.worldRect.height), t.calculative.iconSize = t.iconSize * i, t.calculative.iconWidth = t.iconWidth * i, t.calculative.iconHeight = t.iconHeight * i, t.calculative.iconLeft = t.iconLeft < 1 && t.iconLeft > -1 ? t.iconLeft : t.iconLeft * i, t.calculative.iconTop = t.iconTop < 1 && t.iconTop > -1 ? t.iconTop : t.iconTop * i, t.calculative.textWidth = t.textWidth < 1 && t.textWidth > -1 ? t.textWidth : t.textWidth * i, t.calculative.textHeight = t.textHeight < 1 && t.textHeight > -1 ? t.textHeight : t.textHeight * i, t.calculative.textLeft = t.textLeft < 1 && t.textLeft > -1 ? t.textLeft * t.calculative.worldRect.width : t.textLeft * i, t.calculative.textTop = t.textTop < 1 && t.textTop > -1 ? t.textTop * t.calculative.worldRect.height : t.textTop * i, t.type === ft.Line && t.borderWidth && (t.calculative.borderWidth = t.borderWidth * i);
  }
  updatePenRect(t, {
    worldRectIsReady: i,
    playingAnimate: s
  } = {}) {
    i ? mi(t) : zo(t), s || this.setCalculativeByScale(t), ze(t), Ls(this.store.pens, t), qt(t), Kt(t), rt.path2dDraws[t.name] && this.store.path2dMap.set(t, rt.path2dDraws[t.name](t)), t.calculative.patchFlags = !0, this.patchFlags = !0, t.children && t.children.forEach((o) => {
      const a = this.store.pens[o];
      a && this.updatePenRect(a, { worldRectIsReady: !1 });
    }), t.type && this.initLineRect(t), t.calculative.gradientTimer && clearTimeout(t.calculative.gradientTimer), t.calculative.gradientTimer = setTimeout(() => {
      t.calculative.lineGradient && (t.calculative.lineGradient = null), t.calculative.gradient && (t.calculative.gradient = null), t.calculative.radialGradient && (t.calculative.radialGradient = null), this.patchFlags = !0, t.calculative.gradientTimer = void 0;
    }, 50);
  }
  translate(t = 0, i = 0) {
    if (this.store.data.x += t * this.store.data.scale, this.store.data.y += i * this.store.data.scale, this.store.data.x = Math.round(this.store.data.x), this.store.data.y = Math.round(this.store.data.y), this.store.options.padding) {
      let s = Xt(this.store.options.padding);
      const o = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
      this.width < (o + s[1] + s[3]) * this.store.data.scale && (this.store.data.x + this.store.data.origin.x > s[3] * this.store.data.scale && (this.store.data.x = s[3] * this.store.data.scale - this.store.data.origin.x), this.store.data.x + this.store.data.origin.x + o * this.store.data.scale < this.width - s[1] * this.store.data.scale && (this.store.data.x = this.width - s[1] * this.store.data.scale - (this.store.data.origin.x + o * this.store.data.scale))), this.height < (a + s[0] + s[2]) * this.store.data.scale && (this.store.data.y + this.store.data.origin.y > s[0] * this.store.data.scale && (this.store.data.y = s[0] * this.store.data.scale - this.store.data.origin.y), this.store.data.y + this.store.data.origin.y + a * this.store.data.scale < this.height - s[2] * this.store.data.scale && (this.store.data.y = this.height - s[2] * this.store.data.scale - (this.store.data.origin.y + a * this.store.data.scale)));
    }
    this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init(), this.render(), this.store.emitter.emit("translate", {
      x: this.store.data.x,
      y: this.store.data.y
    }), this.tooltip.translate(t, i), this.scroll && this.scroll.isShow && this.scroll.translate(t, i), this.onMovePens();
  }
  onMovePens() {
    var i;
    const t = this.parent.map;
    t && t.isShow && t.setView();
    for (const s of this.store.data.pens)
      Kt(s), (i = s.onMove) == null || i.call(s, s), s.isRuleLine && (s.width ? s.height || (s.x = -this.store.data.x) : s.y = -this.store.data.y, this.updatePenRect(s));
  }
  /**
   * 缩放整个画布
   * @param scale 缩放比例，最终的 data.scale
   * @param center 中心点，引用类型，存在副作用，会更改原值
   */
  scale(t, i = { x: 0, y: 0 }) {
    var l;
    const s = this.store.data.minScale || this.store.options.minScale, o = this.store.data.maxScale || this.store.options.maxScale;
    if (!(t >= s && t <= o))
      return;
    this.calibrateMouse(i);
    const a = t / this.store.data.scale;
    this.store.data.scale = t, this.store.data.center = i, (l = this.store.clipboard) != null && l.pos && wi(this.store.clipboard.pos, a, i), wi(this.store.data.origin, a, i), this.store.data.pens.forEach((n) => {
      if (!n.parentId) {
        if (Pe(n, a, i), n.onScale && n.onScale(n), n.isRuleLine) {
          const h = 1 / a, c = n.calculative.worldRect.center;
          n.width && n.height || Pe(n, h, c);
        }
        this.updatePenRect(n, { worldRectIsReady: !0 }), this.execPenResize(n);
      }
    }), this.onMovePens(), this.calcActiveRect(), this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init();
    const r = this.parent.map;
    r && r.isShow && r.setView(), this.render(), this.store.emitter.emit("scale", this.store.data.scale);
  }
  templateScale(t, i = { x: 0, y: 0 }) {
    const { minScale: s, maxScale: o } = this.store.options;
    if (!(t >= s && t <= o))
      return;
    const a = t / this.store.data.scale;
    this.store.data.scale = t, this.store.data.center = { x: 0, y: 0 }, this.store.data.origin = { x: 0, y: 0 }, this.store.data.pens.forEach((r) => {
      if (!r.parentId) {
        if (Pe(r, a, i), r.onScale && r.onScale(r), r.isRuleLine) {
          const l = a > 1 ? 1 : 1 / a / a, n = r.calculative.worldRect.center;
          r.width && r.height || Pe(r, l, n);
        }
        this.execPenResize(r);
      }
    }), this.calcActiveRect();
  }
  rotatePens(t) {
    this.initPens || (this.initPens = G(this.getAllByPens(this.store.active))), this.activeRect.rotate = zt(t, this.activeRect.center), this.activeRect.rotate % 90 < 10 && (this.activeRect.rotate -= this.activeRect.rotate % 90), this.activeRect.rotate % 90 > 80 && (this.activeRect.rotate += 90 - this.activeRect.rotate % 90), this.store.active.length === 1 && (this.lastRotate = this.store.active[0].rotate || 0);
    const i = this.activeRect.rotate - this.lastRotate;
    for (const s of this.store.active) {
      if (s.parentId)
        return;
      this.rotatePen(s, i, this.activeRect), s.onRotate && s.onRotate(s), this.updateLines(s);
    }
    this.lastRotate = this.activeRect.rotate, this.getSizeCPs(), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), this.render(), this.store.emitter.emit("rotatePens", this.store.active), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: it.Update,
        pens: G(this.getAllByPens(this.store.active)),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  resizePens(t) {
    if (this.initPens || (this.initPens = G(this.store.active, !0)), !this.initActiveRect) {
      this.initActiveRect = G(this.activeRect);
      return;
    }
    const i = { x: this.mouseDown.x, y: this.mouseDown.y }, s = { x: t.x, y: t.y };
    let o = s.x - i.x, a = s.y - i.y;
    const r = G(this.initActiveRect);
    if (Ws(r, o, a, this.resizeIndex), pt(r), !this.store.options.disableDock) {
      this.clearDock();
      const f = this.customResizeDock || dn;
      this.dock = f(
        this.store,
        r,
        this.store.active,
        this.resizeIndex
      );
      const { xDock: g, yDock: y } = this.dock;
      if (g) {
        o += g.step;
        const v = this.store.pens[g.penId];
        v.calculative.isDock = !0;
      }
      if (y) {
        a += y.step;
        const v = this.store.pens[y.penId];
        v.calculative.isDock = !0;
      }
    }
    const l = this.activeRect.width, n = this.activeRect.height;
    let h = o - this.lastOffsetX, c = a - this.lastOffsetY;
    if (this.lastOffsetX = o, this.lastOffsetY = a, (t.ctrlKey || this.initPens.length === 1 && this.initPens[0].ratio) && (c = ([1, 3].includes(this.resizeIndex) ? -1 : 1) * (h * n) / l), this.activeRect.ratio = this.initPens[0].ratio, Ws(this.activeRect, h, c, this.resizeIndex), this.store.options.strictScope) {
      const f = this.store.data.width || this.store.options.width, g = this.store.data.height || this.store.options.height;
      if (f && g) {
        let y = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: f * this.store.data.scale,
          height: g * this.store.data.scale
        };
        this.activeRect.x < y.x && (this.activeRect.width = this.activeRect.width - (y.x - this.activeRect.x), this.activeRect.x = y.x), this.activeRect.y < y.y && (this.activeRect.height = this.activeRect.height - (y.y - this.activeRect.y), this.activeRect.y = y.y), this.activeRect.x + this.activeRect.width > y.x + y.width && (this.activeRect.width = this.activeRect.width - (this.activeRect.x + this.activeRect.width - (y.x + y.width)), this.activeRect.x = y.x + y.width - this.activeRect.width, this.activeRect.ex = this.activeRect.x + this.activeRect.width), this.activeRect.y + this.activeRect.height > y.y + y.height && (this.activeRect.height = this.activeRect.height - (this.activeRect.y + this.activeRect.height - (y.y + y.height)), this.activeRect.y = y.y + y.height - this.activeRect.height, this.activeRect.ey = this.activeRect.y + this.activeRect.height);
      }
    }
    pt(this.activeRect);
    const d = this.activeRect.width / l, u = this.activeRect.height / n;
    this.store.active.forEach((f, g) => {
      f.calculative.worldRect.x = this.activeInitPos[g].x * this.activeRect.width + this.activeRect.x, f.calculative.worldRect.y = this.activeInitPos[g].y * this.activeRect.height + this.activeRect.y, f.calculative.worldRect.width *= d, f.calculative.iconWidth && (f.calculative.iconWidth *= d), f.calculative.worldRect.height *= u, f.calculative.iconHeight && (f.calculative.iconHeight *= u), wt(f.calculative.worldRect), pt(f.calculative.worldRect), this.updatePenRect(f, { worldRectIsReady: !0 }), this.execPenResize(f), this.updateLines(f);
    }), this.getSizeCPs(), this.initImageCanvas(this.store.active), this.initTemplateCanvas(this.store.active), this.render(), this.store.emitter.emit("resizePens", this.store.active), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: it.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  movePens(t) {
    var l, n;
    if (!this.activeRect || this.store.data.locked)
      return;
    if (!this.initActiveRect) {
      this.initActiveRect = G(this.activeRect);
      return;
    }
    if (!this.store.options.moveConnectedLine && !this.canMoveLine && this.store.active.length === 1 && ((l = this.store.active[0].anchors[0]) != null && l.connectTo || (n = this.store.active[0].anchors[this.store.active[0].anchors.length - 1]) != null && n.connectTo) || (this.movingPens || (this.initMovingPens(), this.store.active.forEach((h) => {
      qe(h, !1);
    }), this.store.hover = void 0), !this.mouseDown))
      return;
    let i = t.x - this.mouseDown.x, s = t.y - this.mouseDown.y;
    t.shiftKey && !t.ctrlKey && (s = 0), t.ctrlKey && (i = 0);
    const o = G(this.initActiveRect);
    be(o, i, s);
    let a = !1;
    if (this.store.options.strictScope) {
      const h = this.store.data.width || this.store.options.width, c = this.store.data.height || this.store.options.height;
      if (h && c) {
        let d = {
          x: this.store.data.origin.x,
          y: this.store.data.origin.y,
          width: h * this.store.data.scale,
          height: c * this.store.data.scale
        };
        o.x < d.x && (o.x = d.x, a = !0), o.y < d.y && (o.y = d.y, a = !0), o.x + o.width > d.x + d.width && (o.x = d.x + d.width - o.width, a = !0), o.y + o.height > d.y + d.height && (o.y = d.y + d.height - o.height, a = !0);
      }
    }
    const r = {
      x: o.x - this.activeRect.x,
      y: o.y - this.activeRect.y
    };
    if (!this.store.options.disableDock && !a) {
      this.clearDock();
      const h = this.customMoveDock || hn;
      this.dock = h(this.store, o, this.movingPens, r);
      const { xDock: c, yDock: d } = this.dock;
      let u;
      c && (r.x += c.step, u = this.store.pens[c.penId], u.calculative.isDock = !0), d && (r.y += d.step, u = this.store.pens[d.penId], u.calculative.isDock = !0);
    }
    this.translatePens(this.movingPens, r.x, r.y, !0);
  }
  /**
   * 初始化移动，更改画笔的 id parentId 等关联关系
   * @param pen 要修改的画笔
   * @param pens 本次操作的画笔们，包含子画笔
   */
  changeIdsByMoving(t, i) {
    t.id += Et, t.parentId && i.find((s) => s.id === t.parentId) && (t.parentId += Et), t.children && (t.children = t.children.map((s) => s + Et)), t.connectedLines && (t.connectedLines = t.connectedLines.map((s) => (i.find((o) => o.id === s.lineId) && (s.lineId += Et), s))), t.type && t.calculative.worldAnchors && (t.calculative.worldAnchors = t.calculative.worldAnchors.map(
      (s) => (s.connectTo && i.find((o) => o.id === s.connectTo) && (s.connectTo += Et), s)
    ));
  }
  /**
   * 初始化 this.movingPens
   * 修改 ids （id parentId children 等）
   * 半透明，去图片
   */
  initMovingPens() {
    var s, o;
    if (!this.store.options.moveConnectedLine && !this.canMoveLine)
      for (let a = 0; a < this.store.active.length; a++) {
        const r = this.store.active[a];
        ((s = r.anchors[0]) != null && s.connectTo || (o = r.anchors[r.anchors.length - 1]) != null && o.connectTo) && (this.store.active.splice(a, 1), r.calculative.active = void 0, --a);
      }
    this.movingPens = G(this.store.active, !0), this.movingPens = this.getAllFollowersByPens(this.movingPens);
    const t = this.getAllByPens(this.movingPens), i = G(t, !0);
    t.forEach((a) => {
      this.changeIdsByMoving(a, i), this.store.pens[a.id] = a, a.calculative.canvas = this;
      const r = {
        globalAlpha: 0.5
      };
      a.lineWidth === 0 && (r.lineWidth = 1), (a.name.endsWith("Dom") || Qa.includes(a.name) || this.store.options.domShapes.includes(a.name) || a.image) && (r.name = "rectangle", r.onDestroy = void 0), this.updateValue(a, r), a.calculative.image = void 0;
    });
  }
  moveLineAnchor(t, i) {
    var l, n, h, c, d;
    if (!this.activeRect || this.store.data.locked)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), (l = this.store.activeAnchor) != null && l.connectTo) {
      const u = this.store.pens[this.store.activeAnchor.connectTo];
      Oe(
        u,
        ye(u, this.store.activeAnchor.anchorId),
        this.store.pens[this.store.activeAnchor.penId],
        this.store.activeAnchor
      );
    }
    let s = (n = this.store.activeAnchor) == null ? void 0 : n.id, o = (c = (h = this.store.pens[this.store.activeAnchor.penId]) == null ? void 0 : h.connectedLines) == null ? void 0 : c.filter((u) => u.anchor === s);
    o && o.length > 0 && o.forEach((u) => {
      const f = this.store.pens[u.lineId];
      Oe(
        this.store.pens[this.store.activeAnchor.penId],
        this.store.activeAnchor,
        f,
        ye(f, u.lineAnchor)
      );
    });
    const a = this.store.active[0];
    xt(a);
    const r = ut(a);
    if (a.lineName === "polyline" && !i.shiftKey)
      nl(a, this.store.activeAnchor, t);
    else {
      let u = 0, f = 0;
      if (a.lineName === "line") {
        let g = a.calculative.worldAnchors.findIndex(
          (v) => v.id === this.store.activeAnchor.id
        );
        g === 0 && (g = 2);
        let y = a.calculative.worldAnchors[g - 1];
        if (i.ctrlKey && i.shiftKey) {
          let v = G(t);
          this.getSpecialAngle(
            v,
            y
          ), u = v.x - this.store.activeAnchor.x, f = v.y - this.store.activeAnchor.y;
        } else if (!i.ctrlKey && i.shiftKey) {
          let v = {
            x: t.x,
            y: y.y
          };
          u = v.x - this.store.activeAnchor.x, f = v.y - this.store.activeAnchor.y;
        } else if (i.ctrlKey && !i.shiftKey) {
          let v = {
            x: y.x,
            y: t.y
          };
          u = v.x - this.store.activeAnchor.x, f = v.y - this.store.activeAnchor.y;
        } else
          u = t.x - this.store.activeAnchor.x, f = t.y - this.store.activeAnchor.y;
      } else
        !i.ctrlKey && i.shiftKey ? (u = t.x - this.store.activeAnchor.x, f = 0) : i.ctrlKey && !i.shiftKey ? (u = 0, f = t.y - this.store.activeAnchor.y) : (u = t.x - this.store.activeAnchor.x, f = t.y - this.store.activeAnchor.y);
      Xe(this.store.activeAnchor, u, f), this.store.hover && this.store.hoverAnchor && this.store.hoverAnchor.penId !== this.store.activeAnchor.penId && (this.store.hoverAnchor.type === ge.Line ? (u = t.x - this.store.activeAnchor.x, f = t.y - this.store.activeAnchor.y, ri(
        this.store.activeAnchor,
        this.store.hoverAnchor,
        this.store
      )) : (u = this.store.hoverAnchor.x - this.store.activeAnchor.x, f = this.store.hoverAnchor.y - this.store.activeAnchor.y), Xe(this.store.activeAnchor, u, f), r.prev = void 0, a.lineName !== "polyline" && ((d = this[a.lineName]) == null || d.call(this, this.store, a)));
    }
    this.patchFlagsLines.add(a), this.store.path2dMap.set(a, rt.path2dDraws[a.name](a)), this.render(), this.store.active[0].calculative && (this.store.active[0].calculative.gradientAnimatePath = void 0), this.store.emitter.emit("moveLineAnchor", {
      pen: this.store.active[0],
      anchor: this.store.activeAnchor
    }), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: it.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 500);
  }
  moveLineAnchorPrev(t) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), this.store.activeAnchor.prev.x = t.x, this.store.activeAnchor.prev.y = t.y, this.store.activeAnchor.next) {
      if (!this.store.activeAnchor.prevNextType)
        this.store.activeAnchor.next.x = t.x, this.store.activeAnchor.next.y = t.y, vt(this.store.activeAnchor.next, 180, this.store.activeAnchor);
      else if (this.store.activeAnchor.prevNextType === De.Bilateral && this.prevAnchor) {
        const s = zt(t, this.store.activeAnchor), o = zt(this.prevAnchor, this.store.activeAnchor);
        this.store.activeAnchor.next.x = this.nextAnchor.x, this.store.activeAnchor.next.y = this.nextAnchor.y, vt(
          this.store.activeAnchor.next,
          s - o,
          this.store.activeAnchor
        );
      }
    }
    const i = this.store.active[0];
    this.patchFlagsLines.add(i), this.store.path2dMap.set(i, rt.path2dDraws[i.name](i)), this.render(), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: it.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  moveLineAnchorNext(t) {
    if (!this.activeRect || this.store.data.locked || !this.store.activeAnchor)
      return;
    if (this.initPens || (this.initPens = G(this.store.active, !0)), this.store.activeAnchor.next.x = t.x, this.store.activeAnchor.next.y = t.y, this.store.activeAnchor.prev) {
      if (!this.store.activeAnchor.prevNextType)
        this.store.activeAnchor.prev.x = t.x, this.store.activeAnchor.prev.y = t.y, vt(this.store.activeAnchor.prev, 180, this.store.activeAnchor);
      else if (this.store.activeAnchor.prevNextType === De.Bilateral && this.nextAnchor) {
        const s = zt(t, this.store.activeAnchor), o = zt(this.nextAnchor, this.store.activeAnchor);
        this.store.activeAnchor.prev.x = this.prevAnchor.x, this.store.activeAnchor.prev.y = this.prevAnchor.y, vt(
          this.store.activeAnchor.prev,
          s - o,
          this.store.activeAnchor
        );
      }
    }
    const i = this.store.active[0];
    this.patchFlagsLines.add(i), this.store.path2dMap.set(i, rt.path2dDraws[i.name](i)), this.render(), this.timer && clearTimeout(this.timer), this.timer = setTimeout(() => {
      this.timer = void 0, this.pushHistory({
        type: it.Update,
        pens: G(this.store.active, !0),
        initPens: this.initPens
      }), this.initPens = void 0;
    }, 200);
  }
  async setAnchor(t) {
    var o;
    const i = [G(this.store.hover, !0)], s = this.store.hover;
    if (this.store.hoverAnchor) {
      if (this.beforeRemoveAnchor && !await this.beforeRemoveAnchor(s, this.store.hoverAnchor))
        return;
      s.type === ft.Line && ((o = s.calculative.worldAnchors) == null ? void 0 : o.length) <= 2 ? this.delete([s]) : (Zr(s, this.store.hoverAnchor), s.type === ft.Line && this.initLineRect(s)), this.store.hoverAnchor = void 0, this.store.activeAnchor = void 0, this.externalElements.style.cursor = "default";
    } else if (s) {
      if (this.beforeAddAnchor && !await this.beforeAddAnchor(s, this.store.pointAt))
        return;
      if (s.type === ft.Line) {
        this.store.activeAnchor = Qr(
          s,
          this.store.pointAt,
          this.store.pointAtIndex
        ), this.initLineRect(s);
        const a = { x: t.x, y: t.y };
        this.getHover(a);
      } else {
        const a = { id: nt(), x: t.x, y: t.y };
        this.store.activeAnchor = Jr(s, a);
      }
    }
    this.hotkeyType = gt.None, this.render(), s && this.pushHistory({
      type: it.Update,
      pens: [G(s, !0)],
      initPens: i
    });
  }
  /**
   * 连线允许移动，若与其它图形有连接，但其它图形不在此次移动中，会断开连接
   * @param line 连线
   * @param pens 本次移动的全部图形，包含子节点
   */
  checkDisconnect(t, i) {
    if (t.id.indexOf(Et) > 0) {
      const s = t.id;
      t = this.store.pens[s.replace(Et, "")];
    }
    t.anchors.forEach((s) => {
      if (s.connectTo && !i.find(
        (o) => o.id === s.connectTo || o.id === s.connectTo + Et
      )) {
        const o = this.store.pens[s.connectTo];
        if (!o || o.type)
          return;
        Oe(o, ye(o, s.anchorId), t, s);
      }
    });
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  translatePens(t = this.store.active, i, s, o) {
    if (!t || !t.length || t.some((n) => {
      if (n.locked >= ht.DisableMove) return !0;
    }))
      return;
    const r = !o && G(t, !0);
    this.activeRect && be(this.activeRect, i, s);
    const l = this.getAllByPens(t);
    t.forEach((n) => {
      var h, c;
      if (!(n.locked >= ht.DisableMove)) {
        if (n.type === ft.Line) {
          if (!this.store.options.moveConnectedLine && !this.canMoveLine || n.isRuleLine)
            return;
          Ms(n, i, s), this.checkDisconnect(n, l), this.store.path2dMap.set(n, rt.path2dDraws[n.name](n)), o || (this.initLineRect(n), (h = n.connectedLines) == null || h.forEach((d) => {
            const u = this.store.pens[d.lineId];
            this.initLineRect(u);
          }));
        } else
          be(n.calculative.worldRect, i, s), this.updatePenRect(n, { worldRectIsReady: !0 }), n.calculative.x = n.x, n.calculative.y = n.y, n.calculative.initRect && (n.calculative.initRect.x = n.calculative.x, n.calculative.initRect.y = n.calculative.y, n.calculative.initRect.ex = n.calculative.x + n.calculative.width, n.calculative.initRect.ey = n.calculative.y + n.calculative.height);
        this.updateLines(n), (c = n.onMove) == null || c.call(n, n);
      }
    }), this.activeRect && this.getSizeCPs(), this.render(), this.tooltip.translate(i, s), o || (this.pushHistory({
      type: it.Update,
      pens: G(t, !0),
      initPens: r
    }), this.initImageCanvas(t), this.initTemplateCanvas(t), this.store.emitter.emit("translatePens", t)), this.store.emitter.emit("translatingPens", t);
  }
  /**
   * 移动 画笔们
   * @param pens 画笔们，不包含子节点
   * @param x 偏移 x
   * @param y 偏移 y
   * @param doing 是否持续移动
   */
  templateTranslatePens(t = this.store.active, i, s) {
    if (!t || !t.length)
      return;
    const o = this.getAllByPens(t);
    t.forEach((a) => {
      var r;
      if (a.type === ft.Line) {
        if (!this.store.options.moveConnectedLine && !this.canMoveLine)
          return;
        Ms(a, i, s), this.checkDisconnect(a, o), this.store.path2dMap.set(a, rt.path2dDraws[a.name](a));
      } else
        be(a.calculative.worldRect, i, s), this.updatePenRect(a, { worldRectIsReady: !0 }), a.calculative.x = a.x, a.calculative.y = a.y, a.calculative.initRect && (a.calculative.initRect.x = a.calculative.x, a.calculative.initRect.y = a.calculative.y, a.calculative.initRect.ex = a.calculative.x + a.calculative.width, a.calculative.initRect.ey = a.calculative.y + a.calculative.height);
      (r = a.onMove) == null || r.call(a, a);
    });
  }
  calcAutoAnchor(t, i, s, o) {
    const a = xt(t), r = ut(t), l = Ne(s, i === a ? r : a);
    l && (i.x = l.x, i.y = l.y, i.prev = void 0, i.next = void 0, o ? o.anchor = l.id : St(s, l, t, i), this[t.lineName] && this[t.lineName](this.store, t), this.store.path2dMap.set(t, rt.path2dDraws.line(t)), this.initLineRect(t));
  }
  restoreNodeAnimate(t) {
    var i, s;
    if (t.calculative.initRect) {
      if (t.keepAnimateState)
        for (const o in t)
          t.calculative[o] !== void 0 && o !== "x" && o !== "y" && o !== "width" && o !== "height" && o !== "initRect" && (typeof t[o] != "object" || o === "lineDash") && (o === "fontSize" || o === "lineWidth" ? t[o] = t.calculative[o] / t.calculative.canvas.store.data.scale : t[o] = t.calculative[o]);
      else {
        const o = t.calculative.initRect.rotate - t.calculative.rotate;
        for (const r in t)
          r !== "x" && r !== "y" && r !== "width" && r !== "height" && r !== "initRect" && r !== "rotate" && (typeof t[r] != "object" || r === "lineDash") && (t.calculative[r] = t[r]);
        (i = t.children) != null && i.length ? o && Wo(t, o, t.calculative.worldRect) : t.calculative.rotate = t.rotate;
        const a = G(this.store.animateMap.get(t));
        a && (a.id = t.id, this.parent.setValue(a, {
          doEvent: !1,
          render: !0,
          history: !1
        })), t.calculative.worldRect = t.calculative.initRect;
      }
      this.updatePenRect(t, { worldRectIsReady: !0 }), this.updateLines(t), t.image && t.name !== "gif" && (this.canvasImage.init(), this.canvasImageBottom.init()), t.calculative.text !== t.text && (t.calculative.text = t.text, ii(t)), (s = this.store.active) != null && s.length && this.calcActiveRect(), t.calculative.initRect = void 0;
    }
  }
  updateLines(t, i) {
    var s;
    (s = t.children) == null || s.forEach((o) => {
      const a = this.store.pens[o];
      a && this.updateLines(a, i);
    }), t.connectedLines && t.connectedLines.forEach((o, a) => {
      const r = this.store.pens[o.lineId];
      if (!r || r.calculative.active)
        return;
      const l = ye(r, o.lineAnchor);
      if (!l)
        return;
      if (!l.connectTo) {
        t.connectedLines.splice(a, 1);
        return;
      }
      if (r.autoFrom) {
        const u = xt(r);
        u.id === l.id && this.calcAutoAnchor(r, u, t, o);
      }
      if (r.autoTo) {
        const u = ut(r);
        u.id === l.id && this.calcAutoAnchor(r, u, t, o);
      }
      const n = ye(t, o.anchor);
      if (!n)
        return;
      let h = t.rotate;
      t.flipX && (h *= -1), t.flipY && (h *= -1);
      let c = l.distance * this.store.data.scale * Math.cos((h + n.rotate) / 180 * Math.PI) || 0, d = l.distance * this.store.data.scale * Math.sin((h + n.rotate) / 180 * Math.PI) || 0;
      if (t.flipX && (c = -c), t.flipY && (d = -d), Xe(
        l,
        n.x - l.x + c,
        n.y - l.y + d
      ), this.store.options.autoPolyline && !this.autoPolylineFlag && r.autoPolyline !== !1 && r.lineName === "polyline") {
        let u = xt(r), f = ut(r), g = !1;
        u.id === l.id ? (u = l, g = !0) : f.id === l.id && (f = l, g = !0), g && (r.calculative.worldAnchors = [u, f], r.calculative.activeAnchor = u, this.polyline(this.store, r, f), this.initLineRect(r));
      }
      this.store.path2dMap.set(r, rt.path2dDraws[r.name](r)), this.patchFlagsLines.add(r), r.calculative.gradientSmooth && (r.calculative.gradientAnimatePath = gs(r)), i && is(r);
    });
  }
  calcActiveRect() {
    const t = this.store.active.filter(
      (i) => (!i.locked || i.locked < ht.DisableMove) && i.visible != !1
    );
    if (t.length)
      t.length === 1 ? (this.activeRect = G(t[0].calculative.worldRect), this.activeRect.rotate = t[0].calculative.rotate || 0, pt(this.activeRect)) : (this.activeRect = jt(t), this.activeRect.rotate = 0);
    else return;
    this.lastRotate = 0, this.getSizeCPs();
  }
  /**
   * 旋转当前画笔包括子节点
   * @param pen 旋转的画笔
   * @param angle 本次的旋转值，加到 pen.calculative.rotate 上
   */
  rotatePen(t, i, s) {
    t.type ? (t.calculative.worldAnchors.forEach((o) => {
      vt(o, i, s.center);
    }), this.initLineRect(t), mi(t)) : (t.calculative.rotate ? t.calculative.rotate += i : t.calculative.rotate = i, vt(t.calculative.worldRect.center, i, s.center), t.parentId ? (t.calculative.worldRect.x = t.calculative.worldRect.center.x - t.calculative.worldRect.width / 2, t.calculative.worldRect.y = t.calculative.worldRect.center.y - t.calculative.worldRect.height / 2, t.x = (t.calculative.worldRect.x - s.x) / s.width, t.y = (t.calculative.worldRect.y - s.y) / s.height) : (t.x = t.calculative.worldRect.center.x - t.width / 2, t.y = t.calculative.worldRect.center.y - t.height / 2), t.rotate = t.calculative.rotate, this.updatePenRect(t), t.children && t.children.forEach((o) => {
      const a = this.store.pens[o];
      this.rotatePen(a, i, t.calculative.worldRect);
    }));
  }
  nextAnimate(t) {
    if (!t)
      return;
    this.store.emitter.emit("animateEnd", t);
    let i;
    t.nextAnimate && (i = this.store.data.pens.filter((s) => s.id === t.nextAnimate || s.tags && s.tags.indexOf(t.nextAnimate) > -1)), i && (i.forEach((s) => {
      var o, a, r, l, n;
      if (s.calculative.pause) {
        const h = Date.now() - s.calculative.pause;
        s.calculative.pause = void 0, s.calculative.frameStart += h, s.calculative.frameEnd += h;
      } else if (s.name === "video")
        s.calculative.media.currentTime = 0, (o = s.calculative.media) == null || o.play(), (a = s.onStartVideo) == null || a.call(s, s);
      else if (s.type || (r = s.frames) != null && r.length || s.animations && s.animations.length) {
        if (s.type) {
          if ((n = s.animations) != null && n.length) {
            const h = G(s.animations[0]);
            delete h.name, h.currentAnimation = 0, this.parent.setValue(
              {
                id: s.id,
                ...h
              },
              {
                doEvent: !1,
                history: !1
              }
            );
          }
        } else {
          if (!s.frames && s.animations && s.animations.length) {
            let h = (l = s.animations) == null ? void 0 : l.findIndex((u) => u.autoPlay), c = h === -1 ? 0 : h;
            const d = G(s.animations[c]);
            delete d.name, d.currentAnimation = c, !s.type && d.frames && (d.showDuration = this.parent.calcAnimateDuration(d)), this.parent.setValue(
              {
                id: s.id,
                ...d
              },
              {
                doEvent: !1,
                history: !1
              }
            );
          }
          this.store.animateMap.set(s, this.getFrameProps(s));
        }
        this.store.animates.add(s);
      }
    }), this.animate());
  }
  getFrameProps(t) {
    let i = {};
    return t.frames && t.frames.forEach((s) => {
      for (let o in s)
        !["duration", "x", "y", "width", "height", "rotate"].includes(
          o
        ) && !i[o] && (i[o] = t[o]);
    }), i;
  }
  animate() {
    this.animateRendering || requestAnimationFrame(() => {
      const t = Date.now();
      if (t - this.lastAnimateRender < this.store.options.animateInterval) {
        this.store.animates.size > 0 && this.animate();
        return;
      }
      this.lastAnimateRender = t, this.animateRendering = !0;
      const i = [];
      let s = !1;
      for (const o of this.store.animates)
        if (!o.calculative.pause) {
          if (o.calculative.active && !o.type && !this.movingPens && (s = !0), !o.type)
            tn(o, t) ? o.calculative.patchFlags && (pt(o.calculative.worldRect), this.updatePenRect(o, {
              worldRectIsReady: !0,
              playingAnimate: !0
            })) : (requestAnimationFrame(() => {
              this.restoreNodeAnimate(o);
            }), i.push(o), this.nextAnimate(o)), this.updateLines(o, !0);
          else if (!sn(o)) {
            if (o.keepAnimateState) {
              for (const a in o)
                o.calculative[a] !== void 0 && a !== "length" && (typeof o[a] != "object" || a === "lineDash") && (a === "lineWidth" ? o[a] = o.calculative[a] / o.calculative.canvas.store.data.scale : o[a] = o.calculative[a]);
              mi(o);
            } else
              for (const a in o)
                (typeof o[a] != "object" || a === "lineDash") && (a === "lineWidth" ? o.calculative[a] = o[a] * o.calculative.canvas.store.data.scale : o.calculative[a] = o[a]);
            i.push(o), this.nextAnimate(o);
          }
          this.patchFlags = !0;
        }
      s && this.calcActiveRect(), i.forEach((o) => {
        this.store.animates.delete(o);
      }), this.render(!1), this.animateRendering = !1, this.animate();
    });
  }
  get clipboardName() {
    return "meta2d-clipboard";
  }
  async copy(t, i = !0) {
    const s = nt(), { origin: o, scale: a } = this.store.data;
    this.store.clipboard = void 0, localStorage.removeItem(this.clipboardName), sessionStorage.setItem("page", s);
    let r = this.getAllByPens(
      G(t || this.store.active, !0)
    );
    r.forEach((n) => {
      n.copyIndex = this.store.data.pens.findIndex(
        (h) => h.id === n.id
      ), n.pathId && (n.path = this.store.data.paths[n.pathId]);
    }), r.sort((n, h) => n.copyIndex - h.copyIndex), r.forEach((n) => {
      delete n.copyIndex;
    });
    const l = {
      meta2d: !0,
      pens: r,
      origin: G(o),
      scale: a,
      page: s,
      initRect: G(this.activeRect),
      offset: 10
    };
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox"))
      try {
        await navigator.clipboard.writeText(JSON.stringify(l));
      } catch {
        localStorage.setItem(this.clipboardName, JSON.stringify(l));
      }
    else
      localStorage.setItem(this.clipboardName, JSON.stringify(l));
    i && this.store.emitter.emit("copy", l.pens);
  }
  cut(t) {
    this.copy(t, !1), this.delete(t), this.store.emitter.emit("cut", t);
  }
  async paste() {
    var l;
    let t, i;
    if (navigator.clipboard && !this.store.options.disableClipboard && !navigator.userAgent.includes("Firefox"))
      try {
        t = await ((l = navigator.clipboard) == null ? void 0 : l.readText());
      } catch {
        t = localStorage.getItem(this.clipboardName);
      }
    else
      t = localStorage.getItem(this.clipboardName);
    if (t) {
      try {
        i = JSON.parse(t);
      } catch (n) {
        console.warn("剪切板数据不是json", n.message);
        return;
      }
      if (!i || !i.meta2d)
        return;
    } else
      return;
    if (this.beforeAddPens && await this.beforeAddPens(i.pens) != !0)
      return;
    let s, o;
    this.store.clipboard && (s = this.store.clipboard.offset + 10, o = this.store.clipboard.pos), this.store.clipboard = G(i), sessionStorage.getItem("page") !== i.page ? (this.store.clipboard.pos = { x: this.mousePos.x, y: this.mousePos.y }, this.store.clipboard.offset = 0) : this.pasteOffset ? (s && (this.store.clipboard.offset = s), o && (this.store.clipboard.pos = o)) : (this.store.clipboard.offset = 0, this.pasteOffset = !0);
    const r = this.store.clipboard.pens.filter((n) => !n.parentId);
    for (const n of r)
      this.pastePen(n, void 0);
    sessionStorage.setItem("page", i.page), this.active(r), this.pushHistory({ type: it.Add, pens: this.store.clipboard.pens }), this.render(), this.store.emitter.emit("add", this.store.clipboard.pens), this.store.emitter.emit("paste", this.store.clipboard.pens);
  }
  /**
   * 获取 pens 列表中的所有节点（包含子节点）
   * @param pens 不包含子节点
   */
  getAllByPens(t) {
    const i = [];
    for (const s of t)
      i.push(...G(Ut(s, this.store), !0));
    return i.concat(t);
  }
  getAllFollowersByPens(t, i = !0) {
    const s = t;
    for (const o of t) {
      let a = us(o, this.store);
      i && (a = G(a, !0));
      for (const r of a)
        s.find((l) => l.id === r.id) || s.push(r);
    }
    return s;
  }
  setFollowers(t = this.store.active) {
    if (t)
      if (t.length < 2)
        t[0].followers = [];
      else {
        let i = t.map((o) => o.id);
        i.pop();
        const s = t[t.length - 1];
        s.followers ? i.forEach((o) => {
          s.followers.includes(o) || s.followers.push(o);
        }) : s.followers = i;
      }
  }
  /**
   * 修改对应连线的 anchors
   * @param oldId 老 id
   * @param pen 节点
   * @param pastePens 本次复制的 pens 包含子节点
   */
  changeLineAnchors(t, i, s) {
    if (Array.isArray(i.connectedLines))
      for (let o = 0; o < i.connectedLines.length; o++) {
        const { lineId: a } = i.connectedLines[o], r = s.find((l) => l.id === a);
        if (r) {
          const l = r.anchors[0], n = r.anchors[r.anchors.length - 1];
          l.connectTo === t && (l.connectTo = i.id), n.connectTo === t && (n.connectTo = i.id);
        } else
          i.connectedLines.splice(o, 1), o--;
      }
  }
  /**
   * 复制连线的过程，修改 与 此线连接 node 的 connectedLines
   * @param oldId 线原 id
   * @param line 线
   * @param pastePens 此处复制的全部 pens (包含子节点)
   */
  changeNodeConnectedLine(t, i, s) {
    var l;
    const o = i.anchors[0], a = i.anchors[i.anchors.length - 1], r = [o, a];
    for (const n of r) {
      const h = n.connectTo;
      if (h) {
        const c = s.find((d) => d.id === h);
        c ? (l = c.connectedLines) == null || l.forEach((d) => {
          d.lineId === t && (d.lineId = i.id, d.lineAnchor = n.id);
        }) : (n.connectTo = void 0, n.prev && (n.prev.connectTo = void 0), n.next && (n.next.connectTo = void 0));
      }
    }
  }
  async delete(t = this.store.active, i = !1, s = !0) {
    if (!t || !t.length || this.beforeRemovePens && await this.beforeRemovePens(t) != !0 || (i || (t = t.filter((a) => !a.locked)), !t || !t.length))
      return;
    const o = [];
    if (this._del(t, o, i), this.initImageCanvas(o), this.initTemplateCanvas(o), this.inactive(), this.clearHover(), this.render(), s) {
      if (o.length === 0) return;
      this.pushHistory({ type: it.Delete, pens: o });
    }
    this.store.emitter.emit("delete", t);
  }
  _del(t, i, s) {
    t && t.forEach((o) => {
      if (o.type && (o.lastConnected = {}), o.parentId)
        if (this.getLockedParent(o)) {
          console.warn("父节点锁定");
          return;
        } else {
          const r = Nt(o), l = r.children.indexOf(o.id);
          r.children.splice(l, 1), i && this.getDelPens(o, i), this.delForce(o);
        }
      else {
        if (!s && o.locked)
          return;
        i && this.getDelPens(o, i), this.delForce(o);
      }
    });
  }
  getDelPens(t, i) {
    if (!t)
      return;
    if (this.store.data.pens.findIndex((o) => o.id === t.id) > -1) {
      const o = this.store.pens[t.id];
      o.calculative.active = void 0, i.push(o);
    }
    t.children && t.children.forEach((o) => {
      this.getDelPens(this.store.pens[o], i);
    });
  }
  getLockedParent(t) {
    if (!t.parentId)
      return !1;
    const i = Nt(t);
    if (i.locked)
      return i;
    this.getLockedParent(i);
  }
  delForce(t) {
    var s;
    if (!t)
      return;
    const i = this.store.data.pens.findIndex((o) => o.id === t.id);
    i > -1 && (this.delConnectedLines(this.store.data.pens[i]), this.store.data.pens.splice(i, 1), this.store.pens[t.id] = void 0, delete this.store.pens[t.id], t.pathId && delete this.store.data.paths[t.pathId]), this.store.animates.delete(t), this.store.animateMap.delete(t), t.children && t.children.forEach((o) => {
      this.delForce(this.store.pens[o]);
    }), (s = t.onDestroy) == null || s.call(t, t);
  }
  delConnectedLines(t) {
    var i;
    if (t.connectedLines)
      for (let s = 0; s < t.connectedLines.length; s++) {
        const { lineId: o, lineAnchor: a } = t.connectedLines[s], r = this.store.pens[o];
        if (r) {
          let l = r.anchors.find((n) => n.id === a);
          (l == null ? void 0 : l.connectTo) === t.id && (l.connectTo = void 0, l.anchorId = void 0, l.prev && (l.prev.connectTo = void 0), l.next && (l.next.connectTo = void 0)), l = ye(r, a), l && (l.connectTo = void 0, l.anchorId = void 0, l.prev && (l.prev.connectTo = void 0), l.next && (l.next.connectTo = void 0));
        }
      }
    t.type && ((i = t.calculative.worldAnchors) == null || i.forEach((s, o) => {
      var r;
      if (!s.connectTo)
        return;
      const a = this.store.pens[s.connectTo];
      a && ((r = a.calculative.worldAnchors) == null || r.forEach((l) => {
        Oe(a, l, t, s);
      }));
    }));
  }
  convertSpecialCharacter(t) {
    var i = { lt: "<", gt: ">", nbsp: " ", amp: "&", quot: '"' };
    return t.replace(/&(lt|gt|nbsp|amp|quot);/gi, function(s, o) {
      return i[o];
    });
  }
  createInput() {
    this.inputParent.classList.add("meta2d-input"), this.inputDiv.classList.add("input-div"), this.inputParent.appendChild(this.inputDiv), this.dropdown.onmouseleave = () => {
      this.store.hover = null;
    }, this.inputParent.appendChild(this.dropdown), this.externalElements.appendChild(this.inputParent), this.inputParent.onmousedown = this.stopPropagation, this.inputDiv.onmousedown = this.stopPropagation, this.inputDiv.contentEditable = "false", this.dropdown.onmousedown = this.stopPropagation;
    let t;
    for (let i = 0; i < document.styleSheets.length; i++)
      document.styleSheets[i].title === "le5le.com" && (t = document.styleSheets[i]);
    if (!t) {
      const i = document.createElement("style");
      i.title = "le5le.com", document.head.appendChild(i), t = i.sheet, t.insertRule(
        ".meta2d-input{display:none;position:absolute;outline:none;align-items: center;}"
      ), t.insertRule(
        ".meta2d-input textarea{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;left:0;top:0}"
      ), t.insertRule(
        ".meta2d-input .right{width:10px;height:10px;flex-shrink:0;border-top: 1px solid;border-right: 1px solid;margin-right: 5px;transition: all .3s cubic-bezier(.645,.045,.355,1);position:absolute;right:1px;}"
      ), t.insertRule(
        ".meta2d-input ul{position:absolute;top:100%;left:-5px;width:calc(100% + 10px);min-height:30px;border-radius: 2px;box-shadow: 0 2px 8px #00000026;list-style-type: none;background-color: #fff;padding: 4px 0;max-height: 105px;overflow-y: auto;}"
      ), t.insertRule(
        ".meta2d-input ul li{padding: 5px 12px;line-height: 22px;white-space: nowrap;cursor: pointer;}"
      ), t.insertRule(".meta2d-input ul li:hover{background: #eeeeee;}"), t.insertRule(".input-div::-webkit-scrollbar {display:none}"), t.insertRule(".input-div{scrollbar-width: none;}"), t.insertRule(
        ".meta2d-input .input-div{resize:none;border:none;outline:none;background:transparent;flex-grow:1;height:100%;width: 100%;left:0;top:0;display:flex;text-align: center;justify-content: center;flex-direction: column;}"
      ), t.insertRule(".input-div div{}");
    }
    this.inputDiv.onfocus = (i) => {
      if (navigator.userAgent.includes("Firefox")) {
        if (!i.target.innerText) {
          let s = this.inputDiv.offsetWidth / 2;
          window.getComputedStyle(this.inputDiv, null).textAlign !== "center" && (s = 0), this.inputDiv.innerHTML = `<br style="margin-left:${s}px;margin-top:4px;" />`;
        }
      } else if (i.target.innerText)
        this.inputDiv.style.paddingTop = "";
      else {
        let s = window.getComputedStyle(this.inputDiv, null);
        s.justifyContent === "center" && (this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(s.lineHeight) / 2}px`);
      }
    }, this.inputDiv.onblur = () => {
      setTimeout(() => {
        this.hideInput();
      }, 300);
    }, this.inputDiv.oninput = (i) => {
      const s = this.store.pens[this.inputDiv.dataset.penId];
      if (s && s.inputType === "number") {
        const o = i.target.innerText, a = o.replace(/[^0-9]/g, "");
        o !== a && (i.preventDefault(), i.target.innerText = a);
      }
      if (navigator.userAgent.includes("Firefox")) {
        if (!i.target.innerText.trim()) {
          let o = this.inputDiv.offsetWidth / 2;
          window.getComputedStyle(this.inputDiv, null).textAlign !== "center" && (o = 0), this.inputDiv.innerHTML = `<br style="margin-left:${o}px;margin-top:4px;" />`;
        }
      } else if (i.target.innerText)
        this.inputDiv.style.paddingTop = "";
      else {
        let o = window.getComputedStyle(this.inputDiv, null);
        o.justifyContent === "center" && (this.inputDiv.style.paddingTop = ` ${this.inputDiv.offsetHeight / 2 - parseFloat(o.lineHeight) / 2}px`);
      }
      this.store.emitter.emit("input", s);
    }, this.inputDiv.onclick = (i) => {
      i.stopPropagation();
      const s = this.store.pens[this.inputDiv.dataset.penId];
      this.dropdown.style.display === "block" ? this.dropdown.style.display = "none" : s != null && s.dropdownList && this.store.data.locked && (this.dropdown.style.display = "block"), this.store.emitter.emit("clickInput", s);
    }, this.inputDiv.onkeyup = (i) => {
      this.setDropdownList(!0);
      const s = this.store.pens[this.inputDiv.dataset.penId];
      this.store.emitter.emit("input", { pen: s, text: i.key }), i.stopPropagation();
    }, this.inputDiv.onkeydown = (i) => {
      i.stopPropagation();
    }, this.inputDiv.onmousedown = this.stopPropagation, this.inputDiv.onwheel = (i) => {
      i.stopPropagation();
    }, this.inputDiv.onpaste = (i) => {
      i.preventDefault();
      let s = "";
      i.clipboardData && i.clipboardData.getData && (s = i.clipboardData.getData("text/plain")), document.execCommand("insertHTML", !1, s);
    };
  }
  clearDropdownList() {
    if (this.dropdown.hasChildNodes())
      for (let t = 0; t < this.dropdown.childNodes.length; t++)
        this.dropdown.childNodes[t].remove(), --t;
  }
  /**
   * 添加一个选项到 dropdown dom 中
   * @param text 选项文字
   * @param index 选项索引
   */
  dropdownAppendOption(t, i) {
    const s = document.createElement("li");
    s.onwheel = this.stopPropagation, s.innerText = t, s.style.overflow = "hidden", s.style.textOverflow = "ellipsis", s.title = t, s.style.zoom = this.store.data.scale, s.onmousedown = this.stopPropagation, s.dataset.i = i + "", s.onclick = this.selectDropdown;
    const o = this.store.pens[this.inputDiv.dataset.penId];
    s.onmouseenter = () => {
      s.style.background = o.dropdownHoverBackground || "#eee", s.style.color = o.dropdownHoverColor || "#bdc7db";
    }, s.onmouseleave = () => {
      s.style.background = o.dropdownBackground || "#fff", s.style.color = o.dropdownColor || "#bdc7db";
    }, this.dropdown.appendChild(s);
  }
  find(t) {
    return this.store.data.pens.filter((i) => i.id == t || i.tags && i.tags.indexOf(t) > -1);
  }
  findOne(t) {
    return this.store.data.pens.find((i) => i.id == t || i.tags && i.tags.indexOf(t) > -1);
  }
  changePenId(t, i) {
    var o, a, r, l, n, h, c;
    if (t === i)
      return;
    const s = this.store.pens[t];
    if (s && !this.store.pens[i]) {
      if (s.id = i, this.store.pens[i] = this.store.pens[t], (o = s.onChangeId) == null || o.call(s, s, t, i), delete this.store.pens[t], s.parentId) {
        const d = this.store.pens[s.parentId], u = (a = d.children) == null ? void 0 : a.findIndex((f) => f === t);
        u !== -1 && ((r = d.children) == null || r.splice(u, 1, i));
      }
      (l = s.children) == null || l.forEach((d) => {
        const u = this.store.pens[d];
        u.parentId = i;
      }), s.type === ft.Line ? this.changeNodeConnectedLine(t, s, this.store.data.pens) : (this.changeLineAnchors(t, s, this.store.data.pens), (n = s.connectedLines) == null || n.forEach(({ lineId: d }) => {
        const u = this.store.pens[d];
        ze(u);
      })), (h = s.anchors) == null || h.forEach((d) => d.penId = i), (c = s.calculative.worldAnchors) == null || c.forEach((d) => d.penId = i);
    }
  }
  updateValue(t, i) {
    var g, y;
    const s = this.getPenRect(t), o = t.name;
    Object.assign(t, i);
    const a = o !== t.name;
    i.newId && this.changePenId(t.id, i.newId);
    let r = !1, l = !1, n = !1, h = !1, c = !1, d = !1, u, f = !1;
    for (const v in i)
      v.indexOf(".") === -1 ? (v === "rotate" ? t.disableRotate ? t.rotate = t.calculative.rotate || 0 : u = t.calculative.rotate || 0 : v === "canvasLayer" || v === "isBottom" || v === "showChild" ? d = !0 : v === "image" && (f = !0), (typeof t[v] != "object" || v === "lineDash") && (!t.disableRotate || v !== "rotate") && (t.calculative[v] = i[v]), Xa.includes(v) && (l = !0), ["name", "borderRadius", "lineSmooth", "close"].includes(v) && (r = !0), Ka.includes(v) && (c = !0), Ga.includes(v) && (n = !0), Ja.includes(v) && (h = !0), t.image && t.name !== "gif" && ["globalAlpha", "flipY", "flipX", "x", "y", "width", "height", "iconWidth", "iconHeight", "imageRatio", "iconLeft", "iconTop", "iconAlign", "rotate"].includes(v) && (f = !0)) : (delete t[v], Ki(t, v, i[v])), v.split(".")[0] === "anchors" && ze(t);
    if (this.setCalculativeByScale(t), a && ((g = t.onDestroy) == null || g.call(t, t), Za(t)), c) {
      const v = {
        x: i.x ?? s.x,
        y: i.y ?? s.y,
        width: i.width ?? s.width,
        height: i.height ?? s.height
      };
      this.setPenRect(t, v, !1), this.updateLines(t, !0), this.store.active && this.store.active.length && t.id === this.store.active[0].id && this.calcActiveRect();
    } else n ? this.updatePenRect(t) : (l && qt(t), h && Ls(this.store.pens, t), r && rt.path2dDraws[t.name] && this.store.path2dMap.set(t, rt.path2dDraws[t.name](t)));
    if (u !== void 0) {
      const v = t.calculative.rotate;
      t.calculative.rotate = u, this.rotatePen(t, v - u, t.calculative.worldRect);
    }
    (i.image || i.backgroundImage || i.strokeImage) && (t.calculative.image = void 0, t.calculative.backgroundImage = void 0, t.calculative.strokeImage = void 0, this.loadImage(t)), i.lineGradientColors && (t.calculative.lineGradient = void 0, t.calculative.gradientColorStop = void 0), i.gradientColors && (t.calculative.gradient = void 0, t.calculative.radialGradient = void 0), i.gradientRadius && (t.calculative.gradient = void 0, t.calculative.radialGradient = void 0), i.animateLineWidth && (t.calculative.gradientAnimatePath = void 0), i.gradientSmooth && (t.calculative.gradientAnimatePath = void 0), d ? (this.canvasImage.init(), this.canvasImageBottom.init()) : f && (t.canvasLayer === void 0 && (t.canvasLayer = dt.CanvasImageBottom, t.calculative.canvasLayer = dt.CanvasImageBottom), t.canvasLayer === dt.CanvasImageBottom ? this.canvasImageBottom.init() : t.canvasLayer === dt.CanvasImage && this.canvasImage.init()), (i.canvasLayer !== void 0 || t.canvasLayer === dt.CanvasTemplate) && this.initTemplateCanvas([t]), i.zIndex !== void 0 && (y = t.calculative.singleton) != null && y.div && Ct(t, t.calculative.singleton.div);
  }
  /**
   * 执行 pen ，以及 pen 的子孙节点的 onResize 生命周期函数
   */
  execPenResize(t) {
    var i, s;
    (i = t.onResize) == null || i.call(t, t), (s = t.children) == null || s.forEach((o) => {
      const a = this.store.pens[o];
      a && this.execPenResize(a);
    });
  }
  setPenRect(t, i, s = !0) {
    if (t.parentId)
      Object.assign(t, i);
    else {
      const { origin: o, scale: a } = this.store.data;
      t.x = o.x + i.x * a, t.y = o.y + i.y * a, t.width = i.width * a, t.height = i.height * a;
    }
    this.updatePenRect(t), this.execPenResize(t), s && this.render();
  }
  getPenRect(t, i = this.store.data.origin, s = this.store.data.scale) {
    if (t)
      return t.parentId ? {
        x: t.x,
        y: t.y,
        width: t.width,
        height: t.height
      } : {
        x: (t.x - i.x) / s,
        y: (t.y - i.y) / s,
        width: t.width / s,
        height: t.height / s
      };
  }
  toPng(t = 2, i, s = !1, o) {
    const a = jt(this.store.data.pens), r = this.store.data.scale;
    if (!isFinite(a.width))
      throw new Error("can not to png, because width is not finite");
    const l = G(a), n = this.store.data, h = s && !n.background && this.store.bkImg;
    let c = !1, d = !1;
    if (h) {
      if (a.x += n.x, a.y += n.y, wt(a), Jt(a, this.canvasRect, !0))
        Object.assign(a, this.canvasRect);
      else {
        const C = Fe([
          ...Zt(a),
          ...Zt(this.canvasRect)
        ]);
        Object.assign(a, C);
      }
      c = a.x === 0, d = a.y === 0;
    }
    const u = this.store.data.width || this.store.options.width, f = this.store.data.height || this.store.options.height;
    let g = !1;
    u && f && !this.store.data.component && (g = !0), g && (a.x = this.store.data.origin.x, a.y = this.store.data.origin.y, a.width = u * this.store.data.scale, a.height = f * this.store.data.scale);
    const y = G(a), v = Xt(t);
    a.x -= v[3] * r, a.y -= v[0] * r, a.width += (v[3] + v[1]) * r, a.height += (v[0] + v[2]) * r;
    const b = (o || 1920) / a.width;
    a.width *= b, a.height *= b, wt(a);
    const x = document.createElement("canvas");
    if (x.width = a.width, x.height = a.height, x.width > 32767 || x.height > 32767 || !navigator.userAgent.includes("Firefox") && x.height * x.width > 268435456 || navigator.userAgent.includes("Firefox") && x.height * x.width > 472907776)
      throw new Error(
        "can not to png, because the size exceeds the browser limit"
      );
    const p = x.getContext("2d");
    p.textBaseline = "middle", p.scale(b, b);
    const k = this.store.data.background || this.store.options.background;
    if (k && (p.save(), p.fillStyle = k, g ? p.fillRect(
      0,
      0,
      y.width + (v[1] + v[3]) * r,
      y.height + (v[0] + v[2]) * r
    ) : p.fillRect(
      0,
      0,
      l.width + (v[3] + v[1]) * r,
      l.height + (v[0] + v[2]) * r
    ), p.restore()), h)
      if (g)
        p.drawImage(
          this.store.bkImg,
          v[3] * r || 0,
          v[0] * r || 0,
          y.width,
          y.height
        );
      else {
        const C = a.x < 0 ? -a.x : 0, R = a.y < 0 ? -a.y : 0;
        p.drawImage(
          this.store.bkImg,
          C,
          R,
          this.canvasRect.width,
          this.canvasRect.height
        );
      }
    h ? g ? p.translate(
      -l.x + v[3] * r || 0,
      -l.y + v[0] * r || 0
    ) : p.translate(
      (c ? n.x : -l.x) + v[3] * r || 0,
      (d ? n.y : -l.y) + v[0] * r || 0
    ) : p.translate(-a.x, -a.y);
    for (const C of this.store.data.pens) {
      if (!Ii(C, this.store) || C.visible == !1)
        continue;
      const { active: R } = C.calculative;
      C.calculative.active = !1, C.calculative.img ? ki(p, C) : ve(p, C, !0), C.calculative.active = R;
    }
    if (i) {
      x.toBlob(i);
      return;
    }
    return x.toDataURL();
  }
  activeToPng(t = 2, i) {
    return this.pensToPng(this.store.active, t, i);
  }
  pensToPng(t = this.store.active, i = 2, s) {
    if (t.length === 0)
      return;
    const o = this.getAllByPens(t);
    let a = o.map((f) => f.id);
    const r = jt(o);
    if (!isFinite(r.width))
      throw new Error("can not to png, because width is not finite");
    const l = G(r), n = Xt(i);
    r.x -= n[3], r.y -= n[0], r.width += n[3] + n[1], r.height += n[0] + n[2], wt(r);
    const h = (s || r.width) / r.width;
    r.width *= h, r.height *= h;
    const c = document.createElement("canvas");
    if (c.width = r.width, c.height = r.height, c.width > 32767 || c.height > 32767 || !navigator.userAgent.includes("Firefox") && c.height * c.width > 268435456 || navigator.userAgent.includes("Firefox") && c.height * c.width > 472907776)
      throw new Error(
        "can not to png, because the size exceeds the browser limit"
      );
    const d = c.getContext("2d");
    d.textBaseline = "middle", d.scale(h, h);
    const u = this.store.data.background || this.store.options.background;
    u && (d.save(), d.fillStyle = u, d.fillRect(
      0,
      0,
      l.width + (n[3] + n[1]),
      l.height + (n[0] + n[2])
    ), d.restore()), d.translate(-l.x + n[3], -l.y + n[0]);
    for (const f of this.store.data.pens)
      if (a.includes(f.id)) {
        if (!Ii(f, this.store) || f.visible == !1)
          continue;
        const { active: g } = f.calculative;
        f.calculative.active = !1, f.calculative.img ? ki(d, f) : ve(d, f), f.calculative.active = g;
      }
    return c.toDataURL();
  }
  toggleAnchorMode() {
    var t;
    if (this.hotkeyType)
      this.hotkeyType === gt.AddAnchor && (this.hotkeyType = gt.None, this.store.hoverAnchor ? this.externalElements.style.cursor = "vertical-text" : this.store.hover && (this.externalElements.style.cursor = "move"));
    else {
      if (this.store.options.disableAnchor || (t = this.store.hover) != null && t.disableAnchor)
        return;
      this.hotkeyType = gt.AddAnchor, this.store.hover && (this.externalElements.style.cursor = "pointer");
    }
    this.patchFlags = !0;
  }
  addAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const t = [G(this.store.active[0], !0)];
      this.store.activeAnchor.prev ? this.store.activeAnchor.next || (this.store.activeAnchor.next = { ...this.store.activeAnchor.prev }, vt(this.store.activeAnchor.next, 180, this.store.activeAnchor), this.initLineRect(this.store.active[0]), this.patchFlags = !0) : (this.store.activeAnchor.next || (this.store.activeAnchor.next = {
        penId: this.store.activeAnchor.penId,
        x: this.store.activeAnchor.x + 50,
        y: this.store.activeAnchor.y
      }), this.store.activeAnchor.prev = { ...this.store.activeAnchor.next }, vt(this.store.activeAnchor.prev, 180, this.store.activeAnchor), this.initLineRect(this.store.active[0]), this.patchFlags = !0), this.pushHistory({
        type: it.Update,
        pens: [G(this.store.active[0], !0)],
        initPens: t
      });
    }
  }
  removeAnchorHand() {
    if (this.store.activeAnchor && this.store.active && this.store.active.length === 1 && this.store.active[0].type) {
      const t = [G(this.store.active[0], !0)];
      this.hoverType === st.LineAnchorPrev ? (this.store.activeAnchor.prev = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0) : this.hoverType === st.LineAnchorNext ? (this.store.activeAnchor.next = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0) : (this.store.activeAnchor.prev = void 0, this.store.activeAnchor.next = void 0, this.initLineRect(this.store.active[0]), this.patchFlags = !0), this.pushHistory({
        type: it.Update,
        pens: [G(this.store.active[0])],
        initPens: t
      });
    }
  }
  toggleAnchorHand() {
    this.store.active.length === 1 && this.store.active[0].type && this.store.activeAnchor && (this.store.activeAnchor.prevNextType || (this.store.activeAnchor.prevNextType = De.Mirror), this.store.activeAnchor.prevNextType = (this.store.activeAnchor.prevNextType + 1) % 3);
  }
  gotoView(t, i) {
    let s = jt(this.store.data.pens);
    if (!isFinite(s.width))
      throw new Error("can not move view, because width is not finite");
    const o = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
    o && a && (s = {
      x: this.store.data.origin.x,
      y: this.store.data.origin.y,
      width: o * this.store.data.scale,
      height: a * this.store.data.scale
    }), this.store.data.x = this.canvas.clientWidth / 2 - t * s.width - s.x, this.store.data.y = this.canvas.clientHeight / 2 - i * s.height - s.y, this.onMovePens(), this.canvasTemplate.init(), this.canvasImage.init(), this.canvasImageBottom.init(), this.render();
  }
  showMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "100", this.externalElements.style.zIndex = "101", this.magnifierCanvas.magnifier = !0, this.magnifierCanvas.updateDomOffscreen(), this.externalElements.style.cursor = "default", this.render();
  }
  hideMagnifier() {
    this.magnifierCanvas.canvas.style.zIndex = "5", this.externalElements.style.zIndex = "5", this.magnifierCanvas.magnifier = !1, this.externalElements.style.cursor = "default", this.render();
  }
  showFit() {
    this.store.data.locked = 0, this.canvasImage.fitFlag = !0, this.canvasImage.activeFit = void 0, this.canvasImage.currentFit = void 0, this.store.data.fits || (this.store.data.fits = []), this.store.data.fits.forEach((t) => t.active = !1), this.canvasImage.init(), this.canvasImage.render();
  }
  hideFit() {
    this.canvasImage.fitFlag = !1, this.canvasImage.activeFit = void 0, this.canvasImage.currentFit = void 0, this.canvasImage.init(), this.canvasImage.render();
  }
  makeFit() {
    if (this.dragRect.width < 100 && this.dragRect.height < 100)
      return;
    const t = this.store.data.pens.filter((h) => {
      if (
        // pen.locked >= LockState.DisableMove || 
        h.parentId || h.isRuleLine
      )
        return !1;
      if (Jt(
        h.calculative.worldRect,
        this.dragRect,
        !0
      ))
        return h.type === ft.Line && !this.store.options.dragAllIn ? Bi(h, this.dragRect) : !0;
    });
    if (!t.length)
      return;
    const i = this.parent.getRect(t), s = this.store.data.scale, o = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
    let r = (Math.floor(i.x) - this.store.data.origin.x) / s / o, l = (Math.floor(i.y) - this.store.data.origin.y) / s / a, n = {
      x: r,
      y: l,
      width: (Math.ceil(i.width) + 1) / s / o,
      height: (Math.ceil(i.height) + 1) / s / a,
      children: t.map((h) => h.id),
      id: nt(),
      active: !0
    };
    n.x < -0.1 && (n.x = -0.1), n.y < -0.1 && (n.y = -0.1), n.width > 0.5 ? (n.left = !0, n.right = !0, n.leftValue = (n.x - 0) * s * o, n.rightValue = (1 - (n.x + n.width)) * s * o) : n.x < 0.5 ? (n.left = !0, n.leftValue = (n.x - 0) * s * o) : (n.right = !0, n.rightValue = (1 - (n.x + n.width)) * s * o), n.leftValue < 1 && (n.leftValue = 0), n.rightValue < 1 && (n.rightValue = 0), n.height > 0.5 ? (n.top = !0, n.bottom = !0, n.topValue = (n.y - 0) * s * a, n.bottomValue = (1 - (n.y + n.height)) * s * a) : n.y < 0.5 ? (n.top = !0, n.topValue = (n.y - 0) * s * a) : (n.bottom = !0, n.bottomValue = (1 - (n.y + n.height)) * s * a), n.topValue < 1 && (n.topValue = 0), n.bottomValue < 1 && (n.bottomValue = 0), this.store.data.fits || (this.store.data.fits = []), this.store.data.fits.forEach((h) => {
      h.active = !1;
    }), this.store.data.fits.push(n), this.canvasImage.activeFit = n, this.store.emitter.emit("fit", n), this.canvasImage.init(), this.canvasImage.render();
  }
  updateFit(t) {
    const i = this.store.data.scale, s = this.store.data.width || this.store.options.width, o = this.store.data.height || this.store.options.height;
    let a = (t.x - this.store.data.origin.x) / i / s, r = (t.y - this.store.data.origin.y) / i / o;
    if (this.canvasImage.currentFit) {
      const l = this.canvasImage.activeFit;
      if (this.canvasImage.currentFit === "top") {
        r < -0.1 && (r = -0.1);
        let c = r - l.y;
        if (l.height -= c, l.height < 0.01) {
          l.height = 0.01;
          return;
        }
        l.y = r;
      }
      if (this.canvasImage.currentFit === "bottom" && (r > 1.1 && (r = 1.1), l.height = r - l.y, l.height <= 0.01 && (l.height = 0.01)), this.canvasImage.currentFit === "left") {
        a < -0.1 && (a = -0.1);
        let c = a - l.x;
        if (l.width -= c, l.width < 0.01) {
          l.width = 0.01;
          return;
        }
        l.x = a;
      }
      this.canvasImage.currentFit === "right" && (a > 1.1 && (a = 1.1), l.width = a - l.x, l.width <= 0.01 && (l.width = 0.01));
      let n = {
        x: l.x * s * i + this.store.data.origin.x,
        y: l.y * o * i + this.store.data.origin.y,
        width: l.width * s * i,
        height: l.height * o * i
      };
      wt(n);
      const h = this.store.data.pens.filter((c) => {
        if (
          // pen.locked >= LockState.DisableMove || 
          c.parentId || c.isRuleLine
        )
          return !1;
        if (Jt(
          c.calculative.worldRect,
          n,
          !0
        ))
          return c.type === ft.Line && !this.store.options.dragAllIn ? Bi(c, n) : !0;
      });
      l.left = void 0, l.leftValue = void 0, l.right = void 0, l.rightValue = void 0, l.top = void 0, l.topValue = void 0, l.bottom = void 0, l.bottomValue = void 0, l.width > 0.5 ? (l.left = !0, l.right = !0, l.leftValue = (l.x - 0) * i * s, l.rightValue = (1 - (l.x + l.width)) * i * s) : l.x < 0.5 ? (l.left = !0, l.leftValue = (l.x - 0) * i * s) : (l.right = !0, l.rightValue = (1 - (l.x + l.width)) * i * s), Math.abs(l.leftValue) < 1 && (l.leftValue = 0), Math.abs(l.rightValue) < 1 && (l.rightValue = 0), l.height > 0.5 ? (l.top = !0, l.bottom = !0, l.topValue = (l.y - 0) * i * o, l.bottomValue = (1 - (l.y + l.height)) * i * o) : l.y < 0.5 ? (l.top = !0, l.topValue = (l.y - 0) * i * o) : (l.bottom = !0, l.bottomValue = (1 - (l.y + l.height)) * i * o), Math.abs(l.topValue) < 1 && (l.topValue = 0), Math.abs(l.bottomValue) < 1 && (l.bottomValue = 0), l.children = h.map((c) => c.id), this.store.emitter.emit("fit", l), this.mouseDown.x = t.x, this.mouseDown.y = t.y, this.canvasImage.init(), this.canvasImage.render();
    }
  }
  updateFitRect(t = this.canvasImage.activeFit) {
    const i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height;
    t.left && (t.leftValue ? t.x = Math.abs(t.leftValue) < 1 ? t.leftValue : t.leftValue / i : t.x = 0), t.right && (t.rightValue ? t.width = 1 - (Math.abs(t.rightValue) < 1 ? t.rightValue : t.rightValue / i) - t.x : t.width = 1 - t.x), t.top && (t.topValue ? t.y = Math.abs(t.topValue) < 1 ? t.topValue : t.topValue / s : t.y = 0), t.bottom && (t.bottomValue ? t.height = 1 - (Math.abs(t.bottomValue) < 1 ? t.bottomValue : t.bottomValue / s) - t.y : t.height = 1 - t.y), this.canvasImage.init(), this.canvasImage.render();
  }
  deleteFit(t = this.canvasImage.activeFit) {
    if (!t)
      return;
    const i = this.store.data.fits.findIndex((s) => s.id === t.id);
    this.store.data.fits.splice(i, 1), this.canvasImage.activeFit = void 0, this.canvasImage.init(), this.canvasImage.render(), this.store.emitter.emit("fit", void 0);
  }
  calcuActiveFit() {
    var l;
    const t = this.store.data.width || this.store.options.width, i = this.store.data.height || this.store.options.height;
    let s = (this.mouseDown.x - this.store.data.origin.x) / this.store.data.scale / t, o = (this.mouseDown.y - this.store.data.origin.y) / this.store.data.scale / i, a = -1, r = -1;
    (l = this.store.data.fits) == null || l.forEach((n, h) => {
      n.ex = null, n.ey = null, oe({ x: s, y: o }, n) && (a = h), n.active && (r = h);
    }), a !== -1 && a !== r ? (this.canvasImage.activeFit = this.store.data.fits[a], this.store.data.fits[a].active = !0, r !== -1 && (this.store.data.fits[r].active = !1), this.store.emitter.emit("fit", this.store.data.fits[a])) : a === -1 && r !== -1 && (this.store.data.fits[r].active = !1, this.store.emitter.emit("fit", void 0), this.canvasImage.activeFit = null), this.inactive(), this.canvasImage.init(), this.canvasImage.render();
  }
  toggleMagnifier() {
    this.magnifierCanvas.magnifier = !this.magnifierCanvas.magnifier, this.magnifierCanvas.magnifier && (this.externalElements.style.cursor = "default"), this.render();
  }
  destroy() {
    var t, i, s, o;
    switch (this.scroll && this.scroll.destroy(), (t = this.tooltip) == null || t.destroy(), (i = this.dialog) == null || i.destroy(), (s = this.title) == null || s.destroy(), (o = this.popconfirm) == null || o.destroy(), this.externalElements.removeEventListener(
      "gesturestart",
      this.onGesturestart
    ), this.externalElements.ondragover = (a) => a.preventDefault(), this.externalElements.ondrop = void 0, this.externalElements.ontouchstart = void 0, this.externalElements.ontouchmove = void 0, this.externalElements.ontouchend = void 0, this.externalElements.onmousedown = void 0, this.externalElements.onmousemove = void 0, this.externalElements.onmouseup = void 0, this.externalElements.onmouseleave = void 0, this.externalElements.ondblclick = void 0, this.store.options.keydown) {
      case Ue.Document:
        document.removeEventListener("keydown", this.onkeydown), document.removeEventListener("keyup", this.onkeyup);
        break;
      case Ue.Canvas:
        this.externalElements.removeEventListener("keydown", this.onkeydown), this.externalElements.removeEventListener("keyup", this.onkeyup);
        break;
    }
    document.removeEventListener("copy", this.onCopy), document.removeEventListener("cut", this.onCut), document.removeEventListener("paste", this.onPaste), window && window.removeEventListener("message", this.onMessage), window && window.removeEventListener("resize", this.onResize), window && window.removeEventListener("scroll", this.onScroll), this.parentElement.innerHTML = "";
  }
}
function Tl(e, t) {
  const i = t || new Path2D();
  e.onDestroy || (e.onDestroy = Pl, e.onMove = Qs, e.onRotate = Qs, e.onMouseEnter = El, e.onMouseLeave = _l, e.onMouseMove = Ml, e.onMouseUp = Ll, e.onInput = Rl);
  let s = e.calculative.borderRadius || 0, o = s;
  const { x: a, y: r, width: l, height: n, ex: h, ey: c } = e.calculative.worldRect, { x: d } = e.calculative.worldTextRect;
  s < 1 && (s = l * s, o = n * o);
  let u = s < o ? s : o;
  l < 2 * u && (u = l / 2), n < 2 * u && (u = n / 2);
  const f = Cl(e.text, e.calculative.fontSize);
  if (i.moveTo(a + u, r), i.lineTo(d - 5, r), i.moveTo(d + f + 5, r), i.lineTo(d + f + 5, r), i.arcTo(h, r, h, c, u), i.arcTo(h, c, a, c, u), i.arcTo(a, c, a, r, u), i.arcTo(a, r, h, r, u), i instanceof Path2D)
    return i;
}
function Cl(e, t) {
  const i = e.match(/[^\x00-\xff]/g) || "", s = i.length * t, o = e.match(/\s/g) || "", a = o.length * t * 0.3, r = (e.length - i.length - o.length) * t * 0.6;
  return s + a + r;
}
function Rl(e, t) {
  e.text = t, e.calculative.text = e.text, e.calculative.canvas.updatePenRect(e);
}
function Pl(e) {
}
function Qs(e) {
}
function El(e) {
}
function _l(e) {
  const t = e.calculative.canvas.store.active;
  t && t.length && t.forEach((i) => {
    if (e.followers) {
      let s = e.followers.findIndex((o) => o === i.id);
      if (s !== -1) {
        const o = e.calculative.canvas.store.pens[i.id + Et];
        o && o.calculative && (Jt(
          o.calculative.worldRect,
          e.calculative.worldRect,
          !0
        ) || e.followers.splice(s, 1));
      }
    }
  });
}
function Ll(e) {
  const t = e.calculative.canvas.store.active;
  t && t.length && t.forEach((i) => {
    const s = e.calculative.canvas.store.pens[i.id + Et];
    if (s && s.calculative) {
      let o = G(e.calculative.worldRect);
      o.x -= 1, o.y -= 1, o.width += 2, o.height += 2, Jt(s.calculative.worldRect, o, !0) && (e.followers || (e.followers = []), e.followers.includes(i.id) || e.followers.push(i.id));
    }
  });
}
function Ml(e, t) {
}
const At = {};
function Nl(e) {
  e.onDestroy || (e.onDestroy = Ol, e.onMove = Zs, e.onResize = Dl, e.onRotate = Zs, e.onValue = Bl, e.onChangeId = zl);
  const t = new Path2D();
  if (e.image) {
    if (!At[e.id]) {
      const i = new Image();
      i.crossOrigin = "anonymous", i.src = e.image, e.calculative.canvas.parent.store.options.cdn && !(e.image.startsWith("http") || e.image.startsWith("//") || e.image.startsWith("data:image")) && (i.src = e.calculative.canvas.parent.store.options.cdn + e.image), At[e.id] = i, i.onload = () => {
        var s;
        At[e.id] === i && (e.calculative.img = i, e.calculative.imgNaturalWidth = i.naturalWidth || e.iconWidth, e.calculative.imgNaturalHeight = i.naturalHeight || e.iconHeight, (s = e.calculative.canvas.externalElements) == null || s.parentElement.appendChild(i), ti(e, i));
      };
    }
    return e.calculative.patchFlags && At[e.id] && ti(e, At[e.id]), t;
  }
}
function Ol(e) {
  At[e.id] && (At[e.id].remove(), At[e.id] = void 0);
}
function Zs(e) {
  At[e.id] && ti(e, At[e.id]);
}
function Dl(e) {
  At[e.id] && ti(e, At[e.id]);
}
function Bl(e) {
  At[e.id] && (ti(e, At[e.id]), At[e.id].getAttribute("src") !== e.image && (At[e.id].src = e.image));
}
function zl(e, t, i) {
  At[t] && (At[i] = At[t], delete At[t]);
}
function ti(e, t) {
  t.style.objectFit = e.imageRatio ? "contain" : "fill", Ct(e, t);
}
function Hl(e, t) {
  return e.onResize || (e.onResize = sa, e.onValue = Fl), ke(e, t);
}
function sa(e) {
  const t = e.anchors.filter((i) => i.flag !== 1);
  oa(e), e.anchors = e.anchors.concat(...t);
}
function Fl(e) {
  sa(e), ze(e);
}
function oa(e) {
  const t = [], { x: i, y: s, width: o, height: a } = e, r = Wl(e), l = 5;
  for (let d = 0; d < l; d++) {
    if (d === 2)
      continue;
    let u = i + o * (d + 1) / (l + 1), f = s;
    u < i + r ? f = fi(i + r, f + r, u, r, -1) : u > i + o - r && (f = fi(i + o - r, f + r, u, r, -1)), t.push({
      id: String(t.length),
      flag: 1,
      penId: e.id,
      x: (u - i) / o,
      y: (f - s) / a
    });
  }
  const n = 3;
  for (let d = 0; d < n; d++) {
    let u = s + a * (d + 1) / (n + 1), f = i + o;
    u < s + r ? f = ui(f - r, s + r, u, r) : u > s + a - r && (f = ui(f - r, s + a - r, u, r)), t.push({
      id: String(t.length),
      flag: 1,
      penId: e.id,
      x: (f - i) / o,
      y: (u - s) / a
    });
  }
  const h = 5;
  for (let d = 0; d < h; d++) {
    if (d === 2)
      continue;
    let u = i + o * (d + 1) / (h + 1), f = s + a;
    u < i + r ? f = fi(i + r, f - r, u, r) : u > i + o - r && (f = fi(i + o - r, f - r, u, r)), t.push({
      id: String(t.length),
      flag: 1,
      penId: e.id,
      x: (u - i) / o,
      y: (f - s) / a
    });
  }
  const c = 3;
  for (let d = 0; d < c; d++) {
    let u = s + a * (d + 1) / (c + 1), f = i;
    u < s + r ? f = ui(f + r, s + r, u, r, -1) : u > s + a - r && (f = ui(f + r, s + a - r, u, r, -1)), t.push({
      id: String(t.length),
      flag: 1,
      penId: e.id,
      x: (f - i) / o,
      y: (u - s) / a
    });
  }
  e.anchors = t;
}
function Wl(e) {
  let t = e.calculative.borderRadius || 0, i = e.calculative.borderRadius || 0;
  const { width: s, height: o } = e;
  e.calculative.borderRadius < 1 && (t = s * e.calculative.borderRadius, i = o * e.calculative.borderRadius);
  let a = t < i ? t : i;
  return s < 2 * a && (a = s / 2), o < 2 * a && (a = o / 2), a;
}
function ui(e, t, i, s, o = 1) {
  return o * Math.sqrt(s ** 2 - (i - t) ** 2) + e;
}
function fi(e, t, i, s, o = 1) {
  return o * Math.sqrt(s ** 2 - (i - e) ** 2) + t;
}
function jl(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.moveTo(s, o + r), i.lineTo(s + a, o + r), i.closePath(), i instanceof Path2D) return i;
}
function Vl(e) {
  const t = [
    {
      x: 0,
      y: 1
    },
    {
      x: 1,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: o + "",
    x: i,
    y: s,
    penId: e.id
  }));
}
function Ul() {
  return {
    rectangle: ke,
    square: Ya,
    circle: $a,
    svgPath: En,
    diamond: _n,
    triangle: Ln,
    pentagon: Nn,
    pentagram: Dn,
    hexagon: zn,
    leftArrow: Hn,
    rightArrow: Fn,
    twowayArrow: Wn,
    message: jn,
    cloud: Vn,
    file: Un,
    people: Yn,
    line: Gn,
    iframe: ul,
    video: ml,
    gif: Nl,
    mindNode: Hl,
    mindLine: jl,
    mindNode2: ke,
    panel: Tl,
    combine: ke
  };
}
function ql() {
  return {
    triangle: Mn,
    pentagon: On,
    pentagram: Yo,
    mindNode: oa,
    mindLine: Vl
  };
}
var It = /* @__PURE__ */ ((e) => (e[e.Link = 0] = "Link", e[e.SetProps = 1] = "SetProps", e[e.StartAnimate = 2] = "StartAnimate", e[e.PauseAnimate = 3] = "PauseAnimate", e[e.StopAnimate = 4] = "StopAnimate", e[e.JS = 5] = "JS", e[e.GlobalFn = 6] = "GlobalFn", e[e.Emit = 7] = "Emit", e[e.StartVideo = 8] = "StartVideo", e[e.PauseVideo = 9] = "PauseVideo", e[e.StopVideo = 10] = "StopVideo", e[e.SendPropData = 11] = "SendPropData", e[e.SendVarData = 12] = "SendVarData", e[e.Navigator = 13] = "Navigator", e[e.Dialog = 14] = "Dialog", e[e.SendData = 15] = "SendData", e[e.PostMessage = 16] = "PostMessage", e[e.PostMessageToParent = 17] = "PostMessageToParent", e[e.Message = 18] = "Message", e))(It || {});
class Yl {
  // 可视区域外框
  constructor(t) {
    O(this, "box");
    O(this, "boxWidth", 320);
    O(this, "boxHeight", 180);
    O(this, "ratio", this.boxWidth / this.boxHeight);
    O(this, "padding", 5);
    O(this, "img");
    O(this, "isShow");
    O(this, "isDown");
    O(this, "view");
    O(this, "onMouseDown", (t) => {
      t.preventDefault(), t.stopPropagation(), this.isDown = !0;
    });
    O(this, "onMouseMove", (t) => {
      if (t.preventDefault(), t.stopPropagation(), this.isDown)
        try {
          this.parent.gotoView(
            t.offsetX / this.box.clientWidth,
            t.offsetY / this.box.clientHeight
          );
        } catch (i) {
          console.warn(i.message), this.isDown = !1;
        }
    });
    O(this, "onMouseUp", (t) => {
      t.preventDefault(), t.stopPropagation();
      try {
        this.parent.gotoView(
          t.offsetX / this.box.clientWidth,
          t.offsetY / this.box.clientHeight
        );
      } catch (i) {
        console.warn(i.message);
      } finally {
        this.isDown = !1;
      }
    });
    O(this, "onWheel", (t) => {
      let i = 0.015;
      if (this.parent.store.options.scaleOff)
        i = this.parent.store.options.scaleOff, t.deltaY > 0 && (i = -this.parent.store.options.scaleOff);
      else if (/mac os /i.test(navigator.userAgent))
        t.ctrlKey ? t.deltaY > 0 && (i *= -1) : i *= t.wheelDeltaY / 240;
      else {
        let n = 0.2;
        t.deltaY.toString().indexOf(".") !== -1 && (n = 0.01), t.deltaY > 0 ? i = -n : i = n;
      }
      let { offsetX: s, offsetY: o } = t;
      const a = this.parent.store.data.width || this.parent.store.options.width, r = this.parent.store.data.height || this.parent.store.options.height;
      if (a && r)
        s = s / this.boxWidth * a * this.parent.store.data.scale + this.parent.store.data.origin.x + this.parent.store.data.x, o = o / this.boxHeight * r * this.parent.store.data.scale + this.parent.store.data.origin.y + this.parent.store.data.y;
      else {
        const l = this.parent.parent.getRect();
        s = s / this.boxWidth * l.width + l.x + this.parent.store.data.x, o = o / this.boxHeight * l.height + l.y + this.parent.store.data.y;
      }
      this.parent.scale(this.parent.store.data.scale + i, { x: s, y: o });
    });
    var s;
    this.parent = t, this.box = document.createElement("div"), this.img = new Image(), this.view = document.createElement("div"), this.box.appendChild(this.img), this.box.appendChild(this.view), (s = this.parent.externalElements) == null || s.parentElement.appendChild(this.box), this.box.className = "meta2d-map", this.box.onmousedown = this.onMouseDown, this.box.onmousemove = this.onMouseMove, this.box.onmouseup = this.onMouseUp, this.box.onwheel = this.onWheel;
    let i;
    for (let o = 0; o < document.styleSheets.length; o++)
      document.styleSheets[o].title === "le5le/map" && (i = document.styleSheets[o]);
    if (!i) {
      let o = document.createElement("style");
      o.type = "text/css", o.title = "le5le.com/map", document.head.appendChild(o), o = document.createElement("style"), o.type = "text/css", document.head.appendChild(o), i = o.sheet, i.insertRule(
        `.meta2d-map{display:flex;width:${this.boxWidth + 2 * this.padding}px;height:${this.boxHeight + 2 * this.padding}px;padding:${this.padding}px;background:#f4f4f4;border:1px solid #ffffff;box-shadow: 0px 0px 14px 0px rgba(0,10,38,0.30);border-radius:8px;position:absolute;z-index:9999;right:0;bottom:0;justify-content:center;align-items:center;cursor:default;user-select:none;overflow: hidden;}`
      ), i.insertRule(
        ".meta2d-map img{max-width:100%;max-height:100%;pointer-events: none;}"
      ), i.insertRule(
        ".meta2d-map div{pointer-events: none;border:1px solid #1890ff;position:absolute}"
      );
    }
  }
  show() {
    this.box.style.display = "flex", this.parent.store.data.pens.length ? (this.img.style.display = "block", this.img.src = this.parent.toPng(), this.setView()) : this.img.style.display = "none", this.isShow = !0;
  }
  hide() {
    this.box.style.display = "none", this.isShow = !1;
  }
  setView() {
    const t = this.parent.store.data;
    if (t.pens.length) {
      let i = jt(t.pens);
      const s = this.parent.store.data.width || this.parent.store.options.width, o = this.parent.store.data.height || this.parent.store.options.height;
      if (s && o && (i = {
        x: this.parent.store.data.origin.x,
        y: this.parent.store.data.origin.y,
        width: s * this.parent.store.data.scale,
        height: o * this.parent.store.data.scale
      }), be(i, t.x, t.y), i.width / i.height > this.ratio) {
        const d = i.width / this.ratio;
        i.y -= (d - i.height) / 2, i.height = d, wt(i);
      } else {
        const d = i.height * this.ratio;
        i.x -= (d - i.width) / 2, i.width = d, wt(i);
      }
      const r = this.parent.canvasRect;
      let l = 0, n = 0;
      if (i.x < 0)
        l = -i.x / i.width;
      else if (i.x + i.width > r.width) {
        let d = 0;
        r.width > i.width && (d = r.width - i.width), l = (-i.x + d) / i.width;
      }
      if (i.y < 0)
        n = -i.y / i.height;
      else if (i.y + i.height > r.height) {
        let d = 0;
        r.height > i.height && (d = r.height - i.height), n = (-i.y + d) / i.height;
      }
      const h = r.width > i.width ? 1 : r.width / i.width, c = r.height > i.height ? 1 : r.height / i.height;
      this.view.style.left = this.padding + l * this.boxWidth + "px", this.view.style.width = h * this.boxWidth + "px", this.view.style.top = this.padding + n * this.boxHeight + "px", this.view.style.height = c * this.boxHeight + "px";
    }
  }
}
var Vt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function mf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function gi(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var aa = { exports: {} };
(function(e, t) {
  (function(i) {
    e.exports = i();
  })(function() {
    return (/* @__PURE__ */ function() {
      return function i(s, o, a) {
        function r(h, c) {
          if (!o[h]) {
            if (!s[h]) {
              var d = typeof gi == "function" && gi;
              if (!c && d) return d(h, !0);
              if (l) return l(h, !0);
              var u = new Error("Cannot find module '" + h + "'");
              throw u.code = "MODULE_NOT_FOUND", u;
            }
            var f = o[h] = { exports: {} };
            s[h][0].call(f.exports, function(g) {
              return r(s[h][1][g] || g);
            }, f, f.exports, i, s, o, a);
          }
          return o[h].exports;
        }
        for (var l = typeof gi == "function" && gi, n = 0; n < a.length; n++) r(a[n]);
        return r;
      };
    }())({ 1: [function(i, s, o) {
      (function(a, r) {
        (function() {
          const l = i("events").EventEmitter, n = i("./store"), h = i("./topic-alias-recv"), c = i("./topic-alias-send"), d = i("mqtt-packet"), u = i("./default-message-id-provider"), f = i("readable-stream").Writable, g = i("inherits"), y = i("reinterval"), v = i("rfdc/default"), b = i("./validations"), x = i("xtend"), p = i("debug")("mqttjs:client"), k = a ? a.nextTick : function(S) {
            setTimeout(S, 0);
          }, C = r.setImmediate || function(S) {
            k(S);
          }, R = { keepalive: 60, reschedulePings: !0, protocolId: "MQTT", protocolVersion: 4, reconnectPeriod: 1e3, connectTimeout: 3e4, clean: !0, resubscribe: !0 }, P = { 0: "", 1: "Unacceptable protocol version", 2: "Identifier rejected", 3: "Server unavailable", 4: "Bad username or password", 5: "Not authorized", 16: "No matching subscribers", 17: "No subscription existed", 128: "Unspecified error", 129: "Malformed Packet", 130: "Protocol Error", 131: "Implementation specific error", 132: "Unsupported Protocol Version", 133: "Client Identifier not valid", 134: "Bad User Name or Password", 135: "Not authorized", 136: "Server unavailable", 137: "Server busy", 138: "Banned", 139: "Server shutting down", 140: "Bad authentication method", 141: "Keep Alive timeout", 142: "Session taken over", 143: "Topic Filter invalid", 144: "Topic Name invalid", 145: "Packet identifier in use", 146: "Packet Identifier not found", 147: "Receive Maximum exceeded", 148: "Topic Alias invalid", 149: "Packet too large", 150: "Message rate too high", 151: "Quota exceeded", 152: "Administrative action", 153: "Payload format invalid", 154: "Retain not supported", 155: "QoS not supported", 156: "Use another server", 157: "Server moved", 158: "Shared Subscriptions not supported", 159: "Connection rate exceeded", 160: "Maximum connect time", 161: "Subscription Identifiers not supported", 162: "Wildcard Subscriptions not supported" };
          function E(S, _) {
            let B;
            _.properties && (B = _.properties.topicAlias);
            let j = _.topic.toString();
            if (j.length === 0) {
              if (B === void 0) return new Error("Unregistered Topic Alias");
              if ((j = S.topicAliasSend.getTopicByAlias(B)) === void 0) return new Error("Unregistered Topic Alias");
              _.topic = j;
            }
            B && delete _.properties.topicAlias;
          }
          function H(S, _, B) {
            p("sendPacket :: packet: %O", _), p("sendPacket :: emitting `packetsend`"), S.emit("packetsend", _), p("sendPacket :: writing to stream");
            const j = d.writeToStream(_, S.stream, S.options);
            p("sendPacket :: writeToStream result %s", j), !j && B && B !== A ? (p("sendPacket :: handle events on `drain` once through callback."), S.stream.once("drain", B)) : B && (p("sendPacket :: invoking cb"), B());
          }
          function $(S, _, B, j) {
            p("storeAndSend :: store packet with cmd %s to outgoingStore", _.cmd);
            let X, z = _;
            if (z.cmd === "publish" && (z = v(_), X = E(S, z))) return B && B(X);
            S.outgoingStore.put(z, function(M) {
              if (M) return B && B(M);
              j(), H(S, _, B);
            });
          }
          function A(S) {
            p("nop ::", S);
          }
          function I(S, _) {
            let B;
            const j = this;
            if (!(this instanceof I)) return new I(S, _);
            for (B in this.options = _ || {}, R) this.options[B] === void 0 ? this.options[B] = R[B] : this.options[B] = _[B];
            p("MqttClient :: options.protocol", _.protocol), p("MqttClient :: options.protocolVersion", _.protocolVersion), p("MqttClient :: options.username", _.username), p("MqttClient :: options.keepalive", _.keepalive), p("MqttClient :: options.reconnectPeriod", _.reconnectPeriod), p("MqttClient :: options.rejectUnauthorized", _.rejectUnauthorized), p("MqttClient :: options.topicAliasMaximum", _.topicAliasMaximum), this.options.clientId = typeof _.clientId == "string" ? _.clientId : "mqttjs_" + Math.random().toString(16).substr(2, 8), p("MqttClient :: clientId", this.options.clientId), this.options.customHandleAcks = _.protocolVersion === 5 && _.customHandleAcks ? _.customHandleAcks : function() {
              arguments[3](0);
            }, this.streamBuilder = S, this.messageIdProvider = this.options.messageIdProvider === void 0 ? new u() : this.options.messageIdProvider, this.outgoingStore = _.outgoingStore || new n(), this.incomingStore = _.incomingStore || new n(), this.queueQoSZero = _.queueQoSZero === void 0 || _.queueQoSZero, this._resubscribeTopics = {}, this.messageIdToTopic = {}, this.pingTimer = null, this.connected = !1, this.disconnecting = !1, this.queue = [], this.connackTimer = null, this.reconnectTimer = null, this._storeProcessing = !1, this._packetIdsDuringStoreProcessing = {}, this._storeProcessingQueue = [], this.outgoing = {}, this._firstConnection = !0, _.topicAliasMaximum > 0 && (_.topicAliasMaximum > 65535 ? p("MqttClient :: options.topicAliasMaximum is out of range") : this.topicAliasRecv = new h(_.topicAliasMaximum)), this.on("connect", function() {
              const X = this.queue;
              p("connect :: sending queued packets"), function z() {
                const M = X.shift();
                p("deliver :: entry %o", M);
                let D = null;
                if (!M) return void j._resubscribe();
                D = M.packet, p("deliver :: call _sendPacket for %o", D);
                let W = !0;
                D.messageId && D.messageId !== 0 && (j.messageIdProvider.register(D.messageId) || (W = !1)), W ? j._sendPacket(D, function(N) {
                  M.cb && M.cb(N), z();
                }) : (p("messageId: %d has already used. The message is skipped and removed.", D.messageId), z());
              }();
            }), this.on("close", function() {
              p("close :: connected set to `false`"), this.connected = !1, p("close :: clearing connackTimer"), clearTimeout(this.connackTimer), p("close :: clearing ping timer"), j.pingTimer !== null && (j.pingTimer.clear(), j.pingTimer = null), this.topicAliasRecv && this.topicAliasRecv.clear(), p("close :: calling _setupReconnect"), this._setupReconnect();
            }), l.call(this), p("MqttClient :: setting up stream"), this._setupStream();
          }
          g(I, l), I.prototype._setupStream = function() {
            const S = this, _ = new f(), B = d.parser(this.options);
            let j = null;
            const X = [];
            function z() {
              if (X.length) k(M);
              else {
                const W = j;
                j = null, W();
              }
            }
            function M() {
              p("work :: getting next packet in queue");
              const W = X.shift();
              if (W) p("work :: packet pulled from queue"), S._handlePacket(W, z);
              else {
                p("work :: no packets in queue");
                const N = j;
                j = null, p("work :: done flag is %s", !!N), N && N();
              }
            }
            p("_setupStream :: calling method to clear reconnect"), this._clearReconnect(), p("_setupStream :: using streamBuilder provided to client to create stream"), this.stream = this.streamBuilder(this), B.on("packet", function(W) {
              p("parser :: on packet push to packets array."), X.push(W);
            }), _._write = function(W, N, U) {
              j = U, p("writable stream :: parsing buffer"), B.parse(W), M();
            }, p("_setupStream :: pipe stream to writable stream"), this.stream.pipe(_), this.stream.on("error", function(W) {
              p("streamErrorHandler :: error", W.message), W.code ? (p("streamErrorHandler :: emitting error"), S.emit("error", W)) : A(W);
            }), this.stream.on("close", function() {
              var W;
              p("(%s)stream :: on close", S.options.clientId), (W = S.outgoing) && (p("flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function"), Object.keys(W).forEach(function(N) {
                W[N].volatile && typeof W[N].cb == "function" && (W[N].cb(new Error("Connection closed")), delete W[N]);
              })), p("stream: emit close to MqttClient"), S.emit("close");
            }), p("_setupStream: sending packet `connect`");
            const D = Object.create(this.options);
            if (D.cmd = "connect", this.topicAliasRecv && (D.properties || (D.properties = {}), this.topicAliasRecv && (D.properties.topicAliasMaximum = this.topicAliasRecv.max)), H(this, D), B.on("error", this.emit.bind(this, "error")), this.options.properties) {
              if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) return S.end(() => this.emit("error", new Error("Packet has no Authentication Method"))), this;
              this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket == "object" && H(this, x({ cmd: "auth", reasonCode: 0 }, this.options.authPacket));
            }
            this.stream.setMaxListeners(1e3), clearTimeout(this.connackTimer), this.connackTimer = setTimeout(function() {
              p("!!connectTimeout hit!! Calling _cleanUp with force `true`"), S._cleanUp(!0);
            }, this.options.connectTimeout);
          }, I.prototype._handlePacket = function(S, _) {
            const B = this.options;
            if (B.protocolVersion === 5 && B.properties && B.properties.maximumPacketSize && B.properties.maximumPacketSize < S.length) return this.emit("error", new Error("exceeding packets size " + S.cmd)), this.end({ reasonCode: 149, properties: { reasonString: "Maximum packet size was exceeded" } }), this;
            switch (p("_handlePacket :: emitting packetreceive"), this.emit("packetreceive", S), S.cmd) {
              case "publish":
                this._handlePublish(S, _);
                break;
              case "puback":
              case "pubrec":
              case "pubcomp":
              case "suback":
              case "unsuback":
                this._handleAck(S), _();
                break;
              case "pubrel":
                this._handlePubrel(S, _);
                break;
              case "connack":
                this._handleConnack(S), _();
                break;
              case "auth":
                this._handleAuth(S), _();
                break;
              case "pingresp":
                this._handlePingresp(S), _();
                break;
              case "disconnect":
                this._handleDisconnect(S), _();
            }
          }, I.prototype._checkDisconnecting = function(S) {
            return this.disconnecting && (S && S !== A ? S(new Error("client disconnecting")) : this.emit("error", new Error("client disconnecting"))), this.disconnecting;
          }, I.prototype.publish = function(S, _, B, j) {
            p("publish :: message `%s` to topic `%s`", _, S);
            const X = this.options;
            if (typeof B == "function" && (j = B, B = null), B = x({ qos: 0, retain: !1, dup: !1 }, B), this._checkDisconnecting(j)) return this;
            const z = this, M = function() {
              let D = 0;
              if ((B.qos === 1 || B.qos === 2) && (D = z._nextId()) === null) return p("No messageId left"), !1;
              const W = { cmd: "publish", topic: S, payload: _, qos: B.qos, retain: B.retain, messageId: D, dup: B.dup };
              switch (X.protocolVersion === 5 && (W.properties = B.properties), p("publish :: qos", B.qos), B.qos) {
                case 1:
                case 2:
                  z.outgoing[W.messageId] = { volatile: !1, cb: j || A }, p("MqttClient:publish: packet cmd: %s", W.cmd), z._sendPacket(W, void 0, B.cbStorePut);
                  break;
                default:
                  p("MqttClient:publish: packet cmd: %s", W.cmd), z._sendPacket(W, j, B.cbStorePut);
              }
              return !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !M()) && this._storeProcessingQueue.push({ invoke: M, cbStorePut: B.cbStorePut, callback: j }), this;
          }, I.prototype.subscribe = function() {
            const S = this, _ = new Array(arguments.length);
            for (let q = 0; q < arguments.length; q++) _[q] = arguments[q];
            const B = [];
            let j = _.shift();
            const X = j.resubscribe;
            let z = _.pop() || A, M = _.pop();
            const D = this.options.protocolVersion;
            delete j.resubscribe, typeof j == "string" && (j = [j]), typeof z != "function" && (M = z, z = A);
            const W = b.validateTopics(j);
            if (W !== null) return C(z, new Error("Invalid topic " + W)), this;
            if (this._checkDisconnecting(z)) return p("subscribe: discconecting true"), this;
            const N = { qos: 0 };
            if (D === 5 && (N.nl = !1, N.rap = !1, N.rh = 0), M = x(N, M), Array.isArray(j) ? j.forEach(function(q) {
              if (p("subscribe: array topic %s", q), !Object.prototype.hasOwnProperty.call(S._resubscribeTopics, q) || S._resubscribeTopics[q].qos < M.qos || X) {
                const Y = { topic: q, qos: M.qos };
                D === 5 && (Y.nl = M.nl, Y.rap = M.rap, Y.rh = M.rh, Y.properties = M.properties), p("subscribe: pushing topic `%s` and qos `%s` to subs list", Y.topic, Y.qos), B.push(Y);
              }
            }) : Object.keys(j).forEach(function(q) {
              if (p("subscribe: object topic %s", q), !Object.prototype.hasOwnProperty.call(S._resubscribeTopics, q) || S._resubscribeTopics[q].qos < j[q].qos || X) {
                const Y = { topic: q, qos: j[q].qos };
                D === 5 && (Y.nl = j[q].nl, Y.rap = j[q].rap, Y.rh = j[q].rh, Y.properties = M.properties), p("subscribe: pushing `%s` to subs list", Y), B.push(Y);
              }
            }), !B.length) return z(null, []), this;
            const U = function() {
              const q = S._nextId();
              if (q === null) return p("No messageId left"), !1;
              const Y = { cmd: "subscribe", subscriptions: B, qos: 1, retain: !1, dup: !1, messageId: q };
              if (M.properties && (Y.properties = M.properties), S.options.resubscribe) {
                p("subscribe :: resubscribe true");
                const Z = [];
                B.forEach(function(Q) {
                  if (S.options.reconnectPeriod > 0) {
                    const J = { qos: Q.qos };
                    D === 5 && (J.nl = Q.nl || !1, J.rap = Q.rap || !1, J.rh = Q.rh || 0, J.properties = Q.properties), S._resubscribeTopics[Q.topic] = J, Z.push(Q.topic);
                  }
                }), S.messageIdToTopic[Y.messageId] = Z;
              }
              return S.outgoing[Y.messageId] = { volatile: !0, cb: function(Z, Q) {
                if (!Z) {
                  const J = Q.granted;
                  for (let m = 0; m < J.length; m += 1) B[m].qos = J[m];
                }
                z(Z, B);
              } }, p("subscribe :: call _sendPacket"), S._sendPacket(Y), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !U()) && this._storeProcessingQueue.push({ invoke: U, callback: z }), this;
          }, I.prototype.unsubscribe = function() {
            const S = this, _ = new Array(arguments.length);
            for (let D = 0; D < arguments.length; D++) _[D] = arguments[D];
            let B = _.shift(), j = _.pop() || A, X = _.pop();
            typeof B == "string" && (B = [B]), typeof j != "function" && (X = j, j = A);
            const z = b.validateTopics(B);
            if (z !== null) return C(j, new Error("Invalid topic " + z)), this;
            if (S._checkDisconnecting(j)) return this;
            const M = function() {
              const D = S._nextId();
              if (D === null) return p("No messageId left"), !1;
              const W = { cmd: "unsubscribe", qos: 1, messageId: D };
              return typeof B == "string" ? W.unsubscriptions = [B] : Array.isArray(B) && (W.unsubscriptions = B), S.options.resubscribe && W.unsubscriptions.forEach(function(N) {
                delete S._resubscribeTopics[N];
              }), typeof X == "object" && X.properties && (W.properties = X.properties), S.outgoing[W.messageId] = { volatile: !0, cb: j }, p("unsubscribe: call _sendPacket"), S._sendPacket(W), !0;
            };
            return (this._storeProcessing || this._storeProcessingQueue.length > 0 || !M()) && this._storeProcessingQueue.push({ invoke: M, callback: j }), this;
          }, I.prototype.end = function(S, _, B) {
            const j = this;
            function X() {
              p("end :: (%s) :: finish :: calling _cleanUp with force %s", j.options.clientId, S), j._cleanUp(S, () => {
                p("end :: finish :: calling process.nextTick on closeStores"), k((function() {
                  p("end :: closeStores: closing incoming and outgoing stores"), j.disconnected = !0, j.incomingStore.close(function(z) {
                    j.outgoingStore.close(function(M) {
                      if (p("end :: closeStores: emitting end"), j.emit("end"), B) {
                        const D = z || M;
                        p("end :: closeStores: invoking callback with args"), B(D);
                      }
                    });
                  }), j._deferredReconnect && j._deferredReconnect();
                }).bind(j));
              }, _);
            }
            return p("end :: (%s)", this.options.clientId), S != null && typeof S == "boolean" || (B = _ || A, _ = S, S = !1, typeof _ != "object" && (B = _, _ = null, typeof B != "function" && (B = A))), typeof _ != "object" && (B = _, _ = null), p("end :: cb? %s", !!B), B = B || A, this.disconnecting ? (B(), this) : (this._clearReconnect(), this.disconnecting = !0, !S && Object.keys(this.outgoing).length > 0 ? (p("end :: (%s) :: calling finish in 10ms once outgoing is empty", j.options.clientId), this.once("outgoingEmpty", setTimeout.bind(null, X, 10))) : (p("end :: (%s) :: immediately calling finish", j.options.clientId), X()), this);
          }, I.prototype.removeOutgoingMessage = function(S) {
            const _ = this.outgoing[S] ? this.outgoing[S].cb : null;
            return delete this.outgoing[S], this.outgoingStore.del({ messageId: S }, function() {
              _(new Error("Message removed"));
            }), this;
          }, I.prototype.reconnect = function(S) {
            p("client reconnect");
            const _ = this, B = function() {
              S ? (_.options.incomingStore = S.incomingStore, _.options.outgoingStore = S.outgoingStore) : (_.options.incomingStore = null, _.options.outgoingStore = null), _.incomingStore = _.options.incomingStore || new n(), _.outgoingStore = _.options.outgoingStore || new n(), _.disconnecting = !1, _.disconnected = !1, _._deferredReconnect = null, _._reconnect();
            };
            return this.disconnecting && !this.disconnected ? this._deferredReconnect = B : B(), this;
          }, I.prototype._reconnect = function() {
            p("_reconnect: emitting reconnect to client"), this.emit("reconnect"), this.connected ? (this.end(() => {
              this._setupStream();
            }), p("client already connected. disconnecting first.")) : (p("_reconnect: calling _setupStream"), this._setupStream());
          }, I.prototype._setupReconnect = function() {
            const S = this;
            !S.disconnecting && !S.reconnectTimer && S.options.reconnectPeriod > 0 ? (this.reconnecting || (p("_setupReconnect :: emit `offline` state"), this.emit("offline"), p("_setupReconnect :: set `reconnecting` to `true`"), this.reconnecting = !0), p("_setupReconnect :: setting reconnectTimer for %d ms", S.options.reconnectPeriod), S.reconnectTimer = setInterval(function() {
              p("reconnectTimer :: reconnect triggered!"), S._reconnect();
            }, S.options.reconnectPeriod)) : p("_setupReconnect :: doing nothing...");
          }, I.prototype._clearReconnect = function() {
            p("_clearReconnect : clearing reconnect timer"), this.reconnectTimer && (clearInterval(this.reconnectTimer), this.reconnectTimer = null);
          }, I.prototype._cleanUp = function(S, _) {
            const B = arguments[2];
            if (_ && (p("_cleanUp :: done callback provided for on stream close"), this.stream.on("close", _)), p("_cleanUp :: forced? %s", S), S) this.options.reconnectPeriod === 0 && this.options.clean && (j = this.outgoing) && (p("flush: queue exists? %b", !!j), Object.keys(j).forEach(function(X) {
              typeof j[X].cb == "function" && (j[X].cb(new Error("Connection closed")), delete j[X]);
            })), p("_cleanUp :: (%s) :: destroying stream", this.options.clientId), this.stream.destroy();
            else {
              const X = x({ cmd: "disconnect" }, B);
              p("_cleanUp :: (%s) :: call _sendPacket with disconnect packet", this.options.clientId), this._sendPacket(X, C.bind(null, this.stream.end.bind(this.stream)));
            }
            var j;
            this.disconnecting || (p("_cleanUp :: client not disconnecting. Clearing and resetting reconnect."), this._clearReconnect(), this._setupReconnect()), this.pingTimer !== null && (p("_cleanUp :: clearing pingTimer"), this.pingTimer.clear(), this.pingTimer = null), _ && !this.connected && (p("_cleanUp :: (%s) :: removing stream `done` callback `close` listener", this.options.clientId), this.stream.removeListener("close", _), _());
          }, I.prototype._sendPacket = function(S, _, B) {
            p("_sendPacket :: (%s) ::  start", this.options.clientId), B = B || A, _ = _ || A;
            const j = function(X, z) {
              if (X.options.protocolVersion === 5 && z.cmd === "publish") {
                let M;
                z.properties && (M = z.properties.topicAlias);
                const D = z.topic.toString();
                if (X.topicAliasSend) if (M) {
                  if (D.length !== 0 && (p("applyTopicAlias :: register topic: %s - alias: %d", D, M), !X.topicAliasSend.put(D, M))) return p("applyTopicAlias :: error out of range. topic: %s - alias: %d", D, M), new Error("Sending Topic Alias out of range");
                } else D.length !== 0 && (X.options.autoAssignTopicAlias ? (M = X.topicAliasSend.getAliasByTopic(D)) ? (z.topic = "", z.properties = { ...z.properties, topicAlias: M }, p("applyTopicAlias :: auto assign(use) topic: %s - alias: %d", D, M)) : (M = X.topicAliasSend.getLruAlias(), X.topicAliasSend.put(D, M), z.properties = { ...z.properties, topicAlias: M }, p("applyTopicAlias :: auto assign topic: %s - alias: %d", D, M)) : X.options.autoUseTopicAlias && (M = X.topicAliasSend.getAliasByTopic(D)) && (z.topic = "", z.properties = { ...z.properties, topicAlias: M }, p("applyTopicAlias :: auto use topic: %s - alias: %d", D, M)));
                else if (M) return p("applyTopicAlias :: error out of range. topic: %s - alias: %d", D, M), new Error("Sending Topic Alias out of range");
              }
            }(this, S);
            if (j) _(j);
            else {
              if (!this.connected) return S.cmd === "auth" ? (this._shiftPingInterval(), void H(this, S, _)) : (p("_sendPacket :: client not connected. Storing packet offline."), void this._storePacket(S, _, B));
              switch (this._shiftPingInterval(), S.cmd) {
                case "publish":
                  break;
                case "pubrel":
                  return void $(this, S, _, B);
                default:
                  return void H(this, S, _);
              }
              switch (S.qos) {
                case 2:
                case 1:
                  $(this, S, _, B);
                  break;
                case 0:
                default:
                  H(this, S, _);
              }
              p("_sendPacket :: (%s) ::  end", this.options.clientId);
            }
          }, I.prototype._storePacket = function(S, _, B) {
            p("_storePacket :: packet: %o", S), p("_storePacket :: cb? %s", !!_), B = B || A;
            let j = S;
            if (j.cmd === "publish") {
              const X = E(this, j = v(S));
              if (X) return _ && _(X);
            }
            (j.qos || 0) === 0 && this.queueQoSZero || j.cmd !== "publish" ? this.queue.push({ packet: j, cb: _ }) : j.qos > 0 ? (_ = this.outgoing[j.messageId] ? this.outgoing[j.messageId].cb : null, this.outgoingStore.put(j, function(X) {
              if (X) return _ && _(X);
              B();
            })) : _ && _(new Error("No connection to broker"));
          }, I.prototype._setupPingTimer = function() {
            p("_setupPingTimer :: keepalive %d (seconds)", this.options.keepalive);
            const S = this;
            !this.pingTimer && this.options.keepalive && (this.pingResp = !0, this.pingTimer = y(function() {
              S._checkPing();
            }, 1e3 * this.options.keepalive));
          }, I.prototype._shiftPingInterval = function() {
            this.pingTimer && this.options.keepalive && this.options.reschedulePings && this.pingTimer.reschedule(1e3 * this.options.keepalive);
          }, I.prototype._checkPing = function() {
            p("_checkPing :: checking ping..."), this.pingResp ? (p("_checkPing :: ping response received. Clearing flag and sending `pingreq`"), this.pingResp = !1, this._sendPacket({ cmd: "pingreq" })) : (p("_checkPing :: calling _cleanUp with force true"), this._cleanUp(!0));
          }, I.prototype._handlePingresp = function() {
            this.pingResp = !0;
          }, I.prototype._handleConnack = function(S) {
            p("_handleConnack");
            const _ = this.options, B = _.protocolVersion === 5 ? S.reasonCode : S.returnCode;
            if (clearTimeout(this.connackTimer), delete this.topicAliasSend, S.properties) {
              if (S.properties.topicAliasMaximum) {
                if (S.properties.topicAliasMaximum > 65535) return void this.emit("error", new Error("topicAliasMaximum from broker is out of range"));
                S.properties.topicAliasMaximum > 0 && (this.topicAliasSend = new c(S.properties.topicAliasMaximum));
              }
              S.properties.serverKeepAlive && _.keepalive && (_.keepalive = S.properties.serverKeepAlive, this._shiftPingInterval()), S.properties.maximumPacketSize && (_.properties || (_.properties = {}), _.properties.maximumPacketSize = S.properties.maximumPacketSize);
            }
            if (B === 0) this.reconnecting = !1, this._onConnect(S);
            else if (B > 0) {
              const j = new Error("Connection refused: " + P[B]);
              j.code = B, this.emit("error", j);
            }
          }, I.prototype._handleAuth = function(S) {
            const _ = this.options.protocolVersion, B = _ === 5 ? S.reasonCode : S.returnCode;
            if (_ !== 5) {
              const X = new Error("Protocol error: Auth packets are only supported in MQTT 5. Your version:" + _);
              return X.code = B, void this.emit("error", X);
            }
            const j = this;
            this.handleAuth(S, function(X, z) {
              if (X) j.emit("error", X);
              else if (B === 24) j.reconnecting = !1, j._sendPacket(z);
              else {
                const M = new Error("Connection refused: " + P[B]);
                X.code = B, j.emit("error", M);
              }
            });
          }, I.prototype.handleAuth = function(S, _) {
            _();
          }, I.prototype._handlePublish = function(S, _) {
            p("_handlePublish: packet %o", S), _ = _ !== void 0 ? _ : A;
            let B = S.topic.toString();
            const j = S.payload, X = S.qos, z = S.messageId, M = this, D = this.options, W = [0, 16, 128, 131, 135, 144, 145, 151, 153];
            if (this.options.protocolVersion === 5) {
              let N;
              if (S.properties && (N = S.properties.topicAlias), N !== void 0) if (B.length === 0) {
                if (!(N > 0 && N <= 65535)) return p("_handlePublish :: topic alias out of range. alias: %d", N), void this.emit("error", new Error("Received Topic Alias is out of range"));
                {
                  const U = this.topicAliasRecv.getTopicByAlias(N);
                  if (!U) return p("_handlePublish :: unregistered topic alias. alias: %d", N), void this.emit("error", new Error("Received unregistered Topic Alias"));
                  p("_handlePublish :: topic complemented by alias. topic: %s - alias: %d", B = U, N);
                }
              } else {
                if (!this.topicAliasRecv.put(B, N)) return p("_handlePublish :: topic alias out of range. alias: %d", N), void this.emit("error", new Error("Received Topic Alias is out of range"));
                p("_handlePublish :: registered topic: %s - alias: %d", B, N);
              }
            }
            switch (p("_handlePublish: qos %d", X), X) {
              case 2:
                D.customHandleAcks(B, j, S, function(N, U) {
                  return N instanceof Error || (U = N, N = null), N ? M.emit("error", N) : W.indexOf(U) === -1 ? M.emit("error", new Error("Wrong reason code for pubrec")) : void (U ? M._sendPacket({ cmd: "pubrec", messageId: z, reasonCode: U }, _) : M.incomingStore.put(S, function() {
                    M._sendPacket({ cmd: "pubrec", messageId: z }, _);
                  }));
                });
                break;
              case 1:
                D.customHandleAcks(B, j, S, function(N, U) {
                  return N instanceof Error || (U = N, N = null), N ? M.emit("error", N) : W.indexOf(U) === -1 ? M.emit("error", new Error("Wrong reason code for puback")) : (U || M.emit("message", B, j, S), void M.handleMessage(S, function(q) {
                    if (q) return _ && _(q);
                    M._sendPacket({ cmd: "puback", messageId: z, reasonCode: U }, _);
                  }));
                });
                break;
              case 0:
                this.emit("message", B, j, S), this.handleMessage(S, _);
                break;
              default:
                p("_handlePublish: unknown QoS. Doing nothing.");
            }
          }, I.prototype.handleMessage = function(S, _) {
            _();
          }, I.prototype._handleAck = function(S) {
            const _ = S.messageId, B = S.cmd;
            let j = null;
            const X = this.outgoing[_] ? this.outgoing[_].cb : null, z = this;
            let M;
            if (X) {
              switch (p("_handleAck :: packet type", B), B) {
                case "pubcomp":
                case "puback": {
                  const D = S.reasonCode;
                  D && D > 0 && D !== 16 && ((M = new Error("Publish error: " + P[D])).code = D, X(M, S)), delete this.outgoing[_], this.outgoingStore.del(S, X), this.messageIdProvider.deallocate(_), this._invokeStoreProcessingQueue();
                  break;
                }
                case "pubrec": {
                  j = { cmd: "pubrel", qos: 2, messageId: _ };
                  const D = S.reasonCode;
                  D && D > 0 && D !== 16 ? ((M = new Error("Publish error: " + P[D])).code = D, X(M, S)) : this._sendPacket(j);
                  break;
                }
                case "suback":
                  delete this.outgoing[_], this.messageIdProvider.deallocate(_);
                  for (let D = 0; D < S.granted.length; D++) if (128 & S.granted[D]) {
                    const W = this.messageIdToTopic[_];
                    W && W.forEach(function(N) {
                      delete z._resubscribeTopics[N];
                    });
                  }
                  this._invokeStoreProcessingQueue(), X(null, S);
                  break;
                case "unsuback":
                  delete this.outgoing[_], this.messageIdProvider.deallocate(_), this._invokeStoreProcessingQueue(), X(null);
                  break;
                default:
                  z.emit("error", new Error("unrecognized packet type"));
              }
              this.disconnecting && Object.keys(this.outgoing).length === 0 && this.emit("outgoingEmpty");
            } else p("_handleAck :: Server sent an ack in error. Ignoring.");
          }, I.prototype._handlePubrel = function(S, _) {
            p("handling pubrel packet"), _ = _ !== void 0 ? _ : A;
            const B = this, j = { cmd: "pubcomp", messageId: S.messageId };
            B.incomingStore.get(S, function(X, z) {
              X ? B._sendPacket(j, _) : (B.emit("message", z.topic, z.payload, z), B.handleMessage(z, function(M) {
                if (M) return _(M);
                B.incomingStore.del(z, A), B._sendPacket(j, _);
              }));
            });
          }, I.prototype._handleDisconnect = function(S) {
            this.emit("disconnect", S);
          }, I.prototype._nextId = function() {
            return this.messageIdProvider.allocate();
          }, I.prototype.getLastMessageId = function() {
            return this.messageIdProvider.getLastAllocated();
          }, I.prototype._resubscribe = function() {
            p("_resubscribe");
            const S = Object.keys(this._resubscribeTopics);
            if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && S.length > 0) if (this.options.resubscribe) if (this.options.protocolVersion === 5) {
              p("_resubscribe: protocolVersion 5");
              for (let _ = 0; _ < S.length; _++) {
                const B = {};
                B[S[_]] = this._resubscribeTopics[S[_]], B.resubscribe = !0, this.subscribe(B, { properties: B[S[_]].properties });
              }
            } else this._resubscribeTopics.resubscribe = !0, this.subscribe(this._resubscribeTopics);
            else this._resubscribeTopics = {};
            this._firstConnection = !1;
          }, I.prototype._onConnect = function(S) {
            if (this.disconnected) return void this.emit("connect", S);
            const _ = this;
            this.connackPacket = S, this.messageIdProvider.clear(), this._setupPingTimer(), this.connected = !0, function B() {
              let j = _.outgoingStore.createStream();
              function X() {
                _._storeProcessing = !1, _._packetIdsDuringStoreProcessing = {};
              }
              function z() {
                j.destroy(), j = null, _._flushStoreProcessingQueue(), X();
              }
              _.once("close", z), j.on("error", function(M) {
                X(), _._flushStoreProcessingQueue(), _.removeListener("close", z), _.emit("error", M);
              }), j.on("end", function() {
                let M = !0;
                for (const D in _._packetIdsDuringStoreProcessing) if (!_._packetIdsDuringStoreProcessing[D]) {
                  M = !1;
                  break;
                }
                M ? (X(), _.removeListener("close", z), _._invokeAllStoreProcessingQueue(), _.emit("connect", S)) : B();
              }), function M() {
                if (!j) return;
                _._storeProcessing = !0;
                const D = j.read(1);
                let W;
                D ? _._packetIdsDuringStoreProcessing[D.messageId] ? M() : _.disconnecting || _.reconnectTimer ? j.destroy && j.destroy() : (W = _.outgoing[D.messageId] ? _.outgoing[D.messageId].cb : null, _.outgoing[D.messageId] = { volatile: !1, cb: function(N, U) {
                  W && W(N, U), M();
                } }, _._packetIdsDuringStoreProcessing[D.messageId] = !0, _.messageIdProvider.register(D.messageId) ? _._sendPacket(D) : p("messageId: %d has already used.", D.messageId)) : j.once("readable", M);
              }();
            }();
          }, I.prototype._invokeStoreProcessingQueue = function() {
            if (this._storeProcessingQueue.length > 0) {
              const S = this._storeProcessingQueue[0];
              if (S && S.invoke()) return this._storeProcessingQueue.shift(), !0;
            }
            return !1;
          }, I.prototype._invokeAllStoreProcessingQueue = function() {
            for (; this._invokeStoreProcessingQueue(); ) ;
          }, I.prototype._flushStoreProcessingQueue = function() {
            for (const S of this._storeProcessingQueue) S.cbStorePut && S.cbStorePut(new Error("Connection closed")), S.callback && S.callback(new Error("Connection closed"));
            this._storeProcessingQueue.splice(0);
          }, s.exports = I;
        }).call(this);
      }).call(this, i("_process"), typeof Vt < "u" ? Vt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./default-message-id-provider": 7, "./store": 8, "./topic-alias-recv": 9, "./topic-alias-send": 10, "./validations": 11, _process: 50, debug: 18, events: 22, inherits: 24, "mqtt-packet": 40, "readable-stream": 69, reinterval: 70, "rfdc/default": 71, xtend: 81 }], 2: [function(i, s, o) {
      const { Buffer: a } = i("buffer"), r = i("readable-stream").Transform, l = i("duplexify");
      let n, h, c, d = !1;
      s.exports = function(u, f) {
        if (f.hostname = f.hostname || f.host, !f.hostname) throw new Error("Could not determine host. Specify host manually.");
        const g = f.protocolId === "MQIsdp" && f.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        (function(v) {
          v.hostname || (v.hostname = "localhost"), v.path || (v.path = "/"), v.wsOptions || (v.wsOptions = {});
        })(f);
        const y = function(v, b) {
          const x = v.protocol === "alis" ? "wss" : "ws";
          let p = x + "://" + v.hostname + v.path;
          return v.port && v.port !== 80 && v.port !== 443 && (p = x + "://" + v.hostname + ":" + v.port + v.path), typeof v.transformWsUrl == "function" && (p = v.transformWsUrl(p, v, b)), p;
        }(f, u);
        return (n = f.my).connectSocket({ url: y, protocols: g }), h = function() {
          const v = new r();
          return v._write = function(b, x, p) {
            n.sendSocketMessage({ data: b.buffer, success: function() {
              p();
            }, fail: function() {
              p(new Error());
            } });
          }, v._flush = function(b) {
            n.closeSocket({ success: function() {
              b();
            } });
          }, v;
        }(), c = l.obj(), d || (d = !0, n.onSocketOpen(function() {
          c.setReadable(h), c.setWritable(h), c.emit("connect");
        }), n.onSocketMessage(function(v) {
          if (typeof v.data == "string") {
            const b = a.from(v.data, "base64");
            h.push(b);
          } else {
            const b = new FileReader();
            b.addEventListener("load", function() {
              let x = b.result;
              x = x instanceof ArrayBuffer ? a.from(x) : a.from(x, "utf8"), h.push(x);
            }), b.readAsArrayBuffer(v.data);
          }
        }), n.onSocketClose(function() {
          c.end(), c.destroy();
        }), n.onSocketError(function(v) {
          c.destroy(v);
        })), c;
      };
    }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 3: [function(i, s, o) {
      const a = i("net"), r = i("debug")("mqttjs:tcp");
      s.exports = function(l, n) {
        n.port = n.port || 1883, n.hostname = n.hostname || n.host || "localhost";
        const h = n.port, c = n.hostname;
        return r("port %d and host %s", h, c), a.createConnection(h, c);
      };
    }, { debug: 18, net: 16 }], 4: [function(i, s, o) {
      const a = i("tls"), r = i("net"), l = i("debug")("mqttjs:tls");
      s.exports = function(n, h) {
        h.port = h.port || 8883, h.host = h.hostname || h.host || "localhost", r.isIP(h.host) === 0 && (h.servername = h.host), h.rejectUnauthorized = h.rejectUnauthorized !== !1, delete h.path, l("port %d host %s rejectUnauthorized %b", h.port, h.host, h.rejectUnauthorized);
        const c = a.connect(h);
        function d(u) {
          h.rejectUnauthorized && n.emit("error", u), c.end();
        }
        return c.on("secureConnect", function() {
          h.rejectUnauthorized && !c.authorized ? c.emit("error", new Error("TLS not authorized")) : c.removeListener("error", d);
        }), c.on("error", d), c;
      };
    }, { debug: 18, net: 16, tls: 16 }], 5: [function(i, s, o) {
      (function(a) {
        (function() {
          const { Buffer: r } = i("buffer"), l = i("ws"), n = i("debug")("mqttjs:ws"), h = i("duplexify"), c = i("readable-stream").Transform, d = ["rejectUnauthorized", "ca", "cert", "key", "pfx", "passphrase"], u = a !== void 0 && a.title === "browser" || typeof __webpack_require__ == "function";
          function f(y, v) {
            let b = y.protocol + "://" + y.hostname + ":" + y.port + y.path;
            return typeof y.transformWsUrl == "function" && (b = y.transformWsUrl(b, y, v)), b;
          }
          function g(y) {
            const v = y;
            return y.hostname || (v.hostname = "localhost"), y.port || (y.protocol === "wss" ? v.port = 443 : v.port = 80), y.path || (v.path = "/"), y.wsOptions || (v.wsOptions = {}), u || y.protocol !== "wss" || d.forEach(function(b) {
              Object.prototype.hasOwnProperty.call(y, b) && !Object.prototype.hasOwnProperty.call(y.wsOptions, b) && (v.wsOptions[b] = y[b]);
            }), v;
          }
          s.exports = u ? function(y, v) {
            let b;
            n("browserStreamBuilder");
            const x = function(S) {
              const _ = g(S);
              if (_.hostname || (_.hostname = _.host), !_.hostname) {
                if (typeof document > "u") throw new Error("Could not determine host. Specify host manually.");
                const B = new URL(document.URL);
                _.hostname = B.hostname, _.port || (_.port = B.port);
              }
              return _.objectMode === void 0 && (_.objectMode = !(_.binary === !0 || _.binary === void 0)), _;
            }(v).browserBufferSize || 524288, p = v.browserBufferTimeout || 1e3, k = !v.objectMode, C = function(S, _) {
              const B = _.protocolId === "MQIsdp" && _.protocolVersion === 3 ? "mqttv3.1" : "mqtt", j = f(_, S), X = new WebSocket(j, [B]);
              return X.binaryType = "arraybuffer", X;
            }(y, v), R = function(S, _, B) {
              const j = new c({ objectModeMode: S.objectMode });
              return j._write = _, j._flush = B, j;
            }(v, function S(_, B, j) {
              C.bufferedAmount > x && setTimeout(S, p, _, B, j), k && typeof _ == "string" && (_ = r.from(_, "utf8"));
              try {
                C.send(_);
              } catch (X) {
                return j(X);
              }
              j();
            }, function(S) {
              C.close(), S();
            });
            v.objectMode || (R._writev = I), R.on("close", () => {
              C.close();
            });
            const P = C.addEventListener !== void 0;
            function E() {
              b.setReadable(R), b.setWritable(R), b.emit("connect");
            }
            function H() {
              b.end(), b.destroy();
            }
            function $(S) {
              b.destroy(S);
            }
            function A(S) {
              let _ = S.data;
              _ = _ instanceof ArrayBuffer ? r.from(_) : r.from(_, "utf8"), R.push(_);
            }
            function I(S, _) {
              const B = new Array(S.length);
              for (let j = 0; j < S.length; j++) typeof S[j].chunk == "string" ? B[j] = r.from(S[j], "utf8") : B[j] = S[j].chunk;
              this._write(r.concat(B), "binary", _);
            }
            return C.readyState === C.OPEN ? b = R : (b = b = h(void 0, void 0, v), v.objectMode || (b._writev = I), P ? C.addEventListener("open", E) : C.onopen = E), b.socket = C, P ? (C.addEventListener("close", H), C.addEventListener("error", $), C.addEventListener("message", A)) : (C.onclose = H, C.onerror = $, C.onmessage = A), b;
          } : function(y, v) {
            n("streamBuilder");
            const b = g(v), x = f(b, y), p = function(C, R, P) {
              n("createWebSocket"), n("protocol: " + P.protocolId + " " + P.protocolVersion);
              const E = P.protocolId === "MQIsdp" && P.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
              return n("creating new Websocket for url: " + R + " and protocol: " + E), new l(R, [E], P.wsOptions);
            }(0, x, b), k = l.createWebSocketStream(p, b.wsOptions);
            return k.url = x, p.on("close", () => {
              k.destroy();
            }), k;
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50, buffer: 17, debug: 18, duplexify: 20, "readable-stream": 69, ws: 80 }], 6: [function(i, s, o) {
      const { Buffer: a } = i("buffer"), r = i("readable-stream").Transform, l = i("duplexify");
      let n, h, c;
      s.exports = function(d, u) {
        if (u.hostname = u.hostname || u.host, !u.hostname) throw new Error("Could not determine host. Specify host manually.");
        const f = u.protocolId === "MQIsdp" && u.protocolVersion === 3 ? "mqttv3.1" : "mqtt";
        (function(v) {
          v.hostname || (v.hostname = "localhost"), v.path || (v.path = "/"), v.wsOptions || (v.wsOptions = {});
        })(u);
        const g = function(v, b) {
          const x = v.protocol === "wxs" ? "wss" : "ws";
          let p = x + "://" + v.hostname + v.path;
          return v.port && v.port !== 80 && v.port !== 443 && (p = x + "://" + v.hostname + ":" + v.port + v.path), typeof v.transformWsUrl == "function" && (p = v.transformWsUrl(p, v, b)), p;
        }(u, d);
        n = wx.connectSocket({ url: g, protocols: [f] }), h = function() {
          const v = new r();
          return v._write = function(b, x, p) {
            n.send({ data: b.buffer, success: function() {
              p();
            }, fail: function(k) {
              p(new Error(k));
            } });
          }, v._flush = function(b) {
            n.close({ success: function() {
              b();
            } });
          }, v;
        }(), (c = l.obj())._destroy = function(v, b) {
          n.close({ success: function() {
            b && b(v);
          } });
        };
        const y = c.destroy;
        return c.destroy = (function() {
          c.destroy = y;
          const v = this;
          setTimeout(function() {
            n.close({ fail: function() {
              v._destroy(new Error());
            } });
          }, 0);
        }).bind(c), n.onOpen(function() {
          c.setReadable(h), c.setWritable(h), c.emit("connect");
        }), n.onMessage(function(v) {
          let b = v.data;
          b = b instanceof ArrayBuffer ? a.from(b) : a.from(b, "utf8"), h.push(b);
        }), n.onClose(function() {
          c.end(), c.destroy();
        }), n.onError(function(v) {
          c.destroy(new Error(v.errMsg));
        }), c;
      };
    }, { buffer: 17, duplexify: 20, "readable-stream": 69 }], 7: [function(i, s, o) {
      function a() {
        if (!(this instanceof a)) return new a();
        this.nextId = Math.max(1, Math.floor(65535 * Math.random()));
      }
      a.prototype.allocate = function() {
        const r = this.nextId++;
        return this.nextId === 65536 && (this.nextId = 1), r;
      }, a.prototype.getLastAllocated = function() {
        return this.nextId === 1 ? 65535 : this.nextId - 1;
      }, a.prototype.register = function(r) {
        return !0;
      }, a.prototype.deallocate = function(r) {
      }, a.prototype.clear = function() {
      }, s.exports = a;
    }, {}], 8: [function(i, s, o) {
      const a = i("xtend"), r = i("readable-stream").Readable, l = { objectMode: !0 }, n = { clean: !0 };
      function h(c) {
        if (!(this instanceof h)) return new h(c);
        this.options = c || {}, this.options = a(n, c), this._inflights = /* @__PURE__ */ new Map();
      }
      h.prototype.put = function(c, d) {
        return this._inflights.set(c.messageId, c), d && d(), this;
      }, h.prototype.createStream = function() {
        const c = new r(l), d = [];
        let u = !1, f = 0;
        return this._inflights.forEach(function(g, y) {
          d.push(g);
        }), c._read = function() {
          !u && f < d.length ? this.push(d[f++]) : this.push(null);
        }, c.destroy = function() {
          if (u) return;
          const g = this;
          u = !0, setTimeout(function() {
            g.emit("close");
          }, 0);
        }, c;
      }, h.prototype.del = function(c, d) {
        return (c = this._inflights.get(c.messageId)) ? (this._inflights.delete(c.messageId), d(null, c)) : d && d(new Error("missing packet")), this;
      }, h.prototype.get = function(c, d) {
        return (c = this._inflights.get(c.messageId)) ? d(null, c) : d && d(new Error("missing packet")), this;
      }, h.prototype.close = function(c) {
        this.options.clean && (this._inflights = null), c && c();
      }, s.exports = h;
    }, { "readable-stream": 69, xtend: 81 }], 9: [function(i, s, o) {
      function a(r) {
        if (!(this instanceof a)) return new a(r);
        this.aliasToTopic = {}, this.max = r;
      }
      a.prototype.put = function(r, l) {
        return !(l === 0 || l > this.max) && (this.aliasToTopic[l] = r, this.length = Object.keys(this.aliasToTopic).length, !0);
      }, a.prototype.getTopicByAlias = function(r) {
        return this.aliasToTopic[r];
      }, a.prototype.clear = function() {
        this.aliasToTopic = {};
      }, s.exports = a;
    }, {}], 10: [function(i, s, o) {
      const a = i("lru-cache"), r = i("number-allocator").NumberAllocator;
      function l(n) {
        if (!(this instanceof l)) return new l(n);
        n > 0 && (this.aliasToTopic = new a({ max: n }), this.topicToAlias = {}, this.numberAllocator = new r(1, n), this.max = n, this.length = 0);
      }
      l.prototype.put = function(n, h) {
        if (h === 0 || h > this.max) return !1;
        const c = this.aliasToTopic.get(h);
        return c && delete this.topicToAlias[c], this.aliasToTopic.set(h, n), this.topicToAlias[n] = h, this.numberAllocator.use(h), this.length = this.aliasToTopic.length, !0;
      }, l.prototype.getTopicByAlias = function(n) {
        return this.aliasToTopic.get(n);
      }, l.prototype.getAliasByTopic = function(n) {
        const h = this.topicToAlias[n];
        return h !== void 0 && this.aliasToTopic.get(h), h;
      }, l.prototype.clear = function() {
        this.aliasToTopic.reset(), this.topicToAlias = {}, this.numberAllocator.clear(), this.length = 0;
      }, l.prototype.getLruAlias = function() {
        return this.numberAllocator.firstVacant() || this.aliasToTopic.keys()[this.aliasToTopic.length - 1];
      }, s.exports = l;
    }, { "lru-cache": 37, "number-allocator": 46 }], 11: [function(i, s, o) {
      function a(r) {
        const l = r.split("/");
        for (let n = 0; n < l.length; n++) if (l[n] !== "+") {
          if (l[n] === "#") return n === l.length - 1;
          if (l[n].indexOf("+") !== -1 || l[n].indexOf("#") !== -1) return !1;
        }
        return !0;
      }
      s.exports = { validateTopics: function(r) {
        if (r.length === 0) return "empty_topic_list";
        for (let l = 0; l < r.length; l++) if (!a(r[l])) return r[l];
        return null;
      } };
    }, {}], 12: [function(i, s, o) {
      (function(a) {
        (function() {
          const r = i("../client"), l = i("../store"), n = i("url"), h = i("xtend"), c = i("debug")("mqttjs"), d = {};
          function u(f, g) {
            if (c("connecting to an MQTT broker..."), typeof f != "object" || g || (g = f, f = null), g = g || {}, f) {
              const v = n.parse(f, !0);
              if (v.port != null && (v.port = Number(v.port)), (g = h(v, g)).protocol === null) throw new Error("Missing protocol");
              g.protocol = g.protocol.replace(/:$/, "");
            }
            if (function(v) {
              let b;
              v.auth && ((b = v.auth.match(/^(.+):(.+)$/)) ? (v.username = b[1], v.password = b[2]) : v.username = v.auth);
            }(g), g.query && typeof g.query.clientId == "string" && (g.clientId = g.query.clientId), g.cert && g.key) {
              if (!g.protocol) throw new Error("Missing secure protocol key");
              if (["mqtts", "wss", "wxs", "alis"].indexOf(g.protocol) === -1) switch (g.protocol) {
                case "mqtt":
                  g.protocol = "mqtts";
                  break;
                case "ws":
                  g.protocol = "wss";
                  break;
                case "wx":
                  g.protocol = "wxs";
                  break;
                case "ali":
                  g.protocol = "alis";
                  break;
                default:
                  throw new Error('Unknown protocol for secure connection: "' + g.protocol + '"!');
              }
            }
            if (!d[g.protocol]) {
              const v = ["mqtts", "wss"].indexOf(g.protocol) !== -1;
              g.protocol = ["mqtt", "mqtts", "ws", "wss", "wx", "wxs", "ali", "alis"].filter(function(b, x) {
                return (!v || x % 2 != 0) && typeof d[b] == "function";
              })[0];
            }
            if (g.clean === !1 && !g.clientId) throw new Error("Missing clientId for unclean clients");
            g.protocol && (g.defaultProtocol = g.protocol);
            const y = new r(function(v) {
              return g.servers && (v._reconnectCount && v._reconnectCount !== g.servers.length || (v._reconnectCount = 0), g.host = g.servers[v._reconnectCount].host, g.port = g.servers[v._reconnectCount].port, g.protocol = g.servers[v._reconnectCount].protocol ? g.servers[v._reconnectCount].protocol : g.defaultProtocol, g.hostname = g.host, v._reconnectCount++), c("calling streambuilder for", g.protocol), d[g.protocol](v, g);
            }, g);
            return y.on("error", function() {
            }), y;
          }
          a !== void 0 && a.title !== "browser" || typeof __webpack_require__ != "function" ? (d.mqtt = i("./tcp"), d.tcp = i("./tcp"), d.ssl = i("./tls"), d.tls = i("./tls"), d.mqtts = i("./tls")) : (d.wx = i("./wx"), d.wxs = i("./wx"), d.ali = i("./ali"), d.alis = i("./ali")), d.ws = i("./ws"), d.wss = i("./ws"), s.exports = u, s.exports.connect = u, s.exports.MqttClient = r, s.exports.Store = l;
        }).call(this);
      }).call(this, i("_process"));
    }, { "../client": 1, "../store": 8, "./ali": 2, "./tcp": 3, "./tls": 4, "./ws": 5, "./wx": 6, _process: 50, debug: 18, url: 76, xtend: 81 }], 13: [function(i, s, o) {
      o.byteLength = function(f) {
        var g = d(f), y = g[0], v = g[1];
        return 3 * (y + v) / 4 - v;
      }, o.toByteArray = function(f) {
        var g, y, v = d(f), b = v[0], x = v[1], p = new l(function(R, P, E) {
          return 3 * (P + E) / 4 - E;
        }(0, b, x)), k = 0, C = x > 0 ? b - 4 : b;
        for (y = 0; y < C; y += 4) g = r[f.charCodeAt(y)] << 18 | r[f.charCodeAt(y + 1)] << 12 | r[f.charCodeAt(y + 2)] << 6 | r[f.charCodeAt(y + 3)], p[k++] = g >> 16 & 255, p[k++] = g >> 8 & 255, p[k++] = 255 & g;
        return x === 2 && (g = r[f.charCodeAt(y)] << 2 | r[f.charCodeAt(y + 1)] >> 4, p[k++] = 255 & g), x === 1 && (g = r[f.charCodeAt(y)] << 10 | r[f.charCodeAt(y + 1)] << 4 | r[f.charCodeAt(y + 2)] >> 2, p[k++] = g >> 8 & 255, p[k++] = 255 & g), p;
      }, o.fromByteArray = function(f) {
        for (var g, y = f.length, v = y % 3, b = [], x = 0, p = y - v; x < p; x += 16383) b.push(u(f, x, x + 16383 > p ? p : x + 16383));
        return v === 1 ? (g = f[y - 1], b.push(a[g >> 2] + a[g << 4 & 63] + "==")) : v === 2 && (g = (f[y - 2] << 8) + f[y - 1], b.push(a[g >> 10] + a[g >> 4 & 63] + a[g << 2 & 63] + "=")), b.join("");
      };
      for (var a = [], r = [], l = typeof Uint8Array < "u" ? Uint8Array : Array, n = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0, c = n.length; h < c; ++h) a[h] = n[h], r[n.charCodeAt(h)] = h;
      function d(f) {
        var g = f.length;
        if (g % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
        var y = f.indexOf("=");
        return y === -1 && (y = g), [y, y === g ? 0 : 4 - y % 4];
      }
      function u(f, g, y) {
        for (var v, b, x = [], p = g; p < y; p += 3) v = (f[p] << 16 & 16711680) + (f[p + 1] << 8 & 65280) + (255 & f[p + 2]), x.push(a[(b = v) >> 18 & 63] + a[b >> 12 & 63] + a[b >> 6 & 63] + a[63 & b]);
        return x.join("");
      }
      r[45] = 62, r[95] = 63;
    }, {}], 14: [function(i, s, o) {
      const { Buffer: a } = i("buffer"), r = Symbol.for("BufferList");
      function l(n) {
        if (!(this instanceof l)) return new l(n);
        l._init.call(this, n);
      }
      l._init = function(n) {
        Object.defineProperty(this, r, { value: !0 }), this._bufs = [], this.length = 0, n && this.append(n);
      }, l.prototype._new = function(n) {
        return new l(n);
      }, l.prototype._offset = function(n) {
        if (n === 0) return [0, 0];
        let h = 0;
        for (let c = 0; c < this._bufs.length; c++) {
          const d = h + this._bufs[c].length;
          if (n < d || c === this._bufs.length - 1) return [c, n - h];
          h = d;
        }
      }, l.prototype._reverseOffset = function(n) {
        const h = n[0];
        let c = n[1];
        for (let d = 0; d < h; d++) c += this._bufs[d].length;
        return c;
      }, l.prototype.get = function(n) {
        if (n > this.length || n < 0) return;
        const h = this._offset(n);
        return this._bufs[h[0]][h[1]];
      }, l.prototype.slice = function(n, h) {
        return typeof n == "number" && n < 0 && (n += this.length), typeof h == "number" && h < 0 && (h += this.length), this.copy(null, 0, n, h);
      }, l.prototype.copy = function(n, h, c, d) {
        if ((typeof c != "number" || c < 0) && (c = 0), (typeof d != "number" || d > this.length) && (d = this.length), c >= this.length || d <= 0) return n || a.alloc(0);
        const u = !!n, f = this._offset(c), g = d - c;
        let y = g, v = u && h || 0, b = f[1];
        if (c === 0 && d === this.length) {
          if (!u) return this._bufs.length === 1 ? this._bufs[0] : a.concat(this._bufs, this.length);
          for (let x = 0; x < this._bufs.length; x++) this._bufs[x].copy(n, v), v += this._bufs[x].length;
          return n;
        }
        if (y <= this._bufs[f[0]].length - b) return u ? this._bufs[f[0]].copy(n, h, b, b + y) : this._bufs[f[0]].slice(b, b + y);
        u || (n = a.allocUnsafe(g));
        for (let x = f[0]; x < this._bufs.length; x++) {
          const p = this._bufs[x].length - b;
          if (!(y > p)) {
            this._bufs[x].copy(n, v, b, b + y), v += p;
            break;
          }
          this._bufs[x].copy(n, v, b), v += p, y -= p, b && (b = 0);
        }
        return n.length > v ? n.slice(0, v) : n;
      }, l.prototype.shallowSlice = function(n, h) {
        if (n = n || 0, h = typeof h != "number" ? this.length : h, n < 0 && (n += this.length), h < 0 && (h += this.length), n === h) return this._new();
        const c = this._offset(n), d = this._offset(h), u = this._bufs.slice(c[0], d[0] + 1);
        return d[1] === 0 ? u.pop() : u[u.length - 1] = u[u.length - 1].slice(0, d[1]), c[1] !== 0 && (u[0] = u[0].slice(c[1])), this._new(u);
      }, l.prototype.toString = function(n, h, c) {
        return this.slice(h, c).toString(n);
      }, l.prototype.consume = function(n) {
        if (n = Math.trunc(n), Number.isNaN(n) || n <= 0) return this;
        for (; this._bufs.length; ) {
          if (!(n >= this._bufs[0].length)) {
            this._bufs[0] = this._bufs[0].slice(n), this.length -= n;
            break;
          }
          n -= this._bufs[0].length, this.length -= this._bufs[0].length, this._bufs.shift();
        }
        return this;
      }, l.prototype.duplicate = function() {
        const n = this._new();
        for (let h = 0; h < this._bufs.length; h++) n.append(this._bufs[h]);
        return n;
      }, l.prototype.append = function(n) {
        if (n == null) return this;
        if (n.buffer) this._appendBuffer(a.from(n.buffer, n.byteOffset, n.byteLength));
        else if (Array.isArray(n)) for (let h = 0; h < n.length; h++) this.append(n[h]);
        else if (this._isBufferList(n)) for (let h = 0; h < n._bufs.length; h++) this.append(n._bufs[h]);
        else typeof n == "number" && (n = n.toString()), this._appendBuffer(a.from(n));
        return this;
      }, l.prototype._appendBuffer = function(n) {
        this._bufs.push(n), this.length += n.length;
      }, l.prototype.indexOf = function(n, h, c) {
        if (c === void 0 && typeof h == "string" && (c = h, h = void 0), typeof n == "function" || Array.isArray(n)) throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        if (typeof n == "number" ? n = a.from([n]) : typeof n == "string" ? n = a.from(n, c) : this._isBufferList(n) ? n = n.slice() : Array.isArray(n.buffer) ? n = a.from(n.buffer, n.byteOffset, n.byteLength) : a.isBuffer(n) || (n = a.from(n)), h = Number(h || 0), isNaN(h) && (h = 0), h < 0 && (h = this.length + h), h < 0 && (h = 0), n.length === 0) return h > this.length ? this.length : h;
        const d = this._offset(h);
        let u = d[0], f = d[1];
        for (; u < this._bufs.length; u++) {
          const g = this._bufs[u];
          for (; f < g.length; )
            if (g.length - f >= n.length) {
              const y = g.indexOf(n, f);
              if (y !== -1) return this._reverseOffset([u, y]);
              f = g.length - n.length + 1;
            } else {
              const y = this._reverseOffset([u, f]);
              if (this._match(y, n)) return y;
              f++;
            }
          f = 0;
        }
        return -1;
      }, l.prototype._match = function(n, h) {
        if (this.length - n < h.length) return !1;
        for (let c = 0; c < h.length; c++) if (this.get(n + c) !== h[c]) return !1;
        return !0;
      }, function() {
        const n = { readDoubleBE: 8, readDoubleLE: 8, readFloatBE: 4, readFloatLE: 4, readInt32BE: 4, readInt32LE: 4, readUInt32BE: 4, readUInt32LE: 4, readInt16BE: 2, readInt16LE: 2, readUInt16BE: 2, readUInt16LE: 2, readInt8: 1, readUInt8: 1, readIntBE: null, readIntLE: null, readUIntBE: null, readUIntLE: null };
        for (const h in n) (function(c) {
          l.prototype[c] = n[c] === null ? function(d, u) {
            return this.slice(d, d + u)[c](0, u);
          } : function(d = 0) {
            return this.slice(d, d + n[c])[c](0);
          };
        })(h);
      }(), l.prototype._isBufferList = function(n) {
        return n instanceof l || l.isBufferList(n);
      }, l.isBufferList = function(n) {
        return n != null && n[r];
      }, s.exports = l;
    }, { buffer: 17 }], 15: [function(i, s, o) {
      const a = i("readable-stream").Duplex, r = i("inherits"), l = i("./BufferList");
      function n(h) {
        if (!(this instanceof n)) return new n(h);
        if (typeof h == "function") {
          this._callback = h;
          const c = (function(d) {
            this._callback && (this._callback(d), this._callback = null);
          }).bind(this);
          this.on("pipe", function(d) {
            d.on("error", c);
          }), this.on("unpipe", function(d) {
            d.removeListener("error", c);
          }), h = null;
        }
        l._init.call(this, h), a.call(this);
      }
      r(n, a), Object.assign(n.prototype, l.prototype), n.prototype._new = function(h) {
        return new n(h);
      }, n.prototype._write = function(h, c, d) {
        this._appendBuffer(h), typeof d == "function" && d();
      }, n.prototype._read = function(h) {
        if (!this.length) return this.push(null);
        h = Math.min(h, this.length), this.push(this.slice(0, h)), this.consume(h);
      }, n.prototype.end = function(h) {
        a.prototype.end.call(this, h), this._callback && (this._callback(null, this.slice()), this._callback = null);
      }, n.prototype._destroy = function(h, c) {
        this._bufs.length = 0, this.length = 0, c(h);
      }, n.prototype._isBufferList = function(h) {
        return h instanceof n || h instanceof l || n.isBufferList(h);
      }, n.isBufferList = l.isBufferList, s.exports = n, s.exports.BufferListStream = n, s.exports.BufferList = l;
    }, { "./BufferList": 14, inherits: 24, "readable-stream": 69 }], 16: [function(i, s, o) {
    }, {}], 17: [function(i, s, o) {
      (function(a) {
        (function() {
          var r = i("base64-js"), l = i("ieee754");
          o.Buffer = c, o.SlowBuffer = function(m) {
            return +m != m && (m = 0), c.alloc(+m);
          }, o.INSPECT_MAX_BYTES = 50;
          var n = 2147483647;
          function h(m) {
            if (m > n) throw new RangeError('The value "' + m + '" is invalid for option "size"');
            var w = new Uint8Array(m);
            return w.__proto__ = c.prototype, w;
          }
          function c(m, w, T) {
            if (typeof m == "number") {
              if (typeof w == "string") throw new TypeError('The "string" argument must be of type string. Received type number');
              return f(m);
            }
            return d(m, w, T);
          }
          function d(m, w, T) {
            if (typeof m == "string") return function(V, K) {
              if (typeof K == "string" && K !== "" || (K = "utf8"), !c.isEncoding(K)) throw new TypeError("Unknown encoding: " + K);
              var et = 0 | v(V, K), tt = h(et), at = tt.write(V, K);
              return at !== et && (tt = tt.slice(0, at)), tt;
            }(m, w);
            if (ArrayBuffer.isView(m)) return g(m);
            if (m == null) throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
            if (Q(m, ArrayBuffer) || m && Q(m.buffer, ArrayBuffer)) return function(V, K, et) {
              if (K < 0 || V.byteLength < K) throw new RangeError('"offset" is outside of buffer bounds');
              if (V.byteLength < K + (et || 0)) throw new RangeError('"length" is outside of buffer bounds');
              var tt;
              return tt = K === void 0 && et === void 0 ? new Uint8Array(V) : et === void 0 ? new Uint8Array(V, K) : new Uint8Array(V, K, et), tt.__proto__ = c.prototype, tt;
            }(m, w, T);
            if (typeof m == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
            var L = m.valueOf && m.valueOf();
            if (L != null && L !== m) return c.from(L, w, T);
            var F = function(V) {
              if (c.isBuffer(V)) {
                var K = 0 | y(V.length), et = h(K);
                return et.length === 0 || V.copy(et, 0, 0, K), et;
              }
              if (V.length !== void 0) return typeof V.length != "number" || J(V.length) ? h(0) : g(V);
              if (V.type === "Buffer" && Array.isArray(V.data)) return g(V.data);
            }(m);
            if (F) return F;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function") return c.from(m[Symbol.toPrimitive]("string"), w, T);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m);
          }
          function u(m) {
            if (typeof m != "number") throw new TypeError('"size" argument must be of type number');
            if (m < 0) throw new RangeError('The value "' + m + '" is invalid for option "size"');
          }
          function f(m) {
            return u(m), h(m < 0 ? 0 : 0 | y(m));
          }
          function g(m) {
            for (var w = m.length < 0 ? 0 : 0 | y(m.length), T = h(w), L = 0; L < w; L += 1) T[L] = 255 & m[L];
            return T;
          }
          function y(m) {
            if (m >= n) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + n.toString(16) + " bytes");
            return 0 | m;
          }
          function v(m, w) {
            if (c.isBuffer(m)) return m.length;
            if (ArrayBuffer.isView(m) || Q(m, ArrayBuffer)) return m.byteLength;
            if (typeof m != "string") throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m);
            var T = m.length, L = arguments.length > 2 && arguments[2] === !0;
            if (!L && T === 0) return 0;
            for (var F = !1; ; ) switch (w) {
              case "ascii":
              case "latin1":
              case "binary":
                return T;
              case "utf8":
              case "utf-8":
                return q(m).length;
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return 2 * T;
              case "hex":
                return T >>> 1;
              case "base64":
                return Y(m).length;
              default:
                if (F) return L ? -1 : q(m).length;
                w = ("" + w).toLowerCase(), F = !0;
            }
          }
          function b(m, w, T) {
            var L = m[w];
            m[w] = m[T], m[T] = L;
          }
          function x(m, w, T, L, F) {
            if (m.length === 0) return -1;
            if (typeof T == "string" ? (L = T, T = 0) : T > 2147483647 ? T = 2147483647 : T < -2147483648 && (T = -2147483648), J(T = +T) && (T = F ? 0 : m.length - 1), T < 0 && (T = m.length + T), T >= m.length) {
              if (F) return -1;
              T = m.length - 1;
            } else if (T < 0) {
              if (!F) return -1;
              T = 0;
            }
            if (typeof w == "string" && (w = c.from(w, L)), c.isBuffer(w)) return w.length === 0 ? -1 : p(m, w, T, L, F);
            if (typeof w == "number") return w &= 255, typeof Uint8Array.prototype.indexOf == "function" ? F ? Uint8Array.prototype.indexOf.call(m, w, T) : Uint8Array.prototype.lastIndexOf.call(m, w, T) : p(m, [w], T, L, F);
            throw new TypeError("val must be string, number or Buffer");
          }
          function p(m, w, T, L, F) {
            var V, K = 1, et = m.length, tt = w.length;
            if (L !== void 0 && ((L = String(L).toLowerCase()) === "ucs2" || L === "ucs-2" || L === "utf16le" || L === "utf-16le")) {
              if (m.length < 2 || w.length < 2) return -1;
              K = 2, et /= 2, tt /= 2, T /= 2;
            }
            function at(Wt, mt) {
              return K === 1 ? Wt[mt] : Wt.readUInt16BE(mt * K);
            }
            if (F) {
              var lt = -1;
              for (V = T; V < et; V++) if (at(m, V) === at(w, lt === -1 ? 0 : V - lt)) {
                if (lt === -1 && (lt = V), V - lt + 1 === tt) return lt * K;
              } else lt !== -1 && (V -= V - lt), lt = -1;
            } else for (T + tt > et && (T = et - tt), V = T; V >= 0; V--) {
              for (var Ft = !0, Bt = 0; Bt < tt; Bt++) if (at(m, V + Bt) !== at(w, Bt)) {
                Ft = !1;
                break;
              }
              if (Ft) return V;
            }
            return -1;
          }
          function k(m, w, T, L) {
            T = Number(T) || 0;
            var F = m.length - T;
            L ? (L = Number(L)) > F && (L = F) : L = F;
            var V = w.length;
            L > V / 2 && (L = V / 2);
            for (var K = 0; K < L; ++K) {
              var et = parseInt(w.substr(2 * K, 2), 16);
              if (J(et)) return K;
              m[T + K] = et;
            }
            return K;
          }
          function C(m, w, T, L) {
            return Z(q(w, m.length - T), m, T, L);
          }
          function R(m, w, T, L) {
            return Z(function(F) {
              for (var V = [], K = 0; K < F.length; ++K) V.push(255 & F.charCodeAt(K));
              return V;
            }(w), m, T, L);
          }
          function P(m, w, T, L) {
            return R(m, w, T, L);
          }
          function E(m, w, T, L) {
            return Z(Y(w), m, T, L);
          }
          function H(m, w, T, L) {
            return Z(function(F, V) {
              for (var K, et, tt, at = [], lt = 0; lt < F.length && !((V -= 2) < 0); ++lt) K = F.charCodeAt(lt), et = K >> 8, tt = K % 256, at.push(tt), at.push(et);
              return at;
            }(w, m.length - T), m, T, L);
          }
          function $(m, w, T) {
            return w === 0 && T === m.length ? r.fromByteArray(m) : r.fromByteArray(m.slice(w, T));
          }
          function A(m, w, T) {
            T = Math.min(m.length, T);
            for (var L = [], F = w; F < T; ) {
              var V, K, et, tt, at = m[F], lt = null, Ft = at > 239 ? 4 : at > 223 ? 3 : at > 191 ? 2 : 1;
              if (F + Ft <= T) switch (Ft) {
                case 1:
                  at < 128 && (lt = at);
                  break;
                case 2:
                  (192 & (V = m[F + 1])) == 128 && (tt = (31 & at) << 6 | 63 & V) > 127 && (lt = tt);
                  break;
                case 3:
                  V = m[F + 1], K = m[F + 2], (192 & V) == 128 && (192 & K) == 128 && (tt = (15 & at) << 12 | (63 & V) << 6 | 63 & K) > 2047 && (tt < 55296 || tt > 57343) && (lt = tt);
                  break;
                case 4:
                  V = m[F + 1], K = m[F + 2], et = m[F + 3], (192 & V) == 128 && (192 & K) == 128 && (192 & et) == 128 && (tt = (15 & at) << 18 | (63 & V) << 12 | (63 & K) << 6 | 63 & et) > 65535 && tt < 1114112 && (lt = tt);
              }
              lt === null ? (lt = 65533, Ft = 1) : lt > 65535 && (lt -= 65536, L.push(lt >>> 10 & 1023 | 55296), lt = 56320 | 1023 & lt), L.push(lt), F += Ft;
            }
            return function(Bt) {
              var Wt = Bt.length;
              if (Wt <= I) return String.fromCharCode.apply(String, Bt);
              for (var mt = "", bt = 0; bt < Wt; ) mt += String.fromCharCode.apply(String, Bt.slice(bt, bt += I));
              return mt;
            }(L);
          }
          o.kMaxLength = n, c.TYPED_ARRAY_SUPPORT = function() {
            try {
              var m = new Uint8Array(1);
              return m.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, m.foo() === 42;
            } catch {
              return !1;
            }
          }(), c.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(c.prototype, "parent", { enumerable: !0, get: function() {
            if (c.isBuffer(this)) return this.buffer;
          } }), Object.defineProperty(c.prototype, "offset", { enumerable: !0, get: function() {
            if (c.isBuffer(this)) return this.byteOffset;
          } }), typeof Symbol < "u" && Symbol.species != null && c[Symbol.species] === c && Object.defineProperty(c, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), c.poolSize = 8192, c.from = function(m, w, T) {
            return d(m, w, T);
          }, c.prototype.__proto__ = Uint8Array.prototype, c.__proto__ = Uint8Array, c.alloc = function(m, w, T) {
            return function(L, F, V) {
              return u(L), L <= 0 ? h(L) : F !== void 0 ? typeof V == "string" ? h(L).fill(F, V) : h(L).fill(F) : h(L);
            }(m, w, T);
          }, c.allocUnsafe = function(m) {
            return f(m);
          }, c.allocUnsafeSlow = function(m) {
            return f(m);
          }, c.isBuffer = function(m) {
            return m != null && m._isBuffer === !0 && m !== c.prototype;
          }, c.compare = function(m, w) {
            if (Q(m, Uint8Array) && (m = c.from(m, m.offset, m.byteLength)), Q(w, Uint8Array) && (w = c.from(w, w.offset, w.byteLength)), !c.isBuffer(m) || !c.isBuffer(w)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (m === w) return 0;
            for (var T = m.length, L = w.length, F = 0, V = Math.min(T, L); F < V; ++F) if (m[F] !== w[F]) {
              T = m[F], L = w[F];
              break;
            }
            return T < L ? -1 : L < T ? 1 : 0;
          }, c.isEncoding = function(m) {
            switch (String(m).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, c.concat = function(m, w) {
            if (!Array.isArray(m)) throw new TypeError('"list" argument must be an Array of Buffers');
            if (m.length === 0) return c.alloc(0);
            var T;
            if (w === void 0) for (w = 0, T = 0; T < m.length; ++T) w += m[T].length;
            var L = c.allocUnsafe(w), F = 0;
            for (T = 0; T < m.length; ++T) {
              var V = m[T];
              if (Q(V, Uint8Array) && (V = c.from(V)), !c.isBuffer(V)) throw new TypeError('"list" argument must be an Array of Buffers');
              V.copy(L, F), F += V.length;
            }
            return L;
          }, c.byteLength = v, c.prototype._isBuffer = !0, c.prototype.swap16 = function() {
            var m = this.length;
            if (m % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var w = 0; w < m; w += 2) b(this, w, w + 1);
            return this;
          }, c.prototype.swap32 = function() {
            var m = this.length;
            if (m % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var w = 0; w < m; w += 4) b(this, w, w + 3), b(this, w + 1, w + 2);
            return this;
          }, c.prototype.swap64 = function() {
            var m = this.length;
            if (m % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var w = 0; w < m; w += 8) b(this, w, w + 7), b(this, w + 1, w + 6), b(this, w + 2, w + 5), b(this, w + 3, w + 4);
            return this;
          }, c.prototype.toString = function() {
            var m = this.length;
            return m === 0 ? "" : arguments.length === 0 ? A(this, 0, m) : (function(w, T, L) {
              var F = !1;
              if ((T === void 0 || T < 0) && (T = 0), T > this.length || ((L === void 0 || L > this.length) && (L = this.length), L <= 0) || (L >>>= 0) <= (T >>>= 0)) return "";
              for (w || (w = "utf8"); ; ) switch (w) {
                case "hex":
                  return B(this, T, L);
                case "utf8":
                case "utf-8":
                  return A(this, T, L);
                case "ascii":
                  return S(this, T, L);
                case "latin1":
                case "binary":
                  return _(this, T, L);
                case "base64":
                  return $(this, T, L);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return j(this, T, L);
                default:
                  if (F) throw new TypeError("Unknown encoding: " + w);
                  w = (w + "").toLowerCase(), F = !0;
              }
            }).apply(this, arguments);
          }, c.prototype.toLocaleString = c.prototype.toString, c.prototype.equals = function(m) {
            if (!c.isBuffer(m)) throw new TypeError("Argument must be a Buffer");
            return this === m || c.compare(this, m) === 0;
          }, c.prototype.inspect = function() {
            var m = "", w = o.INSPECT_MAX_BYTES;
            return m = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(), this.length > w && (m += " ... "), "<Buffer " + m + ">";
          }, c.prototype.compare = function(m, w, T, L, F) {
            if (Q(m, Uint8Array) && (m = c.from(m, m.offset, m.byteLength)), !c.isBuffer(m)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof m);
            if (w === void 0 && (w = 0), T === void 0 && (T = m ? m.length : 0), L === void 0 && (L = 0), F === void 0 && (F = this.length), w < 0 || T > m.length || L < 0 || F > this.length) throw new RangeError("out of range index");
            if (L >= F && w >= T) return 0;
            if (L >= F) return -1;
            if (w >= T) return 1;
            if (w >>>= 0, T >>>= 0, L >>>= 0, F >>>= 0, this === m) return 0;
            for (var V = F - L, K = T - w, et = Math.min(V, K), tt = this.slice(L, F), at = m.slice(w, T), lt = 0; lt < et; ++lt) if (tt[lt] !== at[lt]) {
              V = tt[lt], K = at[lt];
              break;
            }
            return V < K ? -1 : K < V ? 1 : 0;
          }, c.prototype.includes = function(m, w, T) {
            return this.indexOf(m, w, T) !== -1;
          }, c.prototype.indexOf = function(m, w, T) {
            return x(this, m, w, T, !0);
          }, c.prototype.lastIndexOf = function(m, w, T) {
            return x(this, m, w, T, !1);
          }, c.prototype.write = function(m, w, T, L) {
            if (w === void 0) L = "utf8", T = this.length, w = 0;
            else if (T === void 0 && typeof w == "string") L = w, T = this.length, w = 0;
            else {
              if (!isFinite(w)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              w >>>= 0, isFinite(T) ? (T >>>= 0, L === void 0 && (L = "utf8")) : (L = T, T = void 0);
            }
            var F = this.length - w;
            if ((T === void 0 || T > F) && (T = F), m.length > 0 && (T < 0 || w < 0) || w > this.length) throw new RangeError("Attempt to write outside buffer bounds");
            L || (L = "utf8");
            for (var V = !1; ; ) switch (L) {
              case "hex":
                return k(this, m, w, T);
              case "utf8":
              case "utf-8":
                return C(this, m, w, T);
              case "ascii":
                return R(this, m, w, T);
              case "latin1":
              case "binary":
                return P(this, m, w, T);
              case "base64":
                return E(this, m, w, T);
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return H(this, m, w, T);
              default:
                if (V) throw new TypeError("Unknown encoding: " + L);
                L = ("" + L).toLowerCase(), V = !0;
            }
          }, c.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var I = 4096;
          function S(m, w, T) {
            var L = "";
            T = Math.min(m.length, T);
            for (var F = w; F < T; ++F) L += String.fromCharCode(127 & m[F]);
            return L;
          }
          function _(m, w, T) {
            var L = "";
            T = Math.min(m.length, T);
            for (var F = w; F < T; ++F) L += String.fromCharCode(m[F]);
            return L;
          }
          function B(m, w, T) {
            var L = m.length;
            (!w || w < 0) && (w = 0), (!T || T < 0 || T > L) && (T = L);
            for (var F = "", V = w; V < T; ++V) F += U(m[V]);
            return F;
          }
          function j(m, w, T) {
            for (var L = m.slice(w, T), F = "", V = 0; V < L.length; V += 2) F += String.fromCharCode(L[V] + 256 * L[V + 1]);
            return F;
          }
          function X(m, w, T) {
            if (m % 1 != 0 || m < 0) throw new RangeError("offset is not uint");
            if (m + w > T) throw new RangeError("Trying to access beyond buffer length");
          }
          function z(m, w, T, L, F, V) {
            if (!c.isBuffer(m)) throw new TypeError('"buffer" argument must be a Buffer instance');
            if (w > F || w < V) throw new RangeError('"value" argument is out of bounds');
            if (T + L > m.length) throw new RangeError("Index out of range");
          }
          function M(m, w, T, L, F, V) {
            if (T + L > m.length) throw new RangeError("Index out of range");
            if (T < 0) throw new RangeError("Index out of range");
          }
          function D(m, w, T, L, F) {
            return w = +w, T >>>= 0, F || M(m, 0, T, 4), l.write(m, w, T, L, 23, 4), T + 4;
          }
          function W(m, w, T, L, F) {
            return w = +w, T >>>= 0, F || M(m, 0, T, 8), l.write(m, w, T, L, 52, 8), T + 8;
          }
          c.prototype.slice = function(m, w) {
            var T = this.length;
            m = ~~m, w = w === void 0 ? T : ~~w, m < 0 ? (m += T) < 0 && (m = 0) : m > T && (m = T), w < 0 ? (w += T) < 0 && (w = 0) : w > T && (w = T), w < m && (w = m);
            var L = this.subarray(m, w);
            return L.__proto__ = c.prototype, L;
          }, c.prototype.readUIntLE = function(m, w, T) {
            m >>>= 0, w >>>= 0, T || X(m, w, this.length);
            for (var L = this[m], F = 1, V = 0; ++V < w && (F *= 256); ) L += this[m + V] * F;
            return L;
          }, c.prototype.readUIntBE = function(m, w, T) {
            m >>>= 0, w >>>= 0, T || X(m, w, this.length);
            for (var L = this[m + --w], F = 1; w > 0 && (F *= 256); ) L += this[m + --w] * F;
            return L;
          }, c.prototype.readUInt8 = function(m, w) {
            return m >>>= 0, w || X(m, 1, this.length), this[m];
          }, c.prototype.readUInt16LE = function(m, w) {
            return m >>>= 0, w || X(m, 2, this.length), this[m] | this[m + 1] << 8;
          }, c.prototype.readUInt16BE = function(m, w) {
            return m >>>= 0, w || X(m, 2, this.length), this[m] << 8 | this[m + 1];
          }, c.prototype.readUInt32LE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), (this[m] | this[m + 1] << 8 | this[m + 2] << 16) + 16777216 * this[m + 3];
          }, c.prototype.readUInt32BE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), 16777216 * this[m] + (this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3]);
          }, c.prototype.readIntLE = function(m, w, T) {
            m >>>= 0, w >>>= 0, T || X(m, w, this.length);
            for (var L = this[m], F = 1, V = 0; ++V < w && (F *= 256); ) L += this[m + V] * F;
            return L >= (F *= 128) && (L -= Math.pow(2, 8 * w)), L;
          }, c.prototype.readIntBE = function(m, w, T) {
            m >>>= 0, w >>>= 0, T || X(m, w, this.length);
            for (var L = w, F = 1, V = this[m + --L]; L > 0 && (F *= 256); ) V += this[m + --L] * F;
            return V >= (F *= 128) && (V -= Math.pow(2, 8 * w)), V;
          }, c.prototype.readInt8 = function(m, w) {
            return m >>>= 0, w || X(m, 1, this.length), 128 & this[m] ? -1 * (255 - this[m] + 1) : this[m];
          }, c.prototype.readInt16LE = function(m, w) {
            m >>>= 0, w || X(m, 2, this.length);
            var T = this[m] | this[m + 1] << 8;
            return 32768 & T ? 4294901760 | T : T;
          }, c.prototype.readInt16BE = function(m, w) {
            m >>>= 0, w || X(m, 2, this.length);
            var T = this[m + 1] | this[m] << 8;
            return 32768 & T ? 4294901760 | T : T;
          }, c.prototype.readInt32LE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), this[m] | this[m + 1] << 8 | this[m + 2] << 16 | this[m + 3] << 24;
          }, c.prototype.readInt32BE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), this[m] << 24 | this[m + 1] << 16 | this[m + 2] << 8 | this[m + 3];
          }, c.prototype.readFloatLE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), l.read(this, m, !0, 23, 4);
          }, c.prototype.readFloatBE = function(m, w) {
            return m >>>= 0, w || X(m, 4, this.length), l.read(this, m, !1, 23, 4);
          }, c.prototype.readDoubleLE = function(m, w) {
            return m >>>= 0, w || X(m, 8, this.length), l.read(this, m, !0, 52, 8);
          }, c.prototype.readDoubleBE = function(m, w) {
            return m >>>= 0, w || X(m, 8, this.length), l.read(this, m, !1, 52, 8);
          }, c.prototype.writeUIntLE = function(m, w, T, L) {
            m = +m, w >>>= 0, T >>>= 0, L || z(this, m, w, T, Math.pow(2, 8 * T) - 1, 0);
            var F = 1, V = 0;
            for (this[w] = 255 & m; ++V < T && (F *= 256); ) this[w + V] = m / F & 255;
            return w + T;
          }, c.prototype.writeUIntBE = function(m, w, T, L) {
            m = +m, w >>>= 0, T >>>= 0, L || z(this, m, w, T, Math.pow(2, 8 * T) - 1, 0);
            var F = T - 1, V = 1;
            for (this[w + F] = 255 & m; --F >= 0 && (V *= 256); ) this[w + F] = m / V & 255;
            return w + T;
          }, c.prototype.writeUInt8 = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 1, 255, 0), this[w] = 255 & m, w + 1;
          }, c.prototype.writeUInt16LE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 2, 65535, 0), this[w] = 255 & m, this[w + 1] = m >>> 8, w + 2;
          }, c.prototype.writeUInt16BE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 2, 65535, 0), this[w] = m >>> 8, this[w + 1] = 255 & m, w + 2;
          }, c.prototype.writeUInt32LE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 4, 4294967295, 0), this[w + 3] = m >>> 24, this[w + 2] = m >>> 16, this[w + 1] = m >>> 8, this[w] = 255 & m, w + 4;
          }, c.prototype.writeUInt32BE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 4, 4294967295, 0), this[w] = m >>> 24, this[w + 1] = m >>> 16, this[w + 2] = m >>> 8, this[w + 3] = 255 & m, w + 4;
          }, c.prototype.writeIntLE = function(m, w, T, L) {
            if (m = +m, w >>>= 0, !L) {
              var F = Math.pow(2, 8 * T - 1);
              z(this, m, w, T, F - 1, -F);
            }
            var V = 0, K = 1, et = 0;
            for (this[w] = 255 & m; ++V < T && (K *= 256); ) m < 0 && et === 0 && this[w + V - 1] !== 0 && (et = 1), this[w + V] = (m / K >> 0) - et & 255;
            return w + T;
          }, c.prototype.writeIntBE = function(m, w, T, L) {
            if (m = +m, w >>>= 0, !L) {
              var F = Math.pow(2, 8 * T - 1);
              z(this, m, w, T, F - 1, -F);
            }
            var V = T - 1, K = 1, et = 0;
            for (this[w + V] = 255 & m; --V >= 0 && (K *= 256); ) m < 0 && et === 0 && this[w + V + 1] !== 0 && (et = 1), this[w + V] = (m / K >> 0) - et & 255;
            return w + T;
          }, c.prototype.writeInt8 = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 1, 127, -128), m < 0 && (m = 255 + m + 1), this[w] = 255 & m, w + 1;
          }, c.prototype.writeInt16LE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 2, 32767, -32768), this[w] = 255 & m, this[w + 1] = m >>> 8, w + 2;
          }, c.prototype.writeInt16BE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 2, 32767, -32768), this[w] = m >>> 8, this[w + 1] = 255 & m, w + 2;
          }, c.prototype.writeInt32LE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 4, 2147483647, -2147483648), this[w] = 255 & m, this[w + 1] = m >>> 8, this[w + 2] = m >>> 16, this[w + 3] = m >>> 24, w + 4;
          }, c.prototype.writeInt32BE = function(m, w, T) {
            return m = +m, w >>>= 0, T || z(this, m, w, 4, 2147483647, -2147483648), m < 0 && (m = 4294967295 + m + 1), this[w] = m >>> 24, this[w + 1] = m >>> 16, this[w + 2] = m >>> 8, this[w + 3] = 255 & m, w + 4;
          }, c.prototype.writeFloatLE = function(m, w, T) {
            return D(this, m, w, !0, T);
          }, c.prototype.writeFloatBE = function(m, w, T) {
            return D(this, m, w, !1, T);
          }, c.prototype.writeDoubleLE = function(m, w, T) {
            return W(this, m, w, !0, T);
          }, c.prototype.writeDoubleBE = function(m, w, T) {
            return W(this, m, w, !1, T);
          }, c.prototype.copy = function(m, w, T, L) {
            if (!c.isBuffer(m)) throw new TypeError("argument should be a Buffer");
            if (T || (T = 0), L || L === 0 || (L = this.length), w >= m.length && (w = m.length), w || (w = 0), L > 0 && L < T && (L = T), L === T || m.length === 0 || this.length === 0) return 0;
            if (w < 0) throw new RangeError("targetStart out of bounds");
            if (T < 0 || T >= this.length) throw new RangeError("Index out of range");
            if (L < 0) throw new RangeError("sourceEnd out of bounds");
            L > this.length && (L = this.length), m.length - w < L - T && (L = m.length - w + T);
            var F = L - T;
            if (this === m && typeof Uint8Array.prototype.copyWithin == "function") this.copyWithin(w, T, L);
            else if (this === m && T < w && w < L) for (var V = F - 1; V >= 0; --V) m[V + w] = this[V + T];
            else Uint8Array.prototype.set.call(m, this.subarray(T, L), w);
            return F;
          }, c.prototype.fill = function(m, w, T, L) {
            if (typeof m == "string") {
              if (typeof w == "string" ? (L = w, w = 0, T = this.length) : typeof T == "string" && (L = T, T = this.length), L !== void 0 && typeof L != "string") throw new TypeError("encoding must be a string");
              if (typeof L == "string" && !c.isEncoding(L)) throw new TypeError("Unknown encoding: " + L);
              if (m.length === 1) {
                var F = m.charCodeAt(0);
                (L === "utf8" && F < 128 || L === "latin1") && (m = F);
              }
            } else typeof m == "number" && (m &= 255);
            if (w < 0 || this.length < w || this.length < T) throw new RangeError("Out of range index");
            if (T <= w) return this;
            var V;
            if (w >>>= 0, T = T === void 0 ? this.length : T >>> 0, m || (m = 0), typeof m == "number") for (V = w; V < T; ++V) this[V] = m;
            else {
              var K = c.isBuffer(m) ? m : c.from(m, L), et = K.length;
              if (et === 0) throw new TypeError('The value "' + m + '" is invalid for argument "value"');
              for (V = 0; V < T - w; ++V) this[V + w] = K[V % et];
            }
            return this;
          };
          var N = /[^+/0-9A-Za-z-_]/g;
          function U(m) {
            return m < 16 ? "0" + m.toString(16) : m.toString(16);
          }
          function q(m, w) {
            var T;
            w = w || 1 / 0;
            for (var L = m.length, F = null, V = [], K = 0; K < L; ++K) {
              if ((T = m.charCodeAt(K)) > 55295 && T < 57344) {
                if (!F) {
                  if (T > 56319) {
                    (w -= 3) > -1 && V.push(239, 191, 189);
                    continue;
                  }
                  if (K + 1 === L) {
                    (w -= 3) > -1 && V.push(239, 191, 189);
                    continue;
                  }
                  F = T;
                  continue;
                }
                if (T < 56320) {
                  (w -= 3) > -1 && V.push(239, 191, 189), F = T;
                  continue;
                }
                T = 65536 + (F - 55296 << 10 | T - 56320);
              } else F && (w -= 3) > -1 && V.push(239, 191, 189);
              if (F = null, T < 128) {
                if ((w -= 1) < 0) break;
                V.push(T);
              } else if (T < 2048) {
                if ((w -= 2) < 0) break;
                V.push(T >> 6 | 192, 63 & T | 128);
              } else if (T < 65536) {
                if ((w -= 3) < 0) break;
                V.push(T >> 12 | 224, T >> 6 & 63 | 128, 63 & T | 128);
              } else {
                if (!(T < 1114112)) throw new Error("Invalid code point");
                if ((w -= 4) < 0) break;
                V.push(T >> 18 | 240, T >> 12 & 63 | 128, T >> 6 & 63 | 128, 63 & T | 128);
              }
            }
            return V;
          }
          function Y(m) {
            return r.toByteArray(function(w) {
              if ((w = (w = w.split("=")[0]).trim().replace(N, "")).length < 2) return "";
              for (; w.length % 4 != 0; ) w += "=";
              return w;
            }(m));
          }
          function Z(m, w, T, L) {
            for (var F = 0; F < L && !(F + T >= w.length || F >= m.length); ++F) w[F + T] = m[F];
            return F;
          }
          function Q(m, w) {
            return m instanceof w || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === w.name;
          }
          function J(m) {
            return m != m;
          }
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "base64-js": 13, buffer: 17, ieee754: 23 }], 18: [function(i, s, o) {
      (function(a) {
        (function() {
          o.formatArgs = function(l) {
            if (l[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + l[0] + (this.useColors ? "%c " : " ") + "+" + s.exports.humanize(this.diff), !this.useColors) return;
            const n = "color: " + this.color;
            l.splice(1, 0, n, "color: inherit");
            let h = 0, c = 0;
            l[0].replace(/%[a-zA-Z%]/g, (d) => {
              d !== "%%" && d === "%c" && (c = ++h);
            }), l.splice(c, 0, n);
          }, o.save = function(l) {
            try {
              l ? o.storage.setItem("debug", l) : o.storage.removeItem("debug");
            } catch {
            }
          }, o.load = function() {
            let l;
            try {
              l = o.storage.getItem("debug");
            } catch {
            }
            return !l && a !== void 0 && "env" in a && (l = a.env.DEBUG), l;
          }, o.useColors = function() {
            return typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs) ? !0 : typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/) ? !1 : typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }, o.storage = function() {
            try {
              return localStorage;
            } catch {
            }
          }(), o.destroy = /* @__PURE__ */ (() => {
            let l = !1;
            return () => {
              l || (l = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })(), o.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], o.log = console.debug || console.log || (() => {
          }), s.exports = i("./common")(o);
          const { formatters: r } = s.exports;
          r.j = function(l) {
            try {
              return JSON.stringify(l);
            } catch (n) {
              return "[UnexpectedJSONParseError]: " + n.message;
            }
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { "./common": 19, _process: 50 }], 19: [function(i, s, o) {
      s.exports = function(a) {
        function r(h) {
          let c, d, u, f = null;
          function g(...y) {
            if (!g.enabled) return;
            const v = g, b = Number(/* @__PURE__ */ new Date()), x = b - (c || b);
            v.diff = x, v.prev = c, v.curr = b, c = b, y[0] = r.coerce(y[0]), typeof y[0] != "string" && y.unshift("%O");
            let p = 0;
            y[0] = y[0].replace(/%([a-zA-Z%])/g, (k, C) => {
              if (k === "%%") return "%";
              p++;
              const R = r.formatters[C];
              if (typeof R == "function") {
                const P = y[p];
                k = R.call(v, P), y.splice(p, 1), p--;
              }
              return k;
            }), r.formatArgs.call(v, y), (v.log || r.log).apply(v, y);
          }
          return g.namespace = h, g.useColors = r.useColors(), g.color = r.selectColor(h), g.extend = l, g.destroy = r.destroy, Object.defineProperty(g, "enabled", { enumerable: !0, configurable: !1, get: () => f !== null ? f : (d !== r.namespaces && (d = r.namespaces, u = r.enabled(h)), u), set: (y) => {
            f = y;
          } }), typeof r.init == "function" && r.init(g), g;
        }
        function l(h, c) {
          const d = r(this.namespace + (c === void 0 ? ":" : c) + h);
          return d.log = this.log, d;
        }
        function n(h) {
          return h.toString().substring(2, h.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        return r.debug = r, r.default = r, r.coerce = function(h) {
          return h instanceof Error ? h.stack || h.message : h;
        }, r.disable = function() {
          const h = [...r.names.map(n), ...r.skips.map(n).map((c) => "-" + c)].join(",");
          return r.enable(""), h;
        }, r.enable = function(h) {
          let c;
          r.save(h), r.namespaces = h, r.names = [], r.skips = [];
          const d = (typeof h == "string" ? h : "").split(/[\s,]+/), u = d.length;
          for (c = 0; c < u; c++) d[c] && ((h = d[c].replace(/\*/g, ".*?"))[0] === "-" ? r.skips.push(new RegExp("^" + h.substr(1) + "$")) : r.names.push(new RegExp("^" + h + "$")));
        }, r.enabled = function(h) {
          if (h[h.length - 1] === "*") return !0;
          let c, d;
          for (c = 0, d = r.skips.length; c < d; c++) if (r.skips[c].test(h)) return !1;
          for (c = 0, d = r.names.length; c < d; c++) if (r.names[c].test(h)) return !0;
          return !1;
        }, r.humanize = i("ms"), r.destroy = function() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }, Object.keys(a).forEach((h) => {
          r[h] = a[h];
        }), r.names = [], r.skips = [], r.formatters = {}, r.selectColor = function(h) {
          let c = 0;
          for (let d = 0; d < h.length; d++) c = (c << 5) - c + h.charCodeAt(d), c |= 0;
          return r.colors[Math.abs(c) % r.colors.length];
        }, r.enable(r.load()), r;
      };
    }, { ms: 45 }], 20: [function(i, s, o) {
      (function(a, r) {
        (function() {
          var l = i("readable-stream"), n = i("end-of-stream"), h = i("inherits"), c = i("stream-shift"), d = r.from && r.from !== Uint8Array.from ? r.from([0]) : new r([0]), u = function(v, b) {
            v._corked ? v.once("uncork", b) : b();
          }, f = function(v, b) {
            return function(x) {
              x ? function(p, k) {
                p._autoDestroy && p.destroy(k);
              }(v, x.message === "premature close" ? null : x) : b && !v._ended && v.end();
            };
          }, g = function() {
          }, y = function(v, b, x) {
            if (!(this instanceof y)) return new y(v, b, x);
            l.Duplex.call(this, x), this._writable = null, this._readable = null, this._readable2 = null, this._autoDestroy = !x || x.autoDestroy !== !1, this._forwardDestroy = !x || x.destroy !== !1, this._forwardEnd = !x || x.end !== !1, this._corked = 1, this._ondrain = null, this._drained = !1, this._forwarding = !1, this._unwrite = null, this._unread = null, this._ended = !1, this.destroyed = !1, v && this.setWritable(v), b && this.setReadable(b);
          };
          h(y, l.Duplex), y.obj = function(v, b, x) {
            return x || (x = {}), x.objectMode = !0, x.highWaterMark = 16, new y(v, b, x);
          }, y.prototype.cork = function() {
            ++this._corked == 1 && this.emit("cork");
          }, y.prototype.uncork = function() {
            this._corked && --this._corked == 0 && this.emit("uncork");
          }, y.prototype.setWritable = function(v) {
            if (this._unwrite && this._unwrite(), this.destroyed) v && v.destroy && v.destroy();
            else if (v !== null && v !== !1) {
              var b = this, x = n(v, { writable: !0, readable: !1 }, f(this, this._forwardEnd)), p = function() {
                var k = b._ondrain;
                b._ondrain = null, k && k();
              };
              this._unwrite && a.nextTick(p), this._writable = v, this._writable.on("drain", p), this._unwrite = function() {
                b._writable.removeListener("drain", p), x();
              }, this.uncork();
            } else this.end();
          }, y.prototype.setReadable = function(v) {
            if (this._unread && this._unread(), this.destroyed) v && v.destroy && v.destroy();
            else {
              if (v === null || v === !1) return this.push(null), void this.resume();
              var b, x = this, p = n(v, { writable: !1, readable: !0 }, f(this)), k = function() {
                x._forward();
              }, C = function() {
                x.push(null);
              };
              this._drained = !0, this._readable = v, this._readable2 = v._readableState ? v : (b = v, new l.Readable({ objectMode: !0, highWaterMark: 16 }).wrap(b)), this._readable2.on("readable", k), this._readable2.on("end", C), this._unread = function() {
                x._readable2.removeListener("readable", k), x._readable2.removeListener("end", C), p();
              }, this._forward();
            }
          }, y.prototype._read = function() {
            this._drained = !0, this._forward();
          }, y.prototype._forward = function() {
            if (!this._forwarding && this._readable2 && this._drained) {
              var v;
              for (this._forwarding = !0; this._drained && (v = c(this._readable2)) !== null; ) this.destroyed || (this._drained = this.push(v));
              this._forwarding = !1;
            }
          }, y.prototype.destroy = function(v, b) {
            if (b || (b = g), this.destroyed) return b(null);
            this.destroyed = !0;
            var x = this;
            a.nextTick(function() {
              x._destroy(v), b(null);
            });
          }, y.prototype._destroy = function(v) {
            if (v) {
              var b = this._ondrain;
              this._ondrain = null, b ? b(v) : this.emit("error", v);
            }
            this._forwardDestroy && (this._readable && this._readable.destroy && this._readable.destroy(), this._writable && this._writable.destroy && this._writable.destroy()), this.emit("close");
          }, y.prototype._write = function(v, b, x) {
            if (!this.destroyed) return this._corked ? u(this, this._write.bind(this, v, b, x)) : v === d ? this._finish(x) : this._writable ? void (this._writable.write(v) === !1 ? this._ondrain = x : this.destroyed || x()) : x();
          }, y.prototype._finish = function(v) {
            var b = this;
            this.emit("preend"), u(this, function() {
              var x, p;
              x = b._forwardEnd && b._writable, p = function() {
                b._writableState.prefinished === !1 && (b._writableState.prefinished = !0), b.emit("prefinish"), u(b, v);
              }, x ? x._writableState && x._writableState.finished ? p() : x._writableState ? x.end(p) : (x.end(), p()) : p();
            });
          }, y.prototype.end = function(v, b, x) {
            return typeof v == "function" ? this.end(null, null, v) : typeof b == "function" ? this.end(v, null, b) : (this._ended = !0, v && this.write(v), this._writableState.ending || this._writableState.destroyed || this.write(d), l.Writable.prototype.end.call(this, x));
          }, s.exports = y;
        }).call(this);
      }).call(this, i("_process"), i("buffer").Buffer);
    }, { _process: 50, buffer: 17, "end-of-stream": 21, inherits: 24, "readable-stream": 69, "stream-shift": 74 }], 21: [function(i, s, o) {
      (function(a) {
        (function() {
          var r = i("once"), l = function() {
          }, n = function(h, c, d) {
            if (typeof c == "function") return n(h, null, c);
            c || (c = {}), d = r(d || l);
            var u = h._writableState, f = h._readableState, g = c.readable || c.readable !== !1 && h.readable, y = c.writable || c.writable !== !1 && h.writable, v = !1, b = function() {
              h.writable || x();
            }, x = function() {
              y = !1, g || d.call(h);
            }, p = function() {
              g = !1, y || d.call(h);
            }, k = function(H) {
              d.call(h, H ? new Error("exited with error code: " + H) : null);
            }, C = function(H) {
              d.call(h, H);
            }, R = function() {
              a.nextTick(P);
            }, P = function() {
              if (!v) return (!g || f && f.ended && !f.destroyed) && (!y || u && u.ended && !u.destroyed) ? void 0 : d.call(h, new Error("premature close"));
            }, E = function() {
              h.req.on("finish", x);
            };
            return function(H) {
              return H.setHeader && typeof H.abort == "function";
            }(h) ? (h.on("complete", x), h.on("abort", R), h.req ? E() : h.on("request", E)) : y && !u && (h.on("end", b), h.on("close", b)), function(H) {
              return H.stdio && Array.isArray(H.stdio) && H.stdio.length === 3;
            }(h) && h.on("exit", k), h.on("end", p), h.on("finish", x), c.error !== !1 && h.on("error", C), h.on("close", R), function() {
              v = !0, h.removeListener("complete", x), h.removeListener("abort", R), h.removeListener("request", E), h.req && h.req.removeListener("finish", x), h.removeListener("end", b), h.removeListener("close", b), h.removeListener("finish", x), h.removeListener("exit", k), h.removeListener("end", p), h.removeListener("error", C), h.removeListener("close", R);
            };
          };
          s.exports = n;
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50, once: 48 }], 22: [function(i, s, o) {
      var a = Object.create || function(p) {
        var k = function() {
        };
        return k.prototype = p, new k();
      }, r = Object.keys || function(p) {
        var k = [];
        for (var C in p) Object.prototype.hasOwnProperty.call(p, C) && k.push(C);
        return C;
      }, l = Function.prototype.bind || function(p) {
        var k = this;
        return function() {
          return k.apply(p, arguments);
        };
      };
      function n() {
        this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = a(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }
      s.exports = n, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._maxListeners = void 0;
      var h, c = 10;
      try {
        var d = {};
        Object.defineProperty && Object.defineProperty(d, "x", { value: 0 }), h = d.x === 0;
      } catch {
        h = !1;
      }
      function u(p) {
        return p._maxListeners === void 0 ? n.defaultMaxListeners : p._maxListeners;
      }
      function f(p, k, C, R) {
        var P, E, H;
        if (typeof C != "function") throw new TypeError('"listener" argument must be a function');
        if ((E = p._events) ? (E.newListener && (p.emit("newListener", k, C.listener ? C.listener : C), E = p._events), H = E[k]) : (E = p._events = a(null), p._eventsCount = 0), H) {
          if (typeof H == "function" ? H = E[k] = R ? [C, H] : [H, C] : R ? H.unshift(C) : H.push(C), !H.warned && (P = u(p)) && P > 0 && H.length > P) {
            H.warned = !0;
            var $ = new Error("Possible EventEmitter memory leak detected. " + H.length + ' "' + String(k) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
            $.name = "MaxListenersExceededWarning", $.emitter = p, $.type = k, $.count = H.length, typeof console == "object" && console.warn && console.warn("%s: %s", $.name, $.message);
          }
        } else H = E[k] = C, ++p._eventsCount;
        return p;
      }
      function g() {
        if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length) {
          case 0:
            return this.listener.call(this.target);
          case 1:
            return this.listener.call(this.target, arguments[0]);
          case 2:
            return this.listener.call(this.target, arguments[0], arguments[1]);
          case 3:
            return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);
          default:
            for (var p = new Array(arguments.length), k = 0; k < p.length; ++k) p[k] = arguments[k];
            this.listener.apply(this.target, p);
        }
      }
      function y(p, k, C) {
        var R = { fired: !1, wrapFn: void 0, target: p, type: k, listener: C }, P = l.call(g, R);
        return P.listener = C, R.wrapFn = P, P;
      }
      function v(p, k, C) {
        var R = p._events;
        if (!R) return [];
        var P = R[k];
        return P ? typeof P == "function" ? C ? [P.listener || P] : [P] : C ? function(E) {
          for (var H = new Array(E.length), $ = 0; $ < H.length; ++$) H[$] = E[$].listener || E[$];
          return H;
        }(P) : x(P, P.length) : [];
      }
      function b(p) {
        var k = this._events;
        if (k) {
          var C = k[p];
          if (typeof C == "function") return 1;
          if (C) return C.length;
        }
        return 0;
      }
      function x(p, k) {
        for (var C = new Array(k), R = 0; R < k; ++R) C[R] = p[R];
        return C;
      }
      h ? Object.defineProperty(n, "defaultMaxListeners", { enumerable: !0, get: function() {
        return c;
      }, set: function(p) {
        if (typeof p != "number" || p < 0 || p != p) throw new TypeError('"defaultMaxListeners" must be a positive number');
        c = p;
      } }) : n.defaultMaxListeners = c, n.prototype.setMaxListeners = function(p) {
        if (typeof p != "number" || p < 0 || isNaN(p)) throw new TypeError('"n" argument must be a positive number');
        return this._maxListeners = p, this;
      }, n.prototype.getMaxListeners = function() {
        return u(this);
      }, n.prototype.emit = function(p) {
        var k, C, R, P, E, H, $ = p === "error";
        if (H = this._events) $ = $ && H.error == null;
        else if (!$) return !1;
        if ($) {
          if (arguments.length > 1 && (k = arguments[1]), k instanceof Error) throw k;
          var A = new Error('Unhandled "error" event. (' + k + ")");
          throw A.context = k, A;
        }
        if (!(C = H[p])) return !1;
        var I = typeof C == "function";
        switch (R = arguments.length) {
          case 1:
            (function(S, _, B) {
              if (_) S.call(B);
              else for (var j = S.length, X = x(S, j), z = 0; z < j; ++z) X[z].call(B);
            })(C, I, this);
            break;
          case 2:
            (function(S, _, B, j) {
              if (_) S.call(B, j);
              else for (var X = S.length, z = x(S, X), M = 0; M < X; ++M) z[M].call(B, j);
            })(C, I, this, arguments[1]);
            break;
          case 3:
            (function(S, _, B, j, X) {
              if (_) S.call(B, j, X);
              else for (var z = S.length, M = x(S, z), D = 0; D < z; ++D) M[D].call(B, j, X);
            })(C, I, this, arguments[1], arguments[2]);
            break;
          case 4:
            (function(S, _, B, j, X, z) {
              if (_) S.call(B, j, X, z);
              else for (var M = S.length, D = x(S, M), W = 0; W < M; ++W) D[W].call(B, j, X, z);
            })(C, I, this, arguments[1], arguments[2], arguments[3]);
            break;
          default:
            for (P = new Array(R - 1), E = 1; E < R; E++) P[E - 1] = arguments[E];
            (function(S, _, B, j) {
              if (_) S.apply(B, j);
              else for (var X = S.length, z = x(S, X), M = 0; M < X; ++M) z[M].apply(B, j);
            })(C, I, this, P);
        }
        return !0;
      }, n.prototype.addListener = function(p, k) {
        return f(this, p, k, !1);
      }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(p, k) {
        return f(this, p, k, !0);
      }, n.prototype.once = function(p, k) {
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        return this.on(p, y(this, p, k)), this;
      }, n.prototype.prependOnceListener = function(p, k) {
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        return this.prependListener(p, y(this, p, k)), this;
      }, n.prototype.removeListener = function(p, k) {
        var C, R, P, E, H;
        if (typeof k != "function") throw new TypeError('"listener" argument must be a function');
        if (!(R = this._events)) return this;
        if (!(C = R[p])) return this;
        if (C === k || C.listener === k) --this._eventsCount == 0 ? this._events = a(null) : (delete R[p], R.removeListener && this.emit("removeListener", p, C.listener || k));
        else if (typeof C != "function") {
          for (P = -1, E = C.length - 1; E >= 0; E--) if (C[E] === k || C[E].listener === k) {
            H = C[E].listener, P = E;
            break;
          }
          if (P < 0) return this;
          P === 0 ? C.shift() : function($, A) {
            for (var I = A, S = I + 1, _ = $.length; S < _; I += 1, S += 1) $[I] = $[S];
            $.pop();
          }(C, P), C.length === 1 && (R[p] = C[0]), R.removeListener && this.emit("removeListener", p, H || k);
        }
        return this;
      }, n.prototype.removeAllListeners = function(p) {
        var k, C, R;
        if (!(C = this._events)) return this;
        if (!C.removeListener) return arguments.length === 0 ? (this._events = a(null), this._eventsCount = 0) : C[p] && (--this._eventsCount == 0 ? this._events = a(null) : delete C[p]), this;
        if (arguments.length === 0) {
          var P, E = r(C);
          for (R = 0; R < E.length; ++R) (P = E[R]) !== "removeListener" && this.removeAllListeners(P);
          return this.removeAllListeners("removeListener"), this._events = a(null), this._eventsCount = 0, this;
        }
        if (typeof (k = C[p]) == "function") this.removeListener(p, k);
        else if (k) for (R = k.length - 1; R >= 0; R--) this.removeListener(p, k[R]);
        return this;
      }, n.prototype.listeners = function(p) {
        return v(this, p, !0);
      }, n.prototype.rawListeners = function(p) {
        return v(this, p, !1);
      }, n.listenerCount = function(p, k) {
        return typeof p.listenerCount == "function" ? p.listenerCount(k) : b.call(p, k);
      }, n.prototype.listenerCount = b, n.prototype.eventNames = function() {
        return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
      };
    }, {}], 23: [function(i, s, o) {
      o.read = function(a, r, l, n, h) {
        var c, d, u = 8 * h - n - 1, f = (1 << u) - 1, g = f >> 1, y = -7, v = l ? h - 1 : 0, b = l ? -1 : 1, x = a[r + v];
        for (v += b, c = x & (1 << -y) - 1, x >>= -y, y += u; y > 0; c = 256 * c + a[r + v], v += b, y -= 8) ;
        for (d = c & (1 << -y) - 1, c >>= -y, y += n; y > 0; d = 256 * d + a[r + v], v += b, y -= 8) ;
        if (c === 0) c = 1 - g;
        else {
          if (c === f) return d ? NaN : 1 / 0 * (x ? -1 : 1);
          d += Math.pow(2, n), c -= g;
        }
        return (x ? -1 : 1) * d * Math.pow(2, c - n);
      }, o.write = function(a, r, l, n, h, c) {
        var d, u, f, g = 8 * c - h - 1, y = (1 << g) - 1, v = y >> 1, b = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = n ? 0 : c - 1, p = n ? 1 : -1, k = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
        for (r = Math.abs(r), isNaN(r) || r === 1 / 0 ? (u = isNaN(r) ? 1 : 0, d = y) : (d = Math.floor(Math.log(r) / Math.LN2), r * (f = Math.pow(2, -d)) < 1 && (d--, f *= 2), (r += d + v >= 1 ? b / f : b * Math.pow(2, 1 - v)) * f >= 2 && (d++, f /= 2), d + v >= y ? (u = 0, d = y) : d + v >= 1 ? (u = (r * f - 1) * Math.pow(2, h), d += v) : (u = r * Math.pow(2, v - 1) * Math.pow(2, h), d = 0)); h >= 8; a[l + x] = 255 & u, x += p, u /= 256, h -= 8) ;
        for (d = d << h | u, g += h; g > 0; a[l + x] = 255 & d, x += p, d /= 256, g -= 8) ;
        a[l + x - p] |= 128 * k;
      };
    }, {}], 24: [function(i, s, o) {
      typeof Object.create == "function" ? s.exports = function(a, r) {
        r && (a.super_ = r, a.prototype = Object.create(r.prototype, { constructor: { value: a, enumerable: !1, writable: !0, configurable: !0 } }));
      } : s.exports = function(a, r) {
        if (r) {
          a.super_ = r;
          var l = function() {
          };
          l.prototype = r.prototype, a.prototype = new l(), a.prototype.constructor = a;
        }
      };
    }, {}], 25: [function(i, s, o) {
      Object.defineProperty(o, "__esModule", { value: !0 });
      var a = function() {
        function r(l, n) {
          this.color = !0, this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0, this.leftChild = void 0, this.rightChild = void 0, this.key = l, this.value = n;
        }
        return r.prototype.rotateLeft = function() {
          var l = this.parent, n = this.brother, h = this.leftChild, c = this.rightChild;
          if (!c) throw new Error("unknown error");
          var d = c.leftChild, u = c.rightChild;
          return l && (l.leftChild === this ? l.leftChild = c : l.rightChild === this && (l.rightChild = c)), c.parent = l, c.brother = n, c.leftChild = this, c.rightChild = u, n && (n.brother = c), this.parent = c, this.brother = u, this.leftChild = h, this.rightChild = d, u && (u.parent = c, u.brother = this), h && (h.parent = this, h.brother = d), d && (d.parent = this, d.brother = h), c;
        }, r.prototype.rotateRight = function() {
          var l = this.parent, n = this.brother, h = this.leftChild;
          if (!h) throw new Error("unknown error");
          var c = this.rightChild, d = h.leftChild, u = h.rightChild;
          return l && (l.leftChild === this ? l.leftChild = h : l.rightChild === this && (l.rightChild = h)), h.parent = l, h.brother = n, h.leftChild = d, h.rightChild = this, n && (n.brother = h), d && (d.parent = h, d.brother = this), this.parent = h, this.brother = d, this.leftChild = u, this.rightChild = c, u && (u.parent = this, u.brother = c), c && (c.parent = this, c.brother = u), h;
        }, r.prototype.remove = function() {
          if (this.leftChild || this.rightChild) throw new Error("can only remove leaf node");
          this.parent && (this === this.parent.leftChild ? this.parent.leftChild = void 0 : this === this.parent.rightChild && (this.parent.rightChild = void 0)), this.brother && (this.brother.brother = void 0), this.key = void 0, this.value = void 0, this.parent = void 0, this.brother = void 0;
        }, r.TreeNodeColorType = { red: !0, black: !1 }, r;
      }();
      Object.freeze(a), o.default = a;
    }, {}], 26: [function(i, s, o) {
      var a = this && this.__generator || function(l, n) {
        var h, c, d, u, f = { label: 0, sent: function() {
          if (1 & d[0]) throw d[1];
          return d[1];
        }, trys: [], ops: [] };
        return u = { next: g(0), throw: g(1), return: g(2) }, typeof Symbol == "function" && (u[Symbol.iterator] = function() {
          return this;
        }), u;
        function g(y) {
          return function(v) {
            return function(b) {
              if (h) throw new TypeError("Generator is already executing.");
              for (; f; ) try {
                if (h = 1, c && (d = 2 & b[0] ? c.return : b[0] ? c.throw || ((d = c.return) && d.call(c), 0) : c.next) && !(d = d.call(c, b[1])).done) return d;
                switch (c = 0, d && (b = [2 & b[0], d.value]), b[0]) {
                  case 0:
                  case 1:
                    d = b;
                    break;
                  case 4:
                    return f.label++, { value: b[1], done: !1 };
                  case 5:
                    f.label++, c = b[1], b = [0];
                    continue;
                  case 7:
                    b = f.ops.pop(), f.trys.pop();
                    continue;
                  default:
                    if (!(d = (d = f.trys).length > 0 && d[d.length - 1]) && (b[0] === 6 || b[0] === 2)) {
                      f = 0;
                      continue;
                    }
                    if (b[0] === 3 && (!d || b[1] > d[0] && b[1] < d[3])) {
                      f.label = b[1];
                      break;
                    }
                    if (b[0] === 6 && f.label < d[1]) {
                      f.label = d[1], d = b;
                      break;
                    }
                    if (d && f.label < d[2]) {
                      f.label = d[2], f.ops.push(b);
                      break;
                    }
                    d[2] && f.ops.pop(), f.trys.pop();
                    continue;
                }
                b = n.call(l, f);
              } catch (x) {
                b = [6, x], c = 0;
              } finally {
                h = d = 0;
              }
              if (5 & b[0]) throw b[1];
              return { value: b[0] ? b[1] : void 0, done: !0 };
            }([y, v]);
          };
        }
      };
      function r(l) {
        var n = this;
        l === void 0 && (l = []);
        var h = [], c = 0, d = 0, u = 0, f = 0, g = 0, y = 0;
        this.size = function() {
          return y;
        }, this.empty = function() {
          return y === 0;
        }, this.clear = function() {
          c = u = d = f = g = y = 0, b.call(this, r.bucketSize), y = 0;
        }, this.front = function() {
          return h[c][d];
        }, this.back = function() {
          return h[u][f];
        }, this.forEach = function(x) {
          if (!this.empty()) {
            var p = 0;
            if (c !== u) {
              for (C = d; C < r.bucketSize; ++C) x(h[c][C], p++);
              for (C = c + 1; C < u; ++C) for (var k = 0; k < r.bucketSize; ++k) x(h[C][k], p++);
              for (C = 0; C <= f; ++C) x(h[u][C], p++);
            } else for (var C = d; C <= f; ++C) x(h[c][C], p++);
          }
        };
        var v = function(x) {
          var p = c * r.bucketSize + d, k = p + x, C = u * r.bucketSize + f;
          if (k < p || k > C) throw new Error("pos should more than 0 and less than queue's size");
          return { curNodeBucketIndex: Math.floor(k / r.bucketSize), curNodePointerIndex: k % r.bucketSize };
        };
        this.getElementByPos = function(x) {
          var p = v(x), k = p.curNodeBucketIndex, C = p.curNodePointerIndex;
          return h[k][C];
        }, this.eraseElementByPos = function(x) {
          var p = this;
          if (x < 0 || x > y) throw new Error("pos should more than 0 and less than queue's size");
          if (x === 0) this.popFront();
          else if (x === this.size()) this.popBack();
          else {
            for (var k = [], C = x + 1; C < y; ++C) k.push(this.getElementByPos(C));
            this.cut(x), this.popBack(), k.forEach(function(R) {
              return p.pushBack(R);
            });
          }
        }, this.eraseElementByValue = function(x) {
          if (!this.empty()) {
            var p = [];
            this.forEach(function(R) {
              R !== x && p.push(R);
            });
            for (var k = p.length, C = 0; C < k; ++C) this.setElementByPos(C, p[C]);
            this.cut(k - 1);
          }
        };
        var b = function(x) {
          for (var p = [], k = x * r.sigma, C = Math.max(Math.ceil(k / r.bucketSize), 2), R = 0; R < C; ++R) p.push(new Array(r.bucketSize));
          var P = Math.ceil(x / r.bucketSize), E = Math.floor(C / 2) - Math.floor(P / 2), H = E, $ = 0;
          if (this.size()) for (R = 0; R < P; ++R) {
            for (var A = 0; A < r.bucketSize; ++A) if (p[E + R][A] = this.front(), this.popFront(), this.empty()) {
              H = E + R, $ = A;
              break;
            }
            if (this.empty()) break;
          }
          h = p, c = E, d = 0, u = H, f = $, g = C, y = x;
        };
        this.pushBack = function(x) {
          this.empty() || (u === g - 1 && f === r.bucketSize - 1 && b.call(this, this.size()), f < r.bucketSize - 1 ? ++f : u < g - 1 && (++u, f = 0)), ++y, h[u][f] = x;
        }, this.popBack = function() {
          this.empty() || (this.size() !== 1 && (f > 0 ? --f : c < u && (--u, f = r.bucketSize - 1)), y > 0 && --y);
        }, this.setElementByPos = function(x, p) {
          var k = v(x), C = k.curNodeBucketIndex, R = k.curNodePointerIndex;
          h[C][R] = p;
        }, this.insert = function(x, p, k) {
          var C = this;
          if (k === void 0 && (k = 1), x === 0) for (; k--; ) this.pushFront(p);
          else if (x === this.size()) for (; k--; ) this.pushBack(p);
          else {
            for (var R = [], P = x; P < y; ++P) R.push(this.getElementByPos(P));
            for (this.cut(x - 1), P = 0; P < k; ++P) this.pushBack(p);
            R.forEach(function(E) {
              return C.pushBack(E);
            });
          }
        }, this.find = function(x) {
          if (c === u) {
            for (var p = d; p <= f; ++p) if (h[c][p] === x) return !0;
            return !1;
          }
          for (p = d; p < r.bucketSize; ++p) if (h[c][p] === x) return !0;
          for (p = c + 1; p < u; ++p) for (var k = 0; k < r.bucketSize; ++k) if (h[p][k] === x) return !0;
          for (p = 0; p <= f; ++p) if (h[u][p] === x) return !0;
          return !1;
        }, this.reverse = function() {
          for (var x = 0, p = y - 1; x < p; ) {
            var k = this.getElementByPos(x);
            this.setElementByPos(x, this.getElementByPos(p)), this.setElementByPos(p, k), ++x, --p;
          }
        }, this.unique = function() {
          if (!this.empty()) {
            var x = [], p = this.front();
            this.forEach(function(C, R) {
              R !== 0 && C === p || (x.push(C), p = C);
            });
            for (var k = 0; k < y; ++k) this.setElementByPos(k, x[k]);
            this.cut(x.length - 1);
          }
        }, this.sort = function(x) {
          var p = [];
          this.forEach(function(C) {
            p.push(C);
          }), p.sort(x);
          for (var k = 0; k < y; ++k) this.setElementByPos(k, p[k]);
        }, this.pushFront = function(x) {
          this.empty() || (c === 0 && d === 0 && b.call(this, this.size()), d > 0 ? --d : c > 0 && (--c, d = r.bucketSize - 1)), ++y, h[c][d] = x;
        }, this.popFront = function() {
          this.empty() || (this.size() !== 1 && (d < r.bucketSize - 1 ? ++d : c < u && (++c, d = 0)), y > 0 && --y);
        }, this.shrinkToFit = function() {
          var x = this, p = [];
          this.forEach(function(P) {
            p.push(P);
          });
          var k = p.length;
          h = [];
          for (var C = Math.ceil(k / r.bucketSize), R = 0; R < C; ++R) h.push(new Array(r.bucketSize));
          this.clear(), p.forEach(function(P) {
            return x.pushBack(P);
          });
        }, this.cut = function(x) {
          if (x < 0) this.clear();
          else {
            var p = v(x), k = p.curNodeBucketIndex, C = p.curNodePointerIndex;
            u = k, f = C, y = x + 1;
          }
        }, this[Symbol.iterator] = function() {
          return function() {
            var x, p;
            return a(this, function(k) {
              switch (k.label) {
                case 0:
                  if (y === 0) return [2];
                  if (c !== u) return [3, 5];
                  p = d, k.label = 1;
                case 1:
                  return p <= f ? [4, h[c][p]] : [3, 4];
                case 2:
                  k.sent(), k.label = 3;
                case 3:
                  return ++p, [3, 1];
                case 4:
                  return [2];
                case 5:
                  p = d, k.label = 6;
                case 6:
                  return p < r.bucketSize ? [4, h[c][p]] : [3, 9];
                case 7:
                  k.sent(), k.label = 8;
                case 8:
                  return ++p, [3, 6];
                case 9:
                  p = c + 1, k.label = 10;
                case 10:
                  if (!(p < u)) return [3, 15];
                  x = 0, k.label = 11;
                case 11:
                  return x < r.bucketSize ? [4, h[p][x]] : [3, 14];
                case 12:
                  k.sent(), k.label = 13;
                case 13:
                  return ++x, [3, 11];
                case 14:
                  return ++p, [3, 10];
                case 15:
                  p = 0, k.label = 16;
                case 16:
                  return p <= f ? [4, h[u][p]] : [3, 19];
                case 17:
                  k.sent(), k.label = 18;
                case 18:
                  return ++p, [3, 16];
                case 19:
                  return [2];
              }
            });
          }();
        }, function() {
          var x = r.bucketSize;
          l.size ? x = l.size() : l.length && (x = l.length);
          var p = x * r.sigma;
          g = Math.ceil(p / r.bucketSize), g = Math.max(g, 3);
          for (var k = 0; k < g; ++k) h.push(new Array(r.bucketSize));
          var C = Math.ceil(x / r.bucketSize);
          c = Math.floor(g / 2) - Math.floor(C / 2), u = c, l.forEach(function(R) {
            return n.pushBack(R);
          });
        }(), Object.freeze(this);
      }
      Object.defineProperty(o, "__esModule", { value: !0 }), r.sigma = 3, r.bucketSize = 5e3, Object.freeze(r), o.default = r;
    }, {}], 27: [function(i, s, o) {
      var a = this && this.__generator || function(c, d) {
        var u, f, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (u) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (u = 1, f && (g = 2 & k[0] ? f.return : k[0] ? f.throw || ((g = f.return) && g.call(f), 0) : f.next) && !(g = g.call(f, k[1])).done) return g;
                switch (f = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, f = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (C) {
                k = [6, C], f = 0;
              } finally {
                u = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, u = d && c[d], f = 0;
        if (u) return u.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && f >= c.length && (c = void 0), { value: c && c[f++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(o, "__esModule", { value: !0 });
      var l = i("../LinkList/LinkList"), n = i("../Map/Map");
      function h(c, d, u) {
        var f = this;
        if (c === void 0 && (c = []), d === void 0 && (d = h.initSize), u = u || function(b) {
          var x, p, k = 0, C = "";
          if (typeof b == "number") k = ((k = Math.floor(b)) << 5) - k, k &= k;
          else {
            C = typeof b != "string" ? JSON.stringify(b) : b;
            try {
              for (var R = r(C), P = R.next(); !P.done; P = R.next())
                k = (k << 5) - k + P.value.charCodeAt(0), k &= k;
            } catch (E) {
              x = { error: E };
            } finally {
              try {
                P && !P.done && (p = R.return) && p.call(R);
              } finally {
                if (x) throw x.error;
              }
            }
          }
          return k ^= k >>> 16;
        }, (d & d - 1) != 0) throw new Error("initBucketNum must be 2 to the power of n");
        var g = 0, y = [], v = Math.max(h.initSize, Math.min(h.maxSize, d));
        this.size = function() {
          return g;
        }, this.empty = function() {
          return g === 0;
        }, this.clear = function() {
          g = 0, v = d, y = [];
        }, this.forEach = function(b) {
          var x = 0;
          y.forEach(function(p) {
            p.forEach(function(k) {
              b(k, x++);
            });
          });
        }, this.setElement = function(b, x) {
          var p, k;
          if (b == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (x != null) {
            var C = u(b) & v - 1;
            if (y[C]) {
              var R = y[C].size();
              if (y[C] instanceof l.default) {
                try {
                  for (var P = r(y[C]), E = P.next(); !E.done; E = P.next()) {
                    var H = E.value;
                    if (H.key === b) return void (H.value = x);
                  }
                } catch (A) {
                  p = { error: A };
                } finally {
                  try {
                    E && !E.done && (k = P.return) && k.call(P);
                  } finally {
                    if (p) throw p.error;
                  }
                }
                y[C].pushBack({ key: b, value: x }), y[C].size() >= h.treeifyThreshold && (y[C] = new n.default(y[C]));
              } else y[C].setElement(b, x);
              var $ = y[C].size();
              g += $ - R;
            } else ++g, y[C] = new l.default([{ key: b, value: x }]);
            g > v * h.sigma && (function(A) {
              if (!(A >= h.maxSize)) {
                v = 2 * A;
                var I = [];
                y.forEach(function(S, _) {
                  if (!S.empty()) {
                    if (S instanceof l.default && S.size() === 1) {
                      var B = S.front(), j = B.key, X = B.value;
                      I[u(j) & v - 1] = new l.default([{ key: j, value: X }]);
                    } else if (S instanceof n.default) {
                      var z = new l.default(), M = new l.default();
                      S.forEach(function(N) {
                        u(N.key) & A ? M.pushBack(N) : z.pushBack(N);
                      }), z.size() > h.untreeifyThreshold ? I[_] = new n.default(z) : z.size() && (I[_] = z), M.size() > h.untreeifyThreshold ? I[_ + A] = new n.default(M) : M.size() && (I[_ + A] = M);
                    } else {
                      var D = new l.default(), W = new l.default();
                      S.forEach(function(N) {
                        u(N.key) & A ? W.pushBack(N) : D.pushBack(N);
                      }), D.size() && (I[_] = D), W.size() && (I[_ + A] = W);
                    }
                    y[_].clear();
                  }
                }), y = I;
              }
            }).call(this, v);
          } else this.eraseElementByKey(b);
        }, this.getElementByKey = function(b) {
          var x, p, k = u(b) & v - 1;
          if (y[k]) {
            if (y[k] instanceof n.default) return y[k].getElementByKey(b);
            try {
              for (var C = r(y[k]), R = C.next(); !R.done; R = C.next()) {
                var P = R.value;
                if (P.key === b) return P.value;
              }
            } catch (E) {
              x = { error: E };
            } finally {
              try {
                R && !R.done && (p = C.return) && p.call(C);
              } finally {
                if (x) throw x.error;
              }
            }
          }
        }, this.eraseElementByKey = function(b) {
          var x, p, k = u(b) & v - 1;
          if (y[k]) {
            var C = y[k].size();
            if (y[k] instanceof n.default) y[k].eraseElementByKey(b), y[k].size() <= h.untreeifyThreshold && (y[k] = new l.default(y[k]));
            else {
              var R = -1;
              try {
                for (var P = r(y[k]), E = P.next(); !E.done; E = P.next())
                  if (++R, E.value.key === b) {
                    y[k].eraseElementByPos(R);
                    break;
                  }
              } catch ($) {
                x = { error: $ };
              } finally {
                try {
                  E && !E.done && (p = P.return) && p.call(P);
                } finally {
                  if (x) throw x.error;
                }
              }
            }
            var H = y[k].size();
            g += H - C;
          }
        }, this.find = function(b) {
          var x, p, k = u(b) & v - 1;
          if (!y[k]) return !1;
          if (y[k] instanceof n.default) return y[k].find(b);
          try {
            for (var C = r(y[k]), R = C.next(); !R.done; R = C.next())
              if (R.value.key === b) return !0;
          } catch (P) {
            x = { error: P };
          } finally {
            try {
              R && !R.done && (p = C.return) && p.call(C);
            } finally {
              if (x) throw x.error;
            }
          }
          return !1;
        }, this[Symbol.iterator] = function() {
          return function() {
            var b, x, p, k, C, R;
            return a(this, function(P) {
              switch (P.label) {
                case 0:
                  b = 0, P.label = 1;
                case 1:
                  if (!(b < v)) return [3, 10];
                  for (; b < v && !y[b]; ) ++b;
                  if (b >= v) return [3, 10];
                  P.label = 2;
                case 2:
                  P.trys.push([2, 7, 8, 9]), C = void 0, x = r(y[b]), p = x.next(), P.label = 3;
                case 3:
                  return p.done ? [3, 6] : [4, p.value];
                case 4:
                  P.sent(), P.label = 5;
                case 5:
                  return p = x.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return k = P.sent(), C = { error: k }, [3, 9];
                case 8:
                  try {
                    p && !p.done && (R = x.return) && R.call(x);
                  } finally {
                    if (C) throw C.error;
                  }
                  return [7];
                case 9:
                  return ++b, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, c.forEach(function(b) {
          var x = b.key, p = b.value;
          return f.setElement(x, p);
        }), Object.freeze(this);
      }
      h.initSize = 16, h.maxSize = 1 << 30, h.sigma = 0.75, h.treeifyThreshold = 8, h.untreeifyThreshold = 6, h.minTreeifySize = 64, Object.freeze(h), o.default = h;
    }, { "../LinkList/LinkList": 29, "../Map/Map": 30 }], 28: [function(i, s, o) {
      var a = this && this.__generator || function(c, d) {
        var u, f, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (u) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (u = 1, f && (g = 2 & k[0] ? f.return : k[0] ? f.throw || ((g = f.return) && g.call(f), 0) : f.next) && !(g = g.call(f, k[1])).done) return g;
                switch (f = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, f = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (C) {
                k = [6, C], f = 0;
              } finally {
                u = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, u = d && c[d], f = 0;
        if (u) return u.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && f >= c.length && (c = void 0), { value: c && c[f++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(o, "__esModule", { value: !0 });
      var l = i("../Set/Set"), n = i("../LinkList/LinkList");
      function h(c, d, u) {
        var f = this;
        if (c === void 0 && (c = []), d === void 0 && (d = h.initSize), u = u || function(b) {
          var x = 0, p = "";
          if (typeof b == "number") x = ((x = Math.floor(b)) << 5) - x, x &= x;
          else {
            p = typeof b != "string" ? JSON.stringify(b) : b;
            for (var k = 0; k < p.length; k++)
              x = (x << 5) - x + p.charCodeAt(k), x &= x;
          }
          return x ^= x >>> 16;
        }, (d & d - 1) != 0) throw new Error("initBucketNum must be 2 to the power of n");
        var g = 0, y = [], v = Math.max(h.initSize, Math.min(h.maxSize, d));
        this.size = function() {
          return g;
        }, this.empty = function() {
          return g === 0;
        }, this.clear = function() {
          g = 0, v = d, y = [];
        }, this.forEach = function(b) {
          var x = 0;
          y.forEach(function(p) {
            p.forEach(function(k) {
              b(k, x++);
            });
          });
        }, this.insert = function(b) {
          if (b == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          var x = u(b) & v - 1;
          if (y[x]) {
            var p = y[x].size();
            if (y[x] instanceof n.default) {
              if (y[x].find(b)) return;
              y[x].pushBack(b), y[x].size() >= h.treeifyThreshold && (y[x] = new l.default(y[x]));
            } else y[x].insert(b);
            var k = y[x].size();
            g += k - p;
          } else y[x] = new n.default([b]), ++g;
          g > v * h.sigma && (function(C) {
            if (!(C >= h.maxSize)) {
              v = 2 * C;
              var R = [];
              y.forEach(function(P, E) {
                if (!P.empty()) {
                  if (P instanceof n.default && P.size() === 1) {
                    var H = P.front();
                    if (H === void 0) throw new Error("unknown error");
                    R[u(H) & v - 1] = new n.default([H]);
                  } else if (P instanceof l.default) {
                    var $ = new n.default(), A = new n.default();
                    P.forEach(function(_) {
                      u(_) & C ? A.pushBack(_) : $.pushBack(_);
                    }), $.size() > h.untreeifyThreshold ? R[E] = new l.default($) : $.size() && (R[E] = $), A.size() > h.untreeifyThreshold ? R[E + C] = new l.default(A) : A.size() && (R[E + C] = A);
                  } else {
                    var I = new n.default(), S = new n.default();
                    P.forEach(function(_) {
                      u(_) & C ? S.pushBack(_) : I.pushBack(_);
                    }), I.size() && (R[E] = I), S.size() && (R[E + C] = S);
                  }
                  y[E].clear();
                }
              }), y = R;
            }
          }).call(this, v);
        }, this.eraseElementByValue = function(b) {
          var x = u(b) & v - 1;
          if (y[x]) {
            var p = y[x].size();
            y[x].eraseElementByValue(b), y[x] instanceof l.default && y[x].size() <= h.untreeifyThreshold && (y[x] = new n.default(y[x]));
            var k = y[x].size();
            g += k - p;
          }
        }, this.find = function(b) {
          var x = u(b) & v - 1;
          return !!y[x] && y[x].find(b);
        }, this[Symbol.iterator] = function() {
          return function() {
            var b, x, p, k, C, R;
            return a(this, function(P) {
              switch (P.label) {
                case 0:
                  b = 0, P.label = 1;
                case 1:
                  if (!(b < v)) return [3, 10];
                  for (; b < v && !y[b]; ) ++b;
                  if (b >= v) return [3, 10];
                  P.label = 2;
                case 2:
                  P.trys.push([2, 7, 8, 9]), C = void 0, x = r(y[b]), p = x.next(), P.label = 3;
                case 3:
                  return p.done ? [3, 6] : [4, p.value];
                case 4:
                  P.sent(), P.label = 5;
                case 5:
                  return p = x.next(), [3, 3];
                case 6:
                  return [3, 9];
                case 7:
                  return k = P.sent(), C = { error: k }, [3, 9];
                case 8:
                  try {
                    p && !p.done && (R = x.return) && R.call(x);
                  } finally {
                    if (C) throw C.error;
                  }
                  return [7];
                case 9:
                  return ++b, [3, 1];
                case 10:
                  return [2];
              }
            });
          }();
        }, c.forEach(function(b) {
          return f.insert(b);
        }), Object.freeze(this);
      }
      h.initSize = 16, h.maxSize = 1 << 30, h.sigma = 0.75, h.treeifyThreshold = 8, h.untreeifyThreshold = 6, h.minTreeifySize = 64, Object.freeze(h), o.default = h;
    }, { "../LinkList/LinkList": 29, "../Set/Set": 33 }], 29: [function(i, s, o) {
      var a = this && this.__generator || function(n, h) {
        var c, d, u, f, g = { label: 0, sent: function() {
          if (1 & u[0]) throw u[1];
          return u[1];
        }, trys: [], ops: [] };
        return f = { next: y(0), throw: y(1), return: y(2) }, typeof Symbol == "function" && (f[Symbol.iterator] = function() {
          return this;
        }), f;
        function y(v) {
          return function(b) {
            return function(x) {
              if (c) throw new TypeError("Generator is already executing.");
              for (; g; ) try {
                if (c = 1, d && (u = 2 & x[0] ? d.return : x[0] ? d.throw || ((u = d.return) && u.call(d), 0) : d.next) && !(u = u.call(d, x[1])).done) return u;
                switch (d = 0, u && (x = [2 & x[0], u.value]), x[0]) {
                  case 0:
                  case 1:
                    u = x;
                    break;
                  case 4:
                    return g.label++, { value: x[1], done: !1 };
                  case 5:
                    g.label++, d = x[1], x = [0];
                    continue;
                  case 7:
                    x = g.ops.pop(), g.trys.pop();
                    continue;
                  default:
                    if (!(u = (u = g.trys).length > 0 && u[u.length - 1]) && (x[0] === 6 || x[0] === 2)) {
                      g = 0;
                      continue;
                    }
                    if (x[0] === 3 && (!u || x[1] > u[0] && x[1] < u[3])) {
                      g.label = x[1];
                      break;
                    }
                    if (x[0] === 6 && g.label < u[1]) {
                      g.label = u[1], u = x;
                      break;
                    }
                    if (u && g.label < u[2]) {
                      g.label = u[2], g.ops.push(x);
                      break;
                    }
                    u[2] && g.ops.pop(), g.trys.pop();
                    continue;
                }
                x = h.call(n, g);
              } catch (p) {
                x = [6, p], d = 0;
              } finally {
                c = u = 0;
              }
              if (5 & x[0]) throw x[1];
              return { value: x[0] ? x[1] : void 0, done: !0 };
            }([v, b]);
          };
        }
      };
      Object.defineProperty(o, "__esModule", { value: !0 });
      var r = /* @__PURE__ */ function() {
        return function(n) {
          this.value = void 0, this.pre = void 0, this.next = void 0, this.value = n;
        };
      }();
      function l(n) {
        var h = this;
        n === void 0 && (n = []);
        var c = 0, d = void 0, u = void 0;
        this.size = function() {
          return c;
        }, this.empty = function() {
          return c === 0;
        }, this.clear = function() {
          d = u = void 0, c = 0;
        }, this.front = function() {
          return d == null ? void 0 : d.value;
        }, this.back = function() {
          return u == null ? void 0 : u.value;
        }, this.forEach = function(f) {
          for (var g = d, y = 0; g; ) {
            if (g.value === void 0) throw new Error("unknown error");
            f(g.value, y++), g = g.next;
          }
        }, this.getElementByPos = function(f) {
          if (f < 0 || f >= c) throw new Error("pos must more then 0 and less then the list length");
          for (var g = d; f-- && g; ) g = g.next;
          if (!g || g.value === void 0) throw new Error("unknown error");
          return g.value;
        }, this.eraseElementByPos = function(f) {
          if (f < 0 || f >= c) throw new Error("erase pos must more then 0 and less then the list length");
          if (f === 0) this.popFront();
          else if (f === c - 1) this.popBack();
          else {
            for (var g = d; f--; ) {
              if (!(g != null && g.next)) throw new Error("unknown error");
              g = g.next;
            }
            if (!g || !g.pre || !g.next) throw new Error("unknown error");
            var y = g.pre, v = g.next;
            v.pre = y, y.next = v, c > 0 && --c;
          }
        }, this.eraseElementByValue = function(f) {
          for (; d && d.value === f; ) this.popFront();
          for (; u && u.value === f; ) this.popBack();
          if (d) for (var g = d; g; ) {
            if (g.value === f) {
              var y = g.pre, v = g.next;
              v && (v.pre = y), y && (y.next = v), c > 0 && --c;
            }
            g = g.next;
          }
        }, this.pushBack = function(f) {
          if (f == null) throw new Error("you can't push null or undefined here");
          ++c;
          var g = new r(f);
          u ? (u.next = g, g.pre = u, u = g) : d = u = g;
        }, this.popBack = function() {
          u && (c > 0 && --c, u && (d === u ? d = u = void 0 : (u = u.pre) && (u.next = void 0)));
        }, this.setElementByPos = function(f, g) {
          if (g == null) throw new Error("you can't set null or undefined here");
          if (f < 0 || f >= c) throw new Error("pos must more then 0 and less then the list length");
          for (var y = d; f--; ) {
            if (!y) throw new Error("unknown error");
            y = y.next;
          }
          y && (y.value = g);
        }, this.insert = function(f, g, y) {
          if (y === void 0 && (y = 1), g == null) throw new Error("you can't insert null or undefined here");
          if (f < 0 || f > c) throw new Error("insert pos must more then 0 and less then or equal to the list length");
          if (y < 0) throw new Error("insert size must more than 0");
          if (f === 0) for (; y--; ) this.pushFront(g);
          else if (f === c) for (; y--; ) this.pushBack(g);
          else {
            for (var v = d, b = 1; b < f; ++b) {
              if (!(v != null && v.next)) throw new Error("unknown error");
              v = v == null ? void 0 : v.next;
            }
            if (!v) throw new Error("unknown error");
            var x = v.next;
            for (c += y; y--; ) v.next = new r(g), v.next.pre = v, v = v.next;
            v.next = x, x && (x.pre = v);
          }
        }, this.find = function(f) {
          for (var g = d; g; ) {
            if (g.value === f) return !0;
            g = g.next;
          }
          return !1;
        }, this.reverse = function() {
          for (var f = d, g = u, y = 0; f && g && 2 * y < c; ) {
            var v = f.value;
            f.value = g.value, g.value = v, f = f.next, g = g.pre, ++y;
          }
        }, this.unique = function() {
          for (var f = d; f; ) {
            for (var g = f; g && g.next && g.value === g.next.value; ) g = g.next, c > 0 && --c;
            f.next = g.next, f.next && (f.next.pre = f), f = f.next;
          }
        }, this.sort = function(f) {
          var g = [];
          this.forEach(function(v) {
            g.push(v);
          }), g.sort(f);
          var y = d;
          g.forEach(function(v) {
            y && (y.value = v, y = y.next);
          });
        }, this.pushFront = function(f) {
          if (f == null) throw new Error("you can't push null or undefined here");
          ++c;
          var g = new r(f);
          d ? (g.next = d, d.pre = g, d = g) : d = u = g;
        }, this.popFront = function() {
          d && (c > 0 && --c, d && (d === u ? d = u = void 0 : (d = d.next) && (d.pre = void 0)));
        }, this.merge = function(f) {
          var g = this, y = d;
          f.forEach(function(v) {
            for (; y && y.value !== void 0 && y.value <= v; ) y = y.next;
            if (y === void 0) g.pushBack(v), y = u;
            else if (y === d) g.pushFront(v), y = d;
            else {
              ++c;
              var b = y.pre;
              b && (b.next = new r(v), b.next.pre = b, b.next.next = y, y && (y.pre = b.next));
            }
          });
        }, this[Symbol.iterator] = function() {
          return function() {
            var f;
            return a(this, function(g) {
              switch (g.label) {
                case 0:
                  f = d, g.label = 1;
                case 1:
                  if (f === void 0) return [3, 3];
                  if (!f.value) throw new Error("unknown error");
                  return [4, f.value];
                case 2:
                  return g.sent(), f = f.next, [3, 1];
                case 3:
                  return [2];
              }
            });
          }();
        }, n.forEach(function(f) {
          return h.pushBack(f);
        }), Object.freeze(this);
      }
      Object.freeze(l), o.default = l;
    }, {}], 30: [function(i, s, o) {
      var a = this && this.__generator || function(h, c) {
        var d, u, f, g, y = { label: 0, sent: function() {
          if (1 & f[0]) throw f[1];
          return f[1];
        }, trys: [], ops: [] };
        return g = { next: v(0), throw: v(1), return: v(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function v(b) {
          return function(x) {
            return function(p) {
              if (d) throw new TypeError("Generator is already executing.");
              for (; y; ) try {
                if (d = 1, u && (f = 2 & p[0] ? u.return : p[0] ? u.throw || ((f = u.return) && f.call(u), 0) : u.next) && !(f = f.call(u, p[1])).done) return f;
                switch (u = 0, f && (p = [2 & p[0], f.value]), p[0]) {
                  case 0:
                  case 1:
                    f = p;
                    break;
                  case 4:
                    return y.label++, { value: p[1], done: !1 };
                  case 5:
                    y.label++, u = p[1], p = [0];
                    continue;
                  case 7:
                    p = y.ops.pop(), y.trys.pop();
                    continue;
                  default:
                    if (!(f = (f = y.trys).length > 0 && f[f.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      y = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!f || p[1] > f[0] && p[1] < f[3])) {
                      y.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && y.label < f[1]) {
                      y.label = f[1], f = p;
                      break;
                    }
                    if (f && y.label < f[2]) {
                      y.label = f[2], y.ops.push(p);
                      break;
                    }
                    f[2] && y.ops.pop(), y.trys.pop();
                    continue;
                }
                p = c.call(h, y);
              } catch (k) {
                p = [6, k], u = 0;
              } finally {
                d = f = 0;
              }
              if (5 & p[0]) throw p[1];
              return { value: p[0] ? p[1] : void 0, done: !0 };
            }([b, x]);
          };
        }
      }, r = this && this.__values || function(h) {
        var c = typeof Symbol == "function" && Symbol.iterator, d = c && h[c], u = 0;
        if (d) return d.call(h);
        if (h && typeof h.length == "number") return { next: function() {
          return h && u >= h.length && (h = void 0), { value: h && h[u++], done: !h };
        } };
        throw new TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(o, "__esModule", { value: !0 });
      var l = i("../Base/TreeNode");
      function n(h, c) {
        var d = this;
        h === void 0 && (h = []), c = c || function(A, I) {
          return A < I ? -1 : A > I ? 1 : 0;
        };
        var u = 0, f = new l.default();
        f.color = l.default.TreeNodeColorType.black, this.size = function() {
          return u;
        }, this.empty = function() {
          return u === 0;
        }, this.clear = function() {
          u = 0, f.key = f.value = void 0, f.leftChild = f.rightChild = f.brother = void 0;
        };
        var g = function(A) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          return A.leftChild ? g(A.leftChild) : A;
        }, y = function(A) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          return A.rightChild ? y(A.rightChild) : A;
        };
        this.front = function() {
          if (!this.empty()) {
            var A = g(f);
            if (A.key === void 0 || A.value === void 0) throw new Error("unknown error");
            return { key: A.key, value: A.value };
          }
        }, this.back = function() {
          if (!this.empty()) {
            var A = y(f);
            if (A.key === void 0 || A.value === void 0) throw new Error("unknown error");
            return { key: A.key, value: A.value };
          }
        }, this.forEach = function(A) {
          var I, S, _ = 0;
          try {
            for (var B = r(this), j = B.next(); !j.done; j = B.next())
              A(j.value, _++);
          } catch (X) {
            I = { error: X };
          } finally {
            try {
              j && !j.done && (S = B.return) && S.call(B);
            } finally {
              if (I) throw I.error;
            }
          }
        }, this.getElementByPos = function(A) {
          var I, S;
          if (A < 0 || A >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var _ = 0;
          try {
            for (var B = r(this), j = B.next(); !j.done; j = B.next()) {
              var X = j.value;
              if (_ === A) return X;
              ++_;
            }
          } catch (z) {
            I = { error: z };
          } finally {
            try {
              j && !j.done && (S = B.return) && S.call(B);
            } finally {
              if (I) throw I.error;
            }
          }
          throw new Error("unknown Error");
        };
        var v = function(A, I) {
          if (A && A.key !== void 0 && A.value !== void 0) {
            var S = c(A.key, I);
            return S === 0 ? { key: A.key, value: A.value } : S < 0 ? v(A.rightChild, I) : v(A.leftChild, I) || { key: A.key, value: A.value };
          }
        };
        this.lowerBound = function(A) {
          return v(f, A);
        };
        var b = function(A, I) {
          if (A && A.key !== void 0 && A.value !== void 0) return c(A.key, I) <= 0 ? b(A.rightChild, I) : b(A.leftChild, I) || { key: A.key, value: A.value };
        };
        this.upperBound = function(A) {
          return b(f, A);
        };
        var x = function(A, I) {
          if (A && A.key !== void 0 && A.value !== void 0) {
            var S = c(A.key, I);
            return S === 0 ? { key: A.key, value: A.value } : S > 0 ? x(A.leftChild, I) : x(A.rightChild, I) || { key: A.key, value: A.value };
          }
        };
        this.reverseLowerBound = function(A) {
          return x(f, A);
        };
        var p = function(A, I) {
          if (A && A.key !== void 0 && A.value !== void 0) return c(A.key, I) >= 0 ? p(A.leftChild, I) : p(A.rightChild, I) || { key: A.key, value: A.value };
        };
        this.reverseUpperBound = function(A) {
          return p(f, A);
        };
        var k = function(A) {
          var I = A.parent;
          if (!I) {
            if (A === f) return;
            throw new Error("unknown error");
          }
          if (A.color !== l.default.TreeNodeColorType.red) {
            var S = A.brother;
            if (!S) throw new Error("unknown error");
            if (A === I.leftChild)
              if (S.color === l.default.TreeNodeColorType.red) {
                S.color = l.default.TreeNodeColorType.black, I.color = l.default.TreeNodeColorType.red;
                var _ = I.rotateLeft();
                f === I && (f = _), k(A);
              } else S.color === l.default.TreeNodeColorType.black && (S.rightChild && S.rightChild.color === l.default.TreeNodeColorType.red ? (S.color = I.color, I.color = l.default.TreeNodeColorType.black, S.rightChild && (S.rightChild.color = l.default.TreeNodeColorType.black), _ = I.rotateLeft(), f === I && (f = _), A.color = l.default.TreeNodeColorType.black) : S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || !S.leftChild || S.leftChild.color !== l.default.TreeNodeColorType.red ? S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || (S.color = l.default.TreeNodeColorType.red, k(I)) : (S.color = l.default.TreeNodeColorType.red, S.leftChild && (S.leftChild.color = l.default.TreeNodeColorType.black), _ = S.rotateRight(), f === S && (f = _), k(A)));
            else A === I.rightChild && (S.color === l.default.TreeNodeColorType.red ? (S.color = l.default.TreeNodeColorType.black, I.color = l.default.TreeNodeColorType.red, _ = I.rotateRight(), f === I && (f = _), k(A)) : S.color === l.default.TreeNodeColorType.black && (S.leftChild && S.leftChild.color === l.default.TreeNodeColorType.red ? (S.color = I.color, I.color = l.default.TreeNodeColorType.black, S.leftChild && (S.leftChild.color = l.default.TreeNodeColorType.black), _ = I.rotateRight(), f === I && (f = _), A.color = l.default.TreeNodeColorType.black) : S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || !S.rightChild || S.rightChild.color !== l.default.TreeNodeColorType.red ? S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || (S.color = l.default.TreeNodeColorType.red, k(I)) : (S.color = l.default.TreeNodeColorType.red, S.rightChild && (S.rightChild.color = l.default.TreeNodeColorType.black), _ = S.rotateLeft(), f === S && (f = _), k(A))));
          } else A.color = l.default.TreeNodeColorType.black;
        }, C = function(A) {
          for (var I = A; I.leftChild || I.rightChild; ) {
            if (I.rightChild) {
              I = g(I.rightChild);
              var S = A.key;
              A.key = I.key, I.key = S;
              var _ = A.value;
              A.value = I.value, I.value = _, A = I;
            }
            I.leftChild && (I = y(I.leftChild), S = A.key, A.key = I.key, I.key = S, _ = A.value, A.value = I.value, I.value = _, A = I);
          }
          k(I), I && I.remove(), --u, f.color = l.default.TreeNodeColorType.black;
        }, R = function(A, I) {
          return !(!A || A.key === void 0) && (!!R(A.leftChild, I) || !!I(A) || R(A.rightChild, I));
        };
        this.eraseElementByPos = function(A) {
          if (A < 0 || A >= u) throw new Error("pos must more than 0 and less than set's size");
          var I = 0;
          R(f, function(S) {
            return A === I ? (C(S), !0) : (++I, !1);
          });
        }, this.eraseElementByKey = function(A) {
          if (!this.empty()) {
            var I = H(f, A);
            I !== void 0 && I.key !== void 0 && c(I.key, A) === 0 && C(I);
          }
        };
        var P = function(A, I) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          var S = c(I, A.key);
          return S < 0 ? A.leftChild ? P(A.leftChild, I) : (A.leftChild = new l.default(), A.leftChild.parent = A, A.leftChild.brother = A.rightChild, A.rightChild && (A.rightChild.brother = A.leftChild), A.leftChild) : S > 0 ? A.rightChild ? P(A.rightChild, I) : (A.rightChild = new l.default(), A.rightChild.parent = A, A.rightChild.brother = A.leftChild, A.leftChild && (A.leftChild.brother = A.rightChild), A.rightChild) : A;
        }, E = function(A) {
          var I = A.parent;
          if (!I) {
            if (A === f) return;
            throw new Error("unknown error");
          }
          if (I.color !== l.default.TreeNodeColorType.black && I.color === l.default.TreeNodeColorType.red) {
            var S = I.brother, _ = I.parent;
            if (!_) throw new Error("unknown error");
            if (S && S.color === l.default.TreeNodeColorType.red) S.color = I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, E(_);
            else if (!S || S.color === l.default.TreeNodeColorType.black) if (I === _.leftChild)
              if (A === I.leftChild) {
                I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red;
                var B = _.rotateRight();
                _ === f && (f = B);
              } else A === I.rightChild && (B = I.rotateLeft(), _ === f && (f = B), E(I));
            else I === _.rightChild && (A === I.leftChild ? (B = I.rotateRight(), _ === f && (f = B), E(I)) : A === I.rightChild && (I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, B = _.rotateLeft(), _ === f && (f = B)));
          }
        };
        this.setElement = function(A, I) {
          if (A == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (I != null) {
            if (this.empty()) return ++u, f.key = A, f.value = I, void (f.color = l.default.TreeNodeColorType.black);
            var S = P(f, A);
            S.key === void 0 || c(S.key, A) !== 0 ? (++u, S.key = A, S.value = I, E(S), f.color = l.default.TreeNodeColorType.black) : S.value = I;
          } else this.eraseElementByKey(A);
        };
        var H = function(A, I) {
          if (A && A.key !== void 0) {
            var S = c(I, A.key);
            return S < 0 ? H(A.leftChild, I) : S > 0 ? H(A.rightChild, I) : A;
          }
        };
        this.find = function(A) {
          return !!H(f, A);
        }, this.getElementByKey = function(A) {
          var I = H(f, A);
          if ((I == null ? void 0 : I.key) === void 0 || (I == null ? void 0 : I.value) === void 0) throw new Error("unknown error");
          return I.value;
        }, this.union = function(A) {
          var I = this;
          A.forEach(function(S) {
            var _ = S.key, B = S.value;
            return I.setElement(_, B);
          });
        }, this.getHeight = function() {
          if (this.empty()) return 0;
          var A = function(I) {
            return I ? Math.max(A(I.leftChild), A(I.rightChild)) + 1 : 1;
          };
          return A(f);
        };
        var $ = function(A) {
          return a(this, function(I) {
            switch (I.label) {
              case 0:
                return A && A.key !== void 0 && A.value !== void 0 ? [5, r($(A.leftChild))] : [2];
              case 1:
                return I.sent(), [4, { key: A.key, value: A.value }];
              case 2:
                return I.sent(), [5, r($(A.rightChild))];
              case 3:
                return I.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function() {
          return $(f);
        }, h.forEach(function(A) {
          var I = A.key, S = A.value;
          return d.setElement(I, S);
        }), Object.freeze(this);
      }
      Object.freeze(n), o.default = n;
    }, { "../Base/TreeNode": 25 }], 31: [function(i, s, o) {
      function a(r, l) {
        r === void 0 && (r = []), l = l || function(u, f) {
          return u > f ? -1 : u < f ? 1 : 0;
        };
        var n = [];
        r.forEach(function(u) {
          return n.push(u);
        });
        var h = n.length, c = function(u, f) {
          if (u < 0 || u >= h) throw new Error("unknown error");
          if (f < 0 || f >= h) throw new Error("unknown error");
          var g = n[u];
          n[u] = n[f], n[f] = g;
        }, d = function(u) {
          if (u < 0 || u >= h) throw new Error("unknown error");
          var f = 2 * u + 1, g = 2 * u + 2;
          f < h && l(n[u], n[f]) > 0 && c(u, f), g < h && l(n[u], n[g]) > 0 && c(u, g);
        };
        (function() {
          for (var u = Math.floor((h - 1) / 2); u >= 0; --u) for (var f = u, g = 2 * f + 1; g < h; ) {
            var y = g + 1, v = g;
            if (y < h && l(n[g], n[y]) > 0 && (v = y), l(n[f], n[v]) <= 0) break;
            c(f, v), g = 2 * (f = v) + 1;
          }
        })(), this.size = function() {
          return h;
        }, this.empty = function() {
          return h === 0;
        }, this.clear = function() {
          h = 0, n.length = 0;
        }, this.push = function(u) {
          if (n.push(u), ++h !== 1) for (var f = h - 1; f > 0; ) {
            var g = Math.floor((f - 1) / 2);
            if (l(n[g], u) <= 0) break;
            d(g), f = g;
          }
        }, this.pop = function() {
          if (!this.empty()) if (this.size() !== 1) {
            var u = n[h - 1];
            --h;
            for (var f = 0; f < this.size(); ) {
              var g = 2 * f + 1, y = 2 * f + 2;
              if (g >= this.size()) break;
              var v = g;
              if (y < this.size() && l(n[g], n[y]) > 0 && (v = y), l(n[v], u) >= 0) break;
              n[f] = n[v], f = v;
            }
            n[f] = u;
          } else --h;
        }, this.top = function() {
          return n[0];
        }, Object.freeze(this);
      }
      Object.defineProperty(o, "__esModule", { value: !0 }), Object.freeze(a), o.default = a;
    }, {}], 32: [function(i, s, o) {
      Object.defineProperty(o, "__esModule", { value: !0 });
      var a = i("../LinkList/LinkList");
      function r(l) {
        l === void 0 && (l = []);
        var n = new a.default(l);
        this.size = function() {
          return n.size();
        }, this.empty = function() {
          return n.empty();
        }, this.clear = function() {
          n.clear();
        }, this.push = function(h) {
          n.pushBack(h);
        }, this.pop = function() {
          n.popFront();
        }, this.front = function() {
          return n.front();
        }, Object.freeze(this);
      }
      Object.freeze(r), o.default = r;
    }, { "../LinkList/LinkList": 29 }], 33: [function(i, s, o) {
      var a = this && this.__generator || function(h, c) {
        var d, u, f, g, y = { label: 0, sent: function() {
          if (1 & f[0]) throw f[1];
          return f[1];
        }, trys: [], ops: [] };
        return g = { next: v(0), throw: v(1), return: v(2) }, typeof Symbol == "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function v(b) {
          return function(x) {
            return function(p) {
              if (d) throw new TypeError("Generator is already executing.");
              for (; y; ) try {
                if (d = 1, u && (f = 2 & p[0] ? u.return : p[0] ? u.throw || ((f = u.return) && f.call(u), 0) : u.next) && !(f = f.call(u, p[1])).done) return f;
                switch (u = 0, f && (p = [2 & p[0], f.value]), p[0]) {
                  case 0:
                  case 1:
                    f = p;
                    break;
                  case 4:
                    return y.label++, { value: p[1], done: !1 };
                  case 5:
                    y.label++, u = p[1], p = [0];
                    continue;
                  case 7:
                    p = y.ops.pop(), y.trys.pop();
                    continue;
                  default:
                    if (!(f = (f = y.trys).length > 0 && f[f.length - 1]) && (p[0] === 6 || p[0] === 2)) {
                      y = 0;
                      continue;
                    }
                    if (p[0] === 3 && (!f || p[1] > f[0] && p[1] < f[3])) {
                      y.label = p[1];
                      break;
                    }
                    if (p[0] === 6 && y.label < f[1]) {
                      y.label = f[1], f = p;
                      break;
                    }
                    if (f && y.label < f[2]) {
                      y.label = f[2], y.ops.push(p);
                      break;
                    }
                    f[2] && y.ops.pop(), y.trys.pop();
                    continue;
                }
                p = c.call(h, y);
              } catch (k) {
                p = [6, k], u = 0;
              } finally {
                d = f = 0;
              }
              if (5 & p[0]) throw p[1];
              return { value: p[0] ? p[1] : void 0, done: !0 };
            }([b, x]);
          };
        }
      }, r = this && this.__values || function(h) {
        var c = typeof Symbol == "function" && Symbol.iterator, d = c && h[c], u = 0;
        if (d) return d.call(h);
        if (h && typeof h.length == "number") return { next: function() {
          return h && u >= h.length && (h = void 0), { value: h && h[u++], done: !h };
        } };
        throw new TypeError(c ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      Object.defineProperty(o, "__esModule", { value: !0 });
      var l = i("../Base/TreeNode");
      function n(h, c) {
        var d = this;
        h === void 0 && (h = []), c = c || function(A, I) {
          return A < I ? -1 : A > I ? 1 : 0;
        };
        var u = 0, f = new l.default();
        f.color = l.default.TreeNodeColorType.black, this.size = function() {
          return u;
        }, this.empty = function() {
          return u === 0;
        }, this.clear = function() {
          u = 0, f.key = void 0, f.leftChild = f.rightChild = f.brother = f.parent = void 0, f.color = l.default.TreeNodeColorType.black;
        };
        var g = function(A) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          return A.leftChild ? g(A.leftChild) : A;
        }, y = function(A) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          return A.rightChild ? y(A.rightChild) : A;
        };
        this.front = function() {
          if (!this.empty()) return g(f).key;
        }, this.back = function() {
          if (!this.empty()) return y(f).key;
        }, this.forEach = function(A) {
          var I, S, _ = 0;
          try {
            for (var B = r(this), j = B.next(); !j.done; j = B.next())
              A(j.value, _++);
          } catch (X) {
            I = { error: X };
          } finally {
            try {
              j && !j.done && (S = B.return) && S.call(B);
            } finally {
              if (I) throw I.error;
            }
          }
        }, this.getElementByPos = function(A) {
          var I, S;
          if (A < 0 || A >= this.size()) throw new Error("pos must more than 0 and less than set's size");
          var _ = 0;
          try {
            for (var B = r(this), j = B.next(); !j.done; j = B.next()) {
              var X = j.value;
              if (_ === A) return X;
              ++_;
            }
          } catch (z) {
            I = { error: z };
          } finally {
            try {
              j && !j.done && (S = B.return) && S.call(B);
            } finally {
              if (I) throw I.error;
            }
          }
          throw new Error("unknown error");
        };
        var v = function(A) {
          var I = A.parent;
          if (!I) {
            if (A === f) return;
            throw new Error("unknown error");
          }
          if (A.color !== l.default.TreeNodeColorType.red) {
            var S = A.brother;
            if (!S) throw new Error("unknown error");
            if (A === I.leftChild)
              if (S.color === l.default.TreeNodeColorType.red) {
                S.color = l.default.TreeNodeColorType.black, I.color = l.default.TreeNodeColorType.red;
                var _ = I.rotateLeft();
                f === I && (f = _), v(A);
              } else S.color === l.default.TreeNodeColorType.black && (S.rightChild && S.rightChild.color === l.default.TreeNodeColorType.red ? (S.color = I.color, I.color = l.default.TreeNodeColorType.black, S.rightChild && (S.rightChild.color = l.default.TreeNodeColorType.black), _ = I.rotateLeft(), f === I && (f = _), A.color = l.default.TreeNodeColorType.black) : S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || !S.leftChild || S.leftChild.color !== l.default.TreeNodeColorType.red ? S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || (S.color = l.default.TreeNodeColorType.red, v(I)) : (S.color = l.default.TreeNodeColorType.red, S.leftChild && (S.leftChild.color = l.default.TreeNodeColorType.black), _ = S.rotateRight(), f === S && (f = _), v(A)));
            else A === I.rightChild && (S.color === l.default.TreeNodeColorType.red ? (S.color = l.default.TreeNodeColorType.black, I.color = l.default.TreeNodeColorType.red, _ = I.rotateRight(), f === I && (f = _), v(A)) : S.color === l.default.TreeNodeColorType.black && (S.leftChild && S.leftChild.color === l.default.TreeNodeColorType.red ? (S.color = I.color, I.color = l.default.TreeNodeColorType.black, S.leftChild && (S.leftChild.color = l.default.TreeNodeColorType.black), _ = I.rotateRight(), f === I && (f = _), A.color = l.default.TreeNodeColorType.black) : S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || !S.rightChild || S.rightChild.color !== l.default.TreeNodeColorType.red ? S.leftChild && S.leftChild.color !== l.default.TreeNodeColorType.black || S.rightChild && S.rightChild.color !== l.default.TreeNodeColorType.black || (S.color = l.default.TreeNodeColorType.red, v(I)) : (S.color = l.default.TreeNodeColorType.red, S.rightChild && (S.rightChild.color = l.default.TreeNodeColorType.black), _ = S.rotateLeft(), f === S && (f = _), v(A))));
          } else A.color = l.default.TreeNodeColorType.black;
        }, b = function(A) {
          for (var I = A; I.leftChild || I.rightChild; ) {
            if (I.rightChild) {
              I = g(I.rightChild);
              var S = A.key;
              A.key = I.key, I.key = S, A = I;
            }
            I.leftChild && (I = y(I.leftChild), S = A.key, A.key = I.key, I.key = S, A = I);
          }
          v(I), I && I.remove(), --u, f.color = l.default.TreeNodeColorType.black;
        }, x = function(A, I) {
          return !(!A || A.key === void 0) && (!!x(A.leftChild, I) || !!I(A) || x(A.rightChild, I));
        };
        this.eraseElementByPos = function(A) {
          if (A < 0 || A >= u) throw new Error("pos must more than 0 and less than set's size");
          var I = 0;
          x(f, function(S) {
            return A === I ? (b(S), !0) : (++I, !1);
          });
        }, this.eraseElementByValue = function(A) {
          if (!this.empty()) {
            var I = C(f, A);
            I !== void 0 && I.key !== void 0 && c(I.key, A) === 0 && b(I);
          }
        };
        var p = function(A, I) {
          if (!A || A.key === void 0) throw new Error("unknown error");
          var S = c(I, A.key);
          return S < 0 ? A.leftChild ? p(A.leftChild, I) : (A.leftChild = new l.default(), A.leftChild.parent = A, A.leftChild.brother = A.rightChild, A.rightChild && (A.rightChild.brother = A.leftChild), A.leftChild) : S > 0 ? A.rightChild ? p(A.rightChild, I) : (A.rightChild = new l.default(), A.rightChild.parent = A, A.rightChild.brother = A.leftChild, A.leftChild && (A.leftChild.brother = A.rightChild), A.rightChild) : A;
        }, k = function(A) {
          var I = A.parent;
          if (!I) {
            if (A === f) return;
            throw new Error("unknown error");
          }
          if (I.color !== l.default.TreeNodeColorType.black && I.color === l.default.TreeNodeColorType.red) {
            var S = I.brother, _ = I.parent;
            if (!_) throw new Error("unknown error");
            if (S && S.color === l.default.TreeNodeColorType.red) S.color = I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, k(_);
            else if (!S || S.color === l.default.TreeNodeColorType.black) if (I === _.leftChild)
              if (A === I.leftChild) {
                I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red;
                var B = _.rotateRight();
                _ === f && (f = B);
              } else A === I.rightChild && (B = I.rotateLeft(), _ === f && (f = B), k(I));
            else I === _.rightChild && (A === I.leftChild ? (B = I.rotateRight(), _ === f && (f = B), k(I)) : A === I.rightChild && (I.color = l.default.TreeNodeColorType.black, _.color = l.default.TreeNodeColorType.red, B = _.rotateLeft(), _ === f && (f = B)));
          }
        };
        this.insert = function(A) {
          if (A == null) throw new Error("to avoid some unnecessary errors, we don't suggest you insert null or undefined here");
          if (this.empty()) return ++u, f.key = A, void (f.color = l.default.TreeNodeColorType.black);
          var I = p(f, A);
          I.key !== void 0 && c(I.key, A) === 0 || (++u, I.key = A, k(I), f.color = l.default.TreeNodeColorType.black);
        };
        var C = function(A, I) {
          if (A && A.key !== void 0) {
            var S = c(I, A.key);
            return S < 0 ? C(A.leftChild, I) : S > 0 ? C(A.rightChild, I) : A;
          }
        };
        this.find = function(A) {
          var I = C(f, A);
          return I !== void 0 && I.key !== void 0 && c(I.key, A) === 0;
        };
        var R = function(A, I) {
          if (A && A.key !== void 0) {
            var S = c(A.key, I);
            if (S === 0) return A.key;
            if (S < 0) return R(A.rightChild, I);
            var _ = R(A.leftChild, I);
            return _ !== void 0 ? _ : A.key;
          }
        };
        this.lowerBound = function(A) {
          return R(f, A);
        };
        var P = function(A, I) {
          if (A && A.key !== void 0) {
            if (c(A.key, I) <= 0) return P(A.rightChild, I);
            var S = P(A.leftChild, I);
            return S !== void 0 ? S : A.key;
          }
        };
        this.upperBound = function(A) {
          return P(f, A);
        };
        var E = function(A, I) {
          if (A && A.key !== void 0) {
            var S = c(A.key, I);
            if (S === 0) return A.key;
            if (S > 0) return E(A.leftChild, I);
            var _ = E(A.rightChild, I);
            return _ !== void 0 ? _ : A.key;
          }
        };
        this.reverseLowerBound = function(A) {
          return E(f, A);
        };
        var H = function(A, I) {
          if (A && A.key !== void 0) {
            if (c(A.key, I) >= 0) return H(A.leftChild, I);
            var S = H(A.rightChild, I);
            return S !== void 0 ? S : A.key;
          }
        };
        this.reverseUpperBound = function(A) {
          return H(f, A);
        }, this.union = function(A) {
          var I = this;
          A.forEach(function(S) {
            return I.insert(S);
          });
        }, this.getHeight = function() {
          if (this.empty()) return 0;
          var A = function(I) {
            return I ? Math.max(A(I.leftChild), A(I.rightChild)) + 1 : 1;
          };
          return A(f);
        };
        var $ = function(A) {
          return a(this, function(I) {
            switch (I.label) {
              case 0:
                return A && A.key !== void 0 ? [5, r($(A.leftChild))] : [2];
              case 1:
                return I.sent(), [4, A.key];
              case 2:
                return I.sent(), [5, r($(A.rightChild))];
              case 3:
                return I.sent(), [2];
            }
          });
        };
        this[Symbol.iterator] = function() {
          return $(f);
        }, h.forEach(function(A) {
          return d.insert(A);
        }), Object.freeze(this);
      }
      Object.freeze(n), o.default = n;
    }, { "../Base/TreeNode": 25 }], 34: [function(i, s, o) {
      function a(r) {
        var l = this;
        r === void 0 && (r = []);
        var n = 0, h = [];
        this.size = function() {
          return n;
        }, this.empty = function() {
          return n === 0;
        }, this.clear = function() {
          n = 0, h.length = 0;
        }, this.push = function(c) {
          h.push(c), ++n;
        }, this.pop = function() {
          h.pop(), n > 0 && --n;
        }, this.top = function() {
          return h[n - 1];
        }, r.forEach(function(c) {
          return l.push(c);
        }), Object.freeze(this);
      }
      Object.defineProperty(o, "__esModule", { value: !0 }), Object.freeze(a), o.default = a;
    }, {}], 35: [function(i, s, o) {
      var a = this && this.__generator || function(c, d) {
        var u, f, g, y, v = { label: 0, sent: function() {
          if (1 & g[0]) throw g[1];
          return g[1];
        }, trys: [], ops: [] };
        return y = { next: b(0), throw: b(1), return: b(2) }, typeof Symbol == "function" && (y[Symbol.iterator] = function() {
          return this;
        }), y;
        function b(x) {
          return function(p) {
            return function(k) {
              if (u) throw new TypeError("Generator is already executing.");
              for (; v; ) try {
                if (u = 1, f && (g = 2 & k[0] ? f.return : k[0] ? f.throw || ((g = f.return) && g.call(f), 0) : f.next) && !(g = g.call(f, k[1])).done) return g;
                switch (f = 0, g && (k = [2 & k[0], g.value]), k[0]) {
                  case 0:
                  case 1:
                    g = k;
                    break;
                  case 4:
                    return v.label++, { value: k[1], done: !1 };
                  case 5:
                    v.label++, f = k[1], k = [0];
                    continue;
                  case 7:
                    k = v.ops.pop(), v.trys.pop();
                    continue;
                  default:
                    if (!(g = (g = v.trys).length > 0 && g[g.length - 1]) && (k[0] === 6 || k[0] === 2)) {
                      v = 0;
                      continue;
                    }
                    if (k[0] === 3 && (!g || k[1] > g[0] && k[1] < g[3])) {
                      v.label = k[1];
                      break;
                    }
                    if (k[0] === 6 && v.label < g[1]) {
                      v.label = g[1], g = k;
                      break;
                    }
                    if (g && v.label < g[2]) {
                      v.label = g[2], v.ops.push(k);
                      break;
                    }
                    g[2] && v.ops.pop(), v.trys.pop();
                    continue;
                }
                k = d.call(c, v);
              } catch (C) {
                k = [6, C], f = 0;
              } finally {
                u = g = 0;
              }
              if (5 & k[0]) throw k[1];
              return { value: k[0] ? k[1] : void 0, done: !0 };
            }([x, p]);
          };
        }
      }, r = this && this.__read || function(c, d) {
        var u = typeof Symbol == "function" && c[Symbol.iterator];
        if (!u) return c;
        var f, g, y = u.call(c), v = [];
        try {
          for (; (d === void 0 || d-- > 0) && !(f = y.next()).done; ) v.push(f.value);
        } catch (b) {
          g = { error: b };
        } finally {
          try {
            f && !f.done && (u = y.return) && u.call(y);
          } finally {
            if (g) throw g.error;
          }
        }
        return v;
      }, l = this && this.__spreadArray || function(c, d, u) {
        if (u || arguments.length === 2) for (var f, g = 0, y = d.length; g < y; g++) !f && g in d || (f || (f = Array.prototype.slice.call(d, 0, g)), f[g] = d[g]);
        return c.concat(f || Array.prototype.slice.call(d));
      }, n = this && this.__values || function(c) {
        var d = typeof Symbol == "function" && Symbol.iterator, u = d && c[d], f = 0;
        if (u) return u.call(c);
        if (c && typeof c.length == "number") return { next: function() {
          return c && f >= c.length && (c = void 0), { value: c && c[f++], done: !c };
        } };
        throw new TypeError(d ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      function h(c) {
        var d = this;
        c === void 0 && (c = []);
        var u = 0, f = [];
        this.size = function() {
          return u;
        }, this.empty = function() {
          return u === 0;
        }, this.clear = function() {
          u = 0, f.length = 0;
        }, this.front = function() {
          if (!this.empty()) return f[0];
        }, this.back = function() {
          if (!this.empty()) return f[u - 1];
        }, this.forEach = function(g) {
          f.forEach(g);
        }, this.getElementByPos = function(g) {
          if (g < 0 || g >= u) throw new Error("pos must more than 0 and less than vector's size");
          return f[g];
        }, this.eraseElementByPos = function(g) {
          if (g < 0 || g >= u) throw new Error("pos must more than 0 and less than vector's size");
          for (var y = g; y < u - 1; ++y) f[y] = f[y + 1];
          this.popBack();
        }, this.eraseElementByValue = function(g) {
          var y = [];
          this.forEach(function(b) {
            b !== g && y.push(b);
          }), y.forEach(function(b, x) {
            f[x] = b;
          });
          for (var v = y.length; u > v; ) this.popBack();
        }, this.pushBack = function(g) {
          f.push(g), ++u;
        }, this.popBack = function() {
          f.pop(), u > 0 && --u;
        }, this.setElementByPos = function(g, y) {
          if (g < 0 || g >= u) throw new Error("pos must more than 0 and less than vector's size");
          f[g] = y;
        }, this.insert = function(g, y, v) {
          if (v === void 0 && (v = 1), g < 0 || g > u) throw new Error("pos must more than 0 and less than or equal to vector's size");
          f.splice.apply(f, l([g, 0], r(new Array(v).fill(y)), !1)), u += v;
        }, this.find = function(g) {
          return f.includes(g);
        }, this.reverse = function() {
          f.reverse();
        }, this.unique = function() {
          var g, y = [];
          this.forEach(function(b, x) {
            x !== 0 && b === g || (y.push(b), g = b);
          }), y.forEach(function(b, x) {
            f[x] = b;
          });
          for (var v = y.length; u > v; ) this.popBack();
        }, this.sort = function(g) {
          f.sort(g);
        }, this[Symbol.iterator] = function() {
          return function() {
            return a(this, function(g) {
              switch (g.label) {
                case 0:
                  return [5, n(f)];
                case 1:
                  return [2, g.sent()];
              }
            });
          }();
        }, c.forEach(function(g) {
          return d.pushBack(g);
        }), Object.freeze(this);
      }
      Object.defineProperty(o, "__esModule", { value: !0 }), Object.freeze(h), o.default = h;
    }, {}], 36: [function(i, s, o) {
      Object.defineProperty(o, "__esModule", { value: !0 }), o.HashMap = o.HashSet = o.Map = o.Set = o.PriorityQueue = o.Deque = o.LinkList = o.Queue = o.Stack = o.Vector = void 0;
      var a = i("./Vector/Vector");
      o.Vector = a.default;
      var r = i("./Stack/Stack");
      o.Stack = r.default;
      var l = i("./Queue/Queue");
      o.Queue = l.default;
      var n = i("./LinkList/LinkList");
      o.LinkList = n.default;
      var h = i("./Deque/Deque");
      o.Deque = h.default;
      var c = i("./PriorityQueue/PriorityQueue");
      o.PriorityQueue = c.default;
      var d = i("./Set/Set");
      o.Set = d.default;
      var u = i("./Map/Map");
      o.Map = u.default;
      var f = i("./HashSet/HashSet");
      o.HashSet = f.default;
      var g = i("./HashMap/HashMap");
      o.HashMap = g.default;
    }, { "./Deque/Deque": 26, "./HashMap/HashMap": 27, "./HashSet/HashSet": 28, "./LinkList/LinkList": 29, "./Map/Map": 30, "./PriorityQueue/PriorityQueue": 31, "./Queue/Queue": 32, "./Set/Set": 33, "./Stack/Stack": 34, "./Vector/Vector": 35 }], 37: [function(i, s, o) {
      const a = i("yallist"), r = Symbol("max"), l = Symbol("length"), n = Symbol("lengthCalculator"), h = Symbol("allowStale"), c = Symbol("maxAge"), d = Symbol("dispose"), u = Symbol("noDisposeOnSet"), f = Symbol("lruList"), g = Symbol("cache"), y = Symbol("updateAgeOnGet"), v = () => 1, b = (P, E, H) => {
        const $ = P[g].get(E);
        if ($) {
          const A = $.value;
          if (x(P, A)) {
            if (k(P, $), !P[h]) return;
          } else H && (P[y] && ($.value.now = Date.now()), P[f].unshiftNode($));
          return A.value;
        }
      }, x = (P, E) => {
        if (!E || !E.maxAge && !P[c]) return !1;
        const H = Date.now() - E.now;
        return E.maxAge ? H > E.maxAge : P[c] && H > P[c];
      }, p = (P) => {
        if (P[l] > P[r]) for (let E = P[f].tail; P[l] > P[r] && E !== null; ) {
          const H = E.prev;
          k(P, E), E = H;
        }
      }, k = (P, E) => {
        if (E) {
          const H = E.value;
          P[d] && P[d](H.key, H.value), P[l] -= H.length, P[g].delete(H.key), P[f].removeNode(E);
        }
      };
      class C {
        constructor(E, H, $, A, I) {
          this.key = E, this.value = H, this.length = $, this.now = A, this.maxAge = I || 0;
        }
      }
      const R = (P, E, H, $) => {
        let A = H.value;
        x(P, A) && (k(P, H), P[h] || (A = void 0)), A && E.call($, A.value, A.key, P);
      };
      s.exports = class {
        constructor(P) {
          if (typeof P == "number" && (P = { max: P }), P || (P = {}), P.max && (typeof P.max != "number" || P.max < 0)) throw new TypeError("max must be a non-negative number");
          this[r] = P.max || 1 / 0;
          const E = P.length || v;
          if (this[n] = typeof E != "function" ? v : E, this[h] = P.stale || !1, P.maxAge && typeof P.maxAge != "number") throw new TypeError("maxAge must be a number");
          this[c] = P.maxAge || 0, this[d] = P.dispose, this[u] = P.noDisposeOnSet || !1, this[y] = P.updateAgeOnGet || !1, this.reset();
        }
        set max(P) {
          if (typeof P != "number" || P < 0) throw new TypeError("max must be a non-negative number");
          this[r] = P || 1 / 0, p(this);
        }
        get max() {
          return this[r];
        }
        set allowStale(P) {
          this[h] = !!P;
        }
        get allowStale() {
          return this[h];
        }
        set maxAge(P) {
          if (typeof P != "number") throw new TypeError("maxAge must be a non-negative number");
          this[c] = P, p(this);
        }
        get maxAge() {
          return this[c];
        }
        set lengthCalculator(P) {
          typeof P != "function" && (P = v), P !== this[n] && (this[n] = P, this[l] = 0, this[f].forEach((E) => {
            E.length = this[n](E.value, E.key), this[l] += E.length;
          })), p(this);
        }
        get lengthCalculator() {
          return this[n];
        }
        get length() {
          return this[l];
        }
        get itemCount() {
          return this[f].length;
        }
        rforEach(P, E) {
          E = E || this;
          for (let H = this[f].tail; H !== null; ) {
            const $ = H.prev;
            R(this, P, H, E), H = $;
          }
        }
        forEach(P, E) {
          E = E || this;
          for (let H = this[f].head; H !== null; ) {
            const $ = H.next;
            R(this, P, H, E), H = $;
          }
        }
        keys() {
          return this[f].toArray().map((P) => P.key);
        }
        values() {
          return this[f].toArray().map((P) => P.value);
        }
        reset() {
          this[d] && this[f] && this[f].length && this[f].forEach((P) => this[d](P.key, P.value)), this[g] = /* @__PURE__ */ new Map(), this[f] = new a(), this[l] = 0;
        }
        dump() {
          return this[f].map((P) => !x(this, P) && { k: P.key, v: P.value, e: P.now + (P.maxAge || 0) }).toArray().filter((P) => P);
        }
        dumpLru() {
          return this[f];
        }
        set(P, E, H) {
          if ((H = H || this[c]) && typeof H != "number") throw new TypeError("maxAge must be a number");
          const $ = H ? Date.now() : 0, A = this[n](E, P);
          if (this[g].has(P)) {
            if (A > this[r]) return k(this, this[g].get(P)), !1;
            const S = this[g].get(P).value;
            return this[d] && (this[u] || this[d](P, S.value)), S.now = $, S.maxAge = H, S.value = E, this[l] += A - S.length, S.length = A, this.get(P), p(this), !0;
          }
          const I = new C(P, E, A, $, H);
          return I.length > this[r] ? (this[d] && this[d](P, E), !1) : (this[l] += I.length, this[f].unshift(I), this[g].set(P, this[f].head), p(this), !0);
        }
        has(P) {
          if (!this[g].has(P)) return !1;
          const E = this[g].get(P).value;
          return !x(this, E);
        }
        get(P) {
          return b(this, P, !0);
        }
        peek(P) {
          return b(this, P, !1);
        }
        pop() {
          const P = this[f].tail;
          return P ? (k(this, P), P.value) : null;
        }
        del(P) {
          k(this, this[g].get(P));
        }
        load(P) {
          this.reset();
          const E = Date.now();
          for (let H = P.length - 1; H >= 0; H--) {
            const $ = P[H], A = $.e || 0;
            if (A === 0) this.set($.k, $.v);
            else {
              const I = A - E;
              I > 0 && this.set($.k, $.v, I);
            }
          }
        }
        prune() {
          this[g].forEach((P, E) => b(this, E, !1));
        }
      };
    }, { yallist: 83 }], 38: [function(i, s, o) {
      (function(a) {
        (function() {
          const r = s.exports;
          r.types = { 0: "reserved", 1: "connect", 2: "connack", 3: "publish", 4: "puback", 5: "pubrec", 6: "pubrel", 7: "pubcomp", 8: "subscribe", 9: "suback", 10: "unsubscribe", 11: "unsuback", 12: "pingreq", 13: "pingresp", 14: "disconnect", 15: "auth" }, r.codes = {};
          for (const n in r.types) {
            const h = r.types[n];
            r.codes[h] = n;
          }
          r.CMD_SHIFT = 4, r.CMD_MASK = 240, r.DUP_MASK = 8, r.QOS_MASK = 3, r.QOS_SHIFT = 1, r.RETAIN_MASK = 1, r.VARBYTEINT_MASK = 127, r.VARBYTEINT_FIN_MASK = 128, r.VARBYTEINT_MAX = 268435455, r.SESSIONPRESENT_MASK = 1, r.SESSIONPRESENT_HEADER = a.from([r.SESSIONPRESENT_MASK]), r.CONNACK_HEADER = a.from([r.codes.connack << r.CMD_SHIFT]), r.USERNAME_MASK = 128, r.PASSWORD_MASK = 64, r.WILL_RETAIN_MASK = 32, r.WILL_QOS_MASK = 24, r.WILL_QOS_SHIFT = 3, r.WILL_FLAG_MASK = 4, r.CLEAN_SESSION_MASK = 2, r.CONNECT_HEADER = a.from([r.codes.connect << r.CMD_SHIFT]), r.properties = { sessionExpiryInterval: 17, willDelayInterval: 24, receiveMaximum: 33, maximumPacketSize: 39, topicAliasMaximum: 34, requestResponseInformation: 25, requestProblemInformation: 23, userProperties: 38, authenticationMethod: 21, authenticationData: 22, payloadFormatIndicator: 1, messageExpiryInterval: 2, contentType: 3, responseTopic: 8, correlationData: 9, maximumQoS: 36, retainAvailable: 37, assignedClientIdentifier: 18, reasonString: 31, wildcardSubscriptionAvailable: 40, subscriptionIdentifiersAvailable: 41, sharedSubscriptionAvailable: 42, serverKeepAlive: 19, responseInformation: 26, serverReference: 28, topicAlias: 35, subscriptionIdentifier: 11 }, r.propertiesCodes = {};
          for (const n in r.properties) {
            const h = r.properties[n];
            r.propertiesCodes[h] = n;
          }
          function l(n) {
            return [0, 1, 2].map((h) => [0, 1].map((c) => [0, 1].map((d) => {
              const u = a.alloc(1);
              return u.writeUInt8(r.codes[n] << r.CMD_SHIFT | (c ? r.DUP_MASK : 0) | h << r.QOS_SHIFT | d, 0, !0), u;
            })));
          }
          r.propertiesTypes = { sessionExpiryInterval: "int32", willDelayInterval: "int32", receiveMaximum: "int16", maximumPacketSize: "int32", topicAliasMaximum: "int16", requestResponseInformation: "byte", requestProblemInformation: "byte", userProperties: "pair", authenticationMethod: "string", authenticationData: "binary", payloadFormatIndicator: "byte", messageExpiryInterval: "int32", contentType: "string", responseTopic: "string", correlationData: "binary", maximumQoS: "int8", retainAvailable: "byte", assignedClientIdentifier: "string", reasonString: "string", wildcardSubscriptionAvailable: "byte", subscriptionIdentifiersAvailable: "byte", sharedSubscriptionAvailable: "byte", serverKeepAlive: "int16", responseInformation: "string", serverReference: "string", topicAlias: "int16", subscriptionIdentifier: "var" }, r.PUBLISH_HEADER = l("publish"), r.SUBSCRIBE_HEADER = l("subscribe"), r.SUBSCRIBE_OPTIONS_QOS_MASK = 3, r.SUBSCRIBE_OPTIONS_NL_MASK = 1, r.SUBSCRIBE_OPTIONS_NL_SHIFT = 2, r.SUBSCRIBE_OPTIONS_RAP_MASK = 1, r.SUBSCRIBE_OPTIONS_RAP_SHIFT = 3, r.SUBSCRIBE_OPTIONS_RH_MASK = 3, r.SUBSCRIBE_OPTIONS_RH_SHIFT = 4, r.SUBSCRIBE_OPTIONS_RH = [0, 16, 32], r.SUBSCRIBE_OPTIONS_NL = 4, r.SUBSCRIBE_OPTIONS_RAP = 8, r.SUBSCRIBE_OPTIONS_QOS = [0, 1, 2], r.UNSUBSCRIBE_HEADER = l("unsubscribe"), r.ACKS = { unsuback: l("unsuback"), puback: l("puback"), pubcomp: l("pubcomp"), pubrel: l("pubrel"), pubrec: l("pubrec") }, r.SUBACK_HEADER = a.from([r.codes.suback << r.CMD_SHIFT]), r.VERSION3 = a.from([3]), r.VERSION4 = a.from([4]), r.VERSION5 = a.from([5]), r.VERSION131 = a.from([131]), r.VERSION132 = a.from([132]), r.QOS = [0, 1, 2].map((n) => a.from([n])), r.EMPTY = { pingreq: a.from([r.codes.pingreq << 4, 0]), pingresp: a.from([r.codes.pingresp << 4, 0]), disconnect: a.from([r.codes.disconnect << 4, 0]) };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 39: [function(i, s, o) {
      (function(a) {
        (function() {
          const r = i("./writeToStream"), l = i("events");
          class n extends l {
            constructor() {
              super(), this._array = new Array(20), this._i = 0;
            }
            write(c) {
              return this._array[this._i++] = c, !0;
            }
            concat() {
              let c = 0;
              const d = new Array(this._array.length), u = this._array;
              let f, g = 0;
              for (f = 0; f < u.length && u[f] !== void 0; f++) typeof u[f] != "string" ? d[f] = u[f].length : d[f] = a.byteLength(u[f]), c += d[f];
              const y = a.allocUnsafe(c);
              for (f = 0; f < u.length && u[f] !== void 0; f++) typeof u[f] != "string" ? (u[f].copy(y, g), g += d[f]) : (y.write(u[f], g), g += d[f]);
              return y;
            }
          }
          s.exports = function(h, c) {
            const d = new n();
            return r(h, d, c), d.concat();
          };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "./writeToStream": 44, buffer: 17, events: 22 }], 40: [function(i, s, o) {
      o.parser = i("./parser").parser, o.generate = i("./generate"), o.writeToStream = i("./writeToStream");
    }, { "./generate": 39, "./parser": 43, "./writeToStream": 44 }], 41: [function(i, s, o) {
      (function(a) {
        (function() {
          const l = {}, n = a.isBuffer(a.from([1, 2]).subarray(0, 1));
          function h(c) {
            const d = a.allocUnsafe(2);
            return d.writeUInt8(c >> 8, 0), d.writeUInt8(255 & c, 1), d;
          }
          s.exports = { cache: l, generateCache: function() {
            for (let c = 0; c < 65536; c++) l[c] = h(c);
          }, generateNumber: h, genBufVariableByteInt: function(c) {
            let d = 0, u = 0;
            const f = a.allocUnsafe(4);
            do
              d = c % 128 | 0, (c = c / 128 | 0) > 0 && (d |= 128), f.writeUInt8(d, u++);
            while (c > 0 && u < 4);
            return c > 0 && (u = 0), n ? f.subarray(0, u) : f.slice(0, u);
          }, generate4ByteBuffer: function(c) {
            const d = a.allocUnsafe(4);
            return d.writeUInt32BE(c, 0), d;
          } };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 42: [function(i, s, o) {
      s.exports = class {
        constructor() {
          this.cmd = null, this.retain = !1, this.qos = 0, this.dup = !1, this.length = -1, this.topic = null, this.payload = null;
        }
      };
    }, {}], 43: [function(i, s, o) {
      const a = i("bl"), r = i("events"), l = i("./packet"), n = i("./constants"), h = i("debug")("mqtt-packet:parser");
      class c extends r {
        constructor() {
          super(), this.parser = this.constructor.parser;
        }
        static parser(u) {
          return this instanceof c ? (this.settings = u || {}, this._states = ["_parseHeader", "_parseLength", "_parsePayload", "_newPacket"], this._resetState(), this) : new c().parser(u);
        }
        _resetState() {
          h("_resetState: resetting packet, error, _list, and _stateCounter"), this.packet = new l(), this.error = null, this._list = a(), this._stateCounter = 0;
        }
        parse(u) {
          for (this.error && this._resetState(), this._list.append(u), h("parse: current state: %s", this._states[this._stateCounter]); (this.packet.length !== -1 || this._list.length > 0) && this[this._states[this._stateCounter]]() && !this.error; ) this._stateCounter++, h("parse: state complete. _stateCounter is now: %d", this._stateCounter), h("parse: packet.length: %d, buffer list length: %d", this.packet.length, this._list.length), this._stateCounter >= this._states.length && (this._stateCounter = 0);
          return h("parse: exited while loop. packet: %d, buffer list length: %d", this.packet.length, this._list.length), this._list.length;
        }
        _parseHeader() {
          const u = this._list.readUInt8(0);
          return this.packet.cmd = n.types[u >> n.CMD_SHIFT], this.packet.retain = (u & n.RETAIN_MASK) != 0, this.packet.qos = u >> n.QOS_SHIFT & n.QOS_MASK, this.packet.dup = (u & n.DUP_MASK) != 0, h("_parseHeader: packet: %o", this.packet), this._list.consume(1), !0;
        }
        _parseLength() {
          const u = this._parseVarByteNum(!0);
          return u && (this.packet.length = u.value, this._list.consume(u.bytes)), h("_parseLength %d", u.value), !!u;
        }
        _parsePayload() {
          h("_parsePayload: payload %O", this._list);
          let u = !1;
          if (this.packet.length === 0 || this._list.length >= this.packet.length) {
            switch (this._pos = 0, this.packet.cmd) {
              case "connect":
                this._parseConnect();
                break;
              case "connack":
                this._parseConnack();
                break;
              case "publish":
                this._parsePublish();
                break;
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                this._parseConfirmation();
                break;
              case "subscribe":
                this._parseSubscribe();
                break;
              case "suback":
                this._parseSuback();
                break;
              case "unsubscribe":
                this._parseUnsubscribe();
                break;
              case "unsuback":
                this._parseUnsuback();
                break;
              case "pingreq":
              case "pingresp":
                break;
              case "disconnect":
                this._parseDisconnect();
                break;
              case "auth":
                this._parseAuth();
                break;
              default:
                this._emitError(new Error("Not supported"));
            }
            u = !0;
          }
          return h("_parsePayload complete result: %s", u), u;
        }
        _parseConnect() {
          let u, f, g, y;
          h("_parseConnect");
          const v = {}, b = this.packet, x = this._parseString();
          if (x === null) return this._emitError(new Error("Cannot parse protocolId"));
          if (x !== "MQTT" && x !== "MQIsdp") return this._emitError(new Error("Invalid protocolId"));
          if (b.protocolId = x, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (b.protocolVersion = this._list.readUInt8(this._pos), b.protocolVersion >= 128 && (b.bridgeMode = !0, b.protocolVersion = b.protocolVersion - 128), b.protocolVersion !== 3 && b.protocolVersion !== 4 && b.protocolVersion !== 5) return this._emitError(new Error("Invalid protocol version"));
          if (this._pos++, this._pos >= this._list.length) return this._emitError(new Error("Packet too short"));
          if (v.username = this._list.readUInt8(this._pos) & n.USERNAME_MASK, v.password = this._list.readUInt8(this._pos) & n.PASSWORD_MASK, v.will = this._list.readUInt8(this._pos) & n.WILL_FLAG_MASK, v.will && (b.will = {}, b.will.retain = (this._list.readUInt8(this._pos) & n.WILL_RETAIN_MASK) != 0, b.will.qos = (this._list.readUInt8(this._pos) & n.WILL_QOS_MASK) >> n.WILL_QOS_SHIFT), b.clean = (this._list.readUInt8(this._pos) & n.CLEAN_SESSION_MASK) != 0, this._pos++, b.keepalive = this._parseNum(), b.keepalive === -1) return this._emitError(new Error("Packet too short"));
          if (b.protocolVersion === 5) {
            const k = this._parseProperties();
            Object.getOwnPropertyNames(k).length && (b.properties = k);
          }
          const p = this._parseString();
          if (p === null) return this._emitError(new Error("Packet too short"));
          if (b.clientId = p, h("_parseConnect: packet.clientId: %s", b.clientId), v.will) {
            if (b.protocolVersion === 5) {
              const k = this._parseProperties();
              Object.getOwnPropertyNames(k).length && (b.will.properties = k);
            }
            if ((u = this._parseString()) === null) return this._emitError(new Error("Cannot parse will topic"));
            if (b.will.topic = u, h("_parseConnect: packet.will.topic: %s", b.will.topic), (f = this._parseBuffer()) === null) return this._emitError(new Error("Cannot parse will payload"));
            b.will.payload = f, h("_parseConnect: packet.will.paylaod: %s", b.will.payload);
          }
          if (v.username) {
            if ((y = this._parseString()) === null) return this._emitError(new Error("Cannot parse username"));
            b.username = y, h("_parseConnect: packet.username: %s", b.username);
          }
          if (v.password) {
            if ((g = this._parseBuffer()) === null) return this._emitError(new Error("Cannot parse password"));
            b.password = g;
          }
          return this.settings = b, h("_parseConnect: complete"), b;
        }
        _parseConnack() {
          h("_parseConnack");
          const u = this.packet;
          if (this._list.length < 1) return null;
          if (u.sessionPresent = !!(this._list.readUInt8(this._pos++) & n.SESSIONPRESENT_MASK), this.settings.protocolVersion === 5) this._list.length >= 2 ? u.reasonCode = this._list.readUInt8(this._pos++) : u.reasonCode = 0;
          else {
            if (this._list.length < 2) return null;
            u.returnCode = this._list.readUInt8(this._pos++);
          }
          if (u.returnCode === -1 || u.reasonCode === -1) return this._emitError(new Error("Cannot parse return code"));
          if (this.settings.protocolVersion === 5) {
            const f = this._parseProperties();
            Object.getOwnPropertyNames(f).length && (u.properties = f);
          }
          h("_parseConnack: complete");
        }
        _parsePublish() {
          h("_parsePublish");
          const u = this.packet;
          if (u.topic = this._parseString(), u.topic === null) return this._emitError(new Error("Cannot parse topic"));
          if (!(u.qos > 0) || this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const f = this._parseProperties();
              Object.getOwnPropertyNames(f).length && (u.properties = f);
            }
            u.payload = this._list.slice(this._pos, u.length), h("_parsePublish: payload from buffer list: %o", u.payload);
          }
        }
        _parseSubscribe() {
          h("_parseSubscribe");
          const u = this.packet;
          let f, g, y, v, b, x, p;
          if (u.qos !== 1) return this._emitError(new Error("Wrong subscribe header"));
          if (u.subscriptions = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const k = this._parseProperties();
              Object.getOwnPropertyNames(k).length && (u.properties = k);
            }
            for (; this._pos < u.length; ) {
              if ((f = this._parseString()) === null) return this._emitError(new Error("Cannot parse topic"));
              if (this._pos >= u.length) return this._emitError(new Error("Malformed Subscribe Payload"));
              y = (g = this._parseByte()) & n.SUBSCRIBE_OPTIONS_QOS_MASK, x = (g >> n.SUBSCRIBE_OPTIONS_NL_SHIFT & n.SUBSCRIBE_OPTIONS_NL_MASK) != 0, b = (g >> n.SUBSCRIBE_OPTIONS_RAP_SHIFT & n.SUBSCRIBE_OPTIONS_RAP_MASK) != 0, v = g >> n.SUBSCRIBE_OPTIONS_RH_SHIFT & n.SUBSCRIBE_OPTIONS_RH_MASK, p = { topic: f, qos: y }, this.settings.protocolVersion === 5 ? (p.nl = x, p.rap = b, p.rh = v) : this.settings.bridgeMode && (p.rh = 0, p.rap = !0, p.nl = !0), h("_parseSubscribe: push subscription `%s` to subscription", p), u.subscriptions.push(p);
            }
          }
        }
        _parseSuback() {
          h("_parseSuback");
          const u = this.packet;
          if (this.packet.granted = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const f = this._parseProperties();
              Object.getOwnPropertyNames(f).length && (u.properties = f);
            }
            for (; this._pos < this.packet.length; ) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseUnsubscribe() {
          h("_parseUnsubscribe");
          const u = this.packet;
          if (u.unsubscriptions = [], this._parseMessageId()) {
            if (this.settings.protocolVersion === 5) {
              const f = this._parseProperties();
              Object.getOwnPropertyNames(f).length && (u.properties = f);
            }
            for (; this._pos < u.length; ) {
              const f = this._parseString();
              if (f === null) return this._emitError(new Error("Cannot parse topic"));
              h("_parseUnsubscribe: push topic `%s` to unsubscriptions", f), u.unsubscriptions.push(f);
            }
          }
        }
        _parseUnsuback() {
          h("_parseUnsuback");
          const u = this.packet;
          if (!this._parseMessageId()) return this._emitError(new Error("Cannot parse messageId"));
          if (this.settings.protocolVersion === 5) {
            const f = this._parseProperties();
            for (Object.getOwnPropertyNames(f).length && (u.properties = f), u.granted = []; this._pos < this.packet.length; ) this.packet.granted.push(this._list.readUInt8(this._pos++));
          }
        }
        _parseConfirmation() {
          h("_parseConfirmation: packet.cmd: `%s`", this.packet.cmd);
          const u = this.packet;
          if (this._parseMessageId(), this.settings.protocolVersion === 5 && (u.length > 2 ? (u.reasonCode = this._parseByte(), h("_parseConfirmation: packet.reasonCode `%d`", u.reasonCode)) : u.reasonCode = 0, u.length > 3)) {
            const f = this._parseProperties();
            Object.getOwnPropertyNames(f).length && (u.properties = f);
          }
          return !0;
        }
        _parseDisconnect() {
          const u = this.packet;
          if (h("_parseDisconnect"), this.settings.protocolVersion === 5) {
            this._list.length > 0 ? u.reasonCode = this._parseByte() : u.reasonCode = 0;
            const f = this._parseProperties();
            Object.getOwnPropertyNames(f).length && (u.properties = f);
          }
          return h("_parseDisconnect result: true"), !0;
        }
        _parseAuth() {
          h("_parseAuth");
          const u = this.packet;
          if (this.settings.protocolVersion !== 5) return this._emitError(new Error("Not supported auth packet for this version MQTT"));
          u.reasonCode = this._parseByte();
          const f = this._parseProperties();
          return Object.getOwnPropertyNames(f).length && (u.properties = f), h("_parseAuth: result: true"), !0;
        }
        _parseMessageId() {
          const u = this.packet;
          return u.messageId = this._parseNum(), u.messageId === null ? (this._emitError(new Error("Cannot parse messageId")), !1) : (h("_parseMessageId: packet.messageId %d", u.messageId), !0);
        }
        _parseString(u) {
          const f = this._parseNum(), g = f + this._pos;
          if (f === -1 || g > this._list.length || g > this.packet.length) return null;
          const y = this._list.toString("utf8", this._pos, g);
          return this._pos += f, h("_parseString: result: %s", y), y;
        }
        _parseStringPair() {
          return h("_parseStringPair"), { name: this._parseString(), value: this._parseString() };
        }
        _parseBuffer() {
          const u = this._parseNum(), f = u + this._pos;
          if (u === -1 || f > this._list.length || f > this.packet.length) return null;
          const g = this._list.slice(this._pos, f);
          return this._pos += u, h("_parseBuffer: result: %o", g), g;
        }
        _parseNum() {
          if (this._list.length - this._pos < 2) return -1;
          const u = this._list.readUInt16BE(this._pos);
          return this._pos += 2, h("_parseNum: result: %s", u), u;
        }
        _parse4ByteNum() {
          if (this._list.length - this._pos < 4) return -1;
          const u = this._list.readUInt32BE(this._pos);
          return this._pos += 4, h("_parse4ByteNum: result: %s", u), u;
        }
        _parseVarByteNum(u) {
          h("_parseVarByteNum");
          let f, g = 0, y = 1, v = 0, b = !1;
          const x = this._pos ? this._pos : 0;
          for (; g < 4 && x + g < this._list.length; ) {
            if (v += y * ((f = this._list.readUInt8(x + g++)) & n.VARBYTEINT_MASK), y *= 128, (f & n.VARBYTEINT_FIN_MASK) == 0) {
              b = !0;
              break;
            }
            if (this._list.length <= g) break;
          }
          return !b && g === 4 && this._list.length >= g && this._emitError(new Error("Invalid variable byte integer")), x && (this._pos += g), h("_parseVarByteNum: result: %o", b = !!b && (u ? { bytes: g, value: v } : v)), b;
        }
        _parseByte() {
          let u;
          return this._pos < this._list.length && (u = this._list.readUInt8(this._pos), this._pos++), h("_parseByte: result: %o", u), u;
        }
        _parseByType(u) {
          switch (h("_parseByType: type: %s", u), u) {
            case "byte":
              return this._parseByte() !== 0;
            case "int8":
              return this._parseByte();
            case "int16":
              return this._parseNum();
            case "int32":
              return this._parse4ByteNum();
            case "var":
              return this._parseVarByteNum();
            case "string":
              return this._parseString();
            case "pair":
              return this._parseStringPair();
            case "binary":
              return this._parseBuffer();
          }
        }
        _parseProperties() {
          h("_parseProperties");
          const u = this._parseVarByteNum(), f = this._pos + u, g = {};
          for (; this._pos < f; ) {
            const y = this._parseByte();
            if (!y) return this._emitError(new Error("Cannot parse property code type")), !1;
            const v = n.propertiesCodes[y];
            if (!v) return this._emitError(new Error("Unknown property")), !1;
            if (v !== "userProperties") g[v] ? Array.isArray(g[v]) ? g[v].push(this._parseByType(n.propertiesTypes[v])) : (g[v] = [g[v]], g[v].push(this._parseByType(n.propertiesTypes[v]))) : g[v] = this._parseByType(n.propertiesTypes[v]);
            else {
              g[v] || (g[v] = /* @__PURE__ */ Object.create(null));
              const b = this._parseByType(n.propertiesTypes[v]);
              if (g[v][b.name]) if (Array.isArray(g[v][b.name])) g[v][b.name].push(b.value);
              else {
                const x = g[v][b.name];
                g[v][b.name] = [x], g[v][b.name].push(b.value);
              }
              else g[v][b.name] = b.value;
            }
          }
          return g;
        }
        _newPacket() {
          return h("_newPacket"), this.packet && (this._list.consume(this.packet.length), h("_newPacket: parser emit packet: packet.cmd: %s, packet.payload: %s, packet.length: %d", this.packet.cmd, this.packet.payload, this.packet.length), this.emit("packet", this.packet)), h("_newPacket: new packet"), this.packet = new l(), this._pos = 0, !0;
        }
        _emitError(u) {
          h("_emitError"), this.error = u, this.emit("error", u);
        }
      }
      s.exports = c;
    }, { "./constants": 38, "./packet": 42, bl: 15, debug: 18, events: 22 }], 44: [function(i, s, o) {
      (function(a) {
        (function() {
          const r = i("./constants"), l = a.allocUnsafe(0), n = a.from([0]), h = i("./numbers"), c = i("process-nextick-args").nextTick, d = i("debug")("mqtt-packet:writeToStream"), u = h.cache, f = h.generateNumber, g = h.generateCache, y = h.genBufVariableByteInt, v = h.generate4ByteBuffer;
          let b = H, x = !0;
          function p(z, M, D) {
            switch (d("generate called"), M.cork && (M.cork(), c(k, M)), x && (x = !1, g()), d("generate: packet.cmd: %s", z.cmd), z.cmd) {
              case "connect":
                return function(W, N, U) {
                  const q = W || {}, Y = q.protocolId || "MQTT";
                  let Z = q.protocolVersion || 4;
                  const Q = q.will;
                  let J = q.clean;
                  const m = q.keepalive || 0, w = q.clientId || "", T = q.username, L = q.password, F = q.properties;
                  J === void 0 && (J = !0);
                  let V = 0;
                  if (!Y || typeof Y != "string" && !a.isBuffer(Y)) return N.emit("error", new Error("Invalid protocolId")), !1;
                  if (V += Y.length + 2, Z !== 3 && Z !== 4 && Z !== 5) return N.emit("error", new Error("Invalid protocol version")), !1;
                  if (V += 1, (typeof w == "string" || a.isBuffer(w)) && (w || Z >= 4) && (w || J)) V += a.byteLength(w) + 2;
                  else {
                    if (Z < 4) return N.emit("error", new Error("clientId must be supplied before 3.1.1")), !1;
                    if (1 * J == 0) return N.emit("error", new Error("clientId must be given if cleanSession set to 0")), !1;
                  }
                  if (typeof m != "number" || m < 0 || m > 65535 || m % 1 != 0) return N.emit("error", new Error("Invalid keepalive")), !1;
                  if (V += 2, V += 1, Z === 5) {
                    var K = I(N, F);
                    if (!K) return !1;
                    V += K.length;
                  }
                  if (Q) {
                    if (typeof Q != "object") return N.emit("error", new Error("Invalid will")), !1;
                    if (!Q.topic || typeof Q.topic != "string") return N.emit("error", new Error("Invalid will topic")), !1;
                    if (V += a.byteLength(Q.topic) + 2, V += 2, Q.payload) {
                      if (!(Q.payload.length >= 0)) return N.emit("error", new Error("Invalid will payload")), !1;
                      typeof Q.payload == "string" ? V += a.byteLength(Q.payload) : V += Q.payload.length;
                    }
                    var et = {};
                    if (Z === 5) {
                      if (!(et = I(N, Q.properties))) return !1;
                      V += et.length;
                    }
                  }
                  let tt = !1;
                  if (T != null) {
                    if (!X(T)) return N.emit("error", new Error("Invalid username")), !1;
                    tt = !0, V += a.byteLength(T) + 2;
                  }
                  if (L != null) {
                    if (!tt) return N.emit("error", new Error("Username is required to use password")), !1;
                    if (!X(L)) return N.emit("error", new Error("Invalid password")), !1;
                    V += j(L) + 2;
                  }
                  N.write(r.CONNECT_HEADER), R(N, V), A(N, Y), q.bridgeMode && (Z += 128), N.write(Z === 131 ? r.VERSION131 : Z === 132 ? r.VERSION132 : Z === 4 ? r.VERSION4 : Z === 5 ? r.VERSION5 : r.VERSION3);
                  let at = 0;
                  return at |= T != null ? r.USERNAME_MASK : 0, at |= L != null ? r.PASSWORD_MASK : 0, at |= Q && Q.retain ? r.WILL_RETAIN_MASK : 0, at |= Q && Q.qos ? Q.qos << r.WILL_QOS_SHIFT : 0, at |= Q ? r.WILL_FLAG_MASK : 0, at |= J ? r.CLEAN_SESSION_MASK : 0, N.write(a.from([at])), b(N, m), Z === 5 && K.write(), A(N, w), Q && (Z === 5 && et.write(), P(N, Q.topic), A(N, Q.payload)), T != null && A(N, T), L != null && A(N, L), !0;
                }(z, M);
              case "connack":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = q === 5 ? Y.reasonCode : Y.returnCode, Q = Y.properties;
                  let J = 2;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid return code")), !1;
                  let m = null;
                  if (q === 5) {
                    if (!(m = I(N, Q))) return !1;
                    J += m.length;
                  }
                  return N.write(r.CONNACK_HEADER), R(N, J), N.write(Y.sessionPresent ? r.SESSIONPRESENT_HEADER : n), N.write(a.from([Z])), m != null && m.write(), !0;
                }(z, M, D);
              case "publish":
                return function(W, N, U) {
                  d("publish: packet: %o", W);
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.qos || 0, Q = Y.retain ? r.RETAIN_MASK : 0, J = Y.topic, m = Y.payload || l, w = Y.messageId, T = Y.properties;
                  let L = 0;
                  if (typeof J == "string") L += a.byteLength(J) + 2;
                  else {
                    if (!a.isBuffer(J)) return N.emit("error", new Error("Invalid topic")), !1;
                    L += J.length + 2;
                  }
                  if (a.isBuffer(m) ? L += m.length : L += a.byteLength(m), Z && typeof w != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  Z && (L += 2);
                  let F = null;
                  if (q === 5) {
                    if (!(F = I(N, T))) return !1;
                    L += F.length;
                  }
                  return N.write(r.PUBLISH_HEADER[Z][Y.dup ? 1 : 0][Q ? 1 : 0]), R(N, L), b(N, j(J)), N.write(J), Z > 0 && b(N, w), F != null && F.write(), d("publish: payload: %o", m), N.write(m);
                }(z, M, D);
              case "puback":
              case "pubrec":
              case "pubrel":
              case "pubcomp":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.cmd || "puback", Q = Y.messageId, J = Y.dup && Z === "pubrel" ? r.DUP_MASK : 0;
                  let m = 0;
                  const w = Y.reasonCode, T = Y.properties;
                  let L = q === 5 ? 3 : 2;
                  if (Z === "pubrel" && (m = 1), typeof Q != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  let F = null;
                  if (q === 5 && typeof T == "object") {
                    if (!(F = S(N, T, U, L))) return !1;
                    L += F.length;
                  }
                  return N.write(r.ACKS[Z][m][J][0]), R(N, L), b(N, Q), q === 5 && N.write(a.from([w])), F !== null && F.write(), !0;
                }(z, M, D);
              case "subscribe":
                return function(W, N, U) {
                  d("subscribe: packet: ");
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.dup ? r.DUP_MASK : 0, Q = Y.messageId, J = Y.subscriptions, m = Y.properties;
                  let w = 0;
                  if (typeof Q != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  w += 2;
                  let T = null;
                  if (q === 5) {
                    if (!(T = I(N, m))) return !1;
                    w += T.length;
                  }
                  if (typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid subscriptions")), !1;
                  for (let F = 0; F < J.length; F += 1) {
                    const V = J[F].topic, K = J[F].qos;
                    if (typeof V != "string") return N.emit("error", new Error("Invalid subscriptions - invalid topic")), !1;
                    if (typeof K != "number") return N.emit("error", new Error("Invalid subscriptions - invalid qos")), !1;
                    if (q === 5) {
                      if (typeof (J[F].nl || !1) != "boolean") return N.emit("error", new Error("Invalid subscriptions - invalid No Local")), !1;
                      if (typeof (J[F].rap || !1) != "boolean") return N.emit("error", new Error("Invalid subscriptions - invalid Retain as Published")), !1;
                      const at = J[F].rh || 0;
                      if (typeof at != "number" || at > 2) return N.emit("error", new Error("Invalid subscriptions - invalid Retain Handling")), !1;
                    }
                    w += a.byteLength(V) + 2 + 1;
                  }
                  d("subscribe: writing to stream: %o", r.SUBSCRIBE_HEADER), N.write(r.SUBSCRIBE_HEADER[1][Z ? 1 : 0][0]), R(N, w), b(N, Q), T !== null && T.write();
                  let L = !0;
                  for (const F of J) {
                    const V = F.topic, K = F.qos, et = +F.nl, tt = +F.rap, at = F.rh;
                    let lt;
                    P(N, V), lt = r.SUBSCRIBE_OPTIONS_QOS[K], q === 5 && (lt |= et ? r.SUBSCRIBE_OPTIONS_NL : 0, lt |= tt ? r.SUBSCRIBE_OPTIONS_RAP : 0, lt |= at ? r.SUBSCRIBE_OPTIONS_RH[at] : 0), L = N.write(a.from([lt]));
                  }
                  return L;
                }(z, M, D);
              case "suback":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.messageId, Q = Y.granted, J = Y.properties;
                  let m = 0;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (m += 2, typeof Q != "object" || !Q.length) return N.emit("error", new Error("Invalid qos vector")), !1;
                  for (let T = 0; T < Q.length; T += 1) {
                    if (typeof Q[T] != "number") return N.emit("error", new Error("Invalid qos vector")), !1;
                    m += 1;
                  }
                  let w = null;
                  if (q === 5) {
                    if (!(w = S(N, J, U, m))) return !1;
                    m += w.length;
                  }
                  return N.write(r.SUBACK_HEADER), R(N, m), b(N, Z), w !== null && w.write(), N.write(a.from(Q));
                }(z, M, D);
              case "unsubscribe":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.messageId, Q = Y.dup ? r.DUP_MASK : 0, J = Y.unsubscriptions, m = Y.properties;
                  let w = 0;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (w += 2, typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid unsubscriptions")), !1;
                  for (let F = 0; F < J.length; F += 1) {
                    if (typeof J[F] != "string") return N.emit("error", new Error("Invalid unsubscriptions")), !1;
                    w += a.byteLength(J[F]) + 2;
                  }
                  let T = null;
                  if (q === 5) {
                    if (!(T = I(N, m))) return !1;
                    w += T.length;
                  }
                  N.write(r.UNSUBSCRIBE_HEADER[1][Q ? 1 : 0][0]), R(N, w), b(N, Z), T !== null && T.write();
                  let L = !0;
                  for (let F = 0; F < J.length; F++) L = P(N, J[F]);
                  return L;
                }(z, M, D);
              case "unsuback":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.messageId, Q = Y.dup ? r.DUP_MASK : 0, J = Y.granted, m = Y.properties, w = Y.cmd;
                  let T = 2;
                  if (typeof Z != "number") return N.emit("error", new Error("Invalid messageId")), !1;
                  if (q === 5) {
                    if (typeof J != "object" || !J.length) return N.emit("error", new Error("Invalid qos vector")), !1;
                    for (let F = 0; F < J.length; F += 1) {
                      if (typeof J[F] != "number") return N.emit("error", new Error("Invalid qos vector")), !1;
                      T += 1;
                    }
                  }
                  let L = null;
                  if (q === 5) {
                    if (!(L = S(N, m, U, T))) return !1;
                    T += L.length;
                  }
                  return N.write(r.ACKS[w][0][Q][0]), R(N, T), b(N, Z), L !== null && L.write(), q === 5 && N.write(a.from(J)), !0;
                }(z, M, D);
              case "pingreq":
              case "pingresp":
                return function(W, N, U) {
                  return N.write(r.EMPTY[W.cmd]);
                }(z, M);
              case "disconnect":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.reasonCode, Q = Y.properties;
                  let J = q === 5 ? 1 : 0, m = null;
                  if (q === 5) {
                    if (!(m = S(N, Q, U, J))) return !1;
                    J += m.length;
                  }
                  return N.write(a.from([r.codes.disconnect << 4])), R(N, J), q === 5 && N.write(a.from([Z])), m !== null && m.write(), !0;
                }(z, M, D);
              case "auth":
                return function(W, N, U) {
                  const q = U ? U.protocolVersion : 4, Y = W || {}, Z = Y.reasonCode, Q = Y.properties;
                  let J = q === 5 ? 1 : 0;
                  q !== 5 && N.emit("error", new Error("Invalid mqtt version for auth packet"));
                  const m = S(N, Q, U, J);
                  return m ? (J += m.length, N.write(a.from([r.codes.auth << 4])), R(N, J), N.write(a.from([Z])), m !== null && m.write(), !0) : !1;
                }(z, M, D);
              default:
                return M.emit("error", new Error("Unknown command")), !1;
            }
          }
          function k(z) {
            z.uncork();
          }
          Object.defineProperty(p, "cacheNumbers", { get: () => b === H, set(z) {
            z ? (u && Object.keys(u).length !== 0 || (x = !0), b = H) : (x = !1, b = $);
          } });
          const C = {};
          function R(z, M) {
            if (M > r.VARBYTEINT_MAX) return z.emit("error", new Error(`Invalid variable byte integer: ${M}`)), !1;
            let D = C[M];
            return D || (D = y(M), M < 16384 && (C[M] = D)), d("writeVarByteInt: writing to stream: %o", D), z.write(D);
          }
          function P(z, M) {
            const D = a.byteLength(M);
            return b(z, D), d("writeString: %s", M), z.write(M, "utf8");
          }
          function E(z, M, D) {
            P(z, M), P(z, D);
          }
          function H(z, M) {
            return d("writeNumberCached: number: %d", M), d("writeNumberCached: %o", u[M]), z.write(u[M]);
          }
          function $(z, M) {
            const D = f(M);
            return d("writeNumberGenerated: %o", D), z.write(D);
          }
          function A(z, M) {
            typeof M == "string" ? P(z, M) : M ? (b(z, M.length), z.write(M)) : b(z, 0);
          }
          function I(z, M) {
            if (typeof M != "object" || M.length != null) return { length: 1, write() {
              B(z, {}, 0);
            } };
            let D = 0;
            function W(N, U) {
              let q = 0;
              switch (r.propertiesTypes[N]) {
                case "byte":
                  if (typeof U != "boolean") return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 2;
                  break;
                case "int8":
                  if (typeof U != "number" || U < 0 || U > 255) return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 2;
                  break;
                case "binary":
                  if (U && U === null) return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 1 + a.byteLength(U) + 2;
                  break;
                case "int16":
                  if (typeof U != "number" || U < 0 || U > 65535) return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 3;
                  break;
                case "int32":
                  if (typeof U != "number" || U < 0 || U > 4294967295) return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 5;
                  break;
                case "var":
                  if (typeof U != "number" || U < 0 || U > 268435455) return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 1 + a.byteLength(y(U));
                  break;
                case "string":
                  if (typeof U != "string") return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += 3 + a.byteLength(U.toString());
                  break;
                case "pair":
                  if (typeof U != "object") return z.emit("error", new Error(`Invalid ${N}: ${U}`)), !1;
                  q += Object.getOwnPropertyNames(U).reduce((Y, Z) => {
                    const Q = U[Z];
                    return Array.isArray(Q) ? Y += Q.reduce((J, m) => J += 3 + a.byteLength(Z.toString()) + 2 + a.byteLength(m.toString()), 0) : Y += 3 + a.byteLength(Z.toString()) + 2 + a.byteLength(U[Z].toString()), Y;
                  }, 0);
                  break;
                default:
                  return z.emit("error", new Error(`Invalid property ${N}: ${U}`)), !1;
              }
              return q;
            }
            if (M) for (const N in M) {
              let U = 0, q = 0;
              const Y = M[N];
              if (Array.isArray(Y)) for (let Z = 0; Z < Y.length; Z++) {
                if (!(q = W(N, Y[Z]))) return !1;
                U += q;
              }
              else {
                if (!(q = W(N, Y))) return !1;
                U = q;
              }
              if (!U) return !1;
              D += U;
            }
            return { length: a.byteLength(y(D)) + D, write() {
              B(z, M, D);
            } };
          }
          function S(z, M, D, W) {
            const N = ["reasonString", "userProperties"], U = D && D.properties && D.properties.maximumPacketSize ? D.properties.maximumPacketSize : 0;
            let q = I(z, M);
            if (U) for (; W + q.length > U; ) {
              const Y = N.shift();
              if (!Y || !M[Y]) return !1;
              delete M[Y], q = I(z, M);
            }
            return q;
          }
          function _(z, M, D) {
            switch (r.propertiesTypes[M]) {
              case "byte":
                z.write(a.from([r.properties[M]])), z.write(a.from([+D]));
                break;
              case "int8":
                z.write(a.from([r.properties[M]])), z.write(a.from([D]));
                break;
              case "binary":
                z.write(a.from([r.properties[M]])), A(z, D);
                break;
              case "int16":
                z.write(a.from([r.properties[M]])), b(z, D);
                break;
              case "int32":
                z.write(a.from([r.properties[M]])), function(W, N) {
                  const U = v(N);
                  d("write4ByteNumber: %o", U), W.write(U);
                }(z, D);
                break;
              case "var":
                z.write(a.from([r.properties[M]])), R(z, D);
                break;
              case "string":
                z.write(a.from([r.properties[M]])), P(z, D);
                break;
              case "pair":
                Object.getOwnPropertyNames(D).forEach((W) => {
                  const N = D[W];
                  Array.isArray(N) ? N.forEach((U) => {
                    z.write(a.from([r.properties[M]])), E(z, W.toString(), U.toString());
                  }) : (z.write(a.from([r.properties[M]])), E(z, W.toString(), N.toString()));
                });
                break;
              default:
                return z.emit("error", new Error(`Invalid property ${M} value: ${D}`)), !1;
            }
          }
          function B(z, M, D) {
            R(z, D);
            for (const W in M) if (Object.prototype.hasOwnProperty.call(M, W) && M[W] !== null) {
              const N = M[W];
              if (Array.isArray(N)) for (let U = 0; U < N.length; U++) _(z, W, N[U]);
              else _(z, W, N);
            }
          }
          function j(z) {
            return z ? z instanceof a ? z.length : a.byteLength(z) : 0;
          }
          function X(z) {
            return typeof z == "string" || z instanceof a;
          }
          s.exports = p;
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { "./constants": 38, "./numbers": 41, buffer: 17, debug: 18, "process-nextick-args": 49 }], 45: [function(i, s, o) {
      var a = 1e3, r = 60 * a, l = 60 * r, n = 24 * l, h = 7 * n, c = 365.25 * n;
      function d(u, f, g, y) {
        var v = f >= 1.5 * g;
        return Math.round(u / g) + " " + y + (v ? "s" : "");
      }
      s.exports = function(u, f) {
        f = f || {};
        var g = typeof u;
        if (g === "string" && u.length > 0) return function(y) {
          if (!((y = String(y)).length > 100)) {
            var v = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(y);
            if (v) {
              var b = parseFloat(v[1]);
              switch ((v[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return b * c;
                case "weeks":
                case "week":
                case "w":
                  return b * h;
                case "days":
                case "day":
                case "d":
                  return b * n;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return b * l;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return b * r;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return b * a;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return b;
                default:
                  return;
              }
            }
          }
        }(u);
        if (g === "number" && isFinite(u)) return f.long ? function(y) {
          var v = Math.abs(y);
          return v >= n ? d(y, v, n, "day") : v >= l ? d(y, v, l, "hour") : v >= r ? d(y, v, r, "minute") : v >= a ? d(y, v, a, "second") : y + " ms";
        }(u) : function(y) {
          var v = Math.abs(y);
          return v >= n ? Math.round(y / n) + "d" : v >= l ? Math.round(y / l) + "h" : v >= r ? Math.round(y / r) + "m" : v >= a ? Math.round(y / a) + "s" : y + "ms";
        }(u);
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(u));
      };
    }, {}], 46: [function(i, s, o) {
      const a = i("./lib/number-allocator.js");
      s.exports.NumberAllocator = a;
    }, { "./lib/number-allocator.js": 47 }], 47: [function(i, s, o) {
      const a = i("js-sdsl").Set, r = i("debug")("number-allocator:trace"), l = i("debug")("number-allocator:error");
      function n(c, d) {
        this.low = c, this.high = d;
      }
      function h(c, d) {
        if (!(this instanceof h)) return new h(c, d);
        this.min = c, this.max = d, this.ss = new a([], (u, f) => u.compare(f)), r("Create"), this.clear();
      }
      n.prototype.equals = function(c) {
        return this.low === c.low && this.high === c.high;
      }, n.prototype.compare = function(c) {
        return this.low < c.low && this.high < c.low ? -1 : c.low < this.low && c.high < this.low ? 1 : 0;
      }, h.prototype.firstVacant = function() {
        return this.ss.size() === 0 ? null : this.ss.front().low;
      }, h.prototype.alloc = function() {
        if (this.ss.size() === 0) return r("alloc():empty"), null;
        const c = this.ss.front(), d = c.low;
        return d + 1 <= c.high ? ++c.low : this.ss.eraseElementByPos(0), r("alloc():" + d), d;
      }, h.prototype.use = function(c) {
        const d = new n(c, c), u = this.ss.lowerBound(d);
        if (u) {
          if (u.equals(d)) return this.ss.eraseElementByValue(u), r("use():" + c), !0;
          if (u.low > c) return !1;
          if (u.low === c) return ++u.low, r("use():" + c), !0;
          if (u.high === c) return --u.high, r("use():" + c), !0;
          const f = u.low;
          return u.low = c + 1, this.ss.insert(new n(f, c - 1)), r("use():" + c), !0;
        }
        return r("use():failed"), !1;
      }, h.prototype.free = function(c) {
        if (c < this.min || c > this.max) return void l("free():" + c + " is out of range");
        const d = new n(c, c), u = this.ss.lowerBound(d);
        if (u) {
          if (u.low <= c && c <= u.high) return void l("free():" + c + " has already been vacant");
          if (u === this.ss.front()) c + 1 === u.low ? --u.low : this.ss.insert(d);
          else {
            const f = this.ss.reverseLowerBound(d);
            f.high + 1 === c ? c + 1 === u.low ? (this.ss.eraseElementByValue(f), u.low = f.low) : f.high = c : c + 1 === u.low ? u.low = c : this.ss.insert(d);
          }
        } else {
          if (u === this.ss.front()) return void this.ss.insert(d);
          const f = this.ss.reverseLowerBound(d);
          f.high + 1 === c ? f.high = c : this.ss.insert(d);
        }
        r("free():" + c);
      }, h.prototype.clear = function() {
        r("clear()"), this.ss.clear(), this.ss.insert(new n(this.min, this.max));
      }, h.prototype.intervalCount = function() {
        return this.ss.size();
      }, h.prototype.dump = function() {
        console.log("length:" + this.ss.size());
        for (const c of this.ss) console.log(c);
      }, s.exports = h;
    }, { debug: 18, "js-sdsl": 36 }], 48: [function(i, s, o) {
      var a = i("wrappy");
      function r(n) {
        var h = function() {
          return h.called ? h.value : (h.called = !0, h.value = n.apply(this, arguments));
        };
        return h.called = !1, h;
      }
      function l(n) {
        var h = function() {
          if (h.called) throw new Error(h.onceError);
          return h.called = !0, h.value = n.apply(this, arguments);
        }, c = n.name || "Function wrapped with `once`";
        return h.onceError = c + " shouldn't be called more than once", h.called = !1, h;
      }
      s.exports = a(r), s.exports.strict = a(l), r.proto = r(function() {
        Object.defineProperty(Function.prototype, "once", { value: function() {
          return r(this);
        }, configurable: !0 }), Object.defineProperty(Function.prototype, "onceStrict", { value: function() {
          return l(this);
        }, configurable: !0 });
      });
    }, { wrappy: 79 }], 49: [function(i, s, o) {
      (function(a) {
        (function() {
          a === void 0 || !a.version || a.version.indexOf("v0.") === 0 || a.version.indexOf("v1.") === 0 && a.version.indexOf("v1.8.") !== 0 ? s.exports = { nextTick: function(r, l, n, h) {
            if (typeof r != "function") throw new TypeError('"callback" argument must be a function');
            var c, d, u = arguments.length;
            switch (u) {
              case 0:
              case 1:
                return a.nextTick(r);
              case 2:
                return a.nextTick(function() {
                  r.call(null, l);
                });
              case 3:
                return a.nextTick(function() {
                  r.call(null, l, n);
                });
              case 4:
                return a.nextTick(function() {
                  r.call(null, l, n, h);
                });
              default:
                for (c = new Array(u - 1), d = 0; d < c.length; ) c[d++] = arguments[d];
                return a.nextTick(function() {
                  r.apply(null, c);
                });
            }
          } } : s.exports = a;
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50 }], 50: [function(i, s, o) {
      var a, r, l = s.exports = {};
      function n() {
        throw new Error("setTimeout has not been defined");
      }
      function h() {
        throw new Error("clearTimeout has not been defined");
      }
      function c(p) {
        if (a === setTimeout) return setTimeout(p, 0);
        if ((a === n || !a) && setTimeout) return a = setTimeout, setTimeout(p, 0);
        try {
          return a(p, 0);
        } catch {
          try {
            return a.call(null, p, 0);
          } catch {
            return a.call(this, p, 0);
          }
        }
      }
      (function() {
        try {
          a = typeof setTimeout == "function" ? setTimeout : n;
        } catch {
          a = n;
        }
        try {
          r = typeof clearTimeout == "function" ? clearTimeout : h;
        } catch {
          r = h;
        }
      })();
      var d, u = [], f = !1, g = -1;
      function y() {
        f && d && (f = !1, d.length ? u = d.concat(u) : g = -1, u.length && v());
      }
      function v() {
        if (!f) {
          var p = c(y);
          f = !0;
          for (var k = u.length; k; ) {
            for (d = u, u = []; ++g < k; ) d && d[g].run();
            g = -1, k = u.length;
          }
          d = null, f = !1, function(C) {
            if (r === clearTimeout) return clearTimeout(C);
            if ((r === h || !r) && clearTimeout) return r = clearTimeout, clearTimeout(C);
            try {
              r(C);
            } catch {
              try {
                return r.call(null, C);
              } catch {
                return r.call(this, C);
              }
            }
          }(p);
        }
      }
      function b(p, k) {
        this.fun = p, this.array = k;
      }
      function x() {
      }
      l.nextTick = function(p) {
        var k = new Array(arguments.length - 1);
        if (arguments.length > 1) for (var C = 1; C < arguments.length; C++) k[C - 1] = arguments[C];
        u.push(new b(p, k)), u.length !== 1 || f || c(v);
      }, b.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.version = "", l.versions = {}, l.on = x, l.addListener = x, l.once = x, l.off = x, l.removeListener = x, l.removeAllListeners = x, l.emit = x, l.prependListener = x, l.prependOnceListener = x, l.listeners = function(p) {
        return [];
      }, l.binding = function(p) {
        throw new Error("process.binding is not supported");
      }, l.cwd = function() {
        return "/";
      }, l.chdir = function(p) {
        throw new Error("process.chdir is not supported");
      }, l.umask = function() {
        return 0;
      };
    }, {}], 51: [function(i, s, o) {
      (function(a) {
        (function() {
          (function(r) {
            var l = typeof o == "object" && o && !o.nodeType && o, n = typeof s == "object" && s && !s.nodeType && s, h = typeof a == "object" && a;
            h.global !== h && h.window !== h && h.self !== h || (r = h);
            var c, d, u = 2147483647, f = 36, g = 1, y = 26, v = 38, b = 700, x = 72, p = 128, k = "-", C = /^xn--/, R = /[^\x20-\x7E]/, P = /[\x2E\u3002\uFF0E\uFF61]/g, E = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" }, H = f - g, $ = Math.floor, A = String.fromCharCode;
            function I(W) {
              throw new RangeError(E[W]);
            }
            function S(W, N) {
              for (var U = W.length, q = []; U--; ) q[U] = N(W[U]);
              return q;
            }
            function _(W, N) {
              var U = W.split("@"), q = "";
              return U.length > 1 && (q = U[0] + "@", W = U[1]), q + S((W = W.replace(P, ".")).split("."), N).join(".");
            }
            function B(W) {
              for (var N, U, q = [], Y = 0, Z = W.length; Y < Z; ) (N = W.charCodeAt(Y++)) >= 55296 && N <= 56319 && Y < Z ? (64512 & (U = W.charCodeAt(Y++))) == 56320 ? q.push(((1023 & N) << 10) + (1023 & U) + 65536) : (q.push(N), Y--) : q.push(N);
              return q;
            }
            function j(W) {
              return S(W, function(N) {
                var U = "";
                return N > 65535 && (U += A((N -= 65536) >>> 10 & 1023 | 55296), N = 56320 | 1023 & N), U += A(N);
              }).join("");
            }
            function X(W, N) {
              return W + 22 + 75 * (W < 26) - ((N != 0) << 5);
            }
            function z(W, N, U) {
              var q = 0;
              for (W = U ? $(W / b) : W >> 1, W += $(W / N); W > H * y >> 1; q += f) W = $(W / H);
              return $(q + (H + 1) * W / (W + v));
            }
            function M(W) {
              var N, U, q, Y, Z, Q, J, m, w, T, L, F = [], V = W.length, K = 0, et = p, tt = x;
              for ((U = W.lastIndexOf(k)) < 0 && (U = 0), q = 0; q < U; ++q) W.charCodeAt(q) >= 128 && I("not-basic"), F.push(W.charCodeAt(q));
              for (Y = U > 0 ? U + 1 : 0; Y < V; ) {
                for (Z = K, Q = 1, J = f; Y >= V && I("invalid-input"), ((m = (L = W.charCodeAt(Y++)) - 48 < 10 ? L - 22 : L - 65 < 26 ? L - 65 : L - 97 < 26 ? L - 97 : f) >= f || m > $((u - K) / Q)) && I("overflow"), K += m * Q, !(m < (w = J <= tt ? g : J >= tt + y ? y : J - tt)); J += f) Q > $(u / (T = f - w)) && I("overflow"), Q *= T;
                tt = z(K - Z, N = F.length + 1, Z == 0), $(K / N) > u - et && I("overflow"), et += $(K / N), K %= N, F.splice(K++, 0, et);
              }
              return j(F);
            }
            function D(W) {
              var N, U, q, Y, Z, Q, J, m, w, T, L, F, V, K, et, tt = [];
              for (F = (W = B(W)).length, N = p, U = 0, Z = x, Q = 0; Q < F; ++Q) (L = W[Q]) < 128 && tt.push(A(L));
              for (q = Y = tt.length, Y && tt.push(k); q < F; ) {
                for (J = u, Q = 0; Q < F; ++Q) (L = W[Q]) >= N && L < J && (J = L);
                for (J - N > $((u - U) / (V = q + 1)) && I("overflow"), U += (J - N) * V, N = J, Q = 0; Q < F; ++Q) if ((L = W[Q]) < N && ++U > u && I("overflow"), L == N) {
                  for (m = U, w = f; !(m < (T = w <= Z ? g : w >= Z + y ? y : w - Z)); w += f) et = m - T, K = f - T, tt.push(A(X(T + et % K, 0))), m = $(et / K);
                  tt.push(A(X(m, 0))), Z = z(U, V, q == Y), U = 0, ++q;
                }
                ++U, ++N;
              }
              return tt.join("");
            }
            if (c = { version: "1.4.1", ucs2: { decode: B, encode: j }, decode: M, encode: D, toASCII: function(W) {
              return _(W, function(N) {
                return R.test(N) ? "xn--" + D(N) : N;
              });
            }, toUnicode: function(W) {
              return _(W, function(N) {
                return C.test(N) ? M(N.slice(4).toLowerCase()) : N;
              });
            } }, l && n) if (s.exports == l) n.exports = c;
            else for (d in c) c.hasOwnProperty(d) && (l[d] = c[d]);
            else r.punycode = c;
          })(this);
        }).call(this);
      }).call(this, typeof Vt < "u" ? Vt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 52: [function(i, s, o) {
      function a(l, n) {
        return Object.prototype.hasOwnProperty.call(l, n);
      }
      s.exports = function(l, n, h, c) {
        n = n || "&", h = h || "=";
        var d = {};
        if (typeof l != "string" || l.length === 0) return d;
        var u = /\+/g;
        l = l.split(n);
        var f = 1e3;
        c && typeof c.maxKeys == "number" && (f = c.maxKeys);
        var g = l.length;
        f > 0 && g > f && (g = f);
        for (var y = 0; y < g; ++y) {
          var v, b, x, p, k = l[y].replace(u, "%20"), C = k.indexOf(h);
          C >= 0 ? (v = k.substr(0, C), b = k.substr(C + 1)) : (v = k, b = ""), x = decodeURIComponent(v), p = decodeURIComponent(b), a(d, x) ? r(d[x]) ? d[x].push(p) : d[x] = [d[x], p] : d[x] = p;
        }
        return d;
      };
      var r = Array.isArray || function(l) {
        return Object.prototype.toString.call(l) === "[object Array]";
      };
    }, {}], 53: [function(i, s, o) {
      var a = function(h) {
        switch (typeof h) {
          case "string":
            return h;
          case "boolean":
            return h ? "true" : "false";
          case "number":
            return isFinite(h) ? h : "";
          default:
            return "";
        }
      };
      s.exports = function(h, c, d, u) {
        return c = c || "&", d = d || "=", h === null && (h = void 0), typeof h == "object" ? l(n(h), function(f) {
          var g = encodeURIComponent(a(f)) + d;
          return r(h[f]) ? l(h[f], function(y) {
            return g + encodeURIComponent(a(y));
          }).join(c) : g + encodeURIComponent(a(h[f]));
        }).join(c) : u ? encodeURIComponent(a(u)) + d + encodeURIComponent(a(h)) : "";
      };
      var r = Array.isArray || function(h) {
        return Object.prototype.toString.call(h) === "[object Array]";
      };
      function l(h, c) {
        if (h.map) return h.map(c);
        for (var d = [], u = 0; u < h.length; u++) d.push(c(h[u], u));
        return d;
      }
      var n = Object.keys || function(h) {
        var c = [];
        for (var d in h) Object.prototype.hasOwnProperty.call(h, d) && c.push(d);
        return c;
      };
    }, {}], 54: [function(i, s, o) {
      o.decode = o.parse = i("./decode"), o.encode = o.stringify = i("./encode");
    }, { "./decode": 52, "./encode": 53 }], 55: [function(i, s, o) {
      var a = {};
      function r(n, h, c) {
        c || (c = Error);
        var d = function(u) {
          var f, g;
          function y(v, b, x) {
            return u.call(this, function(p, k, C) {
              return typeof h == "string" ? h : h(p, k, C);
            }(v, b, x)) || this;
          }
          return g = u, (f = y).prototype = Object.create(g.prototype), f.prototype.constructor = f, f.__proto__ = g, y;
        }(c);
        d.prototype.name = c.name, d.prototype.code = n, a[n] = d;
      }
      function l(n, h) {
        if (Array.isArray(n)) {
          var c = n.length;
          return n = n.map(function(d) {
            return String(d);
          }), c > 2 ? "one of ".concat(h, " ").concat(n.slice(0, c - 1).join(", "), ", or ") + n[c - 1] : c === 2 ? "one of ".concat(h, " ").concat(n[0], " or ").concat(n[1]) : "of ".concat(h, " ").concat(n[0]);
        }
        return "of ".concat(h, " ").concat(String(n));
      }
      r("ERR_INVALID_OPT_VALUE", function(n, h) {
        return 'The value "' + h + '" is invalid for option "' + n + '"';
      }, TypeError), r("ERR_INVALID_ARG_TYPE", function(n, h, c) {
        var d, u, f;
        if (typeof h == "string" && (u = "not ", h.substr(0, u.length) === u) ? (d = "must not be", h = h.replace(/^not /, "")) : d = "must be", function(y, v, b) {
          return (b === void 0 || b > y.length) && (b = y.length), y.substring(b - v.length, b) === v;
        }(n, " argument")) f = "The ".concat(n, " ").concat(d, " ").concat(l(h, "type"));
        else {
          var g = function(y, v, b) {
            return typeof b != "number" && (b = 0), !(b + v.length > y.length) && y.indexOf(v, b) !== -1;
          }(n, ".") ? "property" : "argument";
          f = 'The "'.concat(n, '" ').concat(g, " ").concat(d, " ").concat(l(h, "type"));
        }
        return f += ". Received type ".concat(typeof c);
      }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(n) {
        return "The " + n + " method is not implemented";
      }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(n) {
        return "Cannot call " + n + " after a stream was destroyed";
      }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(n) {
        return "Unknown encoding: " + n;
      }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), s.exports.codes = a;
    }, {}], 56: [function(i, s, o) {
      (function(a) {
        (function() {
          var r = Object.keys || function(y) {
            var v = [];
            for (var b in y) v.push(b);
            return v;
          };
          s.exports = u;
          var l = i("./_stream_readable"), n = i("./_stream_writable");
          i("inherits")(u, l);
          for (var h = r(n.prototype), c = 0; c < h.length; c++) {
            var d = h[c];
            u.prototype[d] || (u.prototype[d] = n.prototype[d]);
          }
          function u(y) {
            if (!(this instanceof u)) return new u(y);
            l.call(this, y), n.call(this, y), this.allowHalfOpen = !0, y && (y.readable === !1 && (this.readable = !1), y.writable === !1 && (this.writable = !1), y.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", f)));
          }
          function f() {
            this._writableState.ended || a.nextTick(g, this);
          }
          function g(y) {
            y.end();
          }
          Object.defineProperty(u.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), Object.defineProperty(u.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(u.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(u.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(y) {
            this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = y, this._writableState.destroyed = y);
          } });
        }).call(this);
      }).call(this, i("_process"));
    }, { "./_stream_readable": 58, "./_stream_writable": 60, _process: 50, inherits: 24 }], 57: [function(i, s, o) {
      s.exports = r;
      var a = i("./_stream_transform");
      function r(l) {
        if (!(this instanceof r)) return new r(l);
        a.call(this, l);
      }
      i("inherits")(r, a), r.prototype._transform = function(l, n, h) {
        h(null, l);
      };
    }, { "./_stream_transform": 59, inherits: 24 }], 58: [function(i, s, o) {
      (function(a, r) {
        (function() {
          var l;
          s.exports = I, I.ReadableState = A, i("events").EventEmitter;
          var n = function(m, w) {
            return m.listeners(w).length;
          }, h = i("./internal/streams/stream"), c = i("buffer").Buffer, d = r.Uint8Array || function() {
          }, u, f = i("util");
          u = f && f.debuglog ? f.debuglog("stream") : function() {
          };
          var g, y, v, b = i("./internal/streams/buffer_list"), x = i("./internal/streams/destroy"), p = i("./internal/streams/state").getHighWaterMark, k = i("../errors").codes, C = k.ERR_INVALID_ARG_TYPE, R = k.ERR_STREAM_PUSH_AFTER_EOF, P = k.ERR_METHOD_NOT_IMPLEMENTED, E = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          i("inherits")(I, h);
          var H = x.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
          function A(m, w, T) {
            l = l || i("./_stream_duplex"), m = m || {}, typeof T != "boolean" && (T = w instanceof l), this.objectMode = !!m.objectMode, T && (this.objectMode = this.objectMode || !!m.readableObjectMode), this.highWaterMark = p(this, m, "readableHighWaterMark", T), this.buffer = new b(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = m.emitClose !== !1, this.autoDestroy = !!m.autoDestroy, this.destroyed = !1, this.defaultEncoding = m.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, m.encoding && (g || (g = i("string_decoder/").StringDecoder), this.decoder = new g(m.encoding), this.encoding = m.encoding);
          }
          function I(m) {
            if (l = l || i("./_stream_duplex"), !(this instanceof I)) return new I(m);
            var w = this instanceof l;
            this._readableState = new A(m, this, w), this.readable = !0, m && (typeof m.read == "function" && (this._read = m.read), typeof m.destroy == "function" && (this._destroy = m.destroy)), h.call(this);
          }
          function S(m, w, T, L, F) {
            u("readableAddChunk", w);
            var V, K = m._readableState;
            if (w === null) K.reading = !1, function(et, tt) {
              if (u("onEofChunk"), !tt.ended) {
                if (tt.decoder) {
                  var at = tt.decoder.end();
                  at && at.length && (tt.buffer.push(at), tt.length += tt.objectMode ? 1 : at.length);
                }
                tt.ended = !0, tt.sync ? X(et) : (tt.needReadable = !1, tt.emittedReadable || (tt.emittedReadable = !0, z(et)));
              }
            }(m, K);
            else if (F || (V = function(et, tt) {
              var at;
              lt = tt, c.isBuffer(lt) || lt instanceof d || typeof tt == "string" || tt === void 0 || et.objectMode || (at = new C("chunk", ["string", "Buffer", "Uint8Array"], tt));
              var lt;
              return at;
            }(K, w)), V) H(m, V);
            else if (K.objectMode || w && w.length > 0) if (typeof w == "string" || K.objectMode || Object.getPrototypeOf(w) === c.prototype || (w = function(et) {
              return c.from(et);
            }(w)), L) K.endEmitted ? H(m, new E()) : _(m, K, w, !0);
            else if (K.ended) H(m, new R());
            else {
              if (K.destroyed) return !1;
              K.reading = !1, K.decoder && !T ? (w = K.decoder.write(w), K.objectMode || w.length !== 0 ? _(m, K, w, !1) : M(m, K)) : _(m, K, w, !1);
            }
            else L || (K.reading = !1, M(m, K));
            return !K.ended && (K.length < K.highWaterMark || K.length === 0);
          }
          function _(m, w, T, L) {
            w.flowing && w.length === 0 && !w.sync ? (w.awaitDrain = 0, m.emit("data", T)) : (w.length += w.objectMode ? 1 : T.length, L ? w.buffer.unshift(T) : w.buffer.push(T), w.needReadable && X(m)), M(m, w);
          }
          Object.defineProperty(I.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._readableState.destroyed;
          }, set: function(m) {
            this._readableState && (this._readableState.destroyed = m);
          } }), I.prototype.destroy = x.destroy, I.prototype._undestroy = x.undestroy, I.prototype._destroy = function(m, w) {
            w(m);
          }, I.prototype.push = function(m, w) {
            var T, L = this._readableState;
            return L.objectMode ? T = !0 : typeof m == "string" && ((w = w || L.defaultEncoding) !== L.encoding && (m = c.from(m, w), w = ""), T = !0), S(this, m, w, !1, T);
          }, I.prototype.unshift = function(m) {
            return S(this, m, null, !0, !1);
          }, I.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, I.prototype.setEncoding = function(m) {
            g || (g = i("string_decoder/").StringDecoder);
            var w = new g(m);
            this._readableState.decoder = w, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var T = this._readableState.buffer.head, L = ""; T !== null; ) L += w.write(T.data), T = T.next;
            return this._readableState.buffer.clear(), L !== "" && this._readableState.buffer.push(L), this._readableState.length = L.length, this;
          };
          var B = 1073741824;
          function j(m, w) {
            return m <= 0 || w.length === 0 && w.ended ? 0 : w.objectMode ? 1 : m != m ? w.flowing && w.length ? w.buffer.head.data.length : w.length : (m > w.highWaterMark && (w.highWaterMark = function(T) {
              return T >= B ? T = B : (T--, T |= T >>> 1, T |= T >>> 2, T |= T >>> 4, T |= T >>> 8, T |= T >>> 16, T++), T;
            }(m)), m <= w.length ? m : w.ended ? w.length : (w.needReadable = !0, 0));
          }
          function X(m) {
            var w = m._readableState;
            u("emitReadable", w.needReadable, w.emittedReadable), w.needReadable = !1, w.emittedReadable || (u("emitReadable", w.flowing), w.emittedReadable = !0, a.nextTick(z, m));
          }
          function z(m) {
            var w = m._readableState;
            u("emitReadable_", w.destroyed, w.length, w.ended), w.destroyed || !w.length && !w.ended || (m.emit("readable"), w.emittedReadable = !1), w.needReadable = !w.flowing && !w.ended && w.length <= w.highWaterMark, q(m);
          }
          function M(m, w) {
            w.readingMore || (w.readingMore = !0, a.nextTick(D, m, w));
          }
          function D(m, w) {
            for (; !w.reading && !w.ended && (w.length < w.highWaterMark || w.flowing && w.length === 0); ) {
              var T = w.length;
              if (u("maybeReadMore read 0"), m.read(0), T === w.length) break;
            }
            w.readingMore = !1;
          }
          function W(m) {
            var w = m._readableState;
            w.readableListening = m.listenerCount("readable") > 0, w.resumeScheduled && !w.paused ? w.flowing = !0 : m.listenerCount("data") > 0 && m.resume();
          }
          function N(m) {
            u("readable nexttick read 0"), m.read(0);
          }
          function U(m, w) {
            u("resume", w.reading), w.reading || m.read(0), w.resumeScheduled = !1, m.emit("resume"), q(m), w.flowing && !w.reading && m.read(0);
          }
          function q(m) {
            var w = m._readableState;
            for (u("flow", w.flowing); w.flowing && m.read() !== null; ) ;
          }
          function Y(m, w) {
            return w.length === 0 ? null : (w.objectMode ? T = w.buffer.shift() : !m || m >= w.length ? (T = w.decoder ? w.buffer.join("") : w.buffer.length === 1 ? w.buffer.first() : w.buffer.concat(w.length), w.buffer.clear()) : T = w.buffer.consume(m, w.decoder), T);
            var T;
          }
          function Z(m) {
            var w = m._readableState;
            u("endReadable", w.endEmitted), w.endEmitted || (w.ended = !0, a.nextTick(Q, w, m));
          }
          function Q(m, w) {
            if (u("endReadableNT", m.endEmitted, m.length), !m.endEmitted && m.length === 0 && (m.endEmitted = !0, w.readable = !1, w.emit("end"), m.autoDestroy)) {
              var T = w._writableState;
              (!T || T.autoDestroy && T.finished) && w.destroy();
            }
          }
          function J(m, w) {
            for (var T = 0, L = m.length; T < L; T++) if (m[T] === w) return T;
            return -1;
          }
          I.prototype.read = function(m) {
            u("read", m), m = parseInt(m, 10);
            var w = this._readableState, T = m;
            if (m !== 0 && (w.emittedReadable = !1), m === 0 && w.needReadable && ((w.highWaterMark !== 0 ? w.length >= w.highWaterMark : w.length > 0) || w.ended)) return u("read: emitReadable", w.length, w.ended), w.length === 0 && w.ended ? Z(this) : X(this), null;
            if ((m = j(m, w)) === 0 && w.ended) return w.length === 0 && Z(this), null;
            var L, F = w.needReadable;
            return u("need readable", F), (w.length === 0 || w.length - m < w.highWaterMark) && u("length less than watermark", F = !0), w.ended || w.reading ? u("reading or ended", F = !1) : F && (u("do read"), w.reading = !0, w.sync = !0, w.length === 0 && (w.needReadable = !0), this._read(w.highWaterMark), w.sync = !1, w.reading || (m = j(T, w))), (L = m > 0 ? Y(m, w) : null) === null ? (w.needReadable = w.length <= w.highWaterMark, m = 0) : (w.length -= m, w.awaitDrain = 0), w.length === 0 && (w.ended || (w.needReadable = !0), T !== m && w.ended && Z(this)), L !== null && this.emit("data", L), L;
          }, I.prototype._read = function(m) {
            H(this, new P("_read()"));
          }, I.prototype.pipe = function(m, w) {
            var T = this, L = this._readableState;
            switch (L.pipesCount) {
              case 0:
                L.pipes = m;
                break;
              case 1:
                L.pipes = [L.pipes, m];
                break;
              default:
                L.pipes.push(m);
            }
            L.pipesCount += 1, u("pipe count=%d opts=%j", L.pipesCount, w);
            var F = (!w || w.end !== !1) && m !== a.stdout && m !== a.stderr ? K : Wt;
            function V(mt, bt) {
              u("onunpipe"), mt === T && bt && bt.hasUnpiped === !1 && (bt.hasUnpiped = !0, u("cleanup"), m.removeListener("close", Ft), m.removeListener("finish", Bt), m.removeListener("drain", et), m.removeListener("error", lt), m.removeListener("unpipe", V), T.removeListener("end", K), T.removeListener("end", Wt), T.removeListener("data", at), tt = !0, !L.awaitDrain || m._writableState && !m._writableState.needDrain || et());
            }
            function K() {
              u("onend"), m.end();
            }
            L.endEmitted ? a.nextTick(F) : T.once("end", F), m.on("unpipe", V);
            var et = /* @__PURE__ */ function(mt) {
              return function() {
                var bt = mt._readableState;
                u("pipeOnDrain", bt.awaitDrain), bt.awaitDrain && bt.awaitDrain--, bt.awaitDrain === 0 && n(mt, "data") && (bt.flowing = !0, q(mt));
              };
            }(T);
            m.on("drain", et);
            var tt = !1;
            function at(mt) {
              u("ondata");
              var bt = m.write(mt);
              u("dest.write", bt), bt === !1 && ((L.pipesCount === 1 && L.pipes === m || L.pipesCount > 1 && J(L.pipes, m) !== -1) && !tt && (u("false write response, pause", L.awaitDrain), L.awaitDrain++), T.pause());
            }
            function lt(mt) {
              u("onerror", mt), Wt(), m.removeListener("error", lt), n(m, "error") === 0 && H(m, mt);
            }
            function Ft() {
              m.removeListener("finish", Bt), Wt();
            }
            function Bt() {
              u("onfinish"), m.removeListener("close", Ft), Wt();
            }
            function Wt() {
              u("unpipe"), T.unpipe(m);
            }
            return T.on("data", at), function(mt, bt, si) {
              if (typeof mt.prependListener == "function") return mt.prependListener(bt, si);
              mt._events && mt._events[bt] ? Array.isArray(mt._events[bt]) ? mt._events[bt].unshift(si) : mt._events[bt] = [si, mt._events[bt]] : mt.on(bt, si);
            }(m, "error", lt), m.once("close", Ft), m.once("finish", Bt), m.emit("pipe", T), L.flowing || (u("pipe resume"), T.resume()), m;
          }, I.prototype.unpipe = function(m) {
            var w = this._readableState, T = { hasUnpiped: !1 };
            if (w.pipesCount === 0) return this;
            if (w.pipesCount === 1) return m && m !== w.pipes ? this : (m || (m = w.pipes), w.pipes = null, w.pipesCount = 0, w.flowing = !1, m && m.emit("unpipe", this, T), this);
            if (!m) {
              var L = w.pipes, F = w.pipesCount;
              w.pipes = null, w.pipesCount = 0, w.flowing = !1;
              for (var V = 0; V < F; V++) L[V].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var K = J(w.pipes, m);
            return K === -1 ? this : (w.pipes.splice(K, 1), w.pipesCount -= 1, w.pipesCount === 1 && (w.pipes = w.pipes[0]), m.emit("unpipe", this, T), this);
          }, I.prototype.on = function(m, w) {
            var T = h.prototype.on.call(this, m, w), L = this._readableState;
            return m === "data" ? (L.readableListening = this.listenerCount("readable") > 0, L.flowing !== !1 && this.resume()) : m === "readable" && (L.endEmitted || L.readableListening || (L.readableListening = L.needReadable = !0, L.flowing = !1, L.emittedReadable = !1, u("on readable", L.length, L.reading), L.length ? X(this) : L.reading || a.nextTick(N, this))), T;
          }, I.prototype.addListener = I.prototype.on, I.prototype.removeListener = function(m, w) {
            var T = h.prototype.removeListener.call(this, m, w);
            return m === "readable" && a.nextTick(W, this), T;
          }, I.prototype.removeAllListeners = function(m) {
            var w = h.prototype.removeAllListeners.apply(this, arguments);
            return m !== "readable" && m !== void 0 || a.nextTick(W, this), w;
          }, I.prototype.resume = function() {
            var m = this._readableState;
            return m.flowing || (u("resume"), m.flowing = !m.readableListening, function(w, T) {
              T.resumeScheduled || (T.resumeScheduled = !0, a.nextTick(U, w, T));
            }(this, m)), m.paused = !1, this;
          }, I.prototype.pause = function() {
            return u("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (u("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, I.prototype.wrap = function(m) {
            var w = this, T = this._readableState, L = !1;
            for (var F in m.on("end", function() {
              if (u("wrapped end"), T.decoder && !T.ended) {
                var K = T.decoder.end();
                K && K.length && w.push(K);
              }
              w.push(null);
            }), m.on("data", function(K) {
              u("wrapped data"), T.decoder && (K = T.decoder.write(K)), (!T.objectMode || K != null) && (T.objectMode || K && K.length) && (w.push(K) || (L = !0, m.pause()));
            }), m) this[F] === void 0 && typeof m[F] == "function" && (this[F] = /* @__PURE__ */ function(K) {
              return function() {
                return m[K].apply(m, arguments);
              };
            }(F));
            for (var V = 0; V < $.length; V++) m.on($[V], this.emit.bind(this, $[V]));
            return this._read = function(K) {
              u("wrapped _read", K), L && (L = !1, m.resume());
            }, this;
          }, typeof Symbol == "function" && (I.prototype[Symbol.asyncIterator] = function() {
            return y === void 0 && (y = i("./internal/streams/async_iterator")), y(this);
          }), Object.defineProperty(I.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
            return this._readableState.highWaterMark;
          } }), Object.defineProperty(I.prototype, "readableBuffer", { enumerable: !1, get: function() {
            return this._readableState && this._readableState.buffer;
          } }), Object.defineProperty(I.prototype, "readableFlowing", { enumerable: !1, get: function() {
            return this._readableState.flowing;
          }, set: function(m) {
            this._readableState && (this._readableState.flowing = m);
          } }), I._fromList = Y, Object.defineProperty(I.prototype, "readableLength", { enumerable: !1, get: function() {
            return this._readableState.length;
          } }), typeof Symbol == "function" && (I.from = function(m, w) {
            return v === void 0 && (v = i("./internal/streams/from")), v(I, m, w);
          });
        }).call(this);
      }).call(this, i("_process"), typeof Vt < "u" ? Vt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/async_iterator": 61, "./internal/streams/buffer_list": 62, "./internal/streams/destroy": 63, "./internal/streams/from": 65, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, events: 22, inherits: 24, "string_decoder/": 75, util: 16 }], 59: [function(i, s, o) {
      s.exports = d;
      var a = i("../errors").codes, r = a.ERR_METHOD_NOT_IMPLEMENTED, l = a.ERR_MULTIPLE_CALLBACK, n = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, h = a.ERR_TRANSFORM_WITH_LENGTH_0, c = i("./_stream_duplex");
      function d(g) {
        if (!(this instanceof d)) return new d(g);
        c.call(this, g), this._transformState = { afterTransform: (function(y, v) {
          var b = this._transformState;
          b.transforming = !1;
          var x = b.writecb;
          if (x === null) return this.emit("error", new l());
          b.writechunk = null, b.writecb = null, v != null && this.push(v), x(y);
          var p = this._readableState;
          p.reading = !1, (p.needReadable || p.length < p.highWaterMark) && this._read(p.highWaterMark);
        }).bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, g && (typeof g.transform == "function" && (this._transform = g.transform), typeof g.flush == "function" && (this._flush = g.flush)), this.on("prefinish", u);
      }
      function u() {
        var g = this;
        typeof this._flush != "function" || this._readableState.destroyed ? f(this, null, null) : this._flush(function(y, v) {
          f(g, y, v);
        });
      }
      function f(g, y, v) {
        if (y) return g.emit("error", y);
        if (v != null && g.push(v), g._writableState.length) throw new h();
        if (g._transformState.transforming) throw new n();
        return g.push(null);
      }
      i("inherits")(d, c), d.prototype.push = function(g, y) {
        return this._transformState.needTransform = !1, c.prototype.push.call(this, g, y);
      }, d.prototype._transform = function(g, y, v) {
        v(new r("_transform()"));
      }, d.prototype._write = function(g, y, v) {
        var b = this._transformState;
        if (b.writecb = v, b.writechunk = g, b.writeencoding = y, !b.transforming) {
          var x = this._readableState;
          (b.needTransform || x.needReadable || x.length < x.highWaterMark) && this._read(x.highWaterMark);
        }
      }, d.prototype._read = function(g) {
        var y = this._transformState;
        y.writechunk === null || y.transforming ? y.needTransform = !0 : (y.transforming = !0, this._transform(y.writechunk, y.writeencoding, y.afterTransform));
      }, d.prototype._destroy = function(g, y) {
        c.prototype._destroy.call(this, g, function(v) {
          y(v);
        });
      };
    }, { "../errors": 55, "./_stream_duplex": 56, inherits: 24 }], 60: [function(i, s, o) {
      (function(a, r) {
        (function() {
          function l(M) {
            var D = this;
            this.next = null, this.entry = null, this.finish = function() {
              (function(W, N, U) {
                var q = W.entry;
                for (W.entry = null; q; ) {
                  var Y = q.callback;
                  N.pendingcb--, Y(U), q = q.next;
                }
                N.corkedRequestsFree.next = W;
              })(D, M);
            };
          }
          var n;
          s.exports = I, I.WritableState = A;
          var h = { deprecate: i("util-deprecate") }, c = i("./internal/streams/stream"), d = i("buffer").Buffer, u = r.Uint8Array || function() {
          }, f, g = i("./internal/streams/destroy"), y = i("./internal/streams/state").getHighWaterMark, v = i("../errors").codes, b = v.ERR_INVALID_ARG_TYPE, x = v.ERR_METHOD_NOT_IMPLEMENTED, p = v.ERR_MULTIPLE_CALLBACK, k = v.ERR_STREAM_CANNOT_PIPE, C = v.ERR_STREAM_DESTROYED, R = v.ERR_STREAM_NULL_VALUES, P = v.ERR_STREAM_WRITE_AFTER_END, E = v.ERR_UNKNOWN_ENCODING, H = g.errorOrDestroy;
          function $() {
          }
          function A(M, D, W) {
            n = n || i("./_stream_duplex"), M = M || {}, typeof W != "boolean" && (W = D instanceof n), this.objectMode = !!M.objectMode, W && (this.objectMode = this.objectMode || !!M.writableObjectMode), this.highWaterMark = y(this, M, "writableHighWaterMark", W), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var N = M.decodeStrings === !1;
            this.decodeStrings = !N, this.defaultEncoding = M.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(U) {
              (function(q, Y) {
                var Z = q._writableState, Q = Z.sync, J = Z.writecb;
                if (typeof J != "function") throw new p();
                if (function(w) {
                  w.writing = !1, w.writecb = null, w.length -= w.writelen, w.writelen = 0;
                }(Z), Y) (function(w, T, L, F, V) {
                  --T.pendingcb, L ? (a.nextTick(V, F), a.nextTick(z, w, T), w._writableState.errorEmitted = !0, H(w, F)) : (V(F), w._writableState.errorEmitted = !0, H(w, F), z(w, T));
                })(q, Z, Q, Y, J);
                else {
                  var m = j(Z) || q.destroyed;
                  m || Z.corked || Z.bufferProcessing || !Z.bufferedRequest || B(q, Z), Q ? a.nextTick(_, q, Z, m, J) : _(q, Z, m, J);
                }
              })(D, U);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = M.emitClose !== !1, this.autoDestroy = !!M.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new l(this);
          }
          function I(M) {
            var D = this instanceof (n = n || i("./_stream_duplex"));
            if (!D && !f.call(I, this)) return new I(M);
            this._writableState = new A(M, this, D), this.writable = !0, M && (typeof M.write == "function" && (this._write = M.write), typeof M.writev == "function" && (this._writev = M.writev), typeof M.destroy == "function" && (this._destroy = M.destroy), typeof M.final == "function" && (this._final = M.final)), c.call(this);
          }
          function S(M, D, W, N, U, q, Y) {
            D.writelen = N, D.writecb = Y, D.writing = !0, D.sync = !0, D.destroyed ? D.onwrite(new C("write")) : W ? M._writev(U, D.onwrite) : M._write(U, q, D.onwrite), D.sync = !1;
          }
          function _(M, D, W, N) {
            W || function(U, q) {
              q.length === 0 && q.needDrain && (q.needDrain = !1, U.emit("drain"));
            }(M, D), D.pendingcb--, N(), z(M, D);
          }
          function B(M, D) {
            D.bufferProcessing = !0;
            var W = D.bufferedRequest;
            if (M._writev && W && W.next) {
              var N = D.bufferedRequestCount, U = new Array(N), q = D.corkedRequestsFree;
              q.entry = W;
              for (var Y = 0, Z = !0; W; ) U[Y] = W, W.isBuf || (Z = !1), W = W.next, Y += 1;
              U.allBuffers = Z, S(M, D, !0, D.length, U, "", q.finish), D.pendingcb++, D.lastBufferedRequest = null, q.next ? (D.corkedRequestsFree = q.next, q.next = null) : D.corkedRequestsFree = new l(D), D.bufferedRequestCount = 0;
            } else {
              for (; W; ) {
                var Q = W.chunk, J = W.encoding, m = W.callback;
                if (S(M, D, !1, D.objectMode ? 1 : Q.length, Q, J, m), W = W.next, D.bufferedRequestCount--, D.writing) break;
              }
              W === null && (D.lastBufferedRequest = null);
            }
            D.bufferedRequest = W, D.bufferProcessing = !1;
          }
          function j(M) {
            return M.ending && M.length === 0 && M.bufferedRequest === null && !M.finished && !M.writing;
          }
          function X(M, D) {
            M._final(function(W) {
              D.pendingcb--, W && H(M, W), D.prefinished = !0, M.emit("prefinish"), z(M, D);
            });
          }
          function z(M, D) {
            var W = j(D);
            if (W && (function(U, q) {
              q.prefinished || q.finalCalled || (typeof U._final != "function" || q.destroyed ? (q.prefinished = !0, U.emit("prefinish")) : (q.pendingcb++, q.finalCalled = !0, a.nextTick(X, U, q)));
            }(M, D), D.pendingcb === 0 && (D.finished = !0, M.emit("finish"), D.autoDestroy))) {
              var N = M._readableState;
              (!N || N.autoDestroy && N.endEmitted) && M.destroy();
            }
            return W;
          }
          i("inherits")(I, c), A.prototype.getBuffer = function() {
            for (var M = this.bufferedRequest, D = []; M; ) D.push(M), M = M.next;
            return D;
          }, function() {
            try {
              Object.defineProperty(A.prototype, "buffer", { get: h.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch {
            }
          }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(I, Symbol.hasInstance, { value: function(M) {
            return !!f.call(this, M) || this === I && M && M._writableState instanceof A;
          } })) : f = function(M) {
            return M instanceof this;
          }, I.prototype.pipe = function() {
            H(this, new k());
          }, I.prototype.write = function(M, D, W) {
            var N, U = this._writableState, q = !1, Y = !U.objectMode && (N = M, d.isBuffer(N) || N instanceof u);
            return Y && !d.isBuffer(M) && (M = function(Z) {
              return d.from(Z);
            }(M)), typeof D == "function" && (W = D, D = null), Y ? D = "buffer" : D || (D = U.defaultEncoding), typeof W != "function" && (W = $), U.ending ? function(Z, Q) {
              var J = new P();
              H(Z, J), a.nextTick(Q, J);
            }(this, W) : (Y || function(Z, Q, J, m) {
              var w;
              return J === null ? w = new R() : typeof J == "string" || Q.objectMode || (w = new b("chunk", ["string", "Buffer"], J)), !w || (H(Z, w), a.nextTick(m, w), !1);
            }(this, U, M, W)) && (U.pendingcb++, q = function(Z, Q, J, m, w, T) {
              if (!J) {
                var L = function(et, tt, at) {
                  return et.objectMode || et.decodeStrings === !1 || typeof tt != "string" || (tt = d.from(tt, at)), tt;
                }(Q, m, w);
                m !== L && (J = !0, w = "buffer", m = L);
              }
              var F = Q.objectMode ? 1 : m.length;
              Q.length += F;
              var V = Q.length < Q.highWaterMark;
              if (V || (Q.needDrain = !0), Q.writing || Q.corked) {
                var K = Q.lastBufferedRequest;
                Q.lastBufferedRequest = { chunk: m, encoding: w, isBuf: J, callback: T, next: null }, K ? K.next = Q.lastBufferedRequest : Q.bufferedRequest = Q.lastBufferedRequest, Q.bufferedRequestCount += 1;
              } else S(Z, Q, !1, F, m, w, T);
              return V;
            }(this, U, Y, M, D, W)), q;
          }, I.prototype.cork = function() {
            this._writableState.corked++;
          }, I.prototype.uncork = function() {
            var M = this._writableState;
            M.corked && (M.corked--, M.writing || M.corked || M.bufferProcessing || !M.bufferedRequest || B(this, M));
          }, I.prototype.setDefaultEncoding = function(M) {
            if (typeof M == "string" && (M = M.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((M + "").toLowerCase()) > -1)) throw new E(M);
            return this._writableState.defaultEncoding = M, this;
          }, Object.defineProperty(I.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(I.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), I.prototype._write = function(M, D, W) {
            W(new x("_write()"));
          }, I.prototype._writev = null, I.prototype.end = function(M, D, W) {
            var N = this._writableState;
            return typeof M == "function" ? (W = M, M = null, D = null) : typeof D == "function" && (W = D, D = null), M != null && this.write(M, D), N.corked && (N.corked = 1, this.uncork()), N.ending || function(U, q, Y) {
              q.ending = !0, z(U, q), Y && (q.finished ? a.nextTick(Y) : U.once("finish", Y)), q.ended = !0, U.writable = !1;
            }(this, N, W), this;
          }, Object.defineProperty(I.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(I.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._writableState !== void 0 && this._writableState.destroyed;
          }, set: function(M) {
            this._writableState && (this._writableState.destroyed = M);
          } }), I.prototype.destroy = g.destroy, I.prototype._undestroy = g.undestroy, I.prototype._destroy = function(M, D) {
            D(M);
          };
        }).call(this);
      }).call(this, i("_process"), typeof Vt < "u" ? Vt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 55, "./_stream_duplex": 56, "./internal/streams/destroy": 63, "./internal/streams/state": 67, "./internal/streams/stream": 68, _process: 50, buffer: 17, inherits: 24, "util-deprecate": 78 }], 61: [function(i, s, o) {
      (function(a) {
        (function() {
          var r;
          function l(k, C, R) {
            return C in k ? Object.defineProperty(k, C, { value: R, enumerable: !0, configurable: !0, writable: !0 }) : k[C] = R, k;
          }
          var n = i("./end-of-stream"), h = Symbol("lastResolve"), c = Symbol("lastReject"), d = Symbol("error"), u = Symbol("ended"), f = Symbol("lastPromise"), g = Symbol("handlePromise"), y = Symbol("stream");
          function v(k, C) {
            return { value: k, done: C };
          }
          function b(k) {
            var C = k[h];
            if (C !== null) {
              var R = k[y].read();
              R !== null && (k[f] = null, k[h] = null, k[c] = null, C(v(R, !1)));
            }
          }
          var x = Object.getPrototypeOf(function() {
          }), p = Object.setPrototypeOf((l(r = { get stream() {
            return this[y];
          }, next: function() {
            var k = this, C = this[d];
            if (C !== null) return Promise.reject(C);
            if (this[u]) return Promise.resolve(v(void 0, !0));
            if (this[y].destroyed) return new Promise(function(H, $) {
              a.nextTick(function() {
                k[d] ? $(k[d]) : H(v(void 0, !0));
              });
            });
            var R, P = this[f];
            if (P) R = new Promise(/* @__PURE__ */ function(H, $) {
              return function(A, I) {
                H.then(function() {
                  $[u] ? A(v(void 0, !0)) : $[g](A, I);
                }, I);
              };
            }(P, this));
            else {
              var E = this[y].read();
              if (E !== null) return Promise.resolve(v(E, !1));
              R = new Promise(this[g]);
            }
            return this[f] = R, R;
          } }, Symbol.asyncIterator, function() {
            return this;
          }), l(r, "return", function() {
            var k = this;
            return new Promise(function(C, R) {
              k[y].destroy(null, function(P) {
                P ? R(P) : C(v(void 0, !0));
              });
            });
          }), r), x);
          s.exports = function(k) {
            var C, R = Object.create(p, (l(C = {}, y, { value: k, writable: !0 }), l(C, h, { value: null, writable: !0 }), l(C, c, { value: null, writable: !0 }), l(C, d, { value: null, writable: !0 }), l(C, u, { value: k._readableState.endEmitted, writable: !0 }), l(C, g, { value: function(P, E) {
              var H = R[y].read();
              H ? (R[f] = null, R[h] = null, R[c] = null, P(v(H, !1))) : (R[h] = P, R[c] = E);
            }, writable: !0 }), C));
            return R[f] = null, n(k, function(P) {
              if (P && P.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var E = R[c];
                return E !== null && (R[f] = null, R[h] = null, R[c] = null, E(P)), void (R[d] = P);
              }
              var H = R[h];
              H !== null && (R[f] = null, R[h] = null, R[c] = null, H(v(void 0, !0))), R[u] = !0;
            }), k.on("readable", (function(P) {
              a.nextTick(b, P);
            }).bind(null, R)), R;
          };
        }).call(this);
      }).call(this, i("_process"));
    }, { "./end-of-stream": 64, _process: 50 }], 62: [function(i, s, o) {
      function a(d, u) {
        var f = Object.keys(d);
        if (Object.getOwnPropertySymbols) {
          var g = Object.getOwnPropertySymbols(d);
          u && (g = g.filter(function(y) {
            return Object.getOwnPropertyDescriptor(d, y).enumerable;
          })), f.push.apply(f, g);
        }
        return f;
      }
      function r(d, u, f) {
        return u in d ? Object.defineProperty(d, u, { value: f, enumerable: !0, configurable: !0, writable: !0 }) : d[u] = f, d;
      }
      function l(d, u) {
        for (var f = 0; f < u.length; f++) {
          var g = u[f];
          g.enumerable = g.enumerable || !1, g.configurable = !0, "value" in g && (g.writable = !0), Object.defineProperty(d, g.key, g);
        }
      }
      var n = i("buffer").Buffer, h = i("util").inspect, c = h && h.custom || "inspect";
      s.exports = function() {
        function d() {
          (function(g, y) {
            if (!(g instanceof y)) throw new TypeError("Cannot call a class as a function");
          })(this, d), this.head = null, this.tail = null, this.length = 0;
        }
        var u, f;
        return u = d, (f = [{ key: "push", value: function(g) {
          var y = { data: g, next: null };
          this.length > 0 ? this.tail.next = y : this.head = y, this.tail = y, ++this.length;
        } }, { key: "unshift", value: function(g) {
          var y = { data: g, next: this.head };
          this.length === 0 && (this.tail = y), this.head = y, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var g = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, g;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(g) {
          if (this.length === 0) return "";
          for (var y = this.head, v = "" + y.data; y = y.next; ) v += g + y.data;
          return v;
        } }, { key: "concat", value: function(g) {
          if (this.length === 0) return n.alloc(0);
          for (var y, v, b, x = n.allocUnsafe(g >>> 0), p = this.head, k = 0; p; ) y = p.data, v = x, b = k, n.prototype.copy.call(y, v, b), k += p.data.length, p = p.next;
          return x;
        } }, { key: "consume", value: function(g, y) {
          var v;
          return g < this.head.data.length ? (v = this.head.data.slice(0, g), this.head.data = this.head.data.slice(g)) : v = g === this.head.data.length ? this.shift() : y ? this._getString(g) : this._getBuffer(g), v;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(g) {
          var y = this.head, v = 1, b = y.data;
          for (g -= b.length; y = y.next; ) {
            var x = y.data, p = g > x.length ? x.length : g;
            if (p === x.length ? b += x : b += x.slice(0, g), (g -= p) === 0) {
              p === x.length ? (++v, y.next ? this.head = y.next : this.head = this.tail = null) : (this.head = y, y.data = x.slice(p));
              break;
            }
            ++v;
          }
          return this.length -= v, b;
        } }, { key: "_getBuffer", value: function(g) {
          var y = n.allocUnsafe(g), v = this.head, b = 1;
          for (v.data.copy(y), g -= v.data.length; v = v.next; ) {
            var x = v.data, p = g > x.length ? x.length : g;
            if (x.copy(y, y.length - g, 0, p), (g -= p) === 0) {
              p === x.length ? (++b, v.next ? this.head = v.next : this.head = this.tail = null) : (this.head = v, v.data = x.slice(p));
              break;
            }
            ++b;
          }
          return this.length -= b, y;
        } }, { key: c, value: function(g, y) {
          return h(this, function(v) {
            for (var b = 1; b < arguments.length; b++) {
              var x = arguments[b] != null ? arguments[b] : {};
              b % 2 ? a(Object(x), !0).forEach(function(p) {
                r(v, p, x[p]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(v, Object.getOwnPropertyDescriptors(x)) : a(Object(x)).forEach(function(p) {
                Object.defineProperty(v, p, Object.getOwnPropertyDescriptor(x, p));
              });
            }
            return v;
          }({}, y, { depth: 0, customInspect: !1 }));
        } }]) && l(u.prototype, f), d;
      }();
    }, { buffer: 17, util: 16 }], 63: [function(i, s, o) {
      (function(a) {
        (function() {
          function r(h, c) {
            n(h, c), l(h);
          }
          function l(h) {
            h._writableState && !h._writableState.emitClose || h._readableState && !h._readableState.emitClose || h.emit("close");
          }
          function n(h, c) {
            h.emit("error", c);
          }
          s.exports = { destroy: function(h, c) {
            var d = this, u = this._readableState && this._readableState.destroyed, f = this._writableState && this._writableState.destroyed;
            return u || f ? (c ? c(h) : h && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, a.nextTick(n, this, h)) : a.nextTick(n, this, h)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(h || null, function(g) {
              !c && g ? d._writableState ? d._writableState.errorEmitted ? a.nextTick(l, d) : (d._writableState.errorEmitted = !0, a.nextTick(r, d, g)) : a.nextTick(r, d, g) : c ? (a.nextTick(l, d), c(g)) : a.nextTick(l, d);
            }), this);
          }, undestroy: function() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }, errorOrDestroy: function(h, c) {
            var d = h._readableState, u = h._writableState;
            d && d.autoDestroy || u && u.autoDestroy ? h.destroy(c) : h.emit("error", c);
          } };
        }).call(this);
      }).call(this, i("_process"));
    }, { _process: 50 }], 64: [function(i, s, o) {
      var a = i("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function r() {
      }
      s.exports = function l(n, h, c) {
        if (typeof h == "function") return l(n, null, h);
        h || (h = {}), c = /* @__PURE__ */ function(C) {
          var R = !1;
          return function() {
            if (!R) {
              R = !0;
              for (var P = arguments.length, E = new Array(P), H = 0; H < P; H++) E[H] = arguments[H];
              C.apply(this, E);
            }
          };
        }(c || r);
        var d = h.readable || h.readable !== !1 && n.readable, u = h.writable || h.writable !== !1 && n.writable, f = function() {
          n.writable || y();
        }, g = n._writableState && n._writableState.finished, y = function() {
          u = !1, g = !0, d || c.call(n);
        }, v = n._readableState && n._readableState.endEmitted, b = function() {
          d = !1, v = !0, u || c.call(n);
        }, x = function(C) {
          c.call(n, C);
        }, p = function() {
          var C;
          return d && !v ? (n._readableState && n._readableState.ended || (C = new a()), c.call(n, C)) : u && !g ? (n._writableState && n._writableState.ended || (C = new a()), c.call(n, C)) : void 0;
        }, k = function() {
          n.req.on("finish", y);
        };
        return function(C) {
          return C.setHeader && typeof C.abort == "function";
        }(n) ? (n.on("complete", y), n.on("abort", p), n.req ? k() : n.on("request", k)) : u && !n._writableState && (n.on("end", f), n.on("close", f)), n.on("end", b), n.on("finish", y), h.error !== !1 && n.on("error", x), n.on("close", p), function() {
          n.removeListener("complete", y), n.removeListener("abort", p), n.removeListener("request", k), n.req && n.req.removeListener("finish", y), n.removeListener("end", f), n.removeListener("close", f), n.removeListener("finish", y), n.removeListener("end", b), n.removeListener("error", x), n.removeListener("close", p);
        };
      };
    }, { "../../../errors": 55 }], 65: [function(i, s, o) {
      s.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 66: [function(i, s, o) {
      var a, r = i("../../../errors").codes, l = r.ERR_MISSING_ARGS, n = r.ERR_STREAM_DESTROYED;
      function h(u) {
        if (u) throw u;
      }
      function c(u) {
        u();
      }
      function d(u, f) {
        return u.pipe(f);
      }
      s.exports = function() {
        for (var u = arguments.length, f = new Array(u), g = 0; g < u; g++) f[g] = arguments[g];
        var y, v = function(x) {
          return x.length ? typeof x[x.length - 1] != "function" ? h : x.pop() : h;
        }(f);
        if (Array.isArray(f[0]) && (f = f[0]), f.length < 2) throw new l("streams");
        var b = f.map(function(x, p) {
          var k = p < f.length - 1;
          return function(C, R, P, E) {
            E = /* @__PURE__ */ function(A) {
              var I = !1;
              return function() {
                I || (I = !0, A.apply(void 0, arguments));
              };
            }(E);
            var H = !1;
            C.on("close", function() {
              H = !0;
            }), a === void 0 && (a = i("./end-of-stream")), a(C, { readable: R, writable: P }, function(A) {
              if (A) return E(A);
              H = !0, E();
            });
            var $ = !1;
            return function(A) {
              if (!H && !$) return $ = !0, function(I) {
                return I.setHeader && typeof I.abort == "function";
              }(C) ? C.abort() : typeof C.destroy == "function" ? C.destroy() : void E(A || new n("pipe"));
            };
          }(x, k, p > 0, function(C) {
            y || (y = C), C && b.forEach(c), k || (b.forEach(c), v(y));
          });
        });
        return f.reduce(d);
      };
    }, { "../../../errors": 55, "./end-of-stream": 64 }], 67: [function(i, s, o) {
      var a = i("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      s.exports = { getHighWaterMark: function(r, l, n, h) {
        var c = function(d, u, f) {
          return d.highWaterMark != null ? d.highWaterMark : u ? d[f] : null;
        }(l, h, n);
        if (c != null) {
          if (!isFinite(c) || Math.floor(c) !== c || c < 0) throw new a(h ? n : "highWaterMark", c);
          return Math.floor(c);
        }
        return r.objectMode ? 16 : 16384;
      } };
    }, { "../../../errors": 55 }], 68: [function(i, s, o) {
      s.exports = i("events").EventEmitter;
    }, { events: 22 }], 69: [function(i, s, o) {
      (o = s.exports = i("./lib/_stream_readable.js")).Stream = o, o.Readable = o, o.Writable = i("./lib/_stream_writable.js"), o.Duplex = i("./lib/_stream_duplex.js"), o.Transform = i("./lib/_stream_transform.js"), o.PassThrough = i("./lib/_stream_passthrough.js"), o.finished = i("./lib/internal/streams/end-of-stream.js"), o.pipeline = i("./lib/internal/streams/pipeline.js");
    }, { "./lib/_stream_duplex.js": 56, "./lib/_stream_passthrough.js": 57, "./lib/_stream_readable.js": 58, "./lib/_stream_transform.js": 59, "./lib/_stream_writable.js": 60, "./lib/internal/streams/end-of-stream.js": 64, "./lib/internal/streams/pipeline.js": 66 }], 70: [function(i, s, o) {
      s.exports = function() {
        if (typeof arguments[0] != "function") throw new Error("callback needed");
        if (typeof arguments[1] != "number") throw new Error("interval needed");
        var a;
        if (arguments.length > 0) {
          a = new Array(arguments.length - 2);
          for (var r = 0; r < a.length; r++) a[r] = arguments[r + 2];
        }
        return new function(l, n, h) {
          var c = this;
          this._callback = l, this._args = h, this._interval = setInterval(l, n, this._args), this.reschedule = function(d) {
            d || (d = c._interval), c._interval && clearInterval(c._interval), c._interval = setInterval(c._callback, d, c._args);
          }, this.clear = function() {
            c._interval && (clearInterval(c._interval), c._interval = void 0);
          }, this.destroy = function() {
            c._interval && clearInterval(c._interval), c._callback = void 0, c._interval = void 0, c._args = void 0;
          };
        }(arguments[0], arguments[1], a);
      };
    }, {}], 71: [function(i, s, o) {
      s.exports = i("./index.js")();
    }, { "./index.js": 72 }], 72: [function(i, s, o) {
      (function(a) {
        (function() {
          function r(l) {
            return l instanceof a ? a.from(l) : new l.constructor(l.buffer.slice(), l.byteOffset, l.length);
          }
          s.exports = function(l) {
            return (l = l || {}).circles ? function(h) {
              var c = [], d = [];
              return h.proto ? function f(g) {
                if (typeof g != "object" || g === null) return g;
                if (g instanceof Date) return new Date(g);
                if (Array.isArray(g)) return u(g, f);
                if (g instanceof Map) return new Map(u(Array.from(g), f));
                if (g instanceof Set) return new Set(u(Array.from(g), f));
                var y = {};
                for (var v in c.push(g), d.push(y), g) {
                  var b = g[v];
                  if (typeof b != "object" || b === null) y[v] = b;
                  else if (b instanceof Date) y[v] = new Date(b);
                  else if (b instanceof Map) y[v] = new Map(u(Array.from(b), f));
                  else if (b instanceof Set) y[v] = new Set(u(Array.from(b), f));
                  else if (ArrayBuffer.isView(b)) y[v] = r(b);
                  else {
                    var x = c.indexOf(b);
                    y[v] = x !== -1 ? d[x] : f(b);
                  }
                }
                return c.pop(), d.pop(), y;
              } : function f(g) {
                if (typeof g != "object" || g === null) return g;
                if (g instanceof Date) return new Date(g);
                if (Array.isArray(g)) return u(g, f);
                if (g instanceof Map) return new Map(u(Array.from(g), f));
                if (g instanceof Set) return new Set(u(Array.from(g), f));
                var y = {};
                for (var v in c.push(g), d.push(y), g) if (Object.hasOwnProperty.call(g, v) !== !1) {
                  var b = g[v];
                  if (typeof b != "object" || b === null) y[v] = b;
                  else if (b instanceof Date) y[v] = new Date(b);
                  else if (b instanceof Map) y[v] = new Map(u(Array.from(b), f));
                  else if (b instanceof Set) y[v] = new Set(u(Array.from(b), f));
                  else if (ArrayBuffer.isView(b)) y[v] = r(b);
                  else {
                    var x = c.indexOf(b);
                    y[v] = x !== -1 ? d[x] : f(b);
                  }
                }
                return c.pop(), d.pop(), y;
              };
              function u(f, g) {
                for (var y = Object.keys(f), v = new Array(y.length), b = 0; b < y.length; b++) {
                  var x = y[b], p = f[x];
                  if (typeof p != "object" || p === null) v[x] = p;
                  else if (p instanceof Date) v[x] = new Date(p);
                  else if (ArrayBuffer.isView(p)) v[x] = r(p);
                  else {
                    var k = c.indexOf(p);
                    v[x] = k !== -1 ? d[k] : g(p);
                  }
                }
                return v;
              }
            }(l) : l.proto ? function h(c) {
              if (typeof c != "object" || c === null) return c;
              if (c instanceof Date) return new Date(c);
              if (Array.isArray(c)) return n(c, h);
              if (c instanceof Map) return new Map(n(Array.from(c), h));
              if (c instanceof Set) return new Set(n(Array.from(c), h));
              var d = {};
              for (var u in c) {
                var f = c[u];
                typeof f != "object" || f === null ? d[u] = f : f instanceof Date ? d[u] = new Date(f) : f instanceof Map ? d[u] = new Map(n(Array.from(f), h)) : f instanceof Set ? d[u] = new Set(n(Array.from(f), h)) : ArrayBuffer.isView(f) ? d[u] = r(f) : d[u] = h(f);
              }
              return d;
            } : function h(c) {
              if (typeof c != "object" || c === null) return c;
              if (c instanceof Date) return new Date(c);
              if (Array.isArray(c)) return n(c, h);
              if (c instanceof Map) return new Map(n(Array.from(c), h));
              if (c instanceof Set) return new Set(n(Array.from(c), h));
              var d = {};
              for (var u in c) if (Object.hasOwnProperty.call(c, u) !== !1) {
                var f = c[u];
                typeof f != "object" || f === null ? d[u] = f : f instanceof Date ? d[u] = new Date(f) : f instanceof Map ? d[u] = new Map(n(Array.from(f), h)) : f instanceof Set ? d[u] = new Set(n(Array.from(f), h)) : ArrayBuffer.isView(f) ? d[u] = r(f) : d[u] = h(f);
              }
              return d;
            };
            function n(h, c) {
              for (var d = Object.keys(h), u = new Array(d.length), f = 0; f < d.length; f++) {
                var g = d[f], y = h[g];
                typeof y != "object" || y === null ? u[g] = y : y instanceof Date ? u[g] = new Date(y) : ArrayBuffer.isView(y) ? u[g] = r(y) : u[g] = c(y);
              }
              return u;
            }
          };
        }).call(this);
      }).call(this, i("buffer").Buffer);
    }, { buffer: 17 }], 73: [function(i, s, o) {
      var a = i("buffer"), r = a.Buffer;
      function l(h, c) {
        for (var d in h) c[d] = h[d];
      }
      function n(h, c, d) {
        return r(h, c, d);
      }
      r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? s.exports = a : (l(a, o), o.Buffer = n), n.prototype = Object.create(r.prototype), l(r, n), n.from = function(h, c, d) {
        if (typeof h == "number") throw new TypeError("Argument must not be a number");
        return r(h, c, d);
      }, n.alloc = function(h, c, d) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        var u = r(h);
        return c !== void 0 ? typeof d == "string" ? u.fill(c, d) : u.fill(c) : u.fill(0), u;
      }, n.allocUnsafe = function(h) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        return r(h);
      }, n.allocUnsafeSlow = function(h) {
        if (typeof h != "number") throw new TypeError("Argument must be a number");
        return a.SlowBuffer(h);
      };
    }, { buffer: 17 }], 74: [function(i, s, o) {
      s.exports = function(a) {
        var r = a._readableState;
        return r ? r.objectMode || typeof a._duplexState == "number" ? a.read() : a.read((l = r, l.buffer.length ? l.buffer.head ? l.buffer.head.data.length : l.buffer[0].length : l.length)) : null;
        var l;
      };
    }, {}], 75: [function(i, s, o) {
      var a = i("safe-buffer").Buffer, r = a.isEncoding || function(v) {
        switch ((v = "" + v) && v.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function l(v) {
        var b;
        switch (this.encoding = function(x) {
          var p = function(k) {
            if (!k) return "utf8";
            for (var C; ; ) switch (k) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return k;
              default:
                if (C) return;
                k = ("" + k).toLowerCase(), C = !0;
            }
          }(x);
          if (typeof p != "string" && (a.isEncoding === r || !r(x))) throw new Error("Unknown encoding: " + x);
          return p || x;
        }(v), this.encoding) {
          case "utf16le":
            this.text = c, this.end = d, b = 4;
            break;
          case "utf8":
            this.fillLast = h, b = 4;
            break;
          case "base64":
            this.text = u, this.end = f, b = 3;
            break;
          default:
            return this.write = g, void (this.end = y);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = a.allocUnsafe(b);
      }
      function n(v) {
        return v <= 127 ? 0 : v >> 5 == 6 ? 2 : v >> 4 == 14 ? 3 : v >> 3 == 30 ? 4 : v >> 6 == 2 ? -1 : -2;
      }
      function h(v) {
        var b = this.lastTotal - this.lastNeed, x = function(p, k, C) {
          if ((192 & k[0]) != 128) return p.lastNeed = 0, "�";
          if (p.lastNeed > 1 && k.length > 1) {
            if ((192 & k[1]) != 128) return p.lastNeed = 1, "�";
            if (p.lastNeed > 2 && k.length > 2 && (192 & k[2]) != 128) return p.lastNeed = 2, "�";
          }
        }(this, v);
        return x !== void 0 ? x : this.lastNeed <= v.length ? (v.copy(this.lastChar, b, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (v.copy(this.lastChar, b, 0, v.length), void (this.lastNeed -= v.length));
      }
      function c(v, b) {
        if ((v.length - b) % 2 == 0) {
          var x = v.toString("utf16le", b);
          if (x) {
            var p = x.charCodeAt(x.length - 1);
            if (p >= 55296 && p <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1], x.slice(0, -1);
          }
          return x;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = v[v.length - 1], v.toString("utf16le", b, v.length - 1);
      }
      function d(v) {
        var b = v && v.length ? this.write(v) : "";
        if (this.lastNeed) {
          var x = this.lastTotal - this.lastNeed;
          return b + this.lastChar.toString("utf16le", 0, x);
        }
        return b;
      }
      function u(v, b) {
        var x = (v.length - b) % 3;
        return x === 0 ? v.toString("base64", b) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = v[v.length - 1] : (this.lastChar[0] = v[v.length - 2], this.lastChar[1] = v[v.length - 1]), v.toString("base64", b, v.length - x));
      }
      function f(v) {
        var b = v && v.length ? this.write(v) : "";
        return this.lastNeed ? b + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : b;
      }
      function g(v) {
        return v.toString(this.encoding);
      }
      function y(v) {
        return v && v.length ? this.write(v) : "";
      }
      o.StringDecoder = l, l.prototype.write = function(v) {
        if (v.length === 0) return "";
        var b, x;
        if (this.lastNeed) {
          if ((b = this.fillLast(v)) === void 0) return "";
          x = this.lastNeed, this.lastNeed = 0;
        } else x = 0;
        return x < v.length ? b ? b + this.text(v, x) : this.text(v, x) : b || "";
      }, l.prototype.end = function(v) {
        var b = v && v.length ? this.write(v) : "";
        return this.lastNeed ? b + "�" : b;
      }, l.prototype.text = function(v, b) {
        var x = function(k, C, R) {
          var P = C.length - 1;
          if (P < R) return 0;
          var E = n(C[P]);
          return E >= 0 ? (E > 0 && (k.lastNeed = E - 1), E) : --P < R || E === -2 ? 0 : (E = n(C[P])) >= 0 ? (E > 0 && (k.lastNeed = E - 2), E) : --P < R || E === -2 ? 0 : (E = n(C[P])) >= 0 ? (E > 0 && (E === 2 ? E = 0 : k.lastNeed = E - 3), E) : 0;
        }(this, v, b);
        if (!this.lastNeed) return v.toString("utf8", b);
        this.lastTotal = x;
        var p = v.length - (x - this.lastNeed);
        return v.copy(this.lastChar, 0, p), v.toString("utf8", b, p);
      }, l.prototype.fillLast = function(v) {
        if (this.lastNeed <= v.length) return v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        v.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, v.length), this.lastNeed -= v.length;
      };
    }, { "safe-buffer": 73 }], 76: [function(i, s, o) {
      var a = i("punycode"), r = i("./util");
      function l() {
        this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
      }
      o.parse = C, o.resolve = function(R, P) {
        return C(R, !1, !0).resolve(P);
      }, o.resolveObject = function(R, P) {
        return R ? C(R, !1, !0).resolveObject(P) : P;
      }, o.format = function(R) {
        return r.isString(R) && (R = C(R)), R instanceof l ? R.format() : l.prototype.format.call(R);
      }, o.Url = l;
      var n = /^([a-z0-9.+-]+:)/i, h = /:[0-9]*$/, c = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, d = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", `
`, "	"]), u = ["'"].concat(d), f = ["%", "/", "?", ";", "#"].concat(u), g = ["/", "?", "#"], y = /^[+a-z0-9A-Z_-]{0,63}$/, v = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, b = { javascript: !0, "javascript:": !0 }, x = { javascript: !0, "javascript:": !0 }, p = { http: !0, https: !0, ftp: !0, gopher: !0, file: !0, "http:": !0, "https:": !0, "ftp:": !0, "gopher:": !0, "file:": !0 }, k = i("querystring");
      function C(R, P, E) {
        if (R && r.isObject(R) && R instanceof l) return R;
        var H = new l();
        return H.parse(R, P, E), H;
      }
      l.prototype.parse = function(R, P, E) {
        if (!r.isString(R)) throw new TypeError("Parameter 'url' must be a string, not " + typeof R);
        var H = R.indexOf("?"), $ = H !== -1 && H < R.indexOf("#") ? "?" : "#", A = R.split($);
        A[0] = A[0].replace(/\\/g, "/");
        var I = R = A.join($);
        if (I = I.trim(), !E && R.split("#").length === 1) {
          var S = c.exec(I);
          if (S) return this.path = I, this.href = I, this.pathname = S[1], S[2] ? (this.search = S[2], this.query = P ? k.parse(this.search.substr(1)) : this.search.substr(1)) : P && (this.search = "", this.query = {}), this;
        }
        var _ = n.exec(I);
        if (_) {
          var B = (_ = _[0]).toLowerCase();
          this.protocol = B, I = I.substr(_.length);
        }
        if (E || _ || I.match(/^\/\/[^@\/]+@[^@\/]+/)) {
          var j = I.substr(0, 2) === "//";
          !j || _ && x[_] || (I = I.substr(2), this.slashes = !0);
        }
        if (!x[_] && (j || _ && !p[_])) {
          for (var X, z, M = -1, D = 0; D < g.length; D++)
            (W = I.indexOf(g[D])) !== -1 && (M === -1 || W < M) && (M = W);
          for ((z = M === -1 ? I.lastIndexOf("@") : I.lastIndexOf("@", M)) !== -1 && (X = I.slice(0, z), I = I.slice(z + 1), this.auth = decodeURIComponent(X)), M = -1, D = 0; D < f.length; D++) {
            var W;
            (W = I.indexOf(f[D])) !== -1 && (M === -1 || W < M) && (M = W);
          }
          M === -1 && (M = I.length), this.host = I.slice(0, M), I = I.slice(M), this.parseHost(), this.hostname = this.hostname || "";
          var N = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
          if (!N) for (var U = this.hostname.split(/\./), q = (D = 0, U.length); D < q; D++) {
            var Y = U[D];
            if (Y && !Y.match(y)) {
              for (var Z = "", Q = 0, J = Y.length; Q < J; Q++) Y.charCodeAt(Q) > 127 ? Z += "x" : Z += Y[Q];
              if (!Z.match(y)) {
                var m = U.slice(0, D), w = U.slice(D + 1), T = Y.match(v);
                T && (m.push(T[1]), w.unshift(T[2])), w.length && (I = "/" + w.join(".") + I), this.hostname = m.join(".");
                break;
              }
            }
          }
          this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), N || (this.hostname = a.toASCII(this.hostname));
          var L = this.port ? ":" + this.port : "", F = this.hostname || "";
          this.host = F + L, this.href += this.host, N && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), I[0] !== "/" && (I = "/" + I));
        }
        if (!b[B]) for (D = 0, q = u.length; D < q; D++) {
          var V = u[D];
          if (I.indexOf(V) !== -1) {
            var K = encodeURIComponent(V);
            K === V && (K = escape(V)), I = I.split(V).join(K);
          }
        }
        var et = I.indexOf("#");
        et !== -1 && (this.hash = I.substr(et), I = I.slice(0, et));
        var tt = I.indexOf("?");
        if (tt !== -1 ? (this.search = I.substr(tt), this.query = I.substr(tt + 1), P && (this.query = k.parse(this.query)), I = I.slice(0, tt)) : P && (this.search = "", this.query = {}), I && (this.pathname = I), p[B] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
          L = this.pathname || "";
          var at = this.search || "";
          this.path = L + at;
        }
        return this.href = this.format(), this;
      }, l.prototype.format = function() {
        var R = this.auth || "";
        R && (R = (R = encodeURIComponent(R)).replace(/%3A/i, ":"), R += "@");
        var P = this.protocol || "", E = this.pathname || "", H = this.hash || "", $ = !1, A = "";
        this.host ? $ = R + this.host : this.hostname && ($ = R + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && ($ += ":" + this.port)), this.query && r.isObject(this.query) && Object.keys(this.query).length && (A = k.stringify(this.query));
        var I = this.search || A && "?" + A || "";
        return P && P.substr(-1) !== ":" && (P += ":"), this.slashes || (!P || p[P]) && $ !== !1 ? ($ = "//" + ($ || ""), E && E.charAt(0) !== "/" && (E = "/" + E)) : $ || ($ = ""), H && H.charAt(0) !== "#" && (H = "#" + H), I && I.charAt(0) !== "?" && (I = "?" + I), P + $ + (E = E.replace(/[?#]/g, function(S) {
          return encodeURIComponent(S);
        })) + (I = I.replace("#", "%23")) + H;
      }, l.prototype.resolve = function(R) {
        return this.resolveObject(C(R, !1, !0)).format();
      }, l.prototype.resolveObject = function(R) {
        if (r.isString(R)) {
          var P = new l();
          P.parse(R, !1, !0), R = P;
        }
        for (var E = new l(), H = Object.keys(this), $ = 0; $ < H.length; $++) {
          var A = H[$];
          E[A] = this[A];
        }
        if (E.hash = R.hash, R.href === "") return E.href = E.format(), E;
        if (R.slashes && !R.protocol) {
          for (var I = Object.keys(R), S = 0; S < I.length; S++) {
            var _ = I[S];
            _ !== "protocol" && (E[_] = R[_]);
          }
          return p[E.protocol] && E.hostname && !E.pathname && (E.path = E.pathname = "/"), E.href = E.format(), E;
        }
        if (R.protocol && R.protocol !== E.protocol) {
          if (!p[R.protocol]) {
            for (var B = Object.keys(R), j = 0; j < B.length; j++) {
              var X = B[j];
              E[X] = R[X];
            }
            return E.href = E.format(), E;
          }
          if (E.protocol = R.protocol, R.host || x[R.protocol]) E.pathname = R.pathname;
          else {
            for (var z = (R.pathname || "").split("/"); z.length && !(R.host = z.shift()); ) ;
            R.host || (R.host = ""), R.hostname || (R.hostname = ""), z[0] !== "" && z.unshift(""), z.length < 2 && z.unshift(""), E.pathname = z.join("/");
          }
          if (E.search = R.search, E.query = R.query, E.host = R.host || "", E.auth = R.auth, E.hostname = R.hostname || R.host, E.port = R.port, E.pathname || E.search) {
            var M = E.pathname || "", D = E.search || "";
            E.path = M + D;
          }
          return E.slashes = E.slashes || R.slashes, E.href = E.format(), E;
        }
        var W = E.pathname && E.pathname.charAt(0) === "/", N = R.host || R.pathname && R.pathname.charAt(0) === "/", U = N || W || E.host && R.pathname, q = U, Y = E.pathname && E.pathname.split("/") || [], Z = (z = R.pathname && R.pathname.split("/") || [], E.protocol && !p[E.protocol]);
        if (Z && (E.hostname = "", E.port = null, E.host && (Y[0] === "" ? Y[0] = E.host : Y.unshift(E.host)), E.host = "", R.protocol && (R.hostname = null, R.port = null, R.host && (z[0] === "" ? z[0] = R.host : z.unshift(R.host)), R.host = null), U = U && (z[0] === "" || Y[0] === "")), N) E.host = R.host || R.host === "" ? R.host : E.host, E.hostname = R.hostname || R.hostname === "" ? R.hostname : E.hostname, E.search = R.search, E.query = R.query, Y = z;
        else if (z.length) Y || (Y = []), Y.pop(), Y = Y.concat(z), E.search = R.search, E.query = R.query;
        else if (!r.isNullOrUndefined(R.search))
          return Z && (E.hostname = E.host = Y.shift(), (T = !!(E.host && E.host.indexOf("@") > 0) && E.host.split("@")) && (E.auth = T.shift(), E.host = E.hostname = T.shift())), E.search = R.search, E.query = R.query, r.isNull(E.pathname) && r.isNull(E.search) || (E.path = (E.pathname ? E.pathname : "") + (E.search ? E.search : "")), E.href = E.format(), E;
        if (!Y.length) return E.pathname = null, E.search ? E.path = "/" + E.search : E.path = null, E.href = E.format(), E;
        for (var Q = Y.slice(-1)[0], J = (E.host || R.host || Y.length > 1) && (Q === "." || Q === "..") || Q === "", m = 0, w = Y.length; w >= 0; w--) (Q = Y[w]) === "." ? Y.splice(w, 1) : Q === ".." ? (Y.splice(w, 1), m++) : m && (Y.splice(w, 1), m--);
        if (!U && !q) for (; m--; m) Y.unshift("..");
        !U || Y[0] === "" || Y[0] && Y[0].charAt(0) === "/" || Y.unshift(""), J && Y.join("/").substr(-1) !== "/" && Y.push("");
        var T, L = Y[0] === "" || Y[0] && Y[0].charAt(0) === "/";
        return Z && (E.hostname = E.host = L ? "" : Y.length ? Y.shift() : "", (T = !!(E.host && E.host.indexOf("@") > 0) && E.host.split("@")) && (E.auth = T.shift(), E.host = E.hostname = T.shift())), (U = U || E.host && Y.length) && !L && Y.unshift(""), Y.length ? E.pathname = Y.join("/") : (E.pathname = null, E.path = null), r.isNull(E.pathname) && r.isNull(E.search) || (E.path = (E.pathname ? E.pathname : "") + (E.search ? E.search : "")), E.auth = R.auth || E.auth, E.slashes = E.slashes || R.slashes, E.href = E.format(), E;
      }, l.prototype.parseHost = function() {
        var R = this.host, P = h.exec(R);
        P && ((P = P[0]) !== ":" && (this.port = P.substr(1)), R = R.substr(0, R.length - P.length)), R && (this.hostname = R);
      };
    }, { "./util": 77, punycode: 51, querystring: 54 }], 77: [function(i, s, o) {
      s.exports = { isString: function(a) {
        return typeof a == "string";
      }, isObject: function(a) {
        return typeof a == "object" && a !== null;
      }, isNull: function(a) {
        return a === null;
      }, isNullOrUndefined: function(a) {
        return a == null;
      } };
    }, {}], 78: [function(i, s, o) {
      (function(a) {
        (function() {
          function r(l) {
            try {
              if (!a.localStorage) return !1;
            } catch {
              return !1;
            }
            var n = a.localStorage[l];
            return n != null && String(n).toLowerCase() === "true";
          }
          s.exports = function(l, n) {
            if (r("noDeprecation")) return l;
            var h = !1;
            return function() {
              if (!h) {
                if (r("throwDeprecation")) throw new Error(n);
                r("traceDeprecation") ? console.trace(n) : console.warn(n), h = !0;
              }
              return l.apply(this, arguments);
            };
          };
        }).call(this);
      }).call(this, typeof Vt < "u" ? Vt : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 79: [function(i, s, o) {
      s.exports = function a(r, l) {
        if (r && l) return a(r)(l);
        if (typeof r != "function") throw new TypeError("need wrapper function");
        return Object.keys(r).forEach(function(h) {
          n[h] = r[h];
        }), n;
        function n() {
          for (var h = new Array(arguments.length), c = 0; c < h.length; c++) h[c] = arguments[c];
          var d = r.apply(this, h), u = h[h.length - 1];
          return typeof d == "function" && d !== u && Object.keys(u).forEach(function(f) {
            d[f] = u[f];
          }), d;
        }
      };
    }, {}], 80: [function(i, s, o) {
      s.exports = function() {
        throw new Error("ws does not work in the browser. Browser clients must use the native WebSocket object");
      };
    }, {}], 81: [function(i, s, o) {
      s.exports = function() {
        for (var r = {}, l = 0; l < arguments.length; l++) {
          var n = arguments[l];
          for (var h in n) a.call(n, h) && (r[h] = n[h]);
        }
        return r;
      };
      var a = Object.prototype.hasOwnProperty;
    }, {}], 82: [function(i, s, o) {
      s.exports = function(a) {
        a.prototype[Symbol.iterator] = function* () {
          for (let r = this.head; r; r = r.next) yield r.value;
        };
      };
    }, {}], 83: [function(i, s, o) {
      function a(c) {
        var d = this;
        if (d instanceof a || (d = new a()), d.tail = null, d.head = null, d.length = 0, c && typeof c.forEach == "function") c.forEach(function(g) {
          d.push(g);
        });
        else if (arguments.length > 0) for (var u = 0, f = arguments.length; u < f; u++) d.push(arguments[u]);
        return d;
      }
      function r(c, d, u) {
        var f = d === c.head ? new h(u, null, d, c) : new h(u, d, d.next, c);
        return f.next === null && (c.tail = f), f.prev === null && (c.head = f), c.length++, f;
      }
      function l(c, d) {
        c.tail = new h(d, c.tail, null, c), c.head || (c.head = c.tail), c.length++;
      }
      function n(c, d) {
        c.head = new h(d, null, c.head, c), c.tail || (c.tail = c.head), c.length++;
      }
      function h(c, d, u, f) {
        if (!(this instanceof h)) return new h(c, d, u, f);
        this.list = f, this.value = c, d ? (d.next = this, this.prev = d) : this.prev = null, u ? (u.prev = this, this.next = u) : this.next = null;
      }
      s.exports = a, a.Node = h, a.create = a, a.prototype.removeNode = function(c) {
        if (c.list !== this) throw new Error("removing node which does not belong to this list");
        var d = c.next, u = c.prev;
        return d && (d.prev = u), u && (u.next = d), c === this.head && (this.head = d), c === this.tail && (this.tail = u), c.list.length--, c.next = null, c.prev = null, c.list = null, d;
      }, a.prototype.unshiftNode = function(c) {
        if (c !== this.head) {
          c.list && c.list.removeNode(c);
          var d = this.head;
          c.list = this, c.next = d, d && (d.prev = c), this.head = c, this.tail || (this.tail = c), this.length++;
        }
      }, a.prototype.pushNode = function(c) {
        if (c !== this.tail) {
          c.list && c.list.removeNode(c);
          var d = this.tail;
          c.list = this, c.prev = d, d && (d.next = c), this.tail = c, this.head || (this.head = c), this.length++;
        }
      }, a.prototype.push = function() {
        for (var c = 0, d = arguments.length; c < d; c++) l(this, arguments[c]);
        return this.length;
      }, a.prototype.unshift = function() {
        for (var c = 0, d = arguments.length; c < d; c++) n(this, arguments[c]);
        return this.length;
      }, a.prototype.pop = function() {
        if (this.tail) {
          var c = this.tail.value;
          return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, c;
        }
      }, a.prototype.shift = function() {
        if (this.head) {
          var c = this.head.value;
          return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, c;
        }
      }, a.prototype.forEach = function(c, d) {
        d = d || this;
        for (var u = this.head, f = 0; u !== null; f++) c.call(d, u.value, f, this), u = u.next;
      }, a.prototype.forEachReverse = function(c, d) {
        d = d || this;
        for (var u = this.tail, f = this.length - 1; u !== null; f--) c.call(d, u.value, f, this), u = u.prev;
      }, a.prototype.get = function(c) {
        for (var d = 0, u = this.head; u !== null && d < c; d++) u = u.next;
        if (d === c && u !== null) return u.value;
      }, a.prototype.getReverse = function(c) {
        for (var d = 0, u = this.tail; u !== null && d < c; d++) u = u.prev;
        if (d === c && u !== null) return u.value;
      }, a.prototype.map = function(c, d) {
        d = d || this;
        for (var u = new a(), f = this.head; f !== null; ) u.push(c.call(d, f.value, this)), f = f.next;
        return u;
      }, a.prototype.mapReverse = function(c, d) {
        d = d || this;
        for (var u = new a(), f = this.tail; f !== null; ) u.push(c.call(d, f.value, this)), f = f.prev;
        return u;
      }, a.prototype.reduce = function(c, d) {
        var u, f = this.head;
        if (arguments.length > 1) u = d;
        else {
          if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
          f = this.head.next, u = this.head.value;
        }
        for (var g = 0; f !== null; g++) u = c(u, f.value, g), f = f.next;
        return u;
      }, a.prototype.reduceReverse = function(c, d) {
        var u, f = this.tail;
        if (arguments.length > 1) u = d;
        else {
          if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
          f = this.tail.prev, u = this.tail.value;
        }
        for (var g = this.length - 1; f !== null; g--) u = c(u, f.value, g), f = f.prev;
        return u;
      }, a.prototype.toArray = function() {
        for (var c = new Array(this.length), d = 0, u = this.head; u !== null; d++) c[d] = u.value, u = u.next;
        return c;
      }, a.prototype.toArrayReverse = function() {
        for (var c = new Array(this.length), d = 0, u = this.tail; u !== null; d++) c[d] = u.value, u = u.prev;
        return c;
      }, a.prototype.slice = function(c, d) {
        (d = d || this.length) < 0 && (d += this.length), (c = c || 0) < 0 && (c += this.length);
        var u = new a();
        if (d < c || d < 0) return u;
        c < 0 && (c = 0), d > this.length && (d = this.length);
        for (var f = 0, g = this.head; g !== null && f < c; f++) g = g.next;
        for (; g !== null && f < d; f++, g = g.next) u.push(g.value);
        return u;
      }, a.prototype.sliceReverse = function(c, d) {
        (d = d || this.length) < 0 && (d += this.length), (c = c || 0) < 0 && (c += this.length);
        var u = new a();
        if (d < c || d < 0) return u;
        c < 0 && (c = 0), d > this.length && (d = this.length);
        for (var f = this.length, g = this.tail; g !== null && f > d; f--) g = g.prev;
        for (; g !== null && f > c; f--, g = g.prev) u.push(g.value);
        return u;
      }, a.prototype.splice = function(c, d, ...u) {
        c > this.length && (c = this.length - 1), c < 0 && (c = this.length + c);
        for (var f = 0, g = this.head; g !== null && f < c; f++) g = g.next;
        var y = [];
        for (f = 0; g && f < d; f++) y.push(g.value), g = this.removeNode(g);
        for (g === null && (g = this.tail), g !== this.head && g !== this.tail && (g = g.prev), f = 0; f < u.length; f++) g = r(this, g, u[f]);
        return y;
      }, a.prototype.reverse = function() {
        for (var c = this.head, d = this.tail, u = c; u !== null; u = u.prev) {
          var f = u.prev;
          u.prev = u.next, u.next = f;
        }
        return this.head = d, this.tail = c, this;
      };
      try {
        i("./iterator.js")(a);
      } catch {
      }
    }, { "./iterator.js": 82 }] }, {}, [12])(12);
  });
})(aa);
var vi = aa.exports;
const to = {
  success: {
    color: "#2ba471",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM7.5 10.59l3 3 6-6L17.91 9l-7.41 7.41L6.09 12l1.41-1.41z"></path></svg>'
  },
  info: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zM11 8.5v-2h2v2h-2zm2 1.5v7.5h-2V10h2z"></path></svg>'
  },
  warning: {
    color: "#e37318",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  error: {
    color: "#d54941",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 1a11 11 0 110 22 11 11 0 010-22zm-1 13h2V6.5h-2V14zm2 1.5h-2v2h2v-2z"></path></svg>'
  },
  question: {
    color: "#0052d9",
    icon: '<svg fill="none" viewBox="0 0 24 24"><path d="M12 23a11 11 0 100-22 11 11 0 000 22zm-.17-11.11c.43-.53.97-.97 1.4-1.32A2 2 0 0012 7a2 2 0 00-1.89 1.33l-.33.95L7.9 8.6l.34-.94a4 4 0 116.24 4.47 7 7 0 00-1.1 1.01c-.27.34-.37.61-.37.85v1.25h-2V14c0-.87.39-1.57.83-2.11zM11 18.25v-2h2v2h-2z"></path></svg>'
  }
}, Mt = {};
class $l {
  constructor(t, i) {
    O(this, "box");
    O(this, "icon");
    O(this, "text");
    O(this, "closeBtn");
    O(this, "duration");
    //定时销毁时间
    O(this, "content");
    O(this, "theme");
    //主题
    O(this, "placement");
    //位置
    O(this, "id");
    this.parentElement = t, this.box = document.createElement("div"), this.icon = document.createElement("div"), this.text = document.createElement("div"), this.box.className = "meta2d-message", this.icon.className = "icon", this.text.className = "text", this.icon.innerHTML = to[i.theme || "info"].icon, this.text.innerHTML = i.content, this.box.appendChild(this.icon), this.box.appendChild(this.text), i.closeBtn && (this.closeBtn = document.createElement("div"), this.closeBtn.className = "close", this.closeBtn.innerHTML = "x", this.closeBtn.onclick = () => {
      this.close();
    }, this.box.appendChild(this.closeBtn)), t.appendChild(this.box);
    let s;
    for (let o = 0; o < document.styleSheets.length; o++)
      document.styleSheets[o].title === "le5le.com/message" && (s = document.styleSheets[o]);
    if (!s) {
      let o = document.createElement("style");
      o.type = "text/css", o.title = "le5le.com/message", document.head.appendChild(o), o = document.createElement("style"), o.type = "text/css", document.head.appendChild(o), s = o.sheet, s.insertRule(
        `.meta2d-message{
           position:absolute;
           z-index:999;
           transform: translateX(-50%); 
           padding:12px 16px;
           max-width:400px;
           background:#fff;
           border-radius:6px;
           box-shadow:0 3px 14px 2px rgba(0, 0, 0, .05),0 8px 10px 1px rgba(0, 0, 0, 6%),0 5px 5px -3px rgba(0, 0, 0, 10%);
           display:flex;
           animation: fadein .5s;}`
      ), s.insertRule(
        `
        @keyframes fadein {
          0% {
              transform: translate(-50%, -100%);
          }
          100% {
              transform: translate(-50%,0);
          }
      }`
      ), s.insertRule(".meta2d-message .icon{width:20px;height:20px;}"), s.insertRule(
        ".meta2d-message .text{color:rgba(0, 0, 0, 0.9);font-size:12px;margin-left:8px;line-height:20px;}"
      ), s.insertRule(
        ".meta2d-message .close{width:20px;height:20px;padding-left: 16px; cursor: pointer;}"
      );
    }
    this.id = i.id || nt(), this.duration = i.duration ?? 3e3, this.placement = i.placement || "top", this.theme = i.theme || "info";
  }
  init() {
    Mt[this.id] = this, this.duration && setTimeout(() => {
      this.close();
    }, this.duration);
    let t = -1;
    Object.keys(Mt).forEach((i) => {
      var s;
      ((s = Mt[i]) == null ? void 0 : s.placement) === this.placement && t++;
    }), this.setPosition(this.placement, t), this.icon.children[0].style.fill = to[this.theme].color;
  }
  setPosition(t, i = 0) {
    switch (t) {
      case "top":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.left = "50%";
        break;
      case "bottom":
        this.box.style.bottom = `${30 + i * 60}px`, this.box.style.left = "50%";
        break;
      case "left":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.left = "30px";
        break;
      case "right":
        this.box.style.top = `${30 + i * 60}px`, this.box.style.right = "30px";
        break;
    }
  }
  close() {
    Object.keys(Mt).forEach((t) => {
      var i;
      if (((i = Mt[t]) == null ? void 0 : i.placement) === this.placement)
        switch (this.placement) {
          case "top":
          case "left":
          case "right":
            Mt[t].box.style.top = parseInt(Mt[t].box.style.top) - 60 + "px";
            break;
          case "bottom":
            Mt[t].box.style.bottom = parseInt(Mt[t].box.style.bottom) - 60 + "px";
            break;
        }
    }), Mt[this.id] = null, delete Mt[this.id], this.box.remove();
  }
}
class Xl {
  constructor(t, i = {}) {
    O(this, "store");
    O(this, "canvas");
    O(this, "websocket");
    O(this, "mqttClient");
    O(this, "websockets");
    O(this, "mqttClients");
    O(this, "penPluginMap", /* @__PURE__ */ new Map());
    O(this, "socketFn");
    O(this, "events", {});
    O(this, "map");
    O(this, "mapTimer");
    O(this, "facePen", He);
    O(this, "getWords", Io);
    O(this, "calcTextLines", ii);
    O(this, "calcTextRect", qt);
    O(this, "calcTextDrawRect", ko);
    O(this, "jetLinksList", []);
    O(this, "jetLinksClient");
    O(this, "register", me);
    O(this, "registerCanvasDraw", _e);
    O(this, "registerAnchors", Yi);
    O(this, "websocketTimes", 0);
    O(this, "mqttTimes", 0);
    O(this, "httpTimer");
    O(this, "httpTimerList", []);
    O(this, "updateTimer");
    O(this, "updateTimerList", []);
    O(this, "sqlTimerList", []);
    O(this, "onEvent", (t, i) => {
      switch (t) {
        case "add":
          i.forEach((s) => {
            var o;
            (o = s.onAdd) == null || o.call(s, s);
          }), this.onSizeUpdate();
          break;
        case "enter":
          i && i.onMouseEnter && i.onMouseEnter(i, this.canvas.mousePos), this.store.data.locked && this.doEvent(i, t);
          break;
        case "leave":
          i && i.onMouseLeave && i.onMouseLeave(i, this.canvas.mousePos), this.store.data.locked && this.doEvent(i, t);
          break;
        case "active":
        case "inactive":
          this.store.data.locked && i.forEach((s) => {
            this.doEvent(s, t);
          });
          break;
        case "click":
          this.store.data.locked && i.pen && !i.pen.disabled && i.pen.switch && (i.pen.checked = !i.pen.checked, i.pen.calculative.checked = i.pen.checked, i.pen.calculative.gradient = void 0, i.pen.calculative.radialGradient = void 0), i.pen && i.pen.onClick && !i.pen.disabled && i.pen.onClick(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, t);
          break;
        case "contextmenu":
          i.pen && i.pen.onContextmenu && !i.pen.disabled && i.pen.onContextmenu(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, t);
          break;
        case "mousedown":
          i.pen && i.pen.onMouseDown && !i.pen.disabled && i.pen.onMouseDown(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, t);
          break;
        case "mouseup":
          i.pen && i.pen.onMouseUp && !i.pen.disabled && i.pen.onMouseUp(i.pen, this.canvas.mousePos), this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, t);
          break;
        case "dblclick":
          this.store.data.locked && i.pen && !i.pen.disabled && this.doEvent(i.pen, t);
          break;
        case "valueUpdate":
          this.store.data.locked && this.doEvent(i, t), this.canvas.tooltip.updateText(i);
          break;
        case "update":
        case "delete":
        case "translatePens":
        case "rotatePens":
        case "resizePens":
          this.onSizeUpdate();
          break;
        case "navigator":
          this.store.data.id || console.warn("请先保存当前图纸"), this.navigatorTo(i.params);
          break;
        case "input":
          this.store.data.locked && i && !i.disabled && this.doEvent(i, t);
          break;
        case "change":
          this.store.data.locked && i && !i.disabled && this.doEvent(i, t);
          break;
      }
      this.doMessageEvent(t);
    });
    O(this, "doEvent", (t, i) => {
      var a, r, l, n, h, c, d, u, f, g;
      if (!t)
        return;
      let s = !1, o = [];
      if ((a = t.events) == null || a.forEach((y, v) => {
        var b;
        if (y.actions && y.actions.length) {
          if (y.name === i) {
            let x = !1;
            y.conditions && y.conditions.length ? y.conditionType === "and" ? x = y.conditions.every((p) => this.judgeCondition(t, p.key, p)) : y.conditionType === "or" && (x = y.conditions.some((p) => this.judgeCondition(t, p.key, p))) : x = !0, x && o.push(v);
          }
        } else if (s = !0, this.events[y.action] && y.name === i) {
          let x = !((b = y.where) != null && b.type);
          if (y.where) {
            const { fn: p, fnJs: k, comparison: C, key: R, value: P } = y.where;
            if (p)
              x = p(t, { meta2d: this });
            else if (k) {
              try {
                y.where.fn = new Function("pen", "context", k);
              } catch (E) {
                console.error("Error: make function:", E);
              }
              y.where.fn && (x = y.where.fn(t, { meta2d: this }));
            } else {
              let E = t[R];
              switch (["x", "y", "width", "height"].includes(R) && (E = this.getPenRect(t)[R]), C) {
                case ">":
                  x = E > +P;
                  break;
                case ">=":
                  x = E >= +P;
                  break;
                case "<":
                  x = E < +P;
                  break;
                case "<=":
                  x = E <= +P;
                  break;
                case "=":
                case "==":
                  x = E == P;
                  break;
                case "!=":
                  x = E != P;
                  break;
                case "[)":
                  x = Ce(+E, P);
                  break;
                case "![)":
                  x = !Ce(+E, P);
                  break;
                case "[]":
                  x = Re(E, P);
                  break;
                case "![]":
                  x = !Re(E, P);
                  break;
              }
            }
          }
          x && o.push(v);
        }
      }), s ? (r = t.events) == null || r.forEach((y, v) => {
        o.includes(v) && this.events[y.action](t, y);
      }) : (l = t.events) == null || l.forEach(async (y, v) => {
        if (o.includes(v)) {
          if (y.confirm && !await this.canvas.popconfirm.showModal(t, this.canvas.mousePos, y.confirmTitle))
            return;
          y.actions.forEach((b) => {
            if (b.timeout) {
              let x = setTimeout(() => {
                this.events[b.action] && (this.events[b.action](t, b), clearTimeout(x), x = null);
              }, b.timeout);
            } else
              this.events[b.action] && this.events[b.action](t, b);
          });
        }
      }), i === "valueUpdate") {
        (n = t.realTimes) == null || n.forEach((v) => {
          var x, p;
          let b = [];
          (x = v.triggers) == null || x.forEach((k, C) => {
            var P;
            let R = !1;
            (P = k.conditions) != null && P.length ? k.conditionType === "and" ? R = k.conditions.every((E) => this.judgeCondition(t, v.key, E)) : k.conditionType === "or" && (R = k.conditions.some((E) => this.judgeCondition(t, v.key, E))) : R = !0, R && b.push(C);
          }), (p = v.triggers) == null || p.forEach((k, C) => {
            var R;
            b.includes(C) && ((R = k.actions) == null || R.forEach((P) => {
              if (P.timeout) {
                let E = setTimeout(() => {
                  this.events[P.action] && (this.events[P.action](t, P), clearTimeout(E), E = null);
                }, P.timeout);
              } else
                this.events[P.action](t, P);
            }));
          });
        });
        let y = [];
        if ((h = this.store.globalTriggers[t.id]) == null || h.forEach((v, b) => {
          var p;
          let x = !1;
          (p = v.conditions) != null && p.length ? v.conditionType === "and" ? x = v.conditions.every((k) => this.judgeCondition(this.store.pens[k.source], k.key, k)) : v.conditionType === "or" && (x = v.conditions.some((k) => this.judgeCondition(this.store.pens[k.source], k.key, k))) : x = !0, x && y.push(b);
        }), (c = this.store.globalTriggers[t.id]) == null || c.forEach((v, b) => {
          var x;
          y.includes(b) && ((x = v.actions) == null || x.forEach((p) => {
            if (p.timeout) {
              let k = setTimeout(() => {
                this.events[p.action] && (this.events[p.action](t, p), clearTimeout(k), k = null);
              }, p.timeout);
            } else
              this.events[p.action](t, p);
          }));
        }), (d = t.triggers) != null && d.length) {
          for (let v of t.triggers)
            if ((u = v.status) != null && u.length)
              for (let b of v.status) {
                let x = !1;
                if ((f = b.conditions) != null && f.length ? b.conditionType === "and" ? x = b.conditions.every((p) => this.judgeCondition(t, p.key, p)) : b.conditionType === "or" && (x = b.conditions.some((p) => this.judgeCondition(t, p.key, p))) : x = !0, x) {
                  (g = b.actions) == null || g.forEach((p) => {
                    if (p.timeout) {
                      let k = setTimeout(() => {
                        this.events[p.action] && (this.events[p.action](t, p), clearTimeout(k), k = null);
                      }, p.timeout);
                    } else
                      this.events[p.action](t, p);
                  });
                  break;
                }
              }
        }
      }
      this.doEvent(this.store.pens[t.parentId], i);
    });
    O(this, "doDataEvent", (t) => {
      var o, a, r;
      if (!((o = this.store.data.dataEvents) != null && o.length))
        return;
      const i = t.reduce((l, { dataId: n, id: h, value: c }) => (l[h || n] = c, l), {});
      let s = [];
      (a = this.store.data.dataEvents) == null || a.forEach((l, n) => {
        let h = !1;
        l.conditions && l.conditions.length ? l.conditionType === "and" ? h = l.conditions.every((c) => this.dataJudegeCondition(i, c.key, c)) : l.conditionType === "or" && (h = l.conditions.some((c) => this.dataJudegeCondition(i, c.key, c))) : h = !0, h && s.push(n);
      }), (r = this.store.data.dataEvents) == null || r.forEach((l, n) => {
        var h;
        s.includes(n) && ((h = l.actions) == null || h.forEach((c) => {
          this.events[c.action](i, c);
        }));
      });
    });
    O(this, "renderPenRaw", ki);
    O(this, "setElemPosition", Ct);
    O(this, "setLifeCycleFunc", fn);
    this.store = kr(nt()), this.setOptions(i), this.setDatabyOptions(i), this.init(t), this.register(Ul()), this.registerCanvasDraw({ cube: qn }), this.registerAnchors(ql()), globalThis.meta2d = this, this.initEventFns(), this.store.emitter.on("*", this.onEvent);
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  get beforeAddPen() {
    return this.canvas.beforeAddPen;
  }
  /**
   * @deprecated 改用 beforeAddPens
   */
  set beforeAddPen(t) {
    this.canvas.beforeAddPen = t;
  }
  get beforeAddPens() {
    return this.canvas.beforeAddPens;
  }
  set beforeAddPens(t) {
    this.canvas.beforeAddPens = t;
  }
  get beforeAddAnchor() {
    return this.canvas.beforeAddAnchor;
  }
  set beforeAddAnchor(t) {
    this.canvas.beforeAddAnchor = t;
  }
  get beforeRemovePens() {
    return this.canvas.beforeRemovePens;
  }
  set beforeRemovePens(t) {
    this.canvas.beforeRemovePens = t;
  }
  get beforeRemoveAnchor() {
    return this.canvas.beforeRemoveAnchor;
  }
  set beforeRemoveAnchor(t) {
    this.canvas.beforeRemoveAnchor = t;
  }
  setOptions(t = {}) {
    var i;
    (t.grid !== void 0 || t.gridColor !== void 0 || t.gridSize !== void 0) && this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), (t.rule !== void 0 || t.ruleColor !== void 0 || t.ruleOptions !== void 0) && (this.store.patchFlagsTop = !0, t.ruleOptions && (i = this.store.options) != null && i.ruleOptions && (Object.assign(this.store.options.ruleOptions, t.ruleOptions), t.ruleOptions = this.store.options.ruleOptions)), t.background !== void 0 && this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), t.resizeMode !== void 0 && (t.resizeMode || (this.canvas.hotkeyType = gt.None)), (t.width !== void 0 || t.height !== void 0) && (this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0), this.canvas && this.canvas.canvasTemplate.canvas.style.backgroundImage && (this.canvas.canvasTemplate.canvas.style.backgroundImage = "")), this.store.options = Object.assign(this.store.options, t), this.canvas && t.scroll !== void 0 && (t.scroll ? (!this.canvas.scroll && (this.canvas.scroll = new ea(this.canvas)), this.canvas.scroll.show()) : this.canvas.scroll && this.canvas.scroll.hide());
  }
  getOptions() {
    return this.store.options;
  }
  setTheme(t) {
    this.store.data.theme = t, this.setBackgroundColor(this.store.theme[t].background), this.canvas.parentElement.style.background = this.store.theme[t].parentBackground, this.store.data.color = this.store.theme[t].color, this.setOptions({
      ruleColor: this.store.theme[t].ruleColor,
      ruleOptions: this.store.theme[t].ruleOptions
    }), this.render();
  }
  setDatabyOptions(t = {}) {
    const {
      color: i,
      activeColor: s,
      activeBackground: o,
      grid: a,
      gridColor: r,
      gridSize: l,
      fromArrow: n,
      toArrow: h,
      rule: c,
      ruleColor: d,
      textColor: u,
      x: f = 0,
      y: g = 0
    } = t;
    this.setRule({ rule: c, ruleColor: d }), this.setGrid({
      grid: a,
      gridColor: r,
      gridSize: l
    }), this.store.data = Object.assign(this.store.data, {
      textColor: u,
      color: i,
      activeColor: s,
      activeBackground: o,
      fromArrow: n,
      toArrow: h,
      x: f,
      y: g
    });
  }
  init(t) {
    typeof t == "string" ? this.canvas = new Js(
      this,
      document.getElementById(t),
      this.store
    ) : this.canvas = new Js(this, t, this.store), this.resize(), this.canvas.listen();
  }
  initEventFns() {
    this.events[It.Link] = (t, i) => {
      if (window && i.value && typeof i.value == "string") {
        window.open(i.value, i.params ?? "_blank");
        return;
      }
      console.warn("[meta2d] Link param is not a string");
    }, this.events[It.SetProps] = (t, i) => {
      const s = i.value;
      if (s && typeof s == "object") {
        (i.params ? this.find(i.params) : this.find(t.id)).forEach((a) => {
          s.hasOwnProperty("visible") && a.visible !== s.visible && this.setVisible(a, s.visible), this.setValue(
            { id: a.id, ...s },
            { render: !1, doEvent: !1 }
          );
        }), this.render();
        return;
      }
      console.warn("[meta2d] SetProps value is not an object");
    }, this.events[It.StartAnimate] = (t, i) => {
      let s = t;
      if (i.value && (s = this.findOne(i.value)), !(this.store.animates.has(s) && !s.calculative.pause && s.animateName === i.params)) {
        if (i.targetType && i.params) {
          this.startAnimate(i.value || [t], i.params);
          return;
        }
        if (!i.value || typeof i.value == "string") {
          this.startAnimate(i.value || [t]);
          return;
        }
        console.warn("[meta2d] StartAnimate value is not a string");
      }
    }, this.events[It.PauseAnimate] = (t, i) => {
      if (!i.value || typeof i.value == "string") {
        this.pauseAnimate(i.value || [t]);
        return;
      }
      console.warn("[meta2d] PauseAnimate value is not a string");
    }, this.events[It.StopAnimate] = (t, i) => {
      if (!i.value || typeof i.value == "string") {
        if (i.value) {
          let s = this.findOne(i.value);
          if (!this.store.animates.has(s))
            return;
        } else if (!this.store.animates.has(t))
          return;
        this.stopAnimate(i.value || [t]);
        return;
      }
      console.warn("[meta2d] StopAnimate event value is not a string");
    }, this.events[It.StartVideo] = (t, i) => {
      if (!i.value || typeof i.value == "string") {
        this.startVideo(i.value || [t]);
        return;
      }
      console.warn("[meta2d] StartVideo value is not a string");
    }, this.events[It.PauseVideo] = (t, i) => {
      if (!i.value || typeof i.value == "string") {
        this.pauseVideo(i.value || [t]);
        return;
      }
      console.warn("[meta2d] PauseVideo value is not a string");
    }, this.events[It.StopVideo] = (t, i) => {
      if (!i.value || typeof i.value == "string") {
        this.stopVideo(i.value || [t]);
        return;
      }
      console.warn("[meta2d] StopVideo event value is not a string");
    }, this.events[It.JS] = (t, i, s) => {
      var o;
      if (i.value && !i.fn)
        try {
          if (typeof i.value != "string")
            throw new Error("[meta2d] Function value must be string");
          const a = i.value;
          i.fn = new Function("pen", "params", "context", a);
        } catch (a) {
          console.error("[meta2d]: Error on make a function:", a);
        }
      (o = i.fn) == null || o.call(i, t, s || i.params, { meta2d: this, eventName: i.name });
    }, this.events[It.GlobalFn] = (t, i) => {
      if (typeof i.value != "string") {
        console.warn("[meta2d] GlobalFn value must be a string");
        return;
      }
      globalThis[i.value] && globalThis[i.value](t, i.params);
    }, this.events[It.Emit] = (t, i) => {
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      this.store.emitter.emit(i.value, {
        pen: t,
        params: i.params,
        eventName: i.name
      });
    }, this.events[It.SendPropData] = (t, i) => {
      const s = G(i.value);
      if (s && typeof s == "object") {
        const o = i.params ? this.findOne(i.params) : t;
        for (let a in s)
          (s[a] === void 0 || s[a] === "") && (s[a] = o[a]);
        s.id = o.id, this.doSendDataEvent(s, i.extend);
        return;
      }
      console.warn("[meta2d] SendPropData value is not an object");
    }, this.events[It.SendVarData] = (t, i) => {
      const s = G(i.value);
      if (s && typeof s == "object") {
        const o = i.params ? this.findOne(i.params) : t;
        let a = [];
        for (let r in s) {
          let l = {
            dataId: r,
            value: s[r]
          };
          if (!l.value) {
            let n = o.form.find(
              (h) => h.dataIds && h.dataIds.dataId === l.dataId
            );
            n && (l.value = o[n.key]);
          }
          a.push(l);
        }
        this.doSendDataEvent(a, i.extend);
        return;
      }
      console.warn("[meta2d] SendVarData value is not an object");
    }, this.events[It.Navigator] = (t, i) => {
      i.value && typeof i.value == "string" && this.navigatorTo(i.value);
    }, this.events[It.Dialog] = (t, i) => {
      if (i.params && typeof i.params == "string") {
        let s = i.params;
        if (i.params.includes("${")) {
          let o = i.params.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
          o && (o == null || o.forEach((a) => {
            s = s.replace(`\${${a}}`, t[a]);
          }));
        }
        this.canvas.dialog.show(i.value, s, i.extend);
      }
    }, this.events[It.SendData] = (t, i) => {
      var o, a;
      if ((o = i.list) != null && o.length) {
        if (i.network && i.network.protocol === "jetLinks") {
          const l = [];
          i.list.forEach((n, h) => {
            var d, u;
            const c = n.params ? this.findOne(n.params) : t;
            l[h] = {
              deviceId: c.deviceId,
              productId: c.productId,
              properties: {}
            };
            for (let f in n.value)
              if (n.value[f] === void 0 || n.value[f] === "") {
                const g = (d = c.realTimes) == null ? void 0 : d.find((y) => y.propertyId === f);
                g && (l[h].properties[f] = c[g.key]);
              } else if (typeof n.value[f] == "string" && ((u = n.value[f]) == null ? void 0 : u.indexOf("${")) > -1) {
                let g = n.value[f].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
                g != null && g.length && (l[h].properties[f] = c[g[0]]);
              } else
                l[h].properties[f] = n.value[f];
          }), this.jetLinksClient && l.length && l.forEach((n) => {
            this.jetLinksClient.send(JSON.stringify({
              type: "sub",
              topic: `/device-message-sender/${n.productId}/${n.deviceId}`,
              parameter: {
                messageType: "WRITE_PROPERTY",
                properties: n.properties,
                headers: {
                  async: !1
                }
              },
              id: n.productId + "/" + n.deviceId + "-" + nt()
            }));
          });
          return;
        }
        const r = {};
        i.list.forEach((l) => {
          var h;
          const n = l.params ? this.findOne(l.params) : t;
          for (let c in l.value)
            if (l.value[c] === void 0 || l.value[c] === "")
              r[c] = n[c];
            else if (typeof l.value[c] == "string" && ((h = l.value[c]) == null ? void 0 : h.indexOf("${")) > -1) {
              let d = l.value[c].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
              d != null && d.length && (r[c] = n[d[0]]);
            } else
              r[c] = l.value[c];
        }), t.deviceId && (r.deviceId = t.deviceId), this.sendDataToNetWork(r, t, i);
        return;
      }
      const s = G(i.value);
      if (s && typeof s == "object" && i.targetType === "id") {
        const r = i.params ? this.findOne(i.params) : t;
        for (let l in s)
          if (s[l] === void 0 || s[l] === "")
            s[l] = r[l];
          else if (typeof s[l] == "string" && ((a = s[l]) == null ? void 0 : a.indexOf("${")) > -1) {
            let n = s[l].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            n != null && n.length && (s[l] = r[n[0]]);
          }
        r.deviceId && (s.deviceId = r.deviceId), this.sendDataToNetWork(s, t, i);
        return;
      }
    }, this.events[It.PostMessage] = (t, i) => {
      var r;
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const s = i.params ? this.findOne(i.params) : t;
      if (s.name !== "iframe" || !s.iframe) {
        console.warn("不是嵌入页面");
        return;
      }
      let o = Mi(s.iframe.split("?")[1]);
      const a = {};
      (r = i.list) != null && r.length && i.list.forEach((l) => {
        var h;
        const n = l.params ? this.findOne(l.params) : t;
        for (let c in l.value)
          if (l.value[c] === void 0 || l.value[c] === "")
            a[c] = n[c];
          else if (typeof l.value[c] == "string" && ((h = l.value[c]) == null ? void 0 : h.indexOf("${")) > -1) {
            let d = l.value[c].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            d != null && d.length && (a[c] = n[d[0]]);
          } else
            a[c] = l.value[c];
      }), s.calculative.singleton.div.children[0].contentWindow.postMessage(
        JSON.stringify({
          name: i.value,
          id: o.id,
          value: a
        }),
        "*"
      );
    }, this.events[It.PostMessageToParent] = (t, i) => {
      var o;
      if (typeof i.value != "string") {
        console.warn("[meta2d] Emit value must be a string");
        return;
      }
      const s = {};
      (o = i.list) != null && o.length && i.list.forEach((a) => {
        var l;
        const r = a.params ? this.findOne(a.params) : t;
        for (let n in a.value)
          if (a.value[n] === void 0 || a.value[n] === "")
            s[n] = r[n];
          else if (typeof a.value[n] == "string" && ((l = a.value[n]) == null ? void 0 : l.indexOf("${")) > -1) {
            let h = a.value[n].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            h != null && h.length && (s[n] = r[h[0]]);
          } else
            s[n] = a.value[n];
      }), window.parent.postMessage(JSON.stringify({ name: i.value, value: s }), "*");
    }, this.events[It.Message] = (t, i) => {
      this.message({
        theme: i.params,
        content: i.value,
        ...i.extend
      });
    };
  }
  message(t) {
    new $l(this.canvas.parentElement, t).init();
  }
  closeAll() {
    for (let t in Mt)
      Mt[t].close();
  }
  async navigatorTo(t) {
    if (!t)
      return;
    const i = new URL(window.location);
    i.searchParams.set("id", t), history.pushState({}, "", i);
    const s = this.store.options.navigatorNetWork, o = location.href.includes("2d.") || location.href.includes("/2d") ? "2d" : "v", a = await fetch(((s == null ? void 0 : s.url) || `/api/data/${o}/get`) + ((s == null ? void 0 : s.method) === "GET" ? `?id=${t}` : ""), {
      headers: {
        Authorization: `Bearer ${this.getCookie("token") || localStorage.getItem("token") || new URLSearchParams(location.search).get("token") || ""}`
      },
      method: (s == null ? void 0 : s.method) || "POST",
      body: (s == null ? void 0 : s.method) === "GET" ? void 0 : JSON.stringify({ id: t })
    });
    if (a.ok) {
      let r = await a.text();
      r.constructor === Object || r.constructor === Array ? r = JSON.parse(JSON.stringify(r)) : typeof r == "string" && (r = JSON.parse(r)), r.data && (r = r.data), this.open(r);
    } else
      this.store.emitter.emit("error", { type: "http", error: a });
  }
  doSendDataEvent(t, i) {
    let s = JSON.stringify(t);
    this.mqttClient && this.mqttClient.connected && (i ? i.split(",").forEach((o) => {
      this.mqttClient.publish(o, s);
    }) : this.store.data.mqttTopics && this.store.data.mqttTopics.split(",").forEach((o) => {
      this.mqttClient.publish(o, s);
    })), this.websocket && this.websocket.readyState === 1 && this.websocket.send(s), (this.store.data.https || this.store.data.http) && this.sendDatabyHttp(s), this.store.emitter.emit("sendData", s);
  }
  async sendDataToNetWork(t, i, s) {
    var a;
    const o = G(s.network);
    if (o.data && (Object.assign(o, o.data), delete o.data), !!o.url) {
      if (o.protocol === "http") {
        if (typeof o.headers == "object") {
          for (let h in o.headers)
            if (typeof o.headers[h] == "string") {
              let c = o.headers[h].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
              c && (o.headers[h] = o.headers[h].replace(
                `\${${c[0]}}`,
                this.getDynamicParam(c[0])
              ));
            }
        }
        let r, l = o.url;
        if (o.method === "GET" && (r = "?" + Object.keys(t).map((h) => h + "=" + t[h]).join("&")), o.method === "POST" && l.indexOf("${") > -1) {
          let h = l.match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
          h && h.forEach((c) => {
            l = l.replace(`\${${c}}`, Me(i, c) || this.getDynamicParam(c));
          });
        }
        const n = await fetch(l + (r || ""), {
          headers: o.headers || {},
          method: o.method,
          body: o.method === "POST" ? JSON.stringify(t) : void 0
        });
        if (n.ok) {
          if (s.callback) {
            const h = await n.text();
            if (!s.fn)
              try {
                if (typeof s.callback != "string")
                  throw new Error("[meta2d] Function callback must be string");
                const c = s.callback;
                s.fn = new Function("pen", "data", "context", c);
              } catch (c) {
                console.error("[meta2d]: Error on make a function:", c);
              }
            (a = s.fn) == null || a.call(s, i, h, { meta2d: this, e: s });
          }
          console.info("http消息发送成功");
        }
      } else if (o.protocol === "mqtt") {
        const r = this.mqttClients.filter(
          (l) => l.options.href === o.url
        );
        if (r && r.length)
          r[0].connected && o.topics.split(",").forEach((l) => {
            r[0].publish(l, t);
          });
        else {
          let l = vi.connect(o.url, o.options);
          l.on("connect", () => {
            console.info("mqtt连接成功"), o.topics.split(",").forEach((n) => {
              l.publish(n, t), l == null || l.end();
            });
          });
        }
      } else if (o.protocol === "websocket") {
        const r = this.websockets.filter(
          (l) => l.url === o.url
        );
        if (r && r.length)
          r[0].readyState === 1 && r[0].send(t);
        else {
          let l = new WebSocket(
            o.url,
            o.protocols || void 0
          );
          l.onopen = function() {
            console.info("websocket连接成功"), l.send(t), setTimeout(() => {
              l.close();
            }, 100);
          };
        }
      }
    }
  }
  resize(t, i) {
    this.canvas.resize(t, i), this.render(), this.store.emitter.emit("resize", { width: t, height: i }), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.init();
  }
  /**
   *
   * @param emit 是否发送消息
   */
  async addPen(t, i, s = !0, o = !1) {
    return await this.canvas.addPen(t, i, s, o);
  }
  async addPens(t, i, s = !1) {
    return await this.canvas.addPens(t, i, s);
  }
  render(t) {
    var i;
    (i = this.canvas) == null || i.render(t);
  }
  async setBackgroundImage(t, i) {
    var l, n, h, c;
    let s = this;
    async function o(d) {
      return new Promise((u) => {
        const f = new Image();
        f.src = d, s.store.options.cdn && !(d.startsWith("http") || d.startsWith("//") || d.startsWith("data:image")) && (f.src = s.store.options.cdn + d), f.crossOrigin = "anonymous", f.onload = () => {
          u(f);
        };
      });
    }
    this.store.data.bkImage = t;
    const a = (i == null ? void 0 : i.width) || ((l = this.store.data) == null ? void 0 : l.width) || ((n = this.store.options) == null ? void 0 : n.width), r = (i == null ? void 0 : i.height) || ((h = this.store.data) == null ? void 0 : h.height) || ((c = this.store.options) == null ? void 0 : c.height);
    if (a && r ? (this.canvas.canvasTemplate.canvas.style.backgroundImage = null, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0)) : this.canvas.canvasTemplate.canvas.style.backgroundImage = t ? `url('${t}')` : "", t) {
      const d = await o(t);
      this.store.bkImg = d, a && r && this.canvas && (this.canvas.canvasTemplate.init(), this.render());
    } else
      this.store.bkImg = null;
  }
  setBackgroundColor(t = this.store.data.background) {
    this.store.data.background = t, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0);
  }
  setGrid({
    grid: t = this.store.data.grid,
    gridColor: i = this.store.data.gridColor,
    gridSize: s = this.store.data.gridSize,
    gridRotate: o = this.store.data.gridRotate
  } = {}) {
    this.store.data.grid = t, this.store.data.gridColor = i, this.store.data.gridSize = s < 0 ? 0 : s, this.store.data.gridRotate = o, this.canvas && (this.canvas.canvasTemplate.bgPatchFlags = !0);
  }
  setRule({
    rule: t = this.store.data.rule,
    ruleColor: i = this.store.data.ruleColor
  } = {}) {
    this.store.data.rule = t, this.store.data.ruleColor = i, this.store.patchFlagsTop = !0;
  }
  open(t, i = !0) {
    if (this.clear(!1, t == null ? void 0 : t.template), this.canvas.autoPolylineFlag = !0, t) {
      this.setBackgroundImage(t.bkImage, t), Object.assign(this.store.data, t), this.store.data.pens = [];
      for (const s of t.pens)
        s.id || (s.id = nt()), !s.calculative && (s.calculative = { canvas: this.canvas }), this.store.pens[s.id] = s;
      for (const s of t.pens)
        this.canvas.makePen(s);
    }
    if (this.canvas.patchFlagsLines.forEach((s) => {
      s.type && this.canvas.initLineRect(s);
    }), this.store.data.template || (this.store.data.template = nt()), i || (this.canvas.opening = !0), this.initBindDatas(), this.initBinds(), this.initMessageEvents(), this.initGlobalTriggers(), this.render(), this.listenSocket(), this.connectSocket(), this.connectNetwork(), this.startDataMock(), this.startAnimate(), this.startVideo(), this.doInitJS(), this.doInitFn(), setTimeout(() => {
      const s = this.store.data.pens.find((o) => o.autofocus);
      s && this.focus(s.id);
    }, 100), this.store.data.iconUrls)
      for (const s of this.store.data.iconUrls)
        Pr(s, () => {
          this.render();
        });
    this.canvas.autoPolylineFlag = !1, this.store.emitter.emit("opened"), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.init();
  }
  cacheData(t) {
    if (t && this.store.options.cacheLength) {
      let i = this.store.cacheDatas.findIndex(
        (s) => s.data && s.data._id === t
      );
      if (i === -1)
        this.store.cacheDatas.push({
          data: G(this.store.data, !0)
          // offscreen: new Array(2),
          // flag: new Array(2)
        }), this.store.cacheDatas.length > this.store.options.cacheLength && this.store.cacheDatas.shift();
      else {
        let s = this.store.cacheDatas.splice(i, 1)[0];
        this.store.cacheDatas.push(s);
      }
    }
  }
  loadCacheData(t) {
    let i = this.store.cacheDatas.findIndex(
      (s) => s.data && s.data._id === t
    );
    i !== -1 && (this.store.data = this.store.cacheDatas[i].data, this.setBackgroundImage(this.store.data.bkImage), this.store.pens = {}, this.store.data.pens.forEach((s) => {
      s.calculative.canvas = this.canvas, this.store.pens[s.id] = s, rt.path2dDraws[s.name] && this.store.path2dMap.set(s, rt.path2dDraws[s.name](s)), s.type && this.store.path2dMap.set(s, rt.path2dDraws[s.name](s)), s.image && (s.calculative.imageDrawed = !1, this.canvas.loadImage(s));
    }), this.render());
  }
  initBindDatas() {
    this.store.bindDatas = {}, this.store.data.pens.forEach((t) => {
      var i;
      (i = t.form) == null || i.forEach((s) => {
        let o;
        s.dataIds && (Array.isArray(s.dataIds) ? o = s.dataIds : o = [s.dataIds]), o == null || o.forEach((a) => {
          this.store.bindDatas[a.dataId] || (this.store.bindDatas[a.dataId] = []), this.store.bindDatas[a.dataId].push({
            id: t.id,
            formItem: s
          });
        });
      });
    });
  }
  initBinds() {
    this.jetLinksList = [], this.store.bind = {}, this.store.data.pens.forEach((t) => {
      var i;
      (i = t.realTimes) == null || i.forEach((s) => {
        if (s.bind && s.bind.id) {
          this.store.bind[s.bind.id] || (this.store.bind[s.bind.id] = []), this.store.bind[s.bind.id].push({
            id: t.id,
            key: s.key
          });
          const o = s.productId || t.productId, a = s.deviceId || t.deviceId, r = s.propertyId;
          if (o && a && r) {
            const l = this.jetLinksList.findIndex((n) => n.topic.startsWith(`/${o}/${a}`));
            l > -1 ? this.jetLinksList[l].properties.includes(s.propertyId) || this.jetLinksList[l].properties.push(s.propertyId) : this.jetLinksList.push({
              topic: `/${o}/${a}`,
              deviceId: a,
              properties: [s.propertyId]
            });
          }
        }
      });
    });
  }
  connectSocket() {
    this.connectWebsocket(), this.connectMqtt(), this.connectHttp();
  }
  /**
   * open 后执行初始化 Js ，每个图纸可配置一个初始化 js
   */
  doInitJS() {
    const t = this.store.data.initJs;
    if (t && t.trim())
      try {
        new Function("context", t)({ meta2d: this });
      } catch (i) {
        console.warn("initJs error", i);
      }
  }
  doInitFn() {
    let t = Mi(), i = [];
    for (let s in t)
      t.hasOwnProperty(s) && s.startsWith("bind-") && i.push({
        id: s.replace("bind-", ""),
        dataId: s.replace("bind-", ""),
        value: t[s]
      });
    i.length && this.setDatas(i, { history: !1 });
  }
  drawLine(t) {
    t && ia(this.store), this.canvas.drawingLineName = t;
  }
  alignPenToGrid(t) {
    this.canvas.alignPenToGrid(t);
  }
  drawingPencil() {
    this.canvas.drawingPencil();
  }
  stopPencil() {
    this.canvas.stopPencil();
  }
  lock(t) {
    this.store.data.locked = t, this.finishDrawLine(!0), this.canvas.drawingLineName = "", this.stopPencil(), this.store.data.pens.forEach((i) => {
      var s;
      i.externElement === !0 && (s = i.calculative.singleton) != null && s.div && Ct(i, i.calculative.singleton.div);
    }), t > 0 && this.initMessageEvents();
  }
  // end  - 当前鼠标位置，是否作为终点
  async finishDrawLine(t) {
    await this.canvas.finishDrawline(t);
  }
  async finishPencil() {
    await this.canvas.finishPencil();
  }
  updateLineType(t, i) {
    if (!t || t.name != "line" || !i || !this.canvas[i])
      return;
    t.lineName = i;
    const s = xt(t), o = ut(t);
    s.prev = void 0, s.next = void 0, o.prev = void 0, o.next = void 0, t.calculative.worldAnchors = [s, o], t.calculative.activeAnchor = s, this.canvas[i](this.store, t, o), t.lineName === "curve" && (s.prev = {
      penId: s.penId,
      x: s.x - 50,
      y: s.y
    }, s.next = {
      penId: s.penId,
      x: s.x + 50,
      y: s.y
    }, o.prev = {
      penId: o.penId,
      x: o.x - 50,
      y: o.y
    }, o.next = {
      penId: o.penId,
      x: o.x + 50,
      y: o.y
    }), t.calculative.activeAnchor = void 0, this.canvas.initLineRect(t), this.render();
  }
  addDrawLineFn(t, i) {
    this.canvas[t] = i, this.canvas.drawLineFns.push(t);
  }
  removeDrawLineFn(t) {
    const i = this.canvas.drawLineFns.indexOf(t);
    i > -1 && this.canvas.drawLineFns.splice(i, 1);
  }
  showMagnifier() {
    this.canvas.showMagnifier();
  }
  hideMagnifier() {
    this.canvas.hideMagnifier();
  }
  toggleMagnifier() {
    this.canvas.toggleMagnifier();
  }
  /**
   * 擦除画布，释放 store 上的 pens
   * @param render 是否重绘
   */
  clear(t = !0, i) {
    var s;
    for (const o of this.store.data.pens)
      (s = o.onDestroy) == null || s.call(o, o);
    Ir(this.store, i), this.hideInput(), this.canvas.tooltip.hide(), this.map && this.map.isShow && (this.map.show(), this.map.setView()), this.canvas.clearCanvas(), sessionStorage.removeItem("page"), this.store.clipboard = void 0, this.store.sameTemplate || (this.canvas.canvasTemplate.bgPatchFlags = !0), this.store.patchFlagsBackground = !0, this.store.patchFlagsTop = !0, this.setBackgroundImage(void 0), t && this.render();
  }
  emit(t, i) {
    this.store.emitter.emit(t, i);
  }
  on(t, i) {
    return this.store.emitter.on(t, i), this;
  }
  off(t, i) {
    return this.store.emitter.off(t, i), this;
  }
  // customeDock = (store, rect, pens, offset) => {xDock, yDock}
  // customDock return:
  // {
  //   xDock: {x, y, step, prev, penId},
  //   yDock: {x, y, step, prev, penId},
  // }
  // xDock，yDock - 水平或垂直方向的参考线
  // prev - 参考线的起点
  // x,y - 参考线的终点
  // step - 自动吸附需要的偏移量
  // penId - 参考线的笔
  registerMoveDock(t) {
    this.canvas.customMoveDock = t;
  }
  /**
   * 参数同方法 registerMoveDock ，最后一个参数由 offset 偏移修改成了当前 resize 的点
   */
  registerResizeDock(t) {
    this.canvas.customResizeDock = t;
  }
  find(t) {
    return this.canvas.find(t);
  }
  findOne(t) {
    return this.canvas.findOne(t);
  }
  getPenRect(t) {
    return this.canvas.getPenRect(t);
  }
  setPenRect(t, i, s = !0) {
    this.canvas.setPenRect(t, i, s);
  }
  startAnimate(t, i) {
    this.stopAnimate(t);
    let s;
    t ? typeof t == "string" ? s = this.find(t) : s = t : s = this.store.data.pens.filter((o) => (o.type || o.frames) && o.autoPlay || o.animations && o.animations.length && o.animations.findIndex((a) => a.autoPlay) !== -1), s.length && (s.forEach((o) => {
      var a, r;
      if (o.calculative.pause) {
        const l = Date.now() - o.calculative.pause;
        o.calculative.pause = void 0, o.calculative.frameStart += l, o.calculative.frameEnd += l;
      } else {
        let l = -1;
        if (i !== void 0 && o.animations) {
          if (typeof i == "string") {
            if (l = o.animations.findIndex(
              (n) => n.name === i
            ), l === -1)
              return;
          } else if (typeof i == "number")
            if (o.animations.length > i)
              l = i;
            else
              return;
        } else i === void 0 && (l = (a = o.animations) == null ? void 0 : a.findIndex((n) => n.autoPlay), l === -1 && ((r = o.animations) != null && r.length) && (l = 0));
        if (l !== -1 && l !== void 0) {
          const n = G(o.animations[l]);
          n.animateName = n.name, delete n.name, n.currentAnimation = l, !o.type && n.frames && (n.showDuration = this.calcAnimateDuration(n)), this.setValue(
            {
              id: o.id,
              ...n
            },
            {
              doEvent: !1,
              history: !1
            }
          );
        }
        this.store.animates.add(o), o.type || this.store.animateMap.set(
          o,
          o.calculative.canvas.getFrameProps(o)
        );
      }
    }), this.initImageCanvas(s), this.canvas.animate());
  }
  pauseAnimate(t) {
    let i = [];
    t ? typeof t == "string" ? i = this.find(t) : i = t : this.store.animates.forEach((s) => {
      i.push(s);
    }), i.forEach((s) => {
      s.calculative.pause || (s.calculative.pause = Date.now());
    });
  }
  stopAnimate(t) {
    let i = [];
    t ? typeof t == "string" ? i = this.find(t) : i = t : this.store.animates.forEach((s) => {
      i.push(s);
    }), i.forEach((s) => {
      s.currentAnimation = void 0, s.calculative.pause = void 0, s.calculative.start = void 0, s.calculative.duration = void 0, s.calculative.animatePos = 0, this.store.animates.delete(s), this.canvas.restoreNodeAnimate(s), this.canvas.updateLines(s), this.store.animateMap.delete(s);
    }), this.initImageCanvas(i), setTimeout(() => {
      var s;
      (s = this.canvas) == null || s.calcActiveRect(), this.render();
    }, 20);
  }
  startVideo(t) {
    let i;
    t ? typeof t == "string" ? i = this.find(t) : i = t : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var o, a;
      (o = s.calculative.media) == null || o.play(), (a = s.onStartVideo) == null || a.call(s, s);
    });
  }
  pauseVideo(t) {
    let i = [];
    t ? typeof t == "string" ? i = this.find(t) : i = t : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var o, a;
      (o = s.calculative.media) == null || o.pause(), (a = s.onPauseVideo) == null || a.call(s, s);
    });
  }
  stopVideo(t) {
    let i = [];
    t ? typeof t == "string" ? i = this.find(t) : i = t : i = this.store.data.pens.filter((s) => (s.video || s.audio) && s.autoPlay), i.forEach((s) => {
      var o;
      s.calculative.media && (s.calculative.media.currentTime = 0, s.calculative.media.pause()), (o = s.onStopVideo) == null || o.call(s, s);
    });
  }
  calcAnimateDuration(t) {
    return t.frames.reduce((i, s) => i + s.duration, 0);
  }
  /**
   * 组合
   * @param pens 组合的画笔们
   * @param showChild 组合后展示第几个孩子
   */
  combine(t = this.store.active, i) {
    if (!t || !t.length)
      return;
    const s = G(t);
    if (t.length === 1 && t[0].type) {
      t[0].type = ft.Node, this.canvas.active(t), this.pushHistory({
        type: it.Update,
        initPens: s,
        pens: G(t, !0)
      }), this.render();
      return;
    }
    const o = jt(t);
    let a = {
      id: nt(),
      name: "combine",
      ...o,
      children: [],
      showChild: i
    };
    this.canvas.makePen(a);
    const r = G(a);
    let l = 1 / 0;
    return t.forEach((n) => {
      const h = this.store.data.pens.findIndex(
        (d) => d.id === n.id
      );
      if (h < l && (l = h), n === a || n.parentId === a.id || n.id === a.id)
        return;
      a.children.push(n.id), n.parentId = a.id;
      const c = ae(n.calculative.worldRect, o);
      Object.assign(n, c), n.locked = n.lockedOnCombine ?? ht.None, n.locked = n.interaction || Ei.includes(n.name) ? 0 : n.locked;
    }), this.store.data.pens.splice(l, 0, a), this.store.data.pens.pop(), this.canvas.active([a]), this.pushHistory({
      type: it.Add,
      pens: [r],
      step: 3
    }), this.pushHistory({
      type: it.Update,
      initPens: [r],
      pens: [a],
      step: 3
    }), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: t,
      step: 3
    }), i != null && (t.forEach((n) => {
      Kt(n, !0);
    }), this.initImageCanvas([a])), this.store.emitter.emit("combine", [a]), this.render(), a;
  }
  uncombine(t) {
    if (!t && this.store.active && (t = this.store.active[0]), !t || !t.children)
      return;
    const i = t.children.map((a) => this.store.pens[a]);
    let s = G(i);
    i.forEach((a) => {
      a.parentId = void 0, a.x = a.calculative.worldRect.x, a.y = a.calculative.worldRect.y, a.width = a.calculative.worldRect.width, a.height = a.calculative.worldRect.height, a.locked = ht.None, a.calculative.active = void 0, a.calculative.hover = !1, this.setVisible(a, !0);
    });
    const o = this.isCombine(t) ? 3 : 2;
    this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: i,
      step: o
    }), s = [G(t)], t.children = void 0, this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: [t],
      step: o
    }), this.isCombine(t) && (this.delete([t]), this.store.histories[this.store.histories.length - 1].step = o), this.inactive();
  }
  appendChild(t = this.store.active) {
    if (!t || t.length < 2)
      return;
    const i = t.findIndex((s) => s.name === "combine" && s.showChild !== void 0);
    if (i !== -1) {
      let s = t[i];
      const o = jt(t);
      Object.assign(s, o), Object.assign(s.calculative.worldRect, o), ze(s), s.children.forEach((a) => {
        const r = this.store.pens[a], l = ae(r.calculative.worldRect, o);
        Object.assign(r, l);
      }), t.forEach((a) => {
        if (a.id !== s.id) {
          s.children.push(a.id), a.parentId = s.id;
          const r = ae(a.calculative.worldRect, o);
          Object.assign(a, r), a.locked = a.lockedOnCombine ?? ht.DisableMove, a.locked = a.interaction || Ei.includes(a.name) ? 0 : a.locked, Kt(a, !0);
        }
      }), this.initImageCanvas(t), this.render();
    } else
      console.warn("Invalid operation!");
  }
  /***
   * 修改子图元大小，更新整个组合图元
   * @param rect 新的大小 世界坐标
   * @param child 待更新子图元
   * @param parent 父图元
   */
  updateRectbyChild(t, i, s) {
    if (wt(t), pt(t), i.calculative.worldRect = t, Jt(t, s.calculative.worldRect, !0)) {
      const o = ae(t, s.calculative.worldRect);
      Object.assign(i, o);
    } else {
      let o = Math.min(t.x, s.calculative.worldRect.x), a = Math.min(t.y, s.calculative.worldRect.y), r = Math.max(t.ex, s.calculative.worldRect.ex), l = Math.max(t.ey, s.calculative.worldRect.ey);
      s.calculative.worldRect = {
        x: o,
        y: a,
        width: r - o,
        height: l - a,
        ex: r,
        ey: l
      }, s.parentId || Object.assign(s, s.calculative.worldRect), pt(s.calculative.worldRect), s.children.forEach((n) => {
        const h = this.store.pens[n], c = ae(h.calculative.worldRect, s.calculative.worldRect);
        Object.assign(h, c);
      }), s.parentId && this.updateRectbyChild(s.calculative.worldRect, s, this.store.pens[s.parentId]);
    }
    this.canvas.updatePenRect(s), this.render();
  }
  isCombine(t) {
    return !!(t.name === "combine" || t.children && t.children.length > 0);
  }
  active(t, i = !0) {
    this.canvas.active(t, i);
  }
  inactive() {
    this.canvas.inactive();
  }
  activeAll() {
    this.canvas.active(
      this.store.data.pens.filter(
        (t) => !t.parentId && t.locked !== ht.Disable
      )
    ), this.render();
  }
  focus(t) {
    const i = this.findOne(t);
    i && (this.store.hover = i, this.store.hover.calculative.hover = !0, this.showInput(i));
  }
  /**
   * 删除画笔
   * @param pens 需要删除的画笔们
   * @param canDelLocked 是否删除已经锁住的画笔
   */
  delete(t, i = !1, s = !0) {
    this.canvas.delete(t, i, s);
  }
  scale(t, i = { x: 0, y: 0 }) {
    this.canvas.scale(t, i);
  }
  translate(t, i) {
    this.canvas.translate(t, i);
  }
  translatePens(t, i, s) {
    this.canvas.translatePens(t, i, s);
  }
  getParent(t, i) {
    return Nt(t, i);
  }
  getAllChildren(t) {
    return Ut(t, this.store);
  }
  getAllFollowers(t) {
    return us(t, this.store);
  }
  data() {
    const t = G(this.store.data), { pens: i, paths: s } = this.store.data;
    t.version = xo.version, t.paths = {};
    for (const o in s)
      Object.prototype.hasOwnProperty.call(s, o) && i.find((a) => a.pathId === o) && (t.paths[o] = s[o]);
    return t.dataPoints = [...Object.keys(this.store.bind), ...Object.keys(this.store.bindDatas)], t;
  }
  copy(t) {
    this.canvas.copy(t);
  }
  cut(t) {
    this.canvas.cut(t);
  }
  paste() {
    this.canvas.paste();
  }
  undo() {
    this.canvas.undo();
  }
  redo() {
    this.canvas.redo();
  }
  listenSocket() {
    try {
      let t;
      const i = this.store.data.socketCbJs;
      if (i && (t = new Function("e", "context", i)), !t)
        return this.socketFn = null, !1;
      this.socketFn = t;
    } catch (t) {
      return console.error("Create the function for socket:", t), !1;
    }
    return !0;
  }
  connectWebsocket(t) {
    this.closeWebsocket(), t && (this.store.data.websocket = t), this.store.data.websocket && (this.websocket = new WebSocket(
      this.store.data.websocket,
      this.store.data.websocketProtocols || void 0
    ), this.websocket.onmessage = (i) => {
      this.socketCallback(i.data, {
        type: "websocket",
        url: this.store.data.websocket
      });
    }, this.websocket.onerror = (i) => {
      this.store.emitter.emit("error", { type: "websocket", error: i });
    }, this.websocket.onclose = () => {
      if (this.store.options.reconnetTimes && (this.websocketTimes++, this.websocketTimes >= this.store.options.reconnetTimes)) {
        this.websocketTimes = 0, this.closeWebsocket();
        return;
      }
      console.info("Canvas websocket closed and reconneting..."), this.connectWebsocket();
    });
  }
  closeWebsocket() {
    this.websocket && (this.websocket.onclose = void 0, this.websocket.close(), this.websocket = void 0);
  }
  connectMqtt(t) {
    if (this.closeMqtt(), t && (this.store.data.mqtt = t.mqtt, this.store.data.mqttTopics = t.mqttTopics, this.store.data.mqttOptions = t.mqttOptions), this.store.data.mqtt) {
      this.store.data.mqttOptions.clientId && !this.store.data.mqttOptions.customClientId && (this.store.data.mqttOptions.clientId = nt());
      const i = { ...this.store.data.mqttOptions };
      i.username || delete i.username, i.password || delete i.password;
      const { username: s, password: o } = i;
      s && o || !s && !o ? (this.mqttClient = vi.connect(
        this.store.data.mqtt,
        i
      ), this.mqttClient.on("message", (a, r) => {
        this.socketCallback(r.toString(), {
          topic: a,
          type: "mqtt",
          url: this.store.data.mqtt
        });
      }), this.mqttClient.on("error", (a) => {
        this.store.emitter.emit("error", { type: "mqtt", error: a });
      }), this.mqttClient.on("close", () => {
        this.store.options.reconnetTimes && (this.mqttTimes++, this.mqttTimes >= this.store.options.reconnetTimes && (this.mqttTimes = 0, this.closeMqtt()));
      }), this.store.data.mqttTopics && this.mqttClient.subscribe(this.store.data.mqttTopics.split(","))) : console.warn("缺少用户名或密码");
    }
  }
  closeMqtt() {
    var t;
    (t = this.mqttClient) == null || t.end();
  }
  connectHttp() {
    this.closeHttp();
    const { https: t } = this.store.data;
    if (t)
      this.store.data.cancelFirstConnect || t.forEach(async (i) => {
        this.oldRequestHttp(i);
      }), t.forEach((i, s) => {
        i.http && (i.times = 0, this.httpTimerList[s] = setInterval(async () => {
          this.oldRequestHttp(i), this.store.options.reconnetTimes && (i.times++, i.times >= this.store.options.reconnetTimes && (i.times = 0, clearInterval(this.httpTimerList[s]), this.httpTimerList[s] = void 0));
        }, i.httpTimeInterval || 1e3));
      });
    else {
      const { http: i, httpTimeInterval: s, httpHeaders: o } = this.store.data;
      i && (this.httpTimer = setInterval(async () => {
        const a = await fetch(i, {
          headers: o
        });
        if (a.ok) {
          const r = await a.text();
          this.socketCallback(r, { type: "http", url: i });
        }
      }, s || 1e3));
    }
  }
  async oldRequestHttp(t) {
    let i = G(t);
    if (i.http) {
      const s = await fetch(i.http, {
        headers: i.httpHeaders,
        method: i.method || "GET",
        body: i.method === "POST" ? JSON.stringify(i.body) : void 0
      });
      if (s.ok) {
        const o = await s.text();
        this.socketCallback(o, { type: "http", url: i.http });
      } else
        this.store.emitter.emit("error", { type: "http", error: s });
    }
  }
  async sendDatabyHttp(t) {
    const { https: i } = this.store.data;
    if (i)
      i.forEach(async (s) => {
        s.http && (await fetch(s.http, {
          method: "post",
          body: t,
          headers: s.httpHeaders
        })).ok && console.info("http消息发送成功");
      });
    else {
      const { http: s, httpHeaders: o } = this.store.data;
      s && (await fetch(s, {
        method: "post",
        body: t,
        headers: o
      })).ok && console.info("http消息发送成功");
    }
  }
  closeHttp() {
    clearInterval(this.httpTimer), this.httpTimer = void 0, this.httpTimerList && this.httpTimerList.forEach((t) => {
      clearInterval(t), t = void 0;
    });
  }
  connectNetwork() {
    this.closeNetwork();
    const { networks: t } = this.store.data, i = [];
    if (t) {
      let s = 0;
      this.mqttClients = [];
      let o = 0, a = 0;
      this.websockets = [], t.forEach(async (r) => {
        if (r.protocol === "mqtt")
          r.index = s, r.options.clientId && !r.options.customClientId && (r.options.clientId = nt()), r.times = 0, this.mqttClients[s] = vi.connect(r.url, r.options), this.mqttClients[s].on(
            "message",
            (l, n) => {
              this.socketCallback(n.toString(), {
                topic: l,
                type: "mqtt",
                url: r.url
              });
            }
          ), this.mqttClients[s].on("error", (l) => {
            this.store.emitter.emit("error", { type: "mqtt", error: l });
          }), this.mqttClients[s].on("close", () => {
            var l;
            this.store.options.reconnetTimes && (r.times++, r.times >= this.store.options.reconnetTimes && (r.times = 0, this.mqttClients && ((l = this.mqttClients[r.index]) == null || l.end())));
          }), r.topics && this.mqttClients[s].subscribe(r.topics.split(",")), s += 1;
        else if (r.protocol === "websocket")
          r.index = o, this.connectNetWebSocket(r), o += 1;
        else if (r.protocol === "http")
          i.push({
            url: r.url,
            interval: r.interval,
            headers: r.headers || void 0,
            method: r.method,
            body: r.body
          });
        else if (r.protocol === "iot") {
          const l = await this.getIotToken(r.devices);
          r.method === "mqtt" ? (r.index = s, this.mqttClients[s] = vi.connect(r.url), this.mqttClients[s].on("message", (n, h) => {
            this.socketCallback(h.toString(), {
              topic: `le5le-iot/properties/${l}`,
              type: "iot",
              url: r.url,
              method: "mqtt"
            });
          }), this.mqttClients[s].on("error", (n) => {
            this.store.emitter.emit("error", { type: "mqtt", error: n });
          }), this.mqttClients[s].subscribe(`le5le-iot/properties/${l}`), s += 1) : r.method === "websocket" && (r.index = o, this.websockets[o] = new WebSocket(
            `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/api/ws/iot/properties`,
            l
          ), this.websockets[o].onmessage = (n) => {
            this.socketCallback(n.data, { type: "iot", method: "websocket" });
          }, this.websockets[o].onerror = (n) => {
            this.store.emitter.emit("error", { type: "websocket", error: n });
          }, o += 1);
        } else r.protocol === "sql" ? (await this.doSqlCode("list", r.dbId, r.sql), r.interval && (r.index = a, this.sqlTimerList[a] = setInterval(async () => {
          await this.doSqlCode("list", r.dbId, r.sql);
        }, r.interval), a += 1)) : r.protocol === "jetLinks" && this.jetLinksList.length && (this.jetLinksClient = new WebSocket(
          `${r.url}/${localStorage.getItem("X-Access-Token") || this.getCookie("X-Access-Token") || new URLSearchParams(location.search).get("X-Access-Token") || ""}`
          // 'ws://8.134.86.52:29000/api/messaging/961d8b395298d3ec3a021df70d6b6ca4'
        ), this.jetLinksClient.onmessage = (l) => {
          var h;
          const n = JSON.parse(l.data);
          if (n.payload && n.payload.success && ((h = n.payload) != null && h.properties)) {
            const c = [];
            for (let d in n.payload.properties)
              d.startsWith("_") || c.push({
                id: `${n.payload.headers.productId}#${n.payload.deviceId}#${d}`,
                value: n.payload.properties[d]
              });
            this.setDatas(c, { history: !1 });
          }
        }, this.jetLinksClient.onopen = () => {
          this.jetLinksList.forEach((l) => {
            this.jetLinksClient.send(JSON.stringify({
              type: "sub",
              topic: `/device${l.topic}/message/property/report`,
              parameter: {
                deviceId: l.deviceId,
                properties: l.properties,
                history: 1
              },
              id: l.topic + "-" + nt()
            }));
          });
        });
      });
    }
    this.onNetworkConnect(i);
  }
  connectNetWebSocket(t) {
    var i;
    this.websockets[t.index] && (this.websockets[t.index].onclose = void 0, (i = this.websockets[t.index]) == null || i.close(), this.websockets[t.index] = void 0), this.websockets[t.index] = new WebSocket(
      t.url,
      t.protocols || void 0
    ), this.websockets[t.index].onmessage = (s) => {
      this.socketCallback(s.data, { type: "websocket", url: t.url });
    }, this.websockets[t.index].onerror = (s) => {
      this.store.emitter.emit("error", { type: "websocket", error: s });
    }, this.websockets[t.index].onclose = () => {
      var s;
      if (this.store.options.reconnetTimes && (t.times++, t.times >= this.store.options.reconnetTimes)) {
        t.times = 0, this.websockets[t.index].onclose = void 0, (s = this.websockets[t.index]) == null || s.close(), this.websockets[t.index] = void 0;
        return;
      }
      setTimeout(() => {
        console.info("Canvas websocket closed and reconneting..."), this.connectNetWebSocket(t);
      }, 2e3);
    };
  }
  async getIotToken(t) {
    const i = await fetch("/api/iot/subscribe/properties", {
      method: "POST",
      body: JSON.stringify({ devices: t })
    });
    if (i.ok) {
      const s = await i.text();
      return JSON.parse(s).token;
    }
  }
  async doSqlCode(t, i, s) {
    const o = await fetch(`/api/iot/data/sql/${t}`, {
      method: "POST",
      body: JSON.stringify({ dbid: i, sql: s })
    });
    if (o.ok) {
      const a = await o.text();
      a && this.socketCallback(a, { type: "sql", url: `/api/iot/data/sql/${t}` });
    }
  }
  randomString(t) {
    t = t || 32;
    let i = "ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678", s = i.length, o = "";
    for (let a = 0; a < t; a++)
      o += i.charAt(Math.floor(Math.random() * s));
    return o;
  }
  mockValue(t) {
    let i;
    if (t.enableMock && t.mock !== void 0)
      if (t.type === "float")
        if (t.mock && t.mock.indexOf(",") !== -1) {
          let s = t.mock.split(","), o = Math.floor(Math.random() * s.length);
          i = parseFloat(s[o]);
        } else if (t.mock && t.mock.indexOf("-") !== -1) {
          let s, o, a, r = t.mock.split("-");
          if (t.mock.charAt(0) === "-" ? r.length === 4 ? (s = -parseFloat(r[3]), o = -parseFloat(r[1]), a = r[3]) : (s = parseFloat(r[2]), o = -parseFloat(r[1]), a = r[2]) : (s = parseFloat(r[1]), o = parseFloat(r[0]), a = r[1]), (a + "").indexOf(".") !== -1) {
            let l = (a + "").split(".")[1].length;
            i = (Math.random() * (s - o) + o).toFixed(
              l
            );
          } else
            i = Math.random() * (s - o) + o;
        } else
          i = parseFloat(t.mock);
      else if (t.type === "integer")
        if (t.mock && t.mock.indexOf(",") !== -1) {
          let s = t.mock.split(","), o = Math.floor(Math.random() * s.length);
          i = parseInt(s[o]);
        } else if (t.mock && t.mock.indexOf("-") !== -1) {
          let s, o, a = t.mock.split("-");
          t.mock.charAt(0) === "-" ? a.length === 4 ? (s = -parseFloat(a[3]), o = -parseFloat(a[1])) : (s = parseFloat(a[2]), o = -parseFloat(a[1])) : (s = parseInt(a[1]), o = parseInt(a[0])), i = parseInt(
            Math.random() * (s - o) + o + ""
          );
        } else
          i = parseInt(t.mock);
      else if (t.type === "bool")
        typeof t.mock == "boolean" ? i = t.mock : t.mock === "true" ? i = !0 : t.mock === "false" ? i = !1 : i = Math.random() < 0.5;
      else if (t.type === "object" || t.type === "array")
        t.mock;
      else if (t.mock && t.mock.indexOf(",") !== -1) {
        let o = t.mock.substring(1, t.mock.length - 1).split(","), a = Math.floor(Math.random() * o.length);
        i = o[a];
      } else if (t.mock && t.mock.startsWith("[") && t.mock.endsWith("]")) {
        let s = parseInt(
          t.mock.substring(1, t.mock.length - 1)
        );
        i = this.randomString(s);
      } else
        i = t.mock;
    return i;
  }
  //数据模拟
  dataMock() {
    var i, s;
    let t = [];
    (s = (i = this.store.data.dataset) == null ? void 0 : i.devices) == null || s.forEach((o) => {
      let a = this.mockValue(o);
      a !== void 0 && t.push({
        id: o.id,
        value: a
      });
    }), t.length && this.setDatas(t, {
      render: !0,
      doEvent: !0,
      history: !1
    });
  }
  startDataMock() {
    this.store.data.enableMock && (this.stopDataMock(), this.initBinds(), this.updateTimer = setInterval(() => {
      this.store.data.pens.forEach((i) => {
        this.penMock(i);
      }), this.dataMock(), this.render();
    }, this.store.data.networkInterval || 1e3));
  }
  stopDataMock() {
    clearInterval(this.updateTimer), this.updateTimer = void 0;
  }
  penMock(t) {
    var i;
    if (t.realTimes) {
      let s = {};
      if (t.realTimes.forEach((o) => {
        let a = this.mockValue(o);
        a !== void 0 && (s[o.key] = a);
      }), Object.keys(s).length) {
        let o = t.onBeforeValue ? t.onBeforeValue(t, s) : s;
        this.canvas.updateValue(t, o), (i = t.onValue) == null || i.call(t, t), this.store.emitter.emit("valueUpdate", t);
      }
    }
  }
  penNetwork(t) {
    const i = {
      url: t.apiUrl,
      method: t.apiMethod,
      headers: t.apiHeaders,
      body: t.apiBody
    };
    this.requestHttp(i), t.apiEnable ? (this.store.pensNetwork || (this.store.pensNetwork = {}), this.store.pensNetwork[t.id] = i) : delete this.store.pensNetwork[t.id];
  }
  getCookie(t) {
    let i;
    const s = new RegExp("(^| )" + t + "=([^;]*)(;|$)");
    return (i = document.cookie.match(s)) ? decodeURIComponent(i[2]) : "";
  }
  //获取动态参数
  getDynamicParam(t) {
    return Mi()[t] || localStorage[t] || this.getCookie(t) || "";
  }
  onNetworkConnect(t) {
    if (t && t.length) {
      if (this.store.pensNetwork)
        for (let i in this.store.pensNetwork)
          t.push(this.store.pensNetwork[i]);
      this.store.data.cancelFirstConnect || t.forEach(async (i) => {
        this.requestHttp(i);
      }), t.forEach((i, s) => {
        i.times = 0, this.updateTimerList[s] = setInterval(async () => {
          this.requestHttp(i), this.store.options.reconnetTimes && (i.times++, i.times >= this.store.options.reconnetTimes && (i.times = 0, clearInterval(this.updateTimerList[s]), this.updateTimerList[s] = void 0));
        }, i.interval || 1e3);
      });
    }
  }
  async requestHttp(t) {
    let i = G(t);
    if (i.url) {
      if (typeof i.headers == "object") {
        for (let o in i.headers)
          if (typeof i.headers[o] == "string") {
            let a = i.headers[o].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            a && (i.headers[o] = i.headers[o].replace(
              `\${${a[0]}}`,
              this.getDynamicParam(a[0])
            ));
          }
      }
      if (typeof i.body == "object") {
        for (let o in i.body)
          if (typeof i.body[o] == "string") {
            let a = i.body[o].match(new RegExp("(?<=\\$\\{).*?(?=\\})", "g"));
            a && (i.body[o] = i.body[o].replace(
              `\${${a[0]}}`,
              this.getDynamicParam(a[0])
            ));
          }
      }
      const s = await fetch(i.url, {
        headers: i.headers,
        method: i.method,
        body: i.method === "GET" ? void 0 : JSON.stringify(i.body)
      });
      if (s.ok) {
        const o = await s.text();
        this.socketCallback(o, { type: "http", url: i.url });
      } else
        this.store.emitter.emit("error", { type: "http", error: s });
    }
  }
  closeNetwork() {
    this.mqttClients && this.mqttClients.forEach((t) => {
      t.end();
    }), this.websockets && this.websockets.forEach((t) => {
      t && (t.onclose = void 0, t.close(), t = void 0);
    }), this.mqttClients = void 0, this.websockets = void 0, this.updateTimerList && this.updateTimerList.forEach((t) => {
      clearInterval(t), t = void 0;
    }), this.sqlTimerList && this.sqlTimerList.forEach((t) => {
      clearInterval(t), t = void 0;
    });
  }
  socketCallback(t, i) {
    this.store.emitter.emit("socket", { message: t, context: i });
    let s = t;
    if (this.socketFn && (s = this.socketFn(t, {
      meta2d: this,
      type: i.type,
      topic: i.topic,
      url: i.url,
      method: i.method
    }), !s))
      return;
    s === !0 && (s = t);
    let o;
    if (s.constructor === Object || s.constructor === Array)
      o = s;
    else if (typeof s == "string")
      try {
        o = JSON.parse(s);
      } catch (a) {
        console.warn("Invalid socket data:", o, a);
      }
    else
      return;
    o && (Array.isArray(o) || (o = [o]), o.length && (o[0].dataId ? this.setDatas(o) : o.forEach((a) => {
      this.setValue(a);
    })));
  }
  // 绑定变量方式更新组件数据
  setDatas(t, {
    render: i = !0,
    doEvent: s = !0,
    history: o
  } = {}) {
    const a = /* @__PURE__ */ new Map();
    t.forEach((n) => {
      var h, c;
      (h = this.store.bindDatas[n.dataId]) == null || h.forEach(
        (d) => {
          const u = this.store.pens[d.id];
          if (!u)
            return;
          let f = a.get(u);
          if (!u.noOnBinds && typeof u.onBinds == "function") {
            if (f)
              return;
            a.set(u, u.onBinds(u, t, d.formItem));
            return;
          }
          f ? f[d.formItem.key] = n.value : (f = {
            id: d.id,
            [d.formItem.key]: n.value
          }, a.set(u, f));
        }
      ), (c = this.store.bind[n.id || n.dataId]) == null || c.forEach((d) => {
        const u = this.store.pens[d.id];
        if (!u)
          return;
        let f = a.get(u);
        f ? f[d.key] = n.value : (f = {
          id: d.id,
          [d.key]: n.value
        }, a.set(u, f));
      });
    }), this.store.data.locked && this.doDataEvent(t);
    let r, l;
    o && (r = []), a.forEach((n, h) => {
      this.setValue(n, { render: !1, doEvent: s, history: !1 }), o && (r.push(G(h, !0)), l.push(h));
    }), i && this.render(), o && this.pushHistory({
      type: it.Update,
      initPens: r,
      pens: l
    });
  }
  setValue(t, {
    render: i = !0,
    doEvent: s = !0,
    history: o
  } = {}) {
    let a = [];
    if (!t)
      return;
    if (t.id) {
      if (t.id === this.store.data.id) {
        this.setDatabyOptions(t), t.bkImage && this.setBackgroundImage(t.bkImage), t.background && this.setBackgroundColor(t.background), this.render();
        return;
      }
      const l = this.store.pens[t.id];
      if (l)
        a = [l];
      else {
        let n = this.store.bind[t.id];
        if (n && n.length) {
          a = [], this.setDatas([t], {
            render: i,
            doEvent: s,
            history: o
          });
          return;
        }
      }
    } else if (t.dataId) {
      a = [], this.setDatas([t], {
        render: i,
        doEvent: s,
        history: o
      });
      return;
    } else if (t.tag)
      a = this.find(t.tag);
    else {
      let l = [];
      for (let n in t)
        l.push({
          dataId: n,
          id: n,
          value: t[n]
        });
      l.length && this.setDatas(l, {
        render: i,
        doEvent: s,
        history: o
      });
      return;
    }
    o = o && !this.store.data.locked;
    let r;
    if (o && (r = G(a)), a.forEach((l) => {
      var h;
      const n = l.onBeforeValue ? l.onBeforeValue(l, t) : t;
      t.frames && (this.stopAnimate([l]), t.showDuration || (t.showDuration = t.frames.reduce((c, d) => c + d.duration, 0))), ms(l, n), this.canvas.updateValue(l, n), (h = l.onValue) == null || h.call(l, l);
    }), !this.store.data.locked && this.store.active.length && !this.canvas.movingPens && this.canvas.calcActiveRect(), o) {
      let l = G(a);
      this.pushHistory({
        type: it.Update,
        initPens: r,
        pens: l
      });
    }
    s && a.forEach((l) => {
      this.store.emitter.emit("valueUpdate", l);
    }), i && this.render();
  }
  /**
   * @deprecated 改用 setValue
   */
  _setValue(t, i = !1) {
    this.setValue(t, { history: i, render: !1, doEvent: !1 });
  }
  pushHistory(t) {
    this.canvas.pushHistory(t);
  }
  showInput(t, i) {
    this.canvas.showInput(t, i);
  }
  hideInput() {
    this.canvas.hideInput();
  }
  clearDropdownList() {
    this.canvas.clearDropdownList();
  }
  clearRuleLines() {
    this.canvas.clearRuleLines();
  }
  doMessageEvent(t, i) {
    this.store.messageEvents[t] && this.store.messageEvents[t].forEach((s) => {
      let o = !1;
      s.event.conditions && s.event.conditions.length ? s.event.conditionType === "and" ? o = s.event.conditions.every((a) => this.judgeCondition(s.pen, a.key, a)) : s.event.conditionType === "or" && (o = s.event.conditions.some((a) => this.judgeCondition(s.pen, a.key, a))) : o = !0, o && s.event.actions.forEach((a) => {
        this.events[a.action](s.pen, a);
      });
    });
  }
  initGlobalTriggers() {
    var t;
    this.store.globalTriggers = {}, (t = this.store.data.triggers) == null || t.forEach((i) => {
      i.conditions.forEach((s) => {
        s.source && (this.store.globalTriggers[s.source] || (this.store.globalTriggers[s.source] = []), this.store.globalTriggers[s.source].includes(i) || this.store.globalTriggers[s.source].push(i));
      });
    });
  }
  initMessageEvents() {
    this.store.messageEvents = {}, this.store.data.pens.forEach((t) => {
      var i;
      (i = t.events) == null || i.forEach((s) => {
        s.name === "message" && s.message && (this.store.messageEvents[s.message] || (this.store.messageEvents[s.message] = []), this.store.messageEvents[s.message].push({
          pen: t,
          event: s
        }));
      });
    });
  }
  dataJudegeCondition(t, i, s) {
    const { type: o, target: a, fnJs: r, fn: l, operator: n, valueType: h } = s;
    let c = !1;
    if (o === "fn") {
      if (l)
        c = l(t, { meta2d: this });
      else if (r) {
        try {
          s.fn = new Function("data", "context", r);
        } catch (d) {
          console.error("Error: make function:", d);
        }
        s.fn && (c = s.fn(t, { meta2d: this }));
      }
    } else {
      let d = s.value;
      h === "prop" && (d = t[s.value]);
      let u = t[i];
      switch (n) {
        case ">":
          c = u > +d;
          break;
        case ">=":
          c = u >= +d;
          break;
        case "<":
          c = u < +d;
          break;
        case "<=":
          c = u <= +d;
          break;
        case "=":
        case "==":
          c = u == d;
          break;
        case "!=":
          c = u != d;
          break;
        case "[)":
          c = Ce(+u, d);
          break;
        case "![)":
          c = !Ce(+u, d);
          break;
        case "[]":
          c = Re(u, d);
          break;
        case "![]":
          c = !Re(u, d);
          break;
      }
    }
    return c;
  }
  judgeCondition(t, i, s) {
    const { type: o, target: a, fnJs: r, fn: l, operator: n, valueType: h } = s;
    let c = !1;
    if (o === "fn") {
      if (l)
        c = l(t, { meta2d: this });
      else if (r) {
        try {
          s.fn = new Function("pen", "context", r);
        } catch (d) {
          console.error("Error: make function:", d);
        }
        s.fn && (c = s.fn(t, { meta2d: this }));
      }
    } else {
      let d = s.value;
      h === "prop" && (d = this.store.pens[a][s.value]);
      let u = Me(t, i);
      switch (["x", "y", "width", "height"].includes(i) && (u = this.getPenRect(t)[i]), n) {
        case ">":
          c = u > +d;
          break;
        case ">=":
          c = u >= +d;
          break;
        case "<":
          c = u < +d;
          break;
        case "<=":
          c = u <= +d;
          break;
        case "=":
        case "==":
          c = u == d;
          break;
        case "!=":
          c = u != d;
          break;
        case "[)":
          c = Ce(+u, d);
          break;
        case "![)":
          c = !Ce(+u, d);
          break;
        case "[]":
          c = Re(u, d);
          break;
        case "![]":
          c = !Re(u, d);
          break;
      }
    }
    return c;
  }
  pushChildren(t, i) {
    const s = [G(t, !0)], o = [];
    t.children || (t.children = []);
    const a = [];
    i.forEach((l) => {
      let n = G(l, !0);
      if ((!l.id || !this.store.pens[l.id]) && (this.canvas.makePen(l), n = null), l.parentId) {
        const c = this.store.pens[l.parentId], d = c.children.findIndex((u) => u === l.id);
        s.push(G(c, !0)), c.children.splice(d, 1), a.push(G(c, !0));
      }
      t.children.push(l.id), l.parentId = t.id;
      const h = ae(
        l.calculative.worldRect,
        t.calculative.worldRect
      );
      Object.assign(l, h), l.locked = l.lockedOnCombine ?? ht.DisableMove, l.locked = l.interaction || Ei.includes(l.name) ? 0 : l.locked, n ? (s.push(n), a.push(G(l, !0))) : o.push(G(l, !0));
    }), a.push(G(t, !0));
    let r = 1;
    o.length && (r = 2, this.pushHistory({
      type: it.Add,
      pens: o,
      step: r
    })), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: a,
      step: r
    });
  }
  toPng(t, i, s = !1, o) {
    return this.canvas.toPng(t, i, s, o);
  }
  activeToPng(t, i) {
    return this.canvas.activeToPng(t, i);
  }
  pensToPng(t = this.store.active, i, s) {
    return this.canvas.pensToPng(t, i, s);
  }
  /**
   * 下载 png
   * @param name 传入参数自带文件后缀名 例如：'test.png'
   * @param padding 上右下左的内边距
   */
  downloadPng(t, i, s) {
    var o;
    for (const a of this.store.data.pens)
      (a.calculative.img || ["iframe"].includes(a.name)) && ((o = a.onRenderPenRaw) == null || o.call(a, a));
    setTimeout(() => {
      const a = document.createElement("a");
      a.setAttribute(
        "download",
        (t || this.store.data.name || "le5le.meta2d") + ".png"
      ), a.setAttribute("href", this.toPng(i, void 0, !0, s));
      const r = document.createEvent("MouseEvents");
      r.initEvent("click", !0, !0), a.dispatchEvent(r);
    }, 1e3);
  }
  downloadSvg() {
    if (!window.C2S)
      throw console.error(
        "请先加载乐吾乐官网下的canvas2svg.js",
        "https://assets.le5lecdn.com/2d/canvas2svg.js"
      ), new Error("请先加载乐吾乐官网下的canvas2svg.js");
    const t = this.getRect();
    t.x -= 10, t.y -= 10;
    const i = new window.C2S(t.width + 20, t.height + 20);
    i.textBaseline = "middle";
    for (const h of this.store.data.pens)
      h.visible == !1 || !Ii(h, this.store) || ki(i, h, t, !0);
    let s = i.getSerializedSvg();
    this.store.data.background ? (s = s.replace("{{bk}}", ""), s = s.replace(
      "{{bkRect}}",
      `<rect x="0" y="0" width="100%" height="100%" fill="${this.store.data.background}"></rect>`
    )) : (s = s.replace("{{bk}}", ""), s = s.replace("{{bkRect}}", "")), s = s.replace(/--le5le--/g, "&#x");
    const o = window.URL, a = new Blob([s]), r = o.createObjectURL(a), l = document.createElement("a");
    l.setAttribute("download", `${this.store.data.name || "le5le.meta2d"}.svg`), l.setAttribute("href", r);
    const n = document.createEvent("MouseEvents");
    n.initEvent("click", !0, !0), l.dispatchEvent(n);
  }
  getRect(t = this.store.data.pens) {
    return jt(t);
  }
  hiddenTemplate() {
    this.canvas.canvasTemplate.hidden();
  }
  showTemplate() {
    this.canvas.canvasTemplate.show();
  }
  lockTemplate(t) {
    this.store.data.pens.forEach((i) => {
      i.canvasLayer === dt.CanvasTemplate && (i.locked = t);
    });
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitView(t = !0, i = 10) {
    var d, u;
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: o, offsetHeight: a } = s;
    this.resize(o, a);
    const r = Xt(i), l = this.getRect(), n = (o - r[1] - r[3]) / l.width, h = (a - r[0] - r[2]) / l.height;
    let c = n;
    t ? c = n > h ? h : n : c = n > h ? n : h, (d = this.store.data.fits) != null && d.length && (this.canvas.opening = !0), this.scale(c * this.store.data.scale), this.centerView(), (u = this.store.data.fits) != null && u.length && this.fillView();
  }
  fillView() {
    var o, a;
    const t = this.getRect(), i = this.canvas.width - t.width, s = this.canvas.height - t.height;
    if (Math.abs(i) > 10) {
      (o = this.store.data.fits) == null || o.forEach((l) => {
        let n = [];
        l.children.forEach((c) => {
          this.store.pens[c].locked = ht.None, n.push(this.store.pens[c]);
        });
        let h = i / 2;
        if (l.left && l.right) {
          let c = l.leftValue, d = l.rightValue;
          c ? c = Math.abs(c) < 1 ? c * this.canvas.width : c : c = 0, d ? d = Math.abs(d) < 1 ? d * this.canvas.width : d : d = 0;
          let u = (this.canvas.width - c - d) / (t.width - c - d);
          n.forEach((f) => {
            var g;
            f.image && f.imageRatio && f.calculative.worldRect.width / this.canvas.width > 0.1 && (f.imageRatio = !1), f.calculative.worldRect.x = t.x - i / 2 + c + (f.calculative.worldRect.x - t.x) * u, f.calculative.worldRect.width *= u, f.calculative.worldRect.ex = f.calculative.worldRect.x + f.calculative.worldRect.width, f.calculative.width = f.calculative.worldRect.width, f.calculative.x = f.calculative.worldRect.x, f.width = f.calculative.worldRect.width, f.x = f.calculative.worldRect.x, this.canvas.updatePenRect(f, { worldRectIsReady: !1 }), f.externElement && ((g = f.onResize) == null || g.call(f, f));
          });
        } else l.left ? (h = -h, l.leftValue && (h += Math.abs(l.leftValue) < 1 ? l.leftValue * this.canvas.width : l.leftValue), this.translatePens(n, h, 0)) : l.right && (l.rightValue && (h = h - (Math.abs(l.rightValue) < 1 ? l.rightValue * this.canvas.width : l.rightValue)), this.translatePens(n, h, 0));
      });
      const r = this.store.data.pens.filter((l) => l.name === "iframe");
      r == null || r.forEach((l) => {
        var h, c;
        const n = l.calculative.worldRect;
        if (n.width / this.store.data.scale > t.width * 0.8) {
          let d = n.width;
          l.calculative.worldRect.x = n.x - i / 2, l.calculative.worldRect.width = n.width + i, l.calculative.worldRect.ex = n.ex + i, l.operationalRect.x = l.operationalRect.x * d / l.calculative.worldRect.width, l.operationalRect.width = (l.calculative.worldRect.width - (1 - l.operationalRect.width) * d) / l.calculative.worldRect.width, (h = l.onBeforeValue) == null || h.call(l, l, {
            operationalRect: l.operationalRect
          }), (c = l.onResize) == null || c.call(l, l);
        }
      });
    }
    if (Math.abs(s) > 10) {
      (a = this.store.data.fits) == null || a.forEach((l) => {
        let n = [];
        l.children.forEach((c) => {
          this.store.pens[c].locked = ht.None, n.push(this.store.pens[c]);
        });
        let h = s / 2;
        if (l.top && l.bottom) {
          let c = l.topValue, d = l.bottomValue;
          c ? c = Math.abs(c) < 1 ? c * this.canvas.height : c : c = 0, d ? d = Math.abs(d) < 1 ? d * this.canvas.height : d : d = 0;
          let u = (this.canvas.height - c - d) / (t.height - c - d);
          n.forEach((f) => {
            var g;
            f.image && f.imageRatio && f.calculative.worldRect.height / this.canvas.height > 0.1 && (f.imageRatio = !1), f.calculative.worldRect.y = t.y - s / 2 + c + (f.calculative.worldRect.y - t.y) * u, f.calculative.worldRect.height *= u, f.calculative.worldRect.ey = f.calculative.worldRect.y + f.calculative.worldRect.height, f.calculative.height = f.calculative.worldRect.height, f.calculative.y = f.calculative.worldRect.y, f.height = f.calculative.worldRect.height, f.y = f.calculative.worldRect.y, this.canvas.updatePenRect(f, { worldRectIsReady: !1 }), f.externElement && ((g = f.onResize) == null || g.call(f, f));
          });
        } else l.top ? (h = -h, l.topValue && (h += Math.abs(l.topValue) < 1 ? l.topValue * this.canvas.height : l.topValue), this.translatePens(n, 0, h)) : l.bottom && (l.bottomValue && (h = h - (Math.abs(l.bottomValue) < 1 ? l.bottomValue * this.canvas.height : l.bottomValue)), this.translatePens(n, 0, h));
      });
      const r = this.store.data.pens.filter((l) => l.name === "iframe");
      r == null || r.forEach((l) => {
        var h, c;
        const n = l.calculative.worldRect;
        if (n.height / this.store.data.scale > t.height * 0.8) {
          let d = n.height;
          l.calculative.worldRect.y = n.y - s / 2, l.calculative.worldRect.height = n.height + s, l.calculative.worldRect.ey = n.ey + s, l.operationalRect.y = l.operationalRect.y * d / l.calculative.worldRect.width, l.operationalRect.height = (l.calculative.worldRect.height - (1 - l.operationalRect.height) * d) / l.calculative.worldRect.height, (h = l.onBeforeValue) == null || h.call(l, l, {
            operationalRect: l.operationalRect
          }), (c = l.onResize) == null || c.call(l, l);
        }
      });
    }
    this.canvas.canvasTemplate.init(), this.canvas.canvasImage.init(), this.canvas.canvasImageBottom.init(), this.render(!0);
  }
  trimPens() {
    let t = this.store.data.pens.filter(
      (i) => i.name === "line" && i.anchors.length < 2
    );
    this.delete(t);
  }
  /**
   * 放大到屏幕尺寸，并居中
   * @param fit true，填满但完整展示；false，填满，但长边可能截取（即显示不完整）
   */
  fitTemplateView(t = !0, i = 10) {
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: o, offsetHeight: a } = s, r = Xt(i), l = this.getRect(), n = (o - r[1] - r[3]) / l.width, h = (a - r[0] - r[2]) / l.height;
    let c = n;
    t ? c = n > h ? h : n : c = n > h ? n : h, this.canvas.templateScale(c * this.store.data.scale);
    let d = this.getRect(), u = this.store.data.pens.filter((f) => !f.parentId);
    this.canvas.templateTranslatePens(u, -d.x, -d.y), this.store.data.pens.forEach((f) => {
      f.type ? this.canvas.initLineRect(f) : this.canvas.updateLines(f);
    }), this.centerView();
  }
  fitSizeView(t = !0, i = 10) {
    var u, f;
    const { canvas: s } = this.canvas, { offsetWidth: o, offsetHeight: a } = s;
    this.resize(o, a);
    const r = Xt(i), l = (this.store.data.width || this.store.options.width) * this.store.data.scale, n = (this.store.data.height || this.store.options.height) * this.store.data.scale, h = (o - r[1] - r[3]) / l, c = (a - r[0] - r[2]) / n;
    let d = h;
    t === "width" ? d = h : t === "height" ? d = c : t ? d = h > c ? c : h : d = h > c ? h : c, (u = this.store.data.fits) != null && u.length && (this.canvas.opening = !0), this.scale(d * this.store.data.scale), this.centerSizeView(), (f = this.store.data.fits) != null && f.length && this.fillView();
  }
  centerSizeView() {
    const t = this.getViewCenter(), i = this.store.data.width || this.store.options.width, s = this.store.data.height || this.store.options.height, o = {
      x: 0,
      y: 0,
      width: i,
      height: s
    };
    pt(o);
    const { center: a } = o, { scale: r, origin: l, x: n, y: h } = this.store.data;
    this.translate(
      (t.x - l.x) / r - a.x - n / r,
      (t.y - l.y) / r - a.y - h / r
    );
    const { canvas: c } = this.canvas, d = (c.scrollWidth - c.offsetWidth) / 2, u = (c.scrollHeight - c.offsetHeight) / 2;
    c.scrollTo(d, u);
  }
  /**
   * 宽度放大到屏幕尺寸，并滚动到最顶部
   *
   */
  scrollView(t = 10, i = !1) {
    if (!this.hasView() || !this.canvas.scroll)
      return;
    const { canvas: s } = this.canvas, { offsetWidth: o, offsetHeight: a } = s;
    this.resize(o, a);
    const r = Xt(t), l = this.getRect(), n = (o - r[1] - r[3]) / l.width;
    this.scale(n * this.store.data.scale), this.topView(r[0]), i && this.canvas.scroll.changeMode();
  }
  screenView(t = 10, i = !0) {
    if (!this.hasView()) return;
    const { canvas: s } = this.canvas, { offsetWidth: o, offsetHeight: a } = s;
    this.resize(o, a);
    const r = Xt(t), l = this.getRect();
    let n = (o - r[1] - r[3]) / l.width;
    i || (n = (a - r[0] - r[2]) / l.height), this.scale(n * this.store.data.scale), this.topView(r[0]);
  }
  topView(t = 10) {
    if (!this.hasView()) return;
    const i = this.getRect(), s = this.getViewCenter(), o = this.getPenRect(i);
    pt(o);
    const { center: a } = o, { scale: r, origin: l, x: n, y: h } = this.store.data;
    this.translate(
      (s.x - l.x) / r - a.x - n / r,
      (t - l.y) / r - o.y - h / r
    );
    const { canvas: c } = this.canvas, d = (c.scrollWidth - c.offsetWidth) / 2, u = (c.scrollHeight - c.offsetHeight) / 2;
    c.scrollTo(d, u);
  }
  centerView() {
    if (!this.hasView()) return;
    const t = this.getRect(), i = this.getViewCenter(), s = this.getPenRect(t);
    pt(s);
    const { center: o } = s, { scale: a, origin: r, x: l, y: n } = this.store.data;
    this.translate(
      (i.x - r.x) / a - o.x - l / a,
      (i.y - r.y) / a - o.y - n / a
    );
    const { canvas: h } = this.canvas, c = (h.scrollWidth - h.offsetWidth) / 2, d = (h.scrollHeight - h.offsetHeight) / 2;
    h.scrollTo(c, d);
  }
  /**
   * 画布是否有 画笔
   * RuleLine 不算
   */
  hasView() {
    return !!this.store.data.pens.filter((t) => !t.isRuleLine).length;
  }
  getViewCenter() {
    const { width: t, height: i } = this.canvas;
    return {
      x: t / 2,
      y: i / 2
    };
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByFirst(t = this.store.data.pens, i) {
    const s = G(t), o = t[0], { width: a, height: r } = this.getPenRect(o);
    for (let l = 1; l < t.length; l++) {
      const n = t[l];
      i === "width" ? this.setValue({ id: n.id, width: a }, { render: !1, doEvent: !1 }) : i === "height" ? this.setValue(
        { id: n.id, height: r },
        { render: !1, doEvent: !1 }
      ) : this.setValue(
        { id: n.id, width: a, height: r },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: t
    });
  }
  /**
   * 大小相同
   * @param pens 画笔们
   */
  beSameByLast(t = this.store.data.pens, i) {
    const s = G(t), o = t[t.length - 1], { width: a, height: r } = this.getPenRect(o);
    for (let l = 0; l < t.length - 1; l++) {
      const n = t[l];
      i === "width" ? this.setValue({ id: n.id, width: a }, { render: !1, doEvent: !1 }) : i === "height" ? this.setValue(
        { id: n.id, height: r },
        { render: !1, doEvent: !1 }
      ) : this.setValue(
        { id: n.id, width: a, height: r },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: t
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByFirst(t = this.store.data.pens) {
    const i = G(t), s = t[0], o = {};
    We.forEach((a) => {
      o[a] = s[a];
    });
    for (let a = 1; a < t.length; a++) {
      const r = t[a];
      this.setValue(
        { id: r.id, ...o },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: it.Update,
      initPens: i,
      pens: t
    });
  }
  /**
   * 格式刷（样式相同，大小无需一致。）
   * @param pens 画笔们
   */
  formatPainterByLast(t = this.store.data.pens) {
    const i = G(t), s = t[t.length - 1], o = {};
    We.forEach((a) => {
      o[a] = s[a];
    });
    for (let a = 0; a < t.length - 1; a++) {
      const r = t[a];
      this.setValue(
        { id: r.id, ...o },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: it.Update,
      initPens: i,
      pens: t
    });
  }
  setFormatPainter() {
    const t = this.store.active, i = {};
    if (t.length > 0) {
      const s = t[0];
      We.forEach((o) => {
        i[o] = s[o] !== void 0 ? s[o] : this.store.options.defaultFormat[o] || this.store.data[o] || this.store.options[o];
      });
    } else
      We.forEach((s) => {
        this.store.options.defaultFormat[s] || this.store.data[s] || this.store.options[s];
      });
    localStorage.setItem("meta2d-formatPainter", JSON.stringify(i));
  }
  formatPainter() {
    const t = this.store.active, i = G(t), s = JSON.parse(localStorage.getItem("meta2d-formatPainter"));
    for (let o = 0; o < t.length; o++) {
      const a = t[o];
      this.setValue(
        { id: a.id, ...s },
        { render: !1, doEvent: !1 }
      );
    }
    this.render(), this.pushHistory({
      type: it.Update,
      initPens: i,
      pens: t
    });
  }
  clearFormatPainter() {
    const t = this.store.active, i = G(t);
    We.forEach((s) => {
      for (let o = 0; o < t.length; o++) {
        const a = t[o], { fontSize: r, lineHeight: l } = this.store.options;
        s === "lineWidth" ? (a.lineWidth = 1, a.calculative.lineWidth = 1) : s === "fontSize" ? (a.fontSize = r, a.calculative.fontSize = r) : s === "lineHeight" ? (a.lineHeight = l, a.calculative.lineHeight = l) : (delete a[s], delete a.calculative[s]);
      }
    }), this.render(), this.pushHistory({
      type: it.Update,
      initPens: i,
      pens: t
    });
  }
  alignNodes(t, i = this.store.data.pens, s) {
    !s && (s = this.getPenRect(this.getRect(i)));
    const o = G(i);
    for (const a of i)
      this.alignPen(t, a, s);
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: it.Update,
      initPens: o,
      pens: i
    });
  }
  //对齐大屏
  alignNodesV(t, i = this.store.data.pens, s = !1) {
    const o = this.store.data.width || this.store.options.width, a = this.store.data.height || this.store.options.height;
    let r = {
      x: 0,
      y: 0,
      width: o,
      height: a
    };
    const l = G(i);
    if (s) {
      const n = this.store.data.scale, h = this.getRect(i), c = (h.x - this.store.data.origin.x) / n, d = (h.y - this.store.data.origin.y) / n, u = h.width / n, f = h.height / n;
      let g = 0, y = 0;
      switch (t) {
        case "left":
          g = -c;
          break;
        case "right":
          g = o - (c + u);
          break;
        case "top":
          y = -d;
          break;
        case "bottom":
          y = a - (d + f);
          break;
        case "center":
          g = o / 2 - (c + u / 2);
          break;
        case "middle":
          y = a / 2 - (d + f / 2);
          break;
      }
      this.translatePens(i, g * n, y * n);
    } else
      for (const n of i)
        this.alignPen(t, n, r);
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: it.Update,
      initPens: l,
      pens: i
    });
  }
  /**
   * 对齐画笔，基于第一个画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByFirst(t, i = this.store.data.pens) {
    const s = G(i), o = i[0], a = this.getPenRect(o);
    for (let r = 1; r < i.length; r++) {
      const l = i[r];
      this.alignPen(t, l, a);
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: i
    });
  }
  /**
   * 对齐画笔，基于最后选中的画笔
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pens
   */
  alignNodesByLast(t, i = this.store.data.pens) {
    const s = G(i), o = i[i.length - 1], a = this.getPenRect(o);
    for (let r = 0; r < i.length - 1; r++) {
      const l = i[r];
      this.alignPen(t, l, a);
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: it.Update,
      initPens: s,
      pens: i
    });
  }
  /**
   * 将画笔参照 rect 进行 align 对齐
   * @param align 左对齐，右对齐，上对齐，下对齐，居中对齐
   * @param pen 当前需要对齐的画笔
   * @param rect 参照矩形
   * @returns
   */
  alignPen(t, i, s) {
    const o = this.getPenRect(i);
    switch (t) {
      case "left":
        o.x = s.x;
        break;
      case "right":
        o.x = s.x + s.width - o.width;
        break;
      case "top":
        o.y = s.y;
        break;
      case "bottom":
        o.y = s.y + s.height - o.height;
        break;
      case "center":
        o.x = s.x + s.width / 2 - o.width / 2;
        break;
      case "middle":
        o.y = s.y + s.height / 2 - o.height / 2;
        break;
    }
    this.setValue(
      { id: i.id, ...o },
      { render: !1, doEvent: !1 }
    );
  }
  /**
   * 水平或垂直方向的均分
   * @param direction 方向，width 说明水平方向间距相同
   * @param pens 节点们，默认全部的
   * @param distance 总的宽 or 高
   */
  spaceBetweenByDirection(t, i = this.store.data.pens, s) {
    if (!s) {
      let h = 1 / 0, c = -1 / 0, d = t === "width" ? "x" : "y";
      i.forEach((u) => {
        h = Math.min(h, u.calculative.worldRect[d]), c = Math.max(c, u.calculative.worldRect["e" + d]);
      }), s = (c - h) / this.store.data.scale;
    }
    if (i = i.filter((h) => !h.parentId), i.length <= 2)
      return;
    const o = G(i), a = i.reduce((h, c) => {
      const d = this.getPenRect(c);
      return h + d[t];
    }, 0), r = (s - a) / (i.length - 1);
    i = i.sort((h, c) => t === "width" ? h.x - c.x : h.y - c.y);
    const l = this.getPenRect(i[0]);
    let n = t === "width" ? l.x : l.y;
    for (const h of i) {
      const c = this.getPenRect(h);
      t === "width" ? c.x = n : c.y = n, n += c[t] + r, this.setValue(
        { id: h.id, ...c },
        { render: !1, doEvent: !1 }
      );
    }
    this.initImageCanvas(i), this.initTemplateCanvas(i), this.render(), this.pushHistory({
      type: it.Update,
      initPens: o,
      pens: i
    });
  }
  spaceBetween(t, i) {
    this.spaceBetweenByDirection("width", t, i);
  }
  spaceBetweenColumn(t, i) {
    this.spaceBetweenByDirection("height", t, i);
  }
  layout(t = this.store.data.pens, i, s = 30) {
    const o = this.getPenRect(jt(t));
    !i && (i = o.width), t = t.filter((h) => !h.type && !h.parentId);
    const a = G(t);
    let r = 0;
    t.forEach((h) => {
      const c = this.getPenRect(h);
      c.height > r && (r = c.height);
    });
    let l = o.x, n = o.y;
    t.forEach((h, c) => {
      const d = this.getPenRect(h);
      if (d.x = l, d.y = n + r / 2 - d.height / 2, this.setValue(
        { id: h.id, ...d },
        { render: !1, doEvent: !1 }
      ), c === t.length - 1)
        return;
      const u = l + d.width - o.x, f = this.getPenRect(t[c + 1]);
      Math.round(i - u) >= Math.round(f.width + s) ? l += d.width + s : (l = o.x, n += r + s);
    }), this.initImageCanvas(t), this.initTemplateCanvas(t), this.render(), this.pushHistory({
      type: it.Update,
      initPens: a,
      pens: t
    });
  }
  gotoView(t) {
    const i = this.getViewCenter(), s = i.x - t.calculative.worldRect.x - t.calculative.worldRect.width / 2, o = i.y - t.calculative.worldRect.y - t.calculative.worldRect.height / 2;
    this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.translate(
      s - this.store.data.x,
      o - this.store.data.y
    ), this.store.data.x = s, this.store.data.y = o;
    for (const a of this.store.data.pens)
      Kt(a);
    this.canvas.canvasImage.init(), this.canvas.canvasImageBottom.init(), this.render();
  }
  showMap() {
    this.map || (this.map = new Yl(this.canvas)), this.map.show();
  }
  hideMap() {
    this.map.hide();
  }
  onSizeUpdate() {
    this.mapTimer && (clearTimeout(this.mapTimer), this.mapTimer = void 0), this.mapTimer = setTimeout(() => {
      this.map && this.map.isShow && this.map.show(), this.canvas.scroll && this.canvas.scroll.isShow && this.canvas.scroll.resize();
    }, 500);
  }
  toggleAnchorMode() {
    this.canvas.toggleAnchorMode();
  }
  addAnchorHand() {
    this.canvas.addAnchorHand();
  }
  removeAnchorHand() {
    this.canvas.removeAnchorHand();
  }
  toggleAnchorHand() {
    this.canvas.toggleAnchorHand();
  }
  /**
   * 将该画笔置顶，即放到数组最后，最后绘制即在顶部
   * @param pens pen 置顶的画笔
   */
  top(t) {
    t || (t = this.store.active), Array.isArray(t) || (t = [t]);
    for (const i of t) {
      const s = this.store.data.pens, o = [...Ut(i, this.store), i].map((r) => r.id);
      s.filter((r) => o.includes(r.id)).forEach((r) => {
        const l = s.findIndex((n) => n.id === r.id);
        l > -1 && (s.push(s[l]), s.splice(l, 1), this.initTemplateCanvas([r]), this.initImageCanvas([r])), this.specificLayerMove(r, "top");
      });
    }
    this.store.emitter.emit("layer", { type: "top", pens: t });
  }
  /**
   * 若本次改变的画笔存在图片，并且在上层 or 下层，需要擦除上层 or 下层
   * 子节点中包含图片，也需要重绘
   * @param pens 本次改变的 pens
   */
  initImageCanvas(t) {
    this.canvas.initImageCanvas(t);
  }
  /**
   * 模版图元图层改变
   * @param pens 本次改变的 pens
   */
  initTemplateCanvas(t) {
    this.canvas.initTemplateCanvas(t);
  }
  /**
   * 该画笔置底，即放到数组最前，最后绘制即在底部
   * @param pens 画笔们，注意 pen 必须在该数组内才有效
   */
  bottom(t) {
    t || (t = this.store.active), Array.isArray(t) || (t = [t]);
    for (const i of t) {
      const s = this.store.data.pens, o = [...Ut(i, this.store), i].map((r) => r.id), a = s.filter((r) => o.includes(r.id));
      for (let r = a.length - 1; r >= 0; r--) {
        const l = a[r], n = s.findIndex((h) => h.id === l.id);
        n > -1 && (s.unshift(s[n]), s.splice(n + 1, 1), this.initTemplateCanvas([l]), this.initImageCanvas([l])), this.specificLayerMove(l, "bottom");
      }
    }
    this.store.emitter.emit("layer", { type: "bottom", pens: t });
  }
  /**
   * data.pens 决定了绘制顺序，即越后面的越在上层
   * 该方法通过区域重叠计算，找出该画笔之后第一个与其重叠的画笔，然后把该画笔放到找出的画笔之后
   * @param pen 画笔
   */
  upByArea(t) {
    if (this.store.data.pens.findIndex((n) => n.id === t.id) === -1) {
      console.warn("upByArea: pen not in canvas");
      return;
    }
    const s = [t, ...Ut(t, this.store)];
    let o = s.map(
      (n) => this.store.data.pens.findIndex((h) => h.id === n.id)
    );
    o.includes(-1) && (console.warn("upByArea: pen children not in canvas"), o = o.filter((n) => n !== -1));
    const a = Math.min(...o), r = t.calculative.worldRect, l = this.store.data.pens.findIndex((n, h) => {
      if (h <= a || n.id === t.id || _r(n, t))
        return !1;
      const c = n.calculative.worldRect;
      return Jt(r, c);
    });
    if (l === -1) {
      this.up(t);
      return;
    }
    this.store.data.pens.splice(l + 1, 0, ...s);
    for (const n of s) {
      const h = this.store.data.pens.findIndex((c) => c.id === n.id);
      h > -1 && this.store.data.pens.splice(h, 1);
    }
    this.initImageCanvas([t]);
  }
  //特殊图元层级处理
  specificLayerMove(t, i) {
    var s;
    if (t.image && t.name !== "gif") {
      let o = dt.CanvasImageBottom;
      i === "top" ? o = dt.CanvasImage : (i === "up" || i === "down") && (o = dt.CanvasMain), this.setValue(
        { id: t.id, canvasLayer: o },
        { render: !1, doEvent: !1, history: !1 }
      );
    } else if (t.externElement || t.name === "gif") {
      let o = 0;
      i === "top" ? (t.calculative.canvas.maxZindex += 1, o = t.calculative.canvas.maxZindex) : i === "up" ? o = t.calculative.zIndex === void 0 ? 6 : t.calculative.zIndex + 1 : i === "down" && (o = t.calculative.zIndex === void 0 ? 3 : t.calculative.zIndex - 1, o < 0 && (o = 0)), this.setValue(
        { id: t.id, zIndex: o },
        { render: !1, doEvent: !1, history: !1 }
      ), (s = t.calculative.singleton) != null && s.div && Ct(t, t.calculative.singleton.div);
    }
  }
  /**
   * 该画笔上移，即把该画笔在数组中的位置向后移动一个
   * @param pens 画笔
   */
  up(t) {
    t || (t = this.store.active), Array.isArray(t) || (t = [t]);
    for (const i of t) {
      const s = this.store.data.pens;
      if (i.children && i.children.length) {
        const o = [...Ut(i, this.store), i], a = [];
        for (let n = 0; n < s.length; n++) {
          const h = s[n];
          o.findIndex((c) => c.id === h.id) !== -1 && (h.temIndex = n, a.push(h));
        }
        let r = -1, l = 0;
        a.forEach((n) => {
          n.temIndex -= l, s.splice(n.temIndex, 1), l += 1, r = n.temIndex, delete n.temIndex, this.specificLayerMove(n, "up");
        }), s.splice(r + 1, 0, ...a), this.initTemplateCanvas(a), this.initImageCanvas(a);
      } else {
        const o = s.findIndex((a) => a.id === i.id);
        o > -1 && o !== s.length - 1 && (s.splice(o + 2, 0, s[o]), s.splice(o, 1), this.initTemplateCanvas([i]), this.initImageCanvas([i])), this.specificLayerMove(i, "up");
      }
    }
    this.store.emitter.emit("layer", { type: "up", pens: t });
  }
  /**
   * 该画笔下移，即把该画笔在该数组中的位置前移一个
   * @param pen 画笔
   */
  down(t) {
    t || (t = this.store.active), Array.isArray(t) || (t = [t]);
    for (const i of t) {
      const s = this.store.data.pens;
      if (i.children && i.children.length) {
        const o = [...Ut(i, this.store), i], a = [];
        for (let n = 0; n < s.length; n++) {
          const h = s[n];
          o.findIndex((c) => c.id === h.id) !== -1 && (h.temIndex = n, a.push(h));
        }
        let r = -1, l = 0;
        a.forEach((n, h) => {
          n.temIndex -= l, s.splice(n.temIndex, 1), l += 1, h === 0 && (r = n.temIndex), delete n.temIndex, this.specificLayerMove(n, "down");
        }), s.splice(r - 1, 0, ...a), this.initTemplateCanvas(a), this.initImageCanvas(a);
      } else {
        const o = s.findIndex((a) => a.id === i.id);
        o > -1 && o !== 0 && (s.splice(o - 1, 0, s[o]), s.splice(o + 1, 1), this.initTemplateCanvas([i]), this.initImageCanvas([i])), this.specificLayerMove(i, "down");
      }
    }
    this.store.emitter.emit("layer", { type: "down", pens: t });
  }
  setLayer(t, i, s = this.store.data.pens) {
    const o = s.findIndex((a) => a.id === t.id);
    o > -1 && (o > i ? (s.splice(i, 0, s[o]), s.splice(o + 1, 1)) : o < i && (s.splice(i, 0, s[o]), s.splice(o, 1)));
  }
  changePenId(t, i) {
    this.canvas.changePenId(t, i);
  }
  /**
   * 得到与当前节点连接的线
   * @param node 节点，非连线
   * @param type 类型，全部的连接线/入线/出线
   */
  getLines(t, i = "all") {
    var o;
    if (t.type === ft.Line)
      return [];
    const s = [];
    return (o = t.connectedLines) == null || o.forEach(({ lineId: a }) => {
      const r = this.store.pens[a];
      if (!r) {
        console.warn(t, "node contain a error connectedLine");
        return;
      }
      if (!s.find((l) => l.id === r.id))
        switch (i) {
          case "all":
            s.push(r);
            break;
          case "in":
            ut(r).connectTo === t.id && s.push(r);
            break;
          case "out":
            xt(r).connectTo === t.id && s.push(r);
            break;
        }
    }), s;
  }
  /**
   * 得到当前节点的下一个节点，即出口节点数组
   * 得到当前连线的出口节点
   * @param pen 节点或连线
   */
  nextNode(t) {
    if (t.type === ft.Line) {
      const i = this.store.pens[ut(t).connectTo];
      return i ? [i] : [];
    } else {
      const i = this.getLines(t, "out"), s = [];
      return i.forEach((o) => {
        const a = this.nextNode(o);
        for (const r of a)
          !s.find((n) => n.id === r.id) && s.push(r);
      }), s;
    }
  }
  /**
   * 得到当前节点的上一个节点，即入口节点数组
   * 得到当前连线的入口节点
   * @param pen 节点或连线
   */
  previousNode(t) {
    if (t.type === ft.Line) {
      const i = this.store.pens[xt(t).connectTo];
      return i ? [i] : [];
    } else {
      const i = this.getLines(t, "in"), s = [];
      return i.forEach((o) => {
        const a = this.previousNode(o);
        for (const r of a)
          !s.find((n) => n.id === r.id) && s.push(r);
      }), s;
    }
  }
  /**
   * 获取节点所有的下一个连接关系
   * @param pen
   *
   */
  getNext(t) {
    var s;
    if (t.type === ft.Line) {
      console.warn("非连线节点");
      return;
    }
    const i = [];
    return (s = t.connectedLines) == null || s.forEach(({ lineId: o, anchor: a }) => {
      var n, h;
      const r = (n = t.anchors) == null ? void 0 : n.filter(
        (c) => c.id === a
      )[0], l = this.findOne(o);
      if (l.anchors[0].connectTo == t.id) {
        const c = l.anchors[l.anchors.length - 1].connectTo;
        if (c) {
          const d = this.findOne(c), u = (h = d.connectedLines) == null ? void 0 : h.filter(
            (g) => g.lineId === l.id
          )[0], f = d.anchors.filter(
            (g) => g.id === u.anchor
          )[0];
          i.push({
            from: t,
            fromAnchor: r,
            line: l,
            to: d,
            toAnchor: f
          });
        }
      }
    }), i;
  }
  /**
   * 为画布添加锚点
   * @param pen 画笔
   * @param anchor 待添加锚点
   * @param index 连线类型 添加锚点到哪个位置
   */
  addAnchor(t, i, s) {
    if (!t)
      return;
    if (t.anchors || (t.anchors = []), t.calculative.worldAnchors || (t.calculative.worldAnchors = []), t.type === ft.Line && (s < 0 && (s = t.anchors.length + 1 + s), s > t.anchors.length && (s = t.anchors.length), s < 0 && (s = 0), s == 0 && t.anchors[0].connectTo || s == t.anchors.length && t.anchors[s - 1].connectTo)) {
      console.warn("端点存在连接关系");
      return;
    }
    let o = null, a = null;
    i.x <= 1 && i.x >= 0 && i.y <= 1 && i.y >= 0 ? (a = {
      id: i.id || nt(),
      penId: t.id,
      x: t.calculative.worldRect.x + t.calculative.worldRect.width * i.x,
      y: t.calculative.worldRect.y + t.calculative.worldRect.height * i.y
    }, t.calculative.worldRect && t.rotate % 360 && vt(
      a,
      t.rotate,
      t.calculative.worldRect.center
    ), o = {
      id: a.id,
      penId: t.id,
      x: i.x,
      y: i.y
    }) : (a = {
      id: i.id || nt(),
      penId: t.id,
      x: i.x,
      y: i.y
    }, t.calculative.worldRect && (t.rotate % 360 && vt(i, -t.rotate, t.calculative.worldRect.center), o = {
      id: a.id,
      penId: t.id,
      x: (i.x - t.calculative.worldRect.x) / t.calculative.worldRect.width,
      y: (i.y - t.calculative.worldRect.y) / t.calculative.worldRect.height
    })), t.type === ft.Line ? (t.calculative.worldAnchors.splice(s, 0, a), t.anchors.splice(s, 0, o), this.canvas.updateLines(t), this.canvas.initLineRect(t), this.render()) : (t.calculative.worldAnchors.push(a), t.anchors.push(o));
  }
  /**
   *
   * @param from 连接节点
   * @param fromAnchor 连接节点锚点
   * @param to 被连接节点
   * @param toAnchor 被连接节点锚点
   */
  connectLine(t, i, s, o, a = !0) {
    if (!s) {
      const h = i.calculative.worldRect;
      s = Ne(t, {
        x: h.x + h.width / 2,
        y: h.y + h.height / 2
      });
    }
    if (!o) {
      const h = t.calculative.worldRect;
      o = Ne(i, {
        x: h.x + h.width / 2,
        y: h.y + h.height / 2
      });
    }
    const r = Math.abs(s.x - o.x), n = {
      height: Math.abs(s.y - o.y),
      lineName: "line",
      lineWidth: 1,
      name: "line",
      type: 1,
      width: r,
      x: Math.min(s.x, o.x),
      y: Math.min(s.y, o.y),
      anchors: [
        {
          x: s.x > o.x ? 1 : 0,
          y: s.y > o.y ? 1 : 0,
          id: nt()
        },
        {
          x: s.x > o.x ? 0 : 1,
          y: s.x > o.x ? 0 : 1,
          id: nt()
        }
      ]
    };
    return this.addPens([n]), St(t, s, n, n.calculative.worldAnchors[0]), St(i, o, n, n.calculative.worldAnchors[1]), n.calculative.active = !1, this.canvas.updateLines(n), this.canvas.updateLines(t), this.canvas.updateLines(i), this.canvas.initLineRect(n), a && this.render(), n;
  }
  /**
   * 生成一个拷贝组合后的 画笔数组（组合图形），不影响原画布画笔，常用作 二次复用的组件
   * @param pens 画笔数组
   * @param showChild 是否作为状态复用（参考 combine showChild）
   * @param anchor 是否产生默认的锚点
   * @returns 组合图形
   */
  toComponent(t = this.store.data.pens, i, s) {
    if (t.length === 1) {
      const c = G(t[0]);
      return c.type = ft.Node, c.id = void 0, [c];
    }
    const o = G(t, !0), a = jt(o);
    let r = {
      id: nt(),
      name: "combine",
      ...a,
      children: [],
      showChild: i
    };
    s && (r.anchors = [
      {
        id: "0",
        penId: r.id,
        x: 0.5,
        y: 0
      },
      {
        id: "1",
        penId: r.id,
        x: 1,
        y: 0.5
      },
      {
        id: "2",
        penId: r.id,
        x: 0.5,
        y: 1
      },
      {
        id: "3",
        penId: r.id,
        x: 0,
        y: 0.5
      }
    ]);
    const l = o.filter((c) => !c.parentId), n = o.find((c) => c.width === a.width && c.height === a.height), h = n && i === void 0;
    return l.length === 1 ? r = l[0] : h && (n.children || (n.children = []), r = n), o.forEach((c) => {
      if (c === r || c.parentId === r.id || c.parentId)
        return;
      r.children.push(c.id), c.parentId = r.id;
      const d = ae(c.calculative.worldRect, a);
      Object.assign(c, d), c.locked = c.lockedOnCombine ?? ht.DisableMove;
    }), h || l.length === 1 ? G(o) : G([r, ...o]);
  }
  // TODO 安装pen插件 此处是否应当进行相关的适配？不再让插件内部处理install的目标逻辑？
  /**
   * @description 安装插件方法
   * @param plugins 插件列表及其配置项
   * @param pen {string | Pen} 接受tag、name、或者Pen对象*/
  installPenPlugins(t, i) {
    if (!t.tag && !t.name && !t.id) return;
    let s;
    t.id ? s = "id" : t.tag ? s = "tag" : t.name && (s = "name"), i.forEach((o) => {
      let a = o.plugin, r = o.options;
      if (a && gn(a) && s)
        if (a.install(t, r), !this.penPluginMap.has(a))
          this.penPluginMap.set(a, [{ [s]: t[s], option: r }]);
        else {
          let l = this.penPluginMap.get(a).find((n) => n[s] === t[s]);
          l ? l.option = r : this.penPluginMap.get(a).push({
            [s]: t[s],
            option: r
          });
        }
    });
  }
  uninstallPenPlugins(t, i) {
    let s;
    t.id ? s = "id" : t.tag ? s = "tag" : t.name && (s = "name"), s && i.forEach((o) => {
      let a = o.plugin;
      a.uninstall(t, o.options);
      let r = this.penPluginMap.get(a), l = r.findIndex((n) => n[s] === t[s]);
      l !== -1 && (r.splice(l, 1), r.length === 0 && this.penPluginMap.delete(a));
    });
  }
  setVisible(t, i, s = !0) {
    if (this.onSizeUpdate(), this.setValue({ id: t.id, visible: i }, { render: !1, doEvent: !1 }), t.children)
      for (const a of t.children) {
        const r = this.store.pens[a];
        r && this.setVisible(r, i, !1);
      }
    let o = Ut(t, this.store);
    o.push(t), this.initImageCanvas(o), s && this.render();
  }
  clearHover() {
    this.canvas.clearHover();
  }
  closeSocket() {
    this.closeWebsocket(), this.closeMqtt(), this.closeHttp();
  }
  destroy(t) {
    if (this.clear(!1), this.stopDataMock(), this.closeSocket(), this.closeNetwork(), this.closeAll(), this.store.emitter.all.clear(), this.canvas.destroy(), this.canvas = void 0, rt[this.store.id] = void 0, !t) {
      for (const i in rt)
        delete rt[i];
      rt.path2dDraws = {}, rt.canvasDraws = {}, rt.anchors = {}, rt.htmlElements = {};
    }
  }
}
const Kl = [
  {
    元件类型: "C",
    释义: "电容",
    类型: "27",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-13)",
    右下角坐标: "(30,13)",
    "宽度(X向)": "60",
    "高度(Y向)": "26",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "R",
    释义: "电阻",
    类型: "27",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-11)",
    右下角坐标: "(30,11)",
    "宽度(X向)": "60",
    "高度(Y向)": "22",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "TerminalsXT",
    释义: "端子",
    类型: "27",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "(-22,-12)",
    右下角坐标: "(22,12)",
    "宽度(X向)": "44",
    "高度(Y向)": "24",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "IProbe",
    释义: "电流表",
    类型: "4",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-35,-15)",
    右下角坐标: "(35,15)",
    "宽度(X向)": "70",
    "高度(Y向)": "30",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "GND",
    释义: "接地",
    类型: "2",
    接线盘1: "0, 0",
    接线盘2: "",
    左上角坐标: "(-12，0)",
    右下角坐标: "(12，25)",
    "宽度(X向)": "24",
    "高度(Y向)": "25",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "DoubleCoil",
    释义: "双位置继电器",
    类型: "30",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Coil",
    释义: "中间继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "CoilOffDelay",
    释义: "失电延时继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "CoilOnDelay",
    释义: "得电延时继电器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-18，-30)",
    右下角坐标: "(18,30)",
    "宽度(X向)": "36",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Contact",
    释义: "继电器常闭触电",
    类型: "18",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(20,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Contactk",
    释义: "继电器常开触电",
    类型: "17",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(20,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Switch",
    释义: "开关",
    类型: "28",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-32,-17)",
    右下角坐标: "(30,7)",
    "宽度(X向)": "62",
    "高度(Y向)": "24",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Vdc",
    释义: "电源",
    类型: "1",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-14)",
    右下角坐标: "(30,14)",
    "宽度(X向)": "60",
    "高度(Y向)": "28",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Lamp",
    释义: "灯",
    类型: "5",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-15，-30)",
    右下角坐标: "(15，30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "MultipleContact",
    释义: "多位置开关",
    类型: "28",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "80",
    "高度(Y向)": "40",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "IOput",
    释义: "IO端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "",
    "高度(Y向)": "",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "TransformerNew",
    释义: "变压器",
    类型: "24",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-10，-30)",
    右下角坐标: "(10，30)",
    "宽度(X向)": "20",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Breaker",
    释义: "断路器",
    类型: "28",
    接线盘1: "(0, -30)",
    接线盘2: "(0, 30)",
    左上角坐标: "(-20，-30)",
    右下角坐标: "(10,30)",
    "宽度(X向)": "30",
    "高度(Y向)": "60",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Input",
    释义: "输出端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "30",
    "高度(Y向)": "20",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "Output",
    释义: "输入端口",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "30",
    "高度(Y向)": "20",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "RectangularNoteBox",
    释义: "注释矩形框",
    类型: "无",
    接线盘1: "",
    接线盘2: "",
    左上角坐标: "",
    右下角坐标: "",
    "宽度(X向)": "",
    "高度(Y向)": "",
    接线盘排列方式: "",
    "": ""
  },
  {
    元件类型: "Diode",
    释义: "二极管",
    类型: "26",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-30,-11)",
    右下角坐标: "(30,11)",
    "宽度(X向)": "60",
    "高度(Y向)": "22",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "Btn_SelfReset",
    释义: "自复位按钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30,-35)",
    右下角坐标: "(30,35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Btn_SelfLock",
    释义: "自锁按钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Knob_SelfReset",
    释义: "自复位旋钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "Knob_SelfLock",
    释义: "自锁旋钮",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(-30，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "60",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "VProbe",
    释义: "电压表",
    类型: "4",
    接线盘1: "(-30, 0)",
    接线盘2: "(30, 0)",
    左上角坐标: "(-35，-15)",
    右下角坐标: "(35，15)",
    "宽度(X向)": "70",
    "高度(Y向)": "30",
    接线盘排列方式: "横向",
    "": ""
  },
  {
    元件类型: "ElectromagneticValve",
    释义: "电磁阀",
    类型: "无",
    接线盘1: "(-10, -30)",
    接线盘2: "(-10, 30)",
    左上角坐标: "(-25，-30)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "55",
    "高度(Y向)": "65",
    接线盘排列方式: "纵向",
    "": ""
  },
  {
    元件类型: "duanluqi_wx",
    释义: "微型断路器",
    类型: "28",
    接线盘1: "(20, 30)",
    接线盘2: "(20, -30)",
    左上角坐标: "(2，-35)",
    右下角坐标: "(30，35)",
    "宽度(X向)": "32",
    "高度(Y向)": "70",
    接线盘排列方式: "纵向",
    "": ""
  }
], Gl = [
  {
    name: "二极管",
    icon: "svg/二极管.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/二极管.svg",
      tags: ["Diode"],
      electricTypeCode: "Diode",
      electricName: ""
    }
  },
  {
    name: "半圆-封口",
    icon: "svg/半圆-封口.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/半圆-封口.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "半圆-开口",
    icon: "svg/半圆-开口.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/半圆-开口.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "声音-扬声器",
    icon: "svg/声音-扬声器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/声音-扬声器.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "声音-蜂鸣器",
    icon: "svg/声音-蜂鸣器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/声音-蜂鸣器.svg",
      tags: [],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-1位",
    icon: "svg/开关-三位置-1位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-1位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-2位",
    icon: "svg/开关-三位置-2位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-2位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-三位置-3位",
    icon: "svg/开关-三位置-3位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-三位置-3位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-中间位",
    icon: "svg/开关-单刀双掷-中间位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-中间位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-右位",
    icon: "svg/开关-单刀双掷-右位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-右位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-单刀双掷-左位",
    icon: "svg/开关-单刀双掷-左位.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-单刀双掷-左位.svg",
      tags: ["MultipleContact"],
      electricTypeCode: "MultipleContact",
      electricName: ""
    }
  },
  {
    name: "开关-惯性开关-断开",
    icon: "svg/开关-惯性开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-惯性开关-断开.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-惯性开关-闭合",
    icon: "svg/开关-惯性开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-惯性开关-闭合.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "开关-按钮-断开",
    icon: "svg/开关-按钮-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-按钮-断开.svg",
      tags: ["Btn_SelfReset"],
      electricTypeCode: "Btn_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-按钮-闭合",
    icon: "svg/开关-按钮-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-按钮-闭合.svg",
      tags: ["Btn_SelfReset"],
      electricTypeCode: "Btn_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-断路器-断开",
    icon: "svg/开关-断路器-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-断路器-断开.svg",
      tags: ["duanluqi_wx"],
      electricTypeCode: "duanluqi_wx",
      electricName: ""
    }
  },
  {
    name: "开关-断路器-闭合",
    icon: "svg/开关-断路器-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-断路器-闭合.svg",
      tags: ["duanluqi_wx"],
      electricTypeCode: "duanluqi_wx",
      electricName: ""
    }
  },
  {
    name: "开关-自复旋转开关-断开",
    icon: "svg/开关-自复旋转开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自复旋转开关-断开.svg",
      tags: ["Knob_SelfReset"],
      electricTypeCode: "Knob_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-自复旋转开关-闭合",
    icon: "svg/开关-自复旋转开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自复旋转开关-闭合.svg",
      tags: ["Knob_SelfReset"],
      electricTypeCode: "Knob_SelfReset",
      electricName: ""
    }
  },
  {
    name: "开关-自锁按钮-断开",
    icon: "svg/开关-自锁按钮-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁按钮-断开.svg",
      tags: ["Btn_SelfLock"],
      electricTypeCode: "Btn_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁按钮-闭合",
    icon: "svg/开关-自锁按钮-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁按钮-闭合.svg",
      tags: ["Btn_SelfLock"],
      electricTypeCode: "Btn_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁旋转开关-断开",
    icon: "svg/开关-自锁旋转开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁旋转开关-断开.svg",
      tags: ["Knob_SelfLock"],
      electricTypeCode: "Knob_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-自锁旋转开关-闭合",
    icon: "svg/开关-自锁旋转开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-自锁旋转开关-闭合.svg",
      tags: ["Knob_SelfLock"],
      electricTypeCode: "Knob_SelfLock",
      electricName: ""
    }
  },
  {
    name: "开关-通用开关-断开",
    icon: "svg/开关-通用开关-断开.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-通用开关-断开.svg",
      tags: ["Switch", "Contactk"],
      electricTypeCode: "Switch",
      electricName: ""
    }
  },
  {
    name: "开关-通用开关-闭合",
    icon: "svg/开关-通用开关-闭合.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/开关-通用开关-闭合.svg",
      tags: ["Switch", "Contact"],
      electricTypeCode: "Switch",
      electricName: ""
    }
  },
  {
    name: "指示灯",
    icon: "svg/指示灯.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/指示灯.svg",
      tags: ["Lamp"],
      electricTypeCode: "Lamp",
      electricName: ""
    }
  },
  {
    name: "测量-电压表",
    icon: "svg/测量-电压表.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/测量-电压表.svg",
      tags: ["VProbe"],
      electricTypeCode: "VProbe",
      electricName: ""
    }
  },
  {
    name: "测量-电流表",
    icon: "svg/测量-电流表.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/测量-电流表.svg",
      tags: ["IProbe"],
      electricTypeCode: "IProbe",
      electricName: ""
    }
  },
  {
    name: "电动机-三相",
    icon: "svg/电动机-三相.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电动机-三相.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电容器",
    icon: "svg/电容器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电容器.svg",
      tags: ["C"],
      electricTypeCode: "C",
      electricName: ""
    }
  },
  {
    name: "电感-变压器",
    icon: "svg/电感-变压器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-变压器.svg",
      tags: ["TransformerNew"],
      electricTypeCode: "TransformerNew",
      electricName: ""
    }
  },
  {
    name: "电感-绕组-短",
    icon: "svg/电感-绕组-短.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-绕组-短.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电感-绕组-长",
    icon: "svg/电感-绕组-长.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电感-绕组-长.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电源-接地",
    icon: "svg/电源-接地.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-接地.svg",
      tags: ["GND"],
      electricTypeCode: "GND",
      electricName: ""
    }
  },
  {
    name: "电源-电池组",
    icon: "svg/电源-电池组.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-电池组.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "电源-直流电源",
    icon: "svg/电源-直流电源.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电源-直流电源.svg",
      tags: ["Vdc"],
      electricTypeCode: "Vdc",
      electricName: ""
    }
  },
  {
    name: "电磁阀",
    icon: "svg/电磁阀.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电磁阀.svg",
      tags: ["ElectromagneticValve"],
      electricTypeCode: "ElectromagneticValve",
      electricName: ""
    }
  },
  {
    name: "电阻",
    icon: "svg/电阻.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/电阻.svg",
      tags: ["R"],
      electricTypeCode: "R",
      electricName: ""
    }
  },
  {
    name: "端子-环形",
    icon: "svg/端子-环形.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/端子-环形.svg",
      tags: ["TerminalsXT"],
      electricTypeCode: "TerminalsXT",
      electricName: ""
    }
  },
  {
    name: "端子-实心",
    icon: "svg/端子-实心.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/端子-实心.svg",
      tags: ["TerminalsXT"],
      electricTypeCode: "TerminalsXT",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器-折线连接二极管",
    icon: "svg/继电器-中间继电器-折线连接二极管.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器-折线连接二极管.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器-折线连接电阻",
    icon: "svg/继电器-中间继电器-折线连接电阻.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器-折线连接电阻.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "继电器-中间继电器",
    icon: "svg/继电器-中间继电器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-中间继电器.svg",
      tags: ["Coil"],
      electricTypeCode: "Coil",
      electricName: ""
    }
  },
  {
    name: "继电器-双位置",
    icon: "svg/继电器-双位置.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-双位置.svg",
      tags: ["DoubleCoil"],
      electricTypeCode: "DoubleCoil",
      electricName: ""
    }
  },
  {
    name: "继电器-失电延时",
    icon: "svg/继电器-失电延时.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-失电延时.svg",
      tags: ["CoilOffDelay"],
      electricTypeCode: "CoilOffDelay",
      electricName: ""
    }
  },
  {
    name: "继电器-得电延时",
    icon: "svg/继电器-得电延时.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/继电器-得电延时.svg",
      tags: ["CoilOnDelay"],
      electricTypeCode: "CoilOnDelay",
      electricName: ""
    }
  },
  {
    name: "跨接线",
    icon: "svg/跨接线.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/跨接线.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "输出",
    icon: "svg/输入输出.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/输入输出.svg",
      tags: ["Output"],
      anchors: [
        {
          x: 0,
          y: 0.5
        }
      ],
      electricTypeCode: "Output",
      electricName: ""
    }
  },
  {
    name: "输入",
    icon: "svg/输入输出.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/输入输出.svg",
      tags: ["Input"],
      anchors: [
        {
          x: 1,
          y: 0.5
        }
      ],
      electricTypeCode: "Input",
      electricName: ""
    }
  },
  {
    name: "连接端子-插针针孔",
    icon: "svg/连接端子-插针针孔.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/连接端子-插针针孔.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  },
  {
    name: "避雷器",
    icon: "svg/避雷器.svg",
    data: {
      text: "",
      // width: 100,
      // height: 100,
      name: "image",
      image: "svg/避雷器.svg",
      tags: [""],
      electricTypeCode: "",
      electricName: ""
    }
  }
], pf = [
  {
    name: "开关",
    children: [
      {
        name: "开关-三位置",
        icon: "svg/开关-三位置-1位.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-三位置-1位.svg",
          tags: ["MultipleContact"],
          electricTypeCode: "MultipleContact",
          electricName: "",
          showChild: 0
        }
      },
      {
        name: "开关-单刀双掷",
        icon: "svg/开关-单刀双掷-中间位.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-单刀双掷-中间位.svg",
          tags: ["MultipleContact"],
          electricTypeCode: "MultipleContact",
          electricName: ""
        }
      },
      {
        name: "开关-惯性开关",
        icon: "svg/开关-惯性开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-惯性开关-断开.svg",
          tags: [""],
          electricTypeCode: "",
          electricName: ""
        }
      },
      {
        name: "开关-按钮",
        icon: "svg/开关-按钮-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-按钮-断开.svg",
          tags: ["Btn_SelfReset"],
          electricTypeCode: "Btn_SelfReset",
          electricName: ""
        }
      },
      {
        name: "开关-断路器",
        icon: "svg/开关-断路器-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-断路器-断开.svg",
          tags: ["duanluqi_wx"],
          electricTypeCode: "duanluqi_wx",
          electricName: ""
        }
      },
      {
        name: "开关-自复旋转开关",
        icon: "svg/开关-自复旋转开关-闭合.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自复旋转开关-闭合.svg",
          tags: ["Knob_SelfReset"],
          electricTypeCode: "Knob_SelfReset",
          electricName: ""
        }
      },
      {
        name: "开关-自锁按钮",
        icon: "svg/开关-自锁按钮-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自锁按钮-断开.svg",
          tags: ["Btn_SelfLock"],
          electricTypeCode: "Btn_SelfLock",
          electricName: ""
        }
      },
      {
        name: "开关-自锁旋转开关",
        icon: "svg/开关-自锁旋转开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-自锁旋转开关-断开.svg",
          tags: ["Knob_SelfLock"],
          electricTypeCode: "Knob_SelfLock",
          electricName: ""
        }
      },
      {
        name: "开关-通用开关",
        icon: "svg/开关-通用开关-断开.svg",
        type: "combine-json",
        data: {
          text: "",
          // width: 100,
          // height: 100,
          name: "image",
          image: "svg/开关-通用开关-断开.svg",
          tags: ["Switch"],
          electricTypeCode: "Switch",
          electricName: ""
        }
      }
    ]
  }
];
var bs = {}, Pi = {};
(function(e) {
  const t = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", i = t + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", s = "[" + t + "][" + i + "]*", o = new RegExp("^" + s + "$"), a = function(l, n) {
    const h = [];
    let c = n.exec(l);
    for (; c; ) {
      const d = [];
      d.startIndex = n.lastIndex - c[0].length;
      const u = c.length;
      for (let f = 0; f < u; f++)
        d.push(c[f]);
      h.push(d), c = n.exec(l);
    }
    return h;
  }, r = function(l) {
    const n = o.exec(l);
    return !(n === null || typeof n > "u");
  };
  e.isExist = function(l) {
    return typeof l < "u";
  }, e.isEmptyObject = function(l) {
    return Object.keys(l).length === 0;
  }, e.merge = function(l, n, h) {
    if (n) {
      const c = Object.keys(n), d = c.length;
      for (let u = 0; u < d; u++)
        h === "strict" ? l[c[u]] = [n[c[u]]] : l[c[u]] = n[c[u]];
    }
  }, e.getValue = function(l) {
    return e.isExist(l) ? l : "";
  }, e.isName = r, e.getAllMatches = a, e.nameRegexp = s;
})(Pi);
const ws = Pi, Jl = {
  allowBooleanAttributes: !1,
  //A tag can have attributes without any value
  unpairedTags: []
};
bs.validate = function(e, t) {
  t = Object.assign({}, Jl, t);
  const i = [];
  let s = !1, o = !1;
  e[0] === "\uFEFF" && (e = e.substr(1));
  for (let a = 0; a < e.length; a++)
    if (e[a] === "<" && e[a + 1] === "?") {
      if (a += 2, a = io(e, a), a.err) return a;
    } else if (e[a] === "<") {
      let r = a;
      if (a++, e[a] === "!") {
        a = so(e, a);
        continue;
      } else {
        let l = !1;
        e[a] === "/" && (l = !0, a++);
        let n = "";
        for (; a < e.length && e[a] !== ">" && e[a] !== " " && e[a] !== "	" && e[a] !== `
` && e[a] !== "\r"; a++)
          n += e[a];
        if (n = n.trim(), n[n.length - 1] === "/" && (n = n.substring(0, n.length - 1), a--), !ac(n)) {
          let d;
          return n.trim().length === 0 ? d = "Invalid space after '<'." : d = "Tag '" + n + "' is an invalid name.", kt("InvalidTag", d, Pt(e, a));
        }
        const h = tc(e, a);
        if (h === !1)
          return kt("InvalidAttr", "Attributes for '" + n + "' have open quote.", Pt(e, a));
        let c = h.value;
        if (a = h.index, c[c.length - 1] === "/") {
          const d = a - c.length;
          c = c.substring(0, c.length - 1);
          const u = oo(c, t);
          if (u === !0)
            s = !0;
          else
            return kt(u.err.code, u.err.msg, Pt(e, d + u.err.line));
        } else if (l)
          if (h.tagClosed) {
            if (c.trim().length > 0)
              return kt("InvalidTag", "Closing tag '" + n + "' can't have attributes or invalid starting.", Pt(e, r));
            if (i.length === 0)
              return kt("InvalidTag", "Closing tag '" + n + "' has not been opened.", Pt(e, r));
            {
              const d = i.pop();
              if (n !== d.tagName) {
                let u = Pt(e, d.tagStartPos);
                return kt(
                  "InvalidTag",
                  "Expected closing tag '" + d.tagName + "' (opened in line " + u.line + ", col " + u.col + ") instead of closing tag '" + n + "'.",
                  Pt(e, r)
                );
              }
              i.length == 0 && (o = !0);
            }
          } else return kt("InvalidTag", "Closing tag '" + n + "' doesn't have proper closing.", Pt(e, a));
        else {
          const d = oo(c, t);
          if (d !== !0)
            return kt(d.err.code, d.err.msg, Pt(e, a - c.length + d.err.line));
          if (o === !0)
            return kt("InvalidXml", "Multiple possible root nodes found.", Pt(e, a));
          t.unpairedTags.indexOf(n) !== -1 || i.push({ tagName: n, tagStartPos: r }), s = !0;
        }
        for (a++; a < e.length; a++)
          if (e[a] === "<")
            if (e[a + 1] === "!") {
              a++, a = so(e, a);
              continue;
            } else if (e[a + 1] === "?") {
              if (a = io(e, ++a), a.err) return a;
            } else
              break;
          else if (e[a] === "&") {
            const d = sc(e, a);
            if (d == -1)
              return kt("InvalidChar", "char '&' is not expected.", Pt(e, a));
            a = d;
          } else if (o === !0 && !eo(e[a]))
            return kt("InvalidXml", "Extra text at the end", Pt(e, a));
        e[a] === "<" && a--;
      }
    } else {
      if (eo(e[a]))
        continue;
      return kt("InvalidChar", "char '" + e[a] + "' is not expected.", Pt(e, a));
    }
  if (s) {
    if (i.length == 1)
      return kt("InvalidTag", "Unclosed tag '" + i[0].tagName + "'.", Pt(e, i[0].tagStartPos));
    if (i.length > 0)
      return kt("InvalidXml", "Invalid '" + JSON.stringify(i.map((a) => a.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else return kt("InvalidXml", "Start tag expected.", 1);
  return !0;
};
function eo(e) {
  return e === " " || e === "	" || e === `
` || e === "\r";
}
function io(e, t) {
  const i = t;
  for (; t < e.length; t++)
    if (e[t] == "?" || e[t] == " ") {
      const s = e.substr(i, t - i);
      if (t > 5 && s === "xml")
        return kt("InvalidXml", "XML declaration allowed only at the start of the document.", Pt(e, t));
      if (e[t] == "?" && e[t + 1] == ">") {
        t++;
        break;
      } else
        continue;
    }
  return t;
}
function so(e, t) {
  if (e.length > t + 5 && e[t + 1] === "-" && e[t + 2] === "-") {
    for (t += 3; t < e.length; t++)
      if (e[t] === "-" && e[t + 1] === "-" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  } else if (e.length > t + 8 && e[t + 1] === "D" && e[t + 2] === "O" && e[t + 3] === "C" && e[t + 4] === "T" && e[t + 5] === "Y" && e[t + 6] === "P" && e[t + 7] === "E") {
    let i = 1;
    for (t += 8; t < e.length; t++)
      if (e[t] === "<")
        i++;
      else if (e[t] === ">" && (i--, i === 0))
        break;
  } else if (e.length > t + 9 && e[t + 1] === "[" && e[t + 2] === "C" && e[t + 3] === "D" && e[t + 4] === "A" && e[t + 5] === "T" && e[t + 6] === "A" && e[t + 7] === "[") {
    for (t += 8; t < e.length; t++)
      if (e[t] === "]" && e[t + 1] === "]" && e[t + 2] === ">") {
        t += 2;
        break;
      }
  }
  return t;
}
const Ql = '"', Zl = "'";
function tc(e, t) {
  let i = "", s = "", o = !1;
  for (; t < e.length; t++) {
    if (e[t] === Ql || e[t] === Zl)
      s === "" ? s = e[t] : s !== e[t] || (s = "");
    else if (e[t] === ">" && s === "") {
      o = !0;
      break;
    }
    i += e[t];
  }
  return s !== "" ? !1 : {
    value: i,
    index: t,
    tagClosed: o
  };
}
const ec = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function oo(e, t) {
  const i = ws.getAllMatches(e, ec), s = {};
  for (let o = 0; o < i.length; o++) {
    if (i[o][1].length === 0)
      return kt("InvalidAttr", "Attribute '" + i[o][2] + "' has no space in starting.", je(i[o]));
    if (i[o][3] !== void 0 && i[o][4] === void 0)
      return kt("InvalidAttr", "Attribute '" + i[o][2] + "' is without value.", je(i[o]));
    if (i[o][3] === void 0 && !t.allowBooleanAttributes)
      return kt("InvalidAttr", "boolean attribute '" + i[o][2] + "' is not allowed.", je(i[o]));
    const a = i[o][2];
    if (!oc(a))
      return kt("InvalidAttr", "Attribute '" + a + "' is an invalid name.", je(i[o]));
    if (!s.hasOwnProperty(a))
      s[a] = 1;
    else
      return kt("InvalidAttr", "Attribute '" + a + "' is repeated.", je(i[o]));
  }
  return !0;
}
function ic(e, t) {
  let i = /\d/;
  for (e[t] === "x" && (t++, i = /[\da-fA-F]/); t < e.length; t++) {
    if (e[t] === ";")
      return t;
    if (!e[t].match(i))
      break;
  }
  return -1;
}
function sc(e, t) {
  if (t++, e[t] === ";")
    return -1;
  if (e[t] === "#")
    return t++, ic(e, t);
  let i = 0;
  for (; t < e.length; t++, i++)
    if (!(e[t].match(/\w/) && i < 20)) {
      if (e[t] === ";")
        break;
      return -1;
    }
  return t;
}
function kt(e, t, i) {
  return {
    err: {
      code: e,
      msg: t,
      line: i.line || i,
      col: i.col
    }
  };
}
function oc(e) {
  return ws.isName(e);
}
function ac(e) {
  return ws.isName(e);
}
function Pt(e, t) {
  const i = e.substring(0, t).split(/\r?\n/);
  return {
    line: i.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: i[i.length - 1].length + 1
  };
}
function je(e) {
  return e.startIndex + e[1].length;
}
var xs = {};
const ra = {
  preserveOrder: !1,
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  removeNSPrefix: !1,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: !1,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: !0,
  parseAttributeValue: !1,
  trimValues: !0,
  //Trim string values of tag and attributes
  cdataPropName: !1,
  numberParseOptions: {
    hex: !0,
    leadingZeros: !0,
    eNotation: !0
  },
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: !1,
  isArray: () => !1,
  commentPropName: !1,
  unpairedTags: [],
  processEntities: !0,
  htmlEntities: !1,
  ignoreDeclaration: !1,
  ignorePiTags: !1,
  transformTagName: !1,
  transformAttributeName: !1,
  updateTag: function(e, t, i) {
    return e;
  }
  // skipEmptyListItem: false
}, rc = function(e) {
  return Object.assign({}, ra, e);
};
xs.buildOptions = rc;
xs.defaultOptions = ra;
class nc {
  constructor(t) {
    this.tagname = t, this.child = [], this[":@"] = {};
  }
  add(t, i) {
    t === "__proto__" && (t = "#__proto__"), this.child.push({ [t]: i });
  }
  addChild(t) {
    t.tagname === "__proto__" && (t.tagname = "#__proto__"), t[":@"] && Object.keys(t[":@"]).length > 0 ? this.child.push({ [t.tagname]: t.child, ":@": t[":@"] }) : this.child.push({ [t.tagname]: t.child });
  }
}
var lc = nc;
const cc = Pi;
function hc(e, t) {
  const i = {};
  if (e[t + 3] === "O" && e[t + 4] === "C" && e[t + 5] === "T" && e[t + 6] === "Y" && e[t + 7] === "P" && e[t + 8] === "E") {
    t = t + 9;
    let s = 1, o = !1, a = !1, r = "";
    for (; t < e.length; t++)
      if (e[t] === "<" && !a) {
        if (o && fc(e, t))
          t += 7, [entityName, val, t] = dc(e, t + 1), val.indexOf("&") === -1 && (i[mc(entityName)] = {
            regx: RegExp(`&${entityName};`, "g"),
            val
          });
        else if (o && gc(e, t)) t += 8;
        else if (o && vc(e, t)) t += 8;
        else if (o && yc(e, t)) t += 9;
        else if (uc) a = !0;
        else throw new Error("Invalid DOCTYPE");
        s++, r = "";
      } else if (e[t] === ">") {
        if (a ? e[t - 1] === "-" && e[t - 2] === "-" && (a = !1, s--) : s--, s === 0)
          break;
      } else e[t] === "[" ? o = !0 : r += e[t];
    if (s !== 0)
      throw new Error("Unclosed DOCTYPE");
  } else
    throw new Error("Invalid Tag instead of DOCTYPE");
  return { entities: i, i: t };
}
function dc(e, t) {
  let i = "";
  for (; t < e.length && e[t] !== "'" && e[t] !== '"'; t++)
    i += e[t];
  if (i = i.trim(), i.indexOf(" ") !== -1) throw new Error("External entites are not supported");
  const s = e[t++];
  let o = "";
  for (; t < e.length && e[t] !== s; t++)
    o += e[t];
  return [i, o, t];
}
function uc(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "-" && e[t + 3] === "-";
}
function fc(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "N" && e[t + 4] === "T" && e[t + 5] === "I" && e[t + 6] === "T" && e[t + 7] === "Y";
}
function gc(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "E" && e[t + 3] === "L" && e[t + 4] === "E" && e[t + 5] === "M" && e[t + 6] === "E" && e[t + 7] === "N" && e[t + 8] === "T";
}
function vc(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "A" && e[t + 3] === "T" && e[t + 4] === "T" && e[t + 5] === "L" && e[t + 6] === "I" && e[t + 7] === "S" && e[t + 8] === "T";
}
function yc(e, t) {
  return e[t + 1] === "!" && e[t + 2] === "N" && e[t + 3] === "O" && e[t + 4] === "T" && e[t + 5] === "A" && e[t + 6] === "T" && e[t + 7] === "I" && e[t + 8] === "O" && e[t + 9] === "N";
}
function mc(e) {
  if (cc.isName(e))
    return e;
  throw new Error(`Invalid entity name ${e}`);
}
var pc = hc;
const bc = /^[-+]?0x[a-fA-F0-9]+$/, wc = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
!Number.parseInt && window.parseInt && (Number.parseInt = window.parseInt);
!Number.parseFloat && window.parseFloat && (Number.parseFloat = window.parseFloat);
const xc = {
  hex: !0,
  leadingZeros: !0,
  decimalPoint: ".",
  eNotation: !0
  //skipLike: /regex/
};
function kc(e, t = {}) {
  if (t = Object.assign({}, xc, t), !e || typeof e != "string") return e;
  let i = e.trim();
  if (t.skipLike !== void 0 && t.skipLike.test(i)) return e;
  if (t.hex && bc.test(i))
    return Number.parseInt(i, 16);
  {
    const s = wc.exec(i);
    if (s) {
      const o = s[1], a = s[2];
      let r = Ic(s[3]);
      const l = s[4] || s[6];
      if (!t.leadingZeros && a.length > 0 && o && i[2] !== ".") return e;
      if (!t.leadingZeros && a.length > 0 && !o && i[1] !== ".") return e;
      {
        const n = Number(i), h = "" + n;
        return h.search(/[eE]/) !== -1 || l ? t.eNotation ? n : e : i.indexOf(".") !== -1 ? h === "0" && r === "" || h === r || o && h === "-" + r ? n : e : a ? r === h || o + r === h ? n : e : i === h || i === o + h ? n : e;
      }
    } else
      return e;
  }
}
function Ic(e) {
  return e && e.indexOf(".") !== -1 && (e = e.replace(/0+$/, ""), e === "." ? e = "0" : e[0] === "." ? e = "0" + e : e[e.length - 1] === "." && (e = e.substr(0, e.length - 1))), e;
}
var Ac = kc;
function Sc(e) {
  return typeof e == "function" ? e : Array.isArray(e) ? (t) => {
    for (const i of e)
      if (typeof i == "string" && t === i || i instanceof RegExp && i.test(t))
        return !0;
  } : () => !1;
}
var na = Sc;
const la = Pi, Ve = lc, Tc = pc, Cc = Ac, Rc = na;
let Pc = class {
  constructor(t) {
    this.options = t, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = {
      apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
      gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
      lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
      quot: { regex: /&(quot|#34|#x22);/g, val: '"' }
    }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = {
      space: { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      cent: { regex: /&(cent|#162);/g, val: "¢" },
      pound: { regex: /&(pound|#163);/g, val: "£" },
      yen: { regex: /&(yen|#165);/g, val: "¥" },
      euro: { regex: /&(euro|#8364);/g, val: "€" },
      copyright: { regex: /&(copy|#169);/g, val: "©" },
      reg: { regex: /&(reg|#174);/g, val: "®" },
      inr: { regex: /&(inr|#8377);/g, val: "₹" },
      num_dec: { regex: /&#([0-9]{1,7});/g, val: (i, s) => String.fromCharCode(Number.parseInt(s, 10)) },
      num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (i, s) => String.fromCharCode(Number.parseInt(s, 16)) }
    }, this.addExternalEntities = Ec, this.parseXml = Oc, this.parseTextData = _c, this.resolveNameSpace = Lc, this.buildAttributesMap = Nc, this.isItStopNode = Hc, this.replaceEntitiesValue = Bc, this.readStopNodeData = Wc, this.saveTextToParentTag = zc, this.addChild = Dc, this.ignoreAttributesFn = Rc(this.options.ignoreAttributes);
  }
};
function Ec(e) {
  const t = Object.keys(e);
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    this.lastEntities[s] = {
      regex: new RegExp("&" + s + ";", "g"),
      val: e[s]
    };
  }
}
function _c(e, t, i, s, o, a, r) {
  if (e !== void 0 && (this.options.trimValues && !s && (e = e.trim()), e.length > 0)) {
    r || (e = this.replaceEntitiesValue(e));
    const l = this.options.tagValueProcessor(t, e, i, o, a);
    return l == null ? e : typeof l != typeof e || l !== e ? l : this.options.trimValues ? as(e, this.options.parseTagValue, this.options.numberParseOptions) : e.trim() === e ? as(e, this.options.parseTagValue, this.options.numberParseOptions) : e;
  }
}
function Lc(e) {
  if (this.options.removeNSPrefix) {
    const t = e.split(":"), i = e.charAt(0) === "/" ? "/" : "";
    if (t[0] === "xmlns")
      return "";
    t.length === 2 && (e = i + t[1]);
  }
  return e;
}
const Mc = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function Nc(e, t, i) {
  if (this.options.ignoreAttributes !== !0 && typeof e == "string") {
    const s = la.getAllMatches(e, Mc), o = s.length, a = {};
    for (let r = 0; r < o; r++) {
      const l = this.resolveNameSpace(s[r][1]);
      if (this.ignoreAttributesFn(l, t))
        continue;
      let n = s[r][4], h = this.options.attributeNamePrefix + l;
      if (l.length)
        if (this.options.transformAttributeName && (h = this.options.transformAttributeName(h)), h === "__proto__" && (h = "#__proto__"), n !== void 0) {
          this.options.trimValues && (n = n.trim()), n = this.replaceEntitiesValue(n);
          const c = this.options.attributeValueProcessor(l, n, t);
          c == null ? a[h] = n : typeof c != typeof n || c !== n ? a[h] = c : a[h] = as(
            n,
            this.options.parseAttributeValue,
            this.options.numberParseOptions
          );
        } else this.options.allowBooleanAttributes && (a[h] = !0);
    }
    if (!Object.keys(a).length)
      return;
    if (this.options.attributesGroupName) {
      const r = {};
      return r[this.options.attributesGroupName] = a, r;
    }
    return a;
  }
}
const Oc = function(e) {
  e = e.replace(/\r\n?/g, `
`);
  const t = new Ve("!xml");
  let i = t, s = "", o = "";
  for (let a = 0; a < e.length; a++)
    if (e[a] === "<")
      if (e[a + 1] === "/") {
        const l = we(e, ">", a, "Closing Tag is not closed.");
        let n = e.substring(a + 2, l).trim();
        if (this.options.removeNSPrefix) {
          const d = n.indexOf(":");
          d !== -1 && (n = n.substr(d + 1));
        }
        this.options.transformTagName && (n = this.options.transformTagName(n)), i && (s = this.saveTextToParentTag(s, i, o));
        const h = o.substring(o.lastIndexOf(".") + 1);
        if (n && this.options.unpairedTags.indexOf(n) !== -1)
          throw new Error(`Unpaired tag can not be used as closing tag: </${n}>`);
        let c = 0;
        h && this.options.unpairedTags.indexOf(h) !== -1 ? (c = o.lastIndexOf(".", o.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : c = o.lastIndexOf("."), o = o.substring(0, c), i = this.tagsNodeStack.pop(), s = "", a = l;
      } else if (e[a + 1] === "?") {
        let l = os(e, a, !1, "?>");
        if (!l) throw new Error("Pi Tag is not closed.");
        if (s = this.saveTextToParentTag(s, i, o), !(this.options.ignoreDeclaration && l.tagName === "?xml" || this.options.ignorePiTags)) {
          const n = new Ve(l.tagName);
          n.add(this.options.textNodeName, ""), l.tagName !== l.tagExp && l.attrExpPresent && (n[":@"] = this.buildAttributesMap(l.tagExp, o, l.tagName)), this.addChild(i, n, o);
        }
        a = l.closeIndex + 1;
      } else if (e.substr(a + 1, 3) === "!--") {
        const l = we(e, "-->", a + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const n = e.substring(a + 4, l - 2);
          s = this.saveTextToParentTag(s, i, o), i.add(this.options.commentPropName, [{ [this.options.textNodeName]: n }]);
        }
        a = l;
      } else if (e.substr(a + 1, 2) === "!D") {
        const l = Tc(e, a);
        this.docTypeEntities = l.entities, a = l.i;
      } else if (e.substr(a + 1, 2) === "![") {
        const l = we(e, "]]>", a, "CDATA is not closed.") - 2, n = e.substring(a + 9, l);
        s = this.saveTextToParentTag(s, i, o);
        let h = this.parseTextData(n, i.tagname, o, !0, !1, !0, !0);
        h == null && (h = ""), this.options.cdataPropName ? i.add(this.options.cdataPropName, [{ [this.options.textNodeName]: n }]) : i.add(this.options.textNodeName, h), a = l + 2;
      } else {
        let l = os(e, a, this.options.removeNSPrefix), n = l.tagName;
        const h = l.rawTagName;
        let c = l.tagExp, d = l.attrExpPresent, u = l.closeIndex;
        this.options.transformTagName && (n = this.options.transformTagName(n)), i && s && i.tagname !== "!xml" && (s = this.saveTextToParentTag(s, i, o, !1));
        const f = i;
        if (f && this.options.unpairedTags.indexOf(f.tagname) !== -1 && (i = this.tagsNodeStack.pop(), o = o.substring(0, o.lastIndexOf("."))), n !== t.tagname && (o += o ? "." + n : n), this.isItStopNode(this.options.stopNodes, o, n)) {
          let g = "";
          if (c.length > 0 && c.lastIndexOf("/") === c.length - 1)
            n[n.length - 1] === "/" ? (n = n.substr(0, n.length - 1), o = o.substr(0, o.length - 1), c = n) : c = c.substr(0, c.length - 1), a = l.closeIndex;
          else if (this.options.unpairedTags.indexOf(n) !== -1)
            a = l.closeIndex;
          else {
            const v = this.readStopNodeData(e, h, u + 1);
            if (!v) throw new Error(`Unexpected end of ${h}`);
            a = v.i, g = v.tagContent;
          }
          const y = new Ve(n);
          n !== c && d && (y[":@"] = this.buildAttributesMap(c, o, n)), g && (g = this.parseTextData(g, n, o, !0, d, !0, !0)), o = o.substr(0, o.lastIndexOf(".")), y.add(this.options.textNodeName, g), this.addChild(i, y, o);
        } else {
          if (c.length > 0 && c.lastIndexOf("/") === c.length - 1) {
            n[n.length - 1] === "/" ? (n = n.substr(0, n.length - 1), o = o.substr(0, o.length - 1), c = n) : c = c.substr(0, c.length - 1), this.options.transformTagName && (n = this.options.transformTagName(n));
            const g = new Ve(n);
            n !== c && d && (g[":@"] = this.buildAttributesMap(c, o, n)), this.addChild(i, g, o), o = o.substr(0, o.lastIndexOf("."));
          } else {
            const g = new Ve(n);
            this.tagsNodeStack.push(i), n !== c && d && (g[":@"] = this.buildAttributesMap(c, o, n)), this.addChild(i, g, o), i = g;
          }
          s = "", a = u;
        }
      }
    else
      s += e[a];
  return t.child;
};
function Dc(e, t, i) {
  const s = this.options.updateTag(t.tagname, i, t[":@"]);
  s === !1 || (typeof s == "string" && (t.tagname = s), e.addChild(t));
}
const Bc = function(e) {
  if (this.options.processEntities) {
    for (let t in this.docTypeEntities) {
      const i = this.docTypeEntities[t];
      e = e.replace(i.regx, i.val);
    }
    for (let t in this.lastEntities) {
      const i = this.lastEntities[t];
      e = e.replace(i.regex, i.val);
    }
    if (this.options.htmlEntities)
      for (let t in this.htmlEntities) {
        const i = this.htmlEntities[t];
        e = e.replace(i.regex, i.val);
      }
    e = e.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return e;
};
function zc(e, t, i, s) {
  return e && (s === void 0 && (s = Object.keys(t.child).length === 0), e = this.parseTextData(
    e,
    t.tagname,
    i,
    !1,
    t[":@"] ? Object.keys(t[":@"]).length !== 0 : !1,
    s
  ), e !== void 0 && e !== "" && t.add(this.options.textNodeName, e), e = ""), e;
}
function Hc(e, t, i) {
  const s = "*." + i;
  for (const o in e) {
    const a = e[o];
    if (s === a || t === a) return !0;
  }
  return !1;
}
function Fc(e, t, i = ">") {
  let s, o = "";
  for (let a = t; a < e.length; a++) {
    let r = e[a];
    if (s)
      r === s && (s = "");
    else if (r === '"' || r === "'")
      s = r;
    else if (r === i[0])
      if (i[1]) {
        if (e[a + 1] === i[1])
          return {
            data: o,
            index: a
          };
      } else
        return {
          data: o,
          index: a
        };
    else r === "	" && (r = " ");
    o += r;
  }
}
function we(e, t, i, s) {
  const o = e.indexOf(t, i);
  if (o === -1)
    throw new Error(s);
  return o + t.length - 1;
}
function os(e, t, i, s = ">") {
  const o = Fc(e, t + 1, s);
  if (!o) return;
  let a = o.data;
  const r = o.index, l = a.search(/\s/);
  let n = a, h = !0;
  l !== -1 && (n = a.substring(0, l), a = a.substring(l + 1).trimStart());
  const c = n;
  if (i) {
    const d = n.indexOf(":");
    d !== -1 && (n = n.substr(d + 1), h = n !== o.data.substr(d + 1));
  }
  return {
    tagName: n,
    tagExp: a,
    closeIndex: r,
    attrExpPresent: h,
    rawTagName: c
  };
}
function Wc(e, t, i) {
  const s = i;
  let o = 1;
  for (; i < e.length; i++)
    if (e[i] === "<")
      if (e[i + 1] === "/") {
        const a = we(e, ">", i, `${t} is not closed`);
        if (e.substring(i + 2, a).trim() === t && (o--, o === 0))
          return {
            tagContent: e.substring(s, i),
            i: a
          };
        i = a;
      } else if (e[i + 1] === "?")
        i = we(e, "?>", i + 1, "StopNode is not closed.");
      else if (e.substr(i + 1, 3) === "!--")
        i = we(e, "-->", i + 3, "StopNode is not closed.");
      else if (e.substr(i + 1, 2) === "![")
        i = we(e, "]]>", i, "StopNode is not closed.") - 2;
      else {
        const a = os(e, i, ">");
        a && ((a && a.tagName) === t && a.tagExp[a.tagExp.length - 1] !== "/" && o++, i = a.closeIndex);
      }
}
function as(e, t, i) {
  if (t && typeof e == "string") {
    const s = e.trim();
    return s === "true" ? !0 : s === "false" ? !1 : Cc(e, i);
  } else
    return la.isExist(e) ? e : "";
}
var jc = Pc, ca = {};
function Vc(e, t) {
  return ha(e, t);
}
function ha(e, t, i) {
  let s;
  const o = {};
  for (let a = 0; a < e.length; a++) {
    const r = e[a], l = Uc(r);
    let n = "";
    if (i === void 0 ? n = l : n = i + "." + l, l === t.textNodeName)
      s === void 0 ? s = r[l] : s += "" + r[l];
    else {
      if (l === void 0)
        continue;
      if (r[l]) {
        let h = ha(r[l], t, n);
        const c = Yc(h, t);
        r[":@"] ? qc(h, r[":@"], n, t) : Object.keys(h).length === 1 && h[t.textNodeName] !== void 0 && !t.alwaysCreateTextNode ? h = h[t.textNodeName] : Object.keys(h).length === 0 && (t.alwaysCreateTextNode ? h[t.textNodeName] = "" : h = ""), o[l] !== void 0 && o.hasOwnProperty(l) ? (Array.isArray(o[l]) || (o[l] = [o[l]]), o[l].push(h)) : t.isArray(l, n, c) ? o[l] = [h] : o[l] = h;
      }
    }
  }
  return typeof s == "string" ? s.length > 0 && (o[t.textNodeName] = s) : s !== void 0 && (o[t.textNodeName] = s), o;
}
function Uc(e) {
  const t = Object.keys(e);
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    if (s !== ":@") return s;
  }
}
function qc(e, t, i, s) {
  if (t) {
    const o = Object.keys(t), a = o.length;
    for (let r = 0; r < a; r++) {
      const l = o[r];
      s.isArray(l, i + "." + l, !0, !0) ? e[l] = [t[l]] : e[l] = t[l];
    }
  }
}
function Yc(e, t) {
  const { textNodeName: i } = t, s = Object.keys(e).length;
  return !!(s === 0 || s === 1 && (e[i] || typeof e[i] == "boolean" || e[i] === 0));
}
ca.prettify = Vc;
const { buildOptions: $c } = xs, Xc = jc, { prettify: Kc } = ca, Gc = bs;
let Jc = class {
  constructor(t) {
    this.externalEntities = {}, this.options = $c(t);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(t, i) {
    if (typeof t != "string") if (t.toString)
      t = t.toString();
    else
      throw new Error("XML data is accepted in String or Bytes[] form.");
    if (i) {
      i === !0 && (i = {});
      const a = Gc.validate(t, i);
      if (a !== !0)
        throw Error(`${a.err.msg}:${a.err.line}:${a.err.col}`);
    }
    const s = new Xc(this.options);
    s.addExternalEntities(this.externalEntities);
    const o = s.parseXml(t);
    return this.options.preserveOrder || o === void 0 ? o : Kc(o, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(t, i) {
    if (i.indexOf("&") !== -1)
      throw new Error("Entity value can't have '&'");
    if (t.indexOf("&") !== -1 || t.indexOf(";") !== -1)
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (i === "&")
      throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[t] = i;
  }
};
var Qc = Jc;
const Zc = `
`;
function th(e, t) {
  let i = "";
  return t.format && t.indentBy.length > 0 && (i = Zc), da(e, t, "", i);
}
function da(e, t, i, s) {
  let o = "", a = !1;
  for (let r = 0; r < e.length; r++) {
    const l = e[r], n = eh(l);
    if (n === void 0) continue;
    let h = "";
    if (i.length === 0 ? h = n : h = `${i}.${n}`, n === t.textNodeName) {
      let g = l[n];
      ih(h, t) || (g = t.tagValueProcessor(n, g), g = ua(g, t)), a && (o += s), o += g, a = !1;
      continue;
    } else if (n === t.cdataPropName) {
      a && (o += s), o += `<![CDATA[${l[n][0][t.textNodeName]}]]>`, a = !1;
      continue;
    } else if (n === t.commentPropName) {
      o += s + `<!--${l[n][0][t.textNodeName]}-->`, a = !0;
      continue;
    } else if (n[0] === "?") {
      const g = ao(l[":@"], t), y = n === "?xml" ? "" : s;
      let v = l[n][0][t.textNodeName];
      v = v.length !== 0 ? " " + v : "", o += y + `<${n}${v}${g}?>`, a = !0;
      continue;
    }
    let c = s;
    c !== "" && (c += t.indentBy);
    const d = ao(l[":@"], t), u = s + `<${n}${d}`, f = da(l[n], t, h, c);
    t.unpairedTags.indexOf(n) !== -1 ? t.suppressUnpairedNode ? o += u + ">" : o += u + "/>" : (!f || f.length === 0) && t.suppressEmptyNode ? o += u + "/>" : f && f.endsWith(">") ? o += u + `>${f}${s}</${n}>` : (o += u + ">", f && s !== "" && (f.includes("/>") || f.includes("</")) ? o += s + t.indentBy + f + s : o += f, o += `</${n}>`), a = !0;
  }
  return o;
}
function eh(e) {
  const t = Object.keys(e);
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    if (e.hasOwnProperty(s) && s !== ":@")
      return s;
  }
}
function ao(e, t) {
  let i = "";
  if (e && !t.ignoreAttributes)
    for (let s in e) {
      if (!e.hasOwnProperty(s)) continue;
      let o = t.attributeValueProcessor(s, e[s]);
      o = ua(o, t), o === !0 && t.suppressBooleanAttributes ? i += ` ${s.substr(t.attributeNamePrefix.length)}` : i += ` ${s.substr(t.attributeNamePrefix.length)}="${o}"`;
    }
  return i;
}
function ih(e, t) {
  e = e.substr(0, e.length - t.textNodeName.length - 1);
  let i = e.substr(e.lastIndexOf(".") + 1);
  for (let s in t.stopNodes)
    if (t.stopNodes[s] === e || t.stopNodes[s] === "*." + i) return !0;
  return !1;
}
function ua(e, t) {
  if (e && e.length > 0 && t.processEntities)
    for (let i = 0; i < t.entities.length; i++) {
      const s = t.entities[i];
      e = e.replace(s.regex, s.val);
    }
  return e;
}
var sh = th;
const oh = sh, ah = na, rh = {
  attributeNamePrefix: "@_",
  attributesGroupName: !1,
  textNodeName: "#text",
  ignoreAttributes: !0,
  cdataPropName: !1,
  format: !1,
  indentBy: "  ",
  suppressEmptyNode: !1,
  suppressUnpairedNode: !0,
  suppressBooleanAttributes: !0,
  tagValueProcessor: function(e, t) {
    return t;
  },
  attributeValueProcessor: function(e, t) {
    return t;
  },
  preserveOrder: !1,
  commentPropName: !1,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: !0,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: !1
};
function he(e) {
  this.options = Object.assign({}, rh, e), this.options.ignoreAttributes === !0 || this.options.attributesGroupName ? this.isAttribute = function() {
    return !1;
  } : (this.ignoreAttributesFn = ah(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = ch), this.processTextOrObjNode = nh, this.options.format ? (this.indentate = lh, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
he.prototype.build = function(e) {
  return this.options.preserveOrder ? oh(e, this.options) : (Array.isArray(e) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (e = {
    [this.options.arrayNodeName]: e
  }), this.j2x(e, 0, []).val);
};
he.prototype.j2x = function(e, t, i) {
  let s = "", o = "";
  const a = i.join(".");
  for (let r in e)
    if (Object.prototype.hasOwnProperty.call(e, r))
      if (typeof e[r] > "u")
        this.isAttribute(r) && (o += "");
      else if (e[r] === null)
        this.isAttribute(r) ? o += "" : r[0] === "?" ? o += this.indentate(t) + "<" + r + "?" + this.tagEndChar : o += this.indentate(t) + "<" + r + "/" + this.tagEndChar;
      else if (e[r] instanceof Date)
        o += this.buildTextValNode(e[r], r, "", t);
      else if (typeof e[r] != "object") {
        const l = this.isAttribute(r);
        if (l && !this.ignoreAttributesFn(l, a))
          s += this.buildAttrPairStr(l, "" + e[r]);
        else if (!l)
          if (r === this.options.textNodeName) {
            let n = this.options.tagValueProcessor(r, "" + e[r]);
            o += this.replaceEntitiesValue(n);
          } else
            o += this.buildTextValNode(e[r], r, "", t);
      } else if (Array.isArray(e[r])) {
        const l = e[r].length;
        let n = "", h = "";
        for (let c = 0; c < l; c++) {
          const d = e[r][c];
          if (!(typeof d > "u")) if (d === null)
            r[0] === "?" ? o += this.indentate(t) + "<" + r + "?" + this.tagEndChar : o += this.indentate(t) + "<" + r + "/" + this.tagEndChar;
          else if (typeof d == "object")
            if (this.options.oneListGroup) {
              const u = this.j2x(d, t + 1, i.concat(r));
              n += u.val, this.options.attributesGroupName && d.hasOwnProperty(this.options.attributesGroupName) && (h += u.attrStr);
            } else
              n += this.processTextOrObjNode(d, r, t, i);
          else if (this.options.oneListGroup) {
            let u = this.options.tagValueProcessor(r, d);
            u = this.replaceEntitiesValue(u), n += u;
          } else
            n += this.buildTextValNode(d, r, "", t);
        }
        this.options.oneListGroup && (n = this.buildObjectNode(n, r, h, t)), o += n;
      } else if (this.options.attributesGroupName && r === this.options.attributesGroupName) {
        const l = Object.keys(e[r]), n = l.length;
        for (let h = 0; h < n; h++)
          s += this.buildAttrPairStr(l[h], "" + e[r][l[h]]);
      } else
        o += this.processTextOrObjNode(e[r], r, t, i);
  return { attrStr: s, val: o };
};
he.prototype.buildAttrPairStr = function(e, t) {
  return t = this.options.attributeValueProcessor(e, "" + t), t = this.replaceEntitiesValue(t), this.options.suppressBooleanAttributes && t === "true" ? " " + e : " " + e + '="' + t + '"';
};
function nh(e, t, i, s) {
  const o = this.j2x(e, i + 1, s.concat(t));
  return e[this.options.textNodeName] !== void 0 && Object.keys(e).length === 1 ? this.buildTextValNode(e[this.options.textNodeName], t, o.attrStr, i) : this.buildObjectNode(o.val, t, o.attrStr, i);
}
he.prototype.buildObjectNode = function(e, t, i, s) {
  if (e === "")
    return t[0] === "?" ? this.indentate(s) + "<" + t + i + "?" + this.tagEndChar : this.indentate(s) + "<" + t + i + this.closeTag(t) + this.tagEndChar;
  {
    let o = "</" + t + this.tagEndChar, a = "";
    return t[0] === "?" && (a = "?", o = ""), (i || i === "") && e.indexOf("<") === -1 ? this.indentate(s) + "<" + t + i + a + ">" + e + o : this.options.commentPropName !== !1 && t === this.options.commentPropName && a.length === 0 ? this.indentate(s) + `<!--${e}-->` + this.newLine : this.indentate(s) + "<" + t + i + a + this.tagEndChar + e + this.indentate(s) + o;
  }
};
he.prototype.closeTag = function(e) {
  let t = "";
  return this.options.unpairedTags.indexOf(e) !== -1 ? this.options.suppressUnpairedNode || (t = "/") : this.options.suppressEmptyNode ? t = "/" : t = `></${e}`, t;
};
he.prototype.buildTextValNode = function(e, t, i, s) {
  if (this.options.cdataPropName !== !1 && t === this.options.cdataPropName)
    return this.indentate(s) + `<![CDATA[${e}]]>` + this.newLine;
  if (this.options.commentPropName !== !1 && t === this.options.commentPropName)
    return this.indentate(s) + `<!--${e}-->` + this.newLine;
  if (t[0] === "?")
    return this.indentate(s) + "<" + t + i + "?" + this.tagEndChar;
  {
    let o = this.options.tagValueProcessor(t, e);
    return o = this.replaceEntitiesValue(o), o === "" ? this.indentate(s) + "<" + t + i + this.closeTag(t) + this.tagEndChar : this.indentate(s) + "<" + t + i + ">" + o + "</" + t + this.tagEndChar;
  }
};
he.prototype.replaceEntitiesValue = function(e) {
  if (e && e.length > 0 && this.options.processEntities)
    for (let t = 0; t < this.options.entities.length; t++) {
      const i = this.options.entities[t];
      e = e.replace(i.regex, i.val);
    }
  return e;
};
function lh(e) {
  return this.options.indentBy.repeat(e);
}
function ch(e) {
  return e.startsWith(this.options.attributeNamePrefix) && e !== this.options.textNodeName ? e.substr(this.attrPrefixLen) : !1;
}
var hh = he;
const dh = bs, uh = Qc, fh = hh;
var gh = {
  XMLParser: uh,
  XMLValidator: dh,
  XMLBuilder: fh
};
const $t = ":@";
let ot, xe, le = [];
function vh(e) {
  const s = new gh.XMLParser({
    ignoreAttributes: !1,
    attributeNamePrefix: "",
    preserveOrder: !0
  }).parse(e).filter((a) => a.svg), o = [];
  return le = [], s.forEach((a) => {
    const r = a[$t];
    ot = bh(r), ot.width < ot.height ? (r.height || (r.height = 40), xe = r.height / ot.height, !r.width && (r.width = xe * ot.width)) : (r.width || (r.width = 40), xe = r.width / ot.width, !r.height && (r.height = xe * ot.height));
    const n = a.svg, h = {};
    for (let d = 0; d < n.length; d++)
      n[d].g && (h[d] = fa(n[d]));
    for (let d in h)
      n.splice(Number(d), 1, ...h[d]);
    const c = ga(r, n);
    o.push(...c);
  }), yh(o[0]), o;
}
function fa(e) {
  if (e.g && e.g.length == 1 && e.g[0][$t]) {
    const t = Object.keys(e.g[0][$t]);
    if (t.length == 2 && t[0] == "id" && t[1] == "data-name")
      return fa(e.g[0]);
  }
  return e.g;
}
function yh(e) {
  le = le.map((t, i) => ({
    id: i + "",
    penId: e.id,
    x: t.x,
    y: t.y
  })), e.anchors = le;
}
function ga(e, t) {
  const i = [], [s, o] = Ph(e), a = {
    id: nt(),
    name: "combine",
    x: e.x,
    // 最外层的 conbine 用不到该属性
    y: e.y,
    locked: e.locked,
    width: s,
    height: o,
    children: []
  };
  return i.push(a), t.forEach((r) => {
    let l;
    const n = r[$t];
    if (n && n.transform && r.g && r.g.forEach((h) => {
      h[$t] ? h[$t].transform = n.transform : h[$t] = {
        transform: n.transform
      };
    }), r.g)
      l = ga(
        {
          // TODO: g 暂时认为是与父元素一样大
          x: 0,
          y: 0,
          width: 1,
          height: 1,
          locked: 10,
          // 内层的 combine locked 10
          ...n
        },
        r.g
      );
    else if (r.defs)
      lo(r.defs.filter((h) => h.style)), Ch(r.defs.filter((h) => h.linearGradient));
    else if (r.style)
      lo([{ style: r.style }]);
    else if (n)
      if (l = wh(n, e, a.id), r.path)
        l = mh(n, l);
      else if (r.rect) {
        l = ph(n, l);
        const h = l;
        [
          {
            x: h.x + h.width * 0.5,
            y: h.y
          },
          {
            x: h.x + h.width * 1,
            y: h.y + h.height * 0.5
          },
          {
            x: h.x + h.width * 0.5,
            y: h.y + h.height * 1
          },
          {
            x: h.x,
            y: h.y + h.height * 0.5
          }
        ].forEach((d) => {
          (d.x <= 0.01 || d.x >= 0.99 || d.y <= 0.01 || d.y >= 0.99) && le.push(d);
        });
      } else if (r.circle) {
        l = ro(n, l);
        const h = l;
        [
          {
            x: h.x + h.width * 0.5,
            y: h.y
          },
          {
            x: h.x + h.width * 1,
            y: h.y + h.height * 0.5
          },
          {
            x: h.x + h.width * 0.5,
            y: h.y + h.height * 1
          },
          {
            x: h.x,
            y: h.y + h.height * 0.5
          }
        ].forEach((d) => {
          (d.x <= 0.01 || d.x >= 0.99 || d.y <= 0.01 || d.y >= 0.99) && le.push(d);
        });
      } else if (r.ellipse)
        l = ro(n, l);
      else if (r.line) {
        l = kh(n, l);
        const h = l;
        h.anchors.forEach((c) => {
          const d = h.x + c.x * h.width, u = h.y + c.y * h.height;
          (d < 0.01 || d > 0.99 || u < 0.01 || u > 0.99) && le.push({
            x: d,
            y: u
          });
        });
      } else if (r.polygon)
        l = ya(n, l);
      else if (r.polyline) {
        l = Ih(n, l);
        const h = l;
        h.anchors.forEach((c) => {
          const d = h.x + c.x * h.width, u = h.y + c.y * h.height;
          (d < 0.01 || d > 0.99 || u < 0.01 || u > 0.99) && le.push({
            x: d,
            y: u
          });
        });
      } else r.text ? l = Ah(n, r.text, l) : r.image ? l = Sh(n, l) : l = void 0;
    if (l)
      if (Array.isArray(l)) {
        for (const h of l)
          h.parentId || (h.parentId = a.id, a.children.push(h.id));
        i.push(...l);
      } else
        a.children.push(l.id), i.push(l);
  }), i;
}
function va(e) {
  let t = 0, i = 0;
  if (e) {
    let s = e.replace("translate(", "").replace(")", "").split(",");
    t = parseFloat(s[0]), i = parseFloat(s[1]);
  }
  return {
    offsetX: t,
    offsetY: i
  };
}
function mh(e, t) {
  let i = e.d;
  if (!i)
    return;
  let s = qo(i), o = Zi(s), { offsetX: a, offsetY: r } = va(e.transform);
  o.x += a, o.ex += a, o.y += r, o.ey += r;
  const l = (o.x + t.x - ot.x) / ot.width, n = (o.y + t.y - ot.y) / ot.height, h = o.width / ot.width <= 1 ? o.width / ot.width : 1, c = o.height / ot.height <= 1 ? o.height / ot.height : 1;
  return {
    ...t,
    name: "svgPath",
    pathId: nt(),
    // 同样的 pathId ，避免重复存储 path
    path: i,
    x: l,
    y: n,
    width: h,
    height: c,
    disableAnchor: !0
  };
}
function ph(e, t) {
  const i = (e.x || 0 - ot.x + t.x) / ot.width, s = (e.y || 0 - ot.y + t.y) / ot.height, o = e.width / ot.width <= 1 ? e.width / ot.width : 1, a = e.height / ot.height <= 1 ? e.height / ot.height : 1, r = e.rx / e.width || e.ry / e.height || 0;
  return {
    ...t,
    name: "rectangle",
    x: i,
    y: s,
    width: o,
    height: a,
    borderRadius: r
  };
}
function ro(e, t) {
  const i = e.rx || e.r, s = e.ry || e.r, o = (e.cx - i - ot.x + t.x) / ot.width, a = (e.cy - s - ot.y + t.y) / ot.height, r = 2 * i / ot.width, l = 2 * s / ot.height;
  return {
    ...t,
    name: "circle",
    x: o,
    y: a,
    width: r,
    height: l
  };
}
function bh(e) {
  if (e.viewBox) {
    const t = e.viewBox.split(" ");
    return {
      x: Number(t[0]),
      y: Number(t[1]),
      width: Number(t[2]),
      height: Number(t[3])
    };
  } else
    return {
      x: 0,
      y: 0,
      width: parseFloat(e.width),
      height: parseFloat(e.height)
    };
}
function wh(e, t, i) {
  var f;
  const s = co(e.class), o = co(t.class), a = rs(e.style), r = rs(t.style), l = {
    ...t,
    ...o,
    ...r,
    ...e,
    ...s,
    ...a
  };
  let n;
  if (l.fill !== "none") if ((f = l.fill) != null && f.includes("url")) {
    const g = l.fill.replace("url(#", "").replace(")", "");
    let y = ns.find((v) => v.id === g);
    y && !y.color && (y = ns.find(
      (v) => y.from === `#${v.id}`
    )), n = y == null ? void 0 : y.color;
  } else
    n = l.fill, !n && (n = "#000");
  let h = 0, c = 0, d = 0, u = null;
  return l.transform && l.transform.split(") ").forEach((y) => {
    const [v, b] = y.split("("), [x, p] = b.split(" ");
    v === "translate" ? (h = Number(x) || 0, c = Number(p) || 0) : v === "rotate" ? (d = parseFloat(b), h = 0, c = 0) : v === "matrix" && (u = b.split(" ").map((k) => parseFloat(k)));
  }), {
    id: nt(),
    locked: 10,
    parentId: i,
    x: h,
    y: c,
    rotate: d,
    // TODO: background 可以为空
    background: n,
    color: l.stroke,
    lineWidth: l["stroke-width"] ? parseFloat(l["stroke-width"]) * xe : l.stroke ? 1 : 0,
    lineCap: l.strokeLinecap,
    lineJoin: l.strokeLinejoin,
    lineDash: l.strokeDasharray,
    // TODO: 可能不是数组类型
    lineDashOffset: l.strokeDashoffset,
    // strokeMiterlimit: path.strokeMiterlimit,
    globalAlpha: Number(l.opacity),
    // transform: path.transform,
    fontSize: l["font-size"] ? parseFloat(l["font-size"]) * xe : 16,
    fontFamily: l["font-family"],
    fontWeight: l["font-weight"],
    fontStyle: l["font-style"],
    matrix: u
  };
}
function xh(e) {
  const i = e.replace(/[\'\"\\\/\b\f\n\r\t]/g, "").split(/\s|,/), s = [];
  return i.forEach((o, a) => {
    a % 2 === 0 && s.push({
      x: Number(o),
      y: Number(i[a + 1])
    });
  }), s;
}
function ya(e, t) {
  const i = e.points, s = xh(i), o = Fe(s), a = s.map((r) => ({
    x: (r.x - o.x) / o.width,
    y: (r.y - o.y) / o.height,
    id: nt()
  }));
  return {
    ...t,
    name: "line",
    lineName: "line",
    type: 0,
    close: !0,
    anchors: a,
    x: (o.x - ot.x + t.x) / ot.width,
    y: (o.y - ot.y + t.y) / ot.height,
    width: o.width / ot.width,
    height: o.height / ot.height
  };
}
function no(e, t) {
  const [i, s, o, a, r, l] = t, n = e.x, h = e.y, c = i * n + o * h + r, d = s * n + a * h + l;
  return [c, d];
}
function kh(e, t) {
  let i = Number(e.x1) || 0, s = Number(e.x2) || 0, o = Number(e.y1) || 0, a = Number(e.y2) || 0;
  Array.isArray(t.matrix) && ([i, o] = no({ x: i, y: o }, t.matrix), [s, a] = no({ x: s, y: a }, t.matrix));
  const r = Math.min(i, s), l = Math.max(i, s), n = Math.min(o, a), h = Math.max(o, a), c = (r - ot.x + t.x) / ot.width, d = (n - ot.y + t.y) / ot.height, u = (l - r) / ot.width, f = (h - n) / ot.height;
  return {
    ...t,
    name: "line",
    lineName: "line",
    type: 0,
    x: c,
    y: d,
    width: u,
    height: f,
    anchors: [
      {
        x: i < s ? 0 : 1,
        y: o < a ? 0 : 1,
        hidden: !0,
        id: nt()
      },
      {
        x: i < s ? 1 : 0,
        y: o < a ? 1 : 0,
        hidden: !0,
        id: nt()
      }
    ]
  };
}
function Ih(e, t) {
  const i = ya(e, t);
  return Object.assign(i, {
    close: !1,
    type: 1,
    anchors: i.anchors.map((s) => (s.hidden = !0, s))
  });
}
function Ah(e, t, i) {
  var n;
  const s = (n = t[0]) == null ? void 0 : n[ma], o = Th(s, i), a = 0;
  let { offsetX: r, offsetY: l } = va(e.transform);
  return {
    ...i,
    name: "text",
    textAlign: "left",
    text: s,
    x: (parseFloat(e.x) + (r || 0) - ot.x + i.x) / ot.width,
    y: (parseFloat(e.y) + (l || 0) - ot.y + i.y - a) / ot.height,
    width: o / ot.width,
    height: a / ot.height
  };
}
function Sh(e, t) {
  const { x: i, y: s, width: o, height: a } = e;
  return {
    ...t,
    name: "image",
    x: (i - ot.x + t.x) / ot.width,
    y: (s - ot.y + t.y) / ot.height,
    width: o / ot.width,
    height: a / ot.height,
    image: e["xlink:href"]
  };
}
function Th(e, t) {
  return (t.fontSize || 16) / xe * String(e).length;
}
function rs(e) {
  if (!e)
    return {};
  const t = e.split(";"), i = {};
  return t.forEach((s) => {
    const [o, a] = s.split(":");
    o && (i[o] = a);
  }), i;
}
const ma = "#text";
let bi;
function lo(e) {
  e.forEach((t) => {
    t.style && t.style[0] && (bi = Rh(t.style[0][ma]));
  });
}
let ns = [];
function Ch(e) {
  e.forEach((t) => {
    if (t.linearGradient) {
      const i = {
        id: t[$t].id,
        from: t[$t]["xlink:href"],
        color: void 0
      };
      t.linearGradient.length > 0 && (i.color = t.linearGradient[0][$t]["stop-color"]), ns.push(i);
    }
  });
}
function Rh(e) {
  const t = {};
  return e.split("}").forEach((s) => {
    const [o, a] = s.split("{");
    o && (t[o.trim()] = rs(a));
  }), t;
}
function co(e) {
  const t = {};
  for (const i in bi)
    if (Object.prototype.hasOwnProperty.call(bi, i)) {
      const s = bi[i];
      (i === "." + e || i.includes("." + e + ",") || i.includes(",." + e)) && Object.assign(t, s);
    }
  return t;
}
function Ph(e) {
  var s;
  if ((s = String(e.width)) != null && s.endsWith("in")) {
    const o = parseFloat(e.width) * 96, a = parseFloat(e.height) * 96;
    return [o, a];
  }
  const t = parseFloat(e.width) || 0, i = parseFloat(e.height) || 0;
  return [t, i];
}
function Eh(e, t, i = !0) {
  if (!e) return [];
  const s = vh(e);
  return s.forEach((o) => {
    var a;
    o.x || (o.x = 0), o.y || (o.y = 0), o.name == "combine" && !o.parentId && (o.description = t == null ? void 0 : t.name, (a = t == null ? void 0 : t.data) != null && a.anchors && i && t.data.anchors.forEach((r) => {
      //! 报错
      if (o.anchors) {
        const l = o.anchors.length;
        r.id = l, o.anchors.push(r);
      } else
        o.anchors = [r];
    }));
  }), i && (meta2d.canvas.addCaches = G(s)), s;
}
const _h = (e, t, i = !0) => fetch(e).then((s) => s.text().then((a) => Eh(a, t, i))), Lh = 2015, Mh = -2404, Nh = 2.2962853358150284, Oh = [
  {
    id: "251c6ba9",
    name: "combine",
    x: -1917.2818412992815,
    y: 2786.8430321398773,
    ex: -1881.4505065758517,
    ey: 2878.6944455724783,
    width: 35.83133472342976,
    height: 91.85141343260094,
    center: {
      x: -1899.3661739375666,
      y: 2832.7687388561776
    },
    children: [
      "179d2635",
      "8f6b874"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "251c6ba9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "251c6ba9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "251c6ba9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "251c6ba9"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch"
    ],
    description: "开关-通用开关"
  },
  {
    id: "179d2635",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1,
    height: 1,
    children: [
      "efe2dc1",
      "0336d6d",
      "fd8c6a3",
      "2e93e1de",
      "48940cd4",
      "7614682"
    ],
    anchors: [
      {
        id: "0",
        penId: "179d2635",
        x: 0.9069451980466631,
        y: 0
      },
      {
        id: "1",
        penId: "179d2635",
        x: 0.9069451980466631,
        y: 1
      }
    ],
    description: "开关-通用开关-断开",
    parentId: "251c6ba9",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1,
    ey: 1
  },
  {
    id: "efe2dc1",
    locked: 10,
    parentId: "179d2635",
    x: 0.9069451980466631,
    y: 0,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.2964563526361279,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d368225",
        penId: "efe2dc1"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5757269e",
        penId: "efe2dc1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0336d6d",
    locked: 10,
    parentId: "179d2635",
    x: 0.9069451980466631,
    y: 0.6666607870460198,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33333921295398017,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8156d51",
        penId: "0336d6d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5d1bd0bb",
        penId: "0336d6d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "fd8c6a3",
    locked: 10,
    parentId: "179d2635",
    x: 0.8093687827816965,
    y: 0.2952745488861059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "818f759",
    width: 0.19515283052993293,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fd8c6a3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fd8c6a3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fd8c6a3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fd8c6a3"
      }
    ]
  },
  {
    id: "2e93e1de",
    locked: 10,
    parentId: "179d2635",
    x: 0.43868692349430277,
    y: 0.30132467853174116,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46825827455236035,
    height: 0.36533610851427867,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "653d183",
        penId: "2e93e1de"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "59cb558",
        penId: "2e93e1de"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "48940cd4",
    locked: 10,
    parentId: "179d2635",
    x: 0.1861096039066739,
    y: 0.4722981673222444,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46780611322119736,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "6f687ae0",
        penId: "48940cd4"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2b7d21de",
        penId: "48940cd4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7614682",
    locked: 10,
    parentId: "179d2635",
    x: -0.004521613311629589,
    y: 0.4363854444111267,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "64c23b2",
    width: 0.19515283052993307,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7614682"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7614682"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7614682"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7614682"
      }
    ]
  },
  {
    id: "8f6b874",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1,
    height: 1,
    children: [
      "5fb70c43",
      "50b9d5d1",
      "d85f845",
      "a70f7f1",
      "a0fac3b",
      "448edcea"
    ],
    anchors: [
      {
        id: "0",
        penId: "8f6b874",
        x: 0.9069451980466631,
        y: 0
      },
      {
        id: "1",
        penId: "8f6b874",
        x: 0.9069451980466631,
        y: 1
      }
    ],
    description: "开关-通用开关-闭合",
    parentId: "251c6ba9",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1,
    ey: 1
  },
  {
    id: "5fb70c43",
    locked: 10,
    parentId: "8f6b874",
    x: 0.9069451980466631,
    y: 0,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.2964563526361279,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "a594399",
        penId: "5fb70c43"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1e80702",
        penId: "5fb70c43"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "50b9d5d1",
    locked: 10,
    parentId: "8f6b874",
    x: 0.9069451980466631,
    y: 0.6666607870460198,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33333921295398017,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "0fac3c5",
        penId: "50b9d5d1"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d17d7fd",
        penId: "50b9d5d1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d85f845",
    locked: 10,
    parentId: "8f6b874",
    x: 0.8093687827816965,
    y: 0.2952745488861059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "fb0b262",
    width: 0.19515283052993293,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d85f845"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d85f845"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d85f845"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d85f845"
      }
    ]
  },
  {
    id: "a70f7f1",
    locked: 10,
    parentId: "8f6b874",
    x: 0.7954422137818773,
    y: 0.2607552960682977,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11150298426478579,
    height: 0.4061347961829503,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "c1a1ac",
        penId: "a70f7f1"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "b22a5c5",
        penId: "a70f7f1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "a0fac3b",
    locked: 10,
    parentId: "8f6b874",
    x: 0.3850605896183758,
    y: 0.4722981673222444,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.46780611322119736,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3718d05",
        penId: "a0fac3b"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "16ac617f",
        penId: "a0fac3b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "448edcea",
    locked: 10,
    parentId: "8f6b874",
    x: 0.19442937240007235,
    y: 0.4363854444111267,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "607a597",
    width: 0.19515283052993307,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "448edcea"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "448edcea"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "448edcea"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "448edcea"
      }
    ]
  },
  {
    id: "1f12a7e",
    name: "combine",
    x: -1775.3416239933122,
    y: 2786.8430321398773,
    ex: -1737.226639660149,
    ey: 2878.6944455724783,
    width: 38.114984333163285,
    height: 91.8514134326011,
    center: {
      x: -1756.2841318267306,
      y: 2832.768738856178
    },
    children: [
      "3f995752",
      "74bec5df"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1f12a7e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1f12a7e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1f12a7e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1f12a7e"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Knob_SelfLock"
    ],
    description: "开关-自锁旋转开关"
  },
  {
    id: "3f995752",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999998,
    height: 0.9999999999999997,
    children: [
      "6616a45f",
      "e73feb9",
      "18daee8",
      "b584622",
      "3e24993a",
      "646c5b85",
      "fc72299",
      "f64fd90",
      "e218fe2",
      "19e77bf0"
    ],
    anchors: [
      {
        id: "0",
        penId: "3f995752",
        x: 0.008795074758135445,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.6653284671532848
      },
      {
        id: "2",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.9963503649635037
      },
      {
        id: "3",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.6653284671532846
      },
      {
        id: "4",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.0036496350364963507
      },
      {
        id: "5",
        penId: "3f995752",
        x: 0.9912049252418645,
        y: 0.33467153284671536
      }
    ],
    description: "开关-自锁旋转开关-断开",
    parentId: "1f12a7e",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999998,
    ey: 0.9999999999999997
  },
  {
    id: "6616a45f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "54a5ea1b"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6616a45f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6616a45f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6616a45f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6616a45f"
      }
    ],
    rotate: 0
  },
  {
    id: "54a5ea1b",
    locked: 10,
    parentId: "6616a45f",
    x: 0.33157431838170626,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.08883025505716802,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "0dba702",
        penId: "54a5ea1b"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "10ec58a",
        penId: "54a5ea1b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e73feb9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "bb9a15d"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "e73feb9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "e73feb9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "e73feb9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "e73feb9"
      }
    ],
    rotate: 0
  },
  {
    id: "bb9a15d",
    locked: 10,
    parentId: "e73feb9",
    x: 0.4204045734388743,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.0897097625329815,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "844743",
        penId: "bb9a15d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "700e943f",
        penId: "bb9a15d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "18daee8",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a34c0e0"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "18daee8"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "18daee8"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "18daee8"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "18daee8"
      }
    ],
    rotate: 0
  },
  {
    id: "a34c0e0",
    locked: 10,
    parentId: "18daee8",
    x: 0.008795074758135445,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1996481970096746,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e50983d",
        penId: "a34c0e0"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "61365582",
        penId: "a34c0e0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b584622",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "6494b91"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "b584622"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "b584622"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "b584622"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "b584622"
      }
    ],
    rotate: 0
  },
  {
    id: "6494b91",
    locked: 10,
    parentId: "b584622",
    x: 0.20844327176781005,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19964819700967457,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "202f7e2",
        penId: "6494b91"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "53f53a",
        penId: "6494b91"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3e24993a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7ebd9e0"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3e24993a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3e24993a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3e24993a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3e24993a"
      }
    ],
    rotate: 0
  },
  {
    id: "7ebd9e0",
    locked: 10,
    parentId: "3e24993a",
    x: 0.20844327176781005,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e13f914",
        penId: "7ebd9e0"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "58acebce",
        penId: "7ebd9e0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "646c5b85",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "279e9fb8"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "646c5b85"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "646c5b85"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "646c5b85"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "646c5b85"
      }
    ],
    rotate: 0
  },
  {
    id: "279e9fb8",
    locked: 10,
    parentId: "646c5b85",
    x: 0.9912049252418645,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2acf0ff3",
        penId: "279e9fb8"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1bbfe463",
        penId: "279e9fb8"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "fc72299",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "769661e"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fc72299"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fc72299"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fc72299"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fc72299"
      }
    ],
    rotate: 0
  },
  {
    id: "769661e",
    locked: 10,
    parentId: "fc72299",
    x: 0.4335971855760774,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5576077396657871,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "a11431",
        penId: "769661e"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2a0d06b",
        penId: "769661e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f64fd90",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f83e670"
    ],
    parentId: "3f995752",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f64fd90"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f64fd90"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f64fd90"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f64fd90"
      }
    ],
    rotate: 0
  },
  {
    id: "f83e670",
    locked: 10,
    parentId: "f64fd90",
    x: 0.9912049252418645,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6aa4fb5",
        penId: "f83e670"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "34646ed3",
        penId: "f83e670"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e218fe2",
    locked: 10,
    parentId: "3f995752",
    x: 0.20844327176781005,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.12313104661389622,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5c87262",
        penId: "e218fe2"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ddfbe32",
        penId: "e218fe2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "19e77bf0",
    locked: 10,
    parentId: "3f995752",
    x: 0.5101143359718557,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2022867194371152,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "e2dee6e",
        penId: "19e77bf0"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "76eb44b9",
        penId: "19e77bf0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "74bec5df",
    name: "combine",
    x: 0.09630606860157255,
    y: 0,
    locked: 0,
    width: 0.8073878627968337,
    height: 0.9999999999999997,
    children: [
      "ff6d8d9",
      "d3109f",
      "66206ce0",
      "3620bd9",
      "7bf1eeef",
      "8e44f5e",
      "ef5ee9f",
      "20d45f8e",
      "57453965",
      "b1cfbb3",
      "6689d1"
    ],
    anchors: [
      {
        id: "0",
        penId: "74bec5df",
        x: 0.9891067538126362,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "74bec5df",
        x: 0.9891067538126362,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自锁旋转开关-闭合",
    parentId: "1f12a7e",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9036939313984063,
    ey: 0.9999999999999997
  },
  {
    id: "ff6d8d9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b9a2f9e"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ff6d8d9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ff6d8d9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ff6d8d9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ff6d8d9"
      }
    ],
    rotate: 0
  },
  {
    id: "b9a2f9e",
    locked: 10,
    parentId: "ff6d8d9",
    x: 0.7233115468409586,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26579520697167763,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3f55fdc9",
        penId: "b9a2f9e"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "d5d9a7d",
        penId: "b9a2f9e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d3109f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "373e24"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d3109f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d3109f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d3109f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d3109f"
      }
    ],
    rotate: 0
  },
  {
    id: "373e24",
    locked: 10,
    parentId: "d3109f",
    x: 0.9891067538126362,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7410e17d",
        penId: "373e24"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "14f8abf",
        penId: "373e24"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "66206ce0",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "659d77b"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "66206ce0"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "66206ce0"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "66206ce0"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "66206ce0"
      }
    ],
    rotate: 0
  },
  {
    id: "659d77b",
    locked: 10,
    parentId: "66206ce0",
    x: 0.7494553376906318,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23965141612200438,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "7158caa",
        penId: "659d77b"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "dde7ee7",
        penId: "659d77b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3620bd9",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f888a55"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3620bd9"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3620bd9"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3620bd9"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3620bd9"
      }
    ],
    rotate: 0
  },
  {
    id: "f888a55",
    locked: 10,
    parentId: "3620bd9",
    x: 0.9891067538126362,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "668291e0",
        penId: "f888a55"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "643a6891",
        penId: "f888a55"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7bf1eeef",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "8527b0"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7bf1eeef"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7bf1eeef"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7bf1eeef"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7bf1eeef"
      }
    ],
    rotate: 0
  },
  {
    id: "8527b0",
    locked: 10,
    parentId: "7bf1eeef",
    x: 0.4106753812636166,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11002178649237476,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "56a6bcd6",
        penId: "8527b0"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3d4da39c",
        penId: "8527b0"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "8e44f5e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9238a84"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "8e44f5e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "8e44f5e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "8e44f5e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "8e44f5e"
      }
    ],
    rotate: 0
  },
  {
    id: "9238a84",
    locked: 10,
    parentId: "8e44f5e",
    x: 0.010893246187363835,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24727668845315906,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5c879633",
        penId: "9238a84"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "312e0e53",
        penId: "9238a84"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ef5ee9f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "757a51e"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ef5ee9f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ef5ee9f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ef5ee9f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ef5ee9f"
      }
    ],
    rotate: 0
  },
  {
    id: "757a51e",
    locked: 10,
    parentId: "ef5ee9f",
    x: 0.2581699346405229,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.247276688453159,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "17802cc",
        penId: "757a51e"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "79c02ddc",
        penId: "757a51e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20d45f8e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a1299e4"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "20d45f8e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "20d45f8e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "20d45f8e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "20d45f8e"
      }
    ],
    rotate: 0
  },
  {
    id: "a1299e4",
    locked: 10,
    parentId: "20d45f8e",
    x: 0.2581699346405229,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4b138df6",
        penId: "a1299e4"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "aaf1e91",
        penId: "a1299e4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "57453965",
    locked: 10,
    parentId: "74bec5df",
    x: 0.2581699346405229,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.15250544662309368,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "a3bc53",
        penId: "57453965"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2c12c23",
        penId: "57453965"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b1cfbb3",
    locked: 10,
    parentId: "74bec5df",
    x: 0.6318082788671024,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.25054466230936817,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "f3775bd",
        penId: "b1cfbb3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "17bf39a",
        penId: "b1cfbb3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6689d1",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5b9fcab"
    ],
    parentId: "74bec5df",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6689d1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6689d1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6689d1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6689d1"
      }
    ],
    rotate: 0
  },
  {
    id: "5b9fcab",
    locked: 10,
    parentId: "6689d1",
    x: 0.5206971677559913,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.11111111111111106,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3d5ddb1",
        penId: "5b9fcab"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "47d03e5b",
        penId: "5b9fcab"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6dfb",
    name: "combine",
    x: -1638.8912643068752,
    y: 2785.3727420213418,
    ex: -1600.6086679054042,
    ey: 2877.224155453943,
    width: 38.28259640147095,
    height: 91.85141343260112,
    center: {
      x: -1619.7499661061397,
      y: 2831.2984487376425
    },
    children: [
      "56ff30a0",
      "223f54a"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6dfb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6dfb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6dfb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6dfb"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Btn_SelfLock"
    ],
    description: "开关-自锁按钮"
  },
  {
    id: "56ff30a0",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000009,
    height: 0.9999999999999997,
    children: [
      "4c15a83",
      "264dc41",
      "49aad136",
      "3ee358cf",
      "20b8c6",
      "f8e1dc1",
      "4cba84b",
      "13fe1d82",
      "5a73b375"
    ],
    anchors: [
      {
        id: "0",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.594160583941606
      },
      {
        id: "2",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.6653284671532848
      },
      {
        id: "3",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.9963503649635037
      },
      {
        id: "4",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.6653284671532846
      },
      {
        id: "5",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.0036496350364963507
      },
      {
        id: "6",
        penId: "56ff30a0",
        x: 0.9912434325744308,
        y: 0.33467153284671536
      },
      {
        id: "7",
        penId: "56ff30a0",
        x: 0.008756567425569177,
        y: 0.46459854014598545
      }
    ],
    description: "开关-自锁按钮-断开",
    parentId: "6dfb",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000009,
    ey: 0.9999999999999997
  },
  {
    id: "4c15a83",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "63b23b7"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4c15a83"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4c15a83"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4c15a83"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4c15a83"
      }
    ],
    rotate: 0
  },
  {
    id: "63b23b7",
    locked: 10,
    parentId: "4c15a83",
    x: 0.24693520140105077,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.0884413309982487,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "a0126ab",
        penId: "63b23b7"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "504f5d74",
        penId: "63b23b7"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "264dc41",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7ee38676"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "264dc41"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "264dc41"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "264dc41"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "264dc41"
      }
    ],
    rotate: 0
  },
  {
    id: "7ee38676",
    locked: 10,
    parentId: "264dc41",
    x: 0.3353765323992995,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.08931698774080557,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "68b73050",
        penId: "7ee38676"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "96aad71",
        penId: "7ee38676"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "49aad136",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "106ce24f"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "49aad136"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "49aad136"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "49aad136"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "49aad136"
      }
    ],
    rotate: 0
  },
  {
    id: "106ce24f",
    locked: 10,
    parentId: "49aad136",
    x: 0.013134851138353765,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3a86dd35",
        penId: "106ce24f"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "b719e5d",
        penId: "106ce24f"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3ee358cf",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ed612e1"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3ee358cf"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3ee358cf"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3ee358cf"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3ee358cf"
      }
    ],
    rotate: 0
  },
  {
    id: "5ed612e1",
    locked: 10,
    parentId: "3ee358cf",
    x: 0.013134851138353765,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "9830253",
        penId: "5ed612e1"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "ccc420",
        penId: "5ed612e1"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20b8c6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "3d69944"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "20b8c6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "20b8c6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "20b8c6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "20b8c6"
      }
    ],
    rotate: 0
  },
  {
    id: "3d69944",
    locked: 10,
    parentId: "20b8c6",
    x: 0.008756567425569177,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "17cb562",
        penId: "3d69944"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "b26beb3",
        penId: "3d69944"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f8e1dc1",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ee73d3a"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f8e1dc1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f8e1dc1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f8e1dc1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f8e1dc1"
      }
    ],
    rotate: 0
  },
  {
    id: "ee73d3a",
    locked: 10,
    parentId: "f8e1dc1",
    x: 0.9912434325744308,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2202e7b",
        penId: "ee73d3a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ea39150",
        penId: "ee73d3a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4cba84b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "686e50a5"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4cba84b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4cba84b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4cba84b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4cba84b"
      }
    ],
    rotate: 0
  },
  {
    id: "686e50a5",
    locked: 10,
    parentId: "4cba84b",
    x: 0.43607705779334505,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5551663747810858,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5259c8d8",
        penId: "686e50a5"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "4680f719",
        penId: "686e50a5"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "13fe1d82",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "6052ef"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "13fe1d82"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "13fe1d82"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "13fe1d82"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "13fe1d82"
      }
    ],
    rotate: 0
  },
  {
    id: "6052ef",
    locked: 10,
    parentId: "13fe1d82",
    x: 0.9912434325744308,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "10986749",
        penId: "6052ef"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4d11663a",
        penId: "6052ef"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5a73b375",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b7d83e5",
      "4b44534"
    ],
    parentId: "56ff30a0",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5a73b375"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5a73b375"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5a73b375"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5a73b375"
      }
    ],
    rotate: 0
  },
  {
    id: "b7d83e5",
    locked: 10,
    parentId: "5a73b375",
    x: 0.008756567425569177,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23817863397548159,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "4cd5fce",
        penId: "b7d83e5"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "a1f10a0",
        penId: "b7d83e5"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4b44534",
    locked: 10,
    parentId: "5a73b375",
    x: 0.42469352014010503,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2889667250437829,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6afac61b",
        penId: "4b44534"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "73b1c357",
        penId: "4b44534"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "223f54a",
    name: "combine",
    x: 0.09063047285464522,
    y: 0,
    locked: 0,
    width: 0.8187390542907186,
    height: 0.9999999999999997,
    children: [
      "27a60f5e",
      "0c5fa7b",
      "61afb2af",
      "4336ce21",
      "27bb48fc",
      "4dcffcc7",
      "9c724dd",
      "dafe703",
      "81abedc",
      "b5937fa"
    ],
    anchors: [
      {
        id: "0",
        penId: "223f54a",
        x: 0.9893048128342247,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "223f54a",
        x: 0.9893048128342247,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自锁按钮-闭合",
    parentId: "6dfb",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9093695271453638,
    ey: 0.9999999999999997
  },
  {
    id: "27a60f5e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4af889a2"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "27a60f5e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "27a60f5e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "27a60f5e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "27a60f5e"
      }
    ],
    rotate: 0
  },
  {
    id: "4af889a2",
    locked: 10,
    parentId: "27a60f5e",
    x: 0.3016042780748663,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.10802139037433157,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "734716f6",
        penId: "4af889a2"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "cd36907",
        penId: "4af889a2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0c5fa7b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "64a8107"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "0c5fa7b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "0c5fa7b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "0c5fa7b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "0c5fa7b"
      }
    ],
    rotate: 0
  },
  {
    id: "64a8107",
    locked: 10,
    parentId: "0c5fa7b",
    x: 0.4096256684491979,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.10909090909090904,
    height: 0.0967153284671533,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "58693a",
        penId: "64a8107"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "27554959",
        penId: "64a8107"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "61afb2af",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "328a8b96"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "61afb2af"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "61afb2af"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "61afb2af"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "61afb2af"
      }
    ],
    rotate: 0
  },
  {
    id: "328a8b96",
    locked: 10,
    parentId: "61afb2af",
    x: 0.7283422459893047,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26096256684491986,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e873dd9",
        penId: "328a8b96"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1611cf",
        penId: "328a8b96"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4336ce21",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1937d0d2"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4336ce21"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4336ce21"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4336ce21"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4336ce21"
      }
    ],
    rotate: 0
  },
  {
    id: "1937d0d2",
    locked: 10,
    parentId: "4336ce21",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "68945e83",
        penId: "1937d0d2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "564f8ff",
        penId: "1937d0d2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "27bb48fc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "93f2e70"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "27bb48fc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "27bb48fc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "27bb48fc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "27bb48fc"
      }
    ],
    rotate: 0
  },
  {
    id: "93f2e70",
    locked: 10,
    parentId: "27bb48fc",
    x: 0.9893048128342247,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4910df9f",
        penId: "93f2e70"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4bc33ae",
        penId: "93f2e70"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4dcffcc7",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ab0543d"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4dcffcc7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4dcffcc7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4dcffcc7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4dcffcc7"
      }
    ],
    rotate: 0
  },
  {
    id: "5ab0543d",
    locked: 10,
    parentId: "4dcffcc7",
    x: 0.7540106951871658,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23529411764705885,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "32b8f28b",
        penId: "5ab0543d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "7d6f792a",
        penId: "5ab0543d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9c724dd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ab2f7ad"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9c724dd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9c724dd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9c724dd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9c724dd"
      }
    ],
    rotate: 0
  },
  {
    id: "ab2f7ad",
    locked: 10,
    parentId: "9c724dd",
    x: 0.9893048128342247,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e058e22",
        penId: "ab2f7ad"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "753f8a9d",
        penId: "ab2f7ad"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "dafe703",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d64c17",
      "af3e5a8"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dafe703"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dafe703"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dafe703"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dafe703"
      }
    ],
    rotate: 0
  },
  {
    id: "d64c17",
    locked: 10,
    parentId: "dafe703",
    x: 0.010695187165775402,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2909090909090909,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "b9d7405",
        penId: "d64c17"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "8eb45ab",
        penId: "d64c17"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "af3e5a8",
    locked: 10,
    parentId: "dafe703",
    x: 0.5187165775401069,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.3529411764705883,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "096160e",
        penId: "af3e5a8"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "738a652",
        penId: "af3e5a8"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "81abedc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1c18cc7"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "81abedc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "81abedc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "81abedc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "81abedc"
      }
    ],
    rotate: 0
  },
  {
    id: "1c18cc7",
    locked: 10,
    parentId: "81abedc",
    x: 0.010695187165775402,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "11716587",
        penId: "1c18cc7"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "890f4b3",
        penId: "1c18cc7"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b5937fa",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "490327f9"
    ],
    parentId: "223f54a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "b5937fa"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "b5937fa"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "b5937fa"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "b5937fa"
      }
    ],
    rotate: 0
  },
  {
    id: "490327f9",
    locked: 10,
    parentId: "b5937fa",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "c667fd8",
        penId: "490327f9"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "34913b61",
        penId: "490327f9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "707640bd",
    name: "combine",
    x: -1496.0187372814241,
    y: 2788.3277558237087,
    ex: -1457.903752948261,
    ey: 2880.1791692563097,
    width: 38.11498433316316,
    height: 91.85141343260112,
    center: {
      x: -1476.9612451148425,
      y: 2834.2534625400094
    },
    children: [
      "734b6268",
      "77f99e2b"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "707640bd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "707640bd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "707640bd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "707640bd"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Knob_SelfReset"
    ],
    description: "开关-自复旋转开关"
  },
  {
    id: "734b6268",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.000000000000003,
    height: 0.9999999999999997,
    children: [
      "adee920",
      "cf3c833",
      "1059b4a7",
      "418a0ea2",
      "9210dc6",
      "f2ec300",
      "3c81a07d"
    ],
    anchors: [
      {
        id: "0",
        penId: "734b6268",
        x: 0.008795074758135445,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.6653284671532848
      },
      {
        id: "2",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.9963503649635037
      },
      {
        id: "3",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.6653284671532846
      },
      {
        id: "4",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.0036496350364963507
      },
      {
        id: "5",
        penId: "734b6268",
        x: 0.9912049252418645,
        y: 0.33467153284671536
      }
    ],
    description: "开关-自复旋转开关-断开",
    parentId: "707640bd",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.000000000000003,
    ey: 0.9999999999999997
  },
  {
    id: "adee920",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "fb90df3"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "adee920"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "adee920"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "adee920"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "adee920"
      }
    ],
    rotate: 0
  },
  {
    id: "fb90df3",
    locked: 10,
    parentId: "adee920",
    x: 0.008795074758135445,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1996481970096746,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7c5644c3",
        penId: "fb90df3"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "da0a2eb",
        penId: "fb90df3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "cf3c833",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ff046f9"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "cf3c833"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "cf3c833"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "cf3c833"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "cf3c833"
      }
    ],
    rotate: 0
  },
  {
    id: "ff046f9",
    locked: 10,
    parentId: "cf3c833",
    x: 0.20844327176781005,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19964819700967457,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "46b60693",
        penId: "ff046f9"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "46725267",
        penId: "ff046f9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1059b4a7",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1317983"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1059b4a7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1059b4a7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1059b4a7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1059b4a7"
      }
    ],
    rotate: 0
  },
  {
    id: "1317983",
    locked: 10,
    parentId: "1059b4a7",
    x: 0.20844327176781005,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5ba7ed9c",
        penId: "1317983"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "10580a05",
        penId: "1317983"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "418a0ea2",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "44ba209"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "418a0ea2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "418a0ea2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "418a0ea2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "418a0ea2"
      }
    ],
    rotate: 0
  },
  {
    id: "44ba209",
    locked: 10,
    parentId: "418a0ea2",
    x: 0.9912049252418645,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "71a95b10",
        penId: "44ba209"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "0da5101",
        penId: "44ba209"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9210dc6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "39e956ca"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9210dc6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9210dc6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9210dc6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9210dc6"
      }
    ],
    rotate: 0
  },
  {
    id: "39e956ca",
    locked: 10,
    parentId: "9210dc6",
    x: 0.4335971855760774,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5576077396657871,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "92c92ad",
        penId: "39e956ca"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "7fb8c6b",
        penId: "39e956ca"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f2ec300",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "dba3189"
    ],
    parentId: "734b6268",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f2ec300"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f2ec300"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f2ec300"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f2ec300"
      }
    ],
    rotate: 0
  },
  {
    id: "dba3189",
    locked: 10,
    parentId: "f2ec300",
    x: 0.9912049252418645,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "42d60d96",
        penId: "dba3189"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "225e8799",
        penId: "dba3189"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3c81a07d",
    locked: 10,
    parentId: "734b6268",
    x: 0.20844327176781005,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.503957783641161,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6ab4484",
        penId: "3c81a07d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "625af93",
        penId: "3c81a07d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "77f99e2b",
    name: "combine",
    x: 0.09630606860158658,
    y: 0,
    locked: 0,
    width: 0.8073878627968365,
    height: 0.9999999999999997,
    children: [
      "bbff594",
      "52d89af3",
      "620a535a",
      "ab740cd",
      "ca9fcbe",
      "6dc1ea",
      "e8cd234",
      "b872601"
    ],
    anchors: [
      {
        id: "0",
        penId: "77f99e2b",
        x: 0.9891067538126362,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "77f99e2b",
        x: 0.9891067538126362,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-自复旋转开关-闭合",
    parentId: "707640bd",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9036939313984231,
    ey: 0.9999999999999997
  },
  {
    id: "bbff594",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "06beb47"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bbff594"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bbff594"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bbff594"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bbff594"
      }
    ],
    rotate: 0
  },
  {
    id: "06beb47",
    locked: 10,
    parentId: "bbff594",
    x: 0.7233115468409586,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26579520697167763,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "6ddf9a66",
        penId: "06beb47"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "cbb1b0b",
        penId: "06beb47"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "52d89af3",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "3f3055d"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "52d89af3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "52d89af3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "52d89af3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "52d89af3"
      }
    ],
    rotate: 0
  },
  {
    id: "3f3055d",
    locked: 10,
    parentId: "52d89af3",
    x: 0.9891067538126362,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "68afaca9",
        penId: "3f3055d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "74532d0c",
        penId: "3f3055d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "620a535a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4e4bad61"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "620a535a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "620a535a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "620a535a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "620a535a"
      }
    ],
    rotate: 0
  },
  {
    id: "4e4bad61",
    locked: 10,
    parentId: "620a535a",
    x: 0.7494553376906318,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23965141612200438,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "15104d7",
        penId: "4e4bad61"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "28abb1e",
        penId: "4e4bad61"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ab740cd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9575b04"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ab740cd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ab740cd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ab740cd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ab740cd"
      }
    ],
    rotate: 0
  },
  {
    id: "9575b04",
    locked: 10,
    parentId: "ab740cd",
    x: 0.9891067538126362,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "b36217e",
        penId: "9575b04"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ab49ff1",
        penId: "9575b04"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ca9fcbe",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "687f70fc"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ca9fcbe"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ca9fcbe"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ca9fcbe"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ca9fcbe"
      }
    ],
    rotate: 0
  },
  {
    id: "687f70fc",
    locked: 10,
    parentId: "ca9fcbe",
    x: 0.010893246187363835,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24727668845315906,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "bd0b8a4",
        penId: "687f70fc"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "9d08cce",
        penId: "687f70fc"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6dc1ea",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "a9b9146"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6dc1ea"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6dc1ea"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6dc1ea"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6dc1ea"
      }
    ],
    rotate: 0
  },
  {
    id: "a9b9146",
    locked: 10,
    parentId: "6dc1ea",
    x: 0.2581699346405229,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.247276688453159,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "40bd01fe",
        penId: "a9b9146"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "17d63f8d",
        penId: "a9b9146"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "e8cd234",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5ecc403"
    ],
    parentId: "77f99e2b",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "e8cd234"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "e8cd234"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "e8cd234"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "e8cd234"
      }
    ],
    rotate: 0
  },
  {
    id: "5ecc403",
    locked: 10,
    parentId: "e8cd234",
    x: 0.2581699346405229,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "acde0ef",
        penId: "5ecc403"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d0ca477",
        penId: "5ecc403"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "b872601",
    locked: 10,
    parentId: "77f99e2b",
    x: 0.2581699346405229,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.6241830065359477,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "b5d8797",
        penId: "b872601"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "98d15e",
        penId: "b872601"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "504f755",
    name: "combine",
    x: -1354.11184218387,
    y: 2788.662979960327,
    ex: -1332.6140134424525,
    ey: 2880.514393392928,
    width: 21.49782874141763,
    height: 91.85141343260112,
    center: {
      x: -1343.3629278131611,
      y: 2834.5886866766277
    },
    children: [
      "9e0dfb",
      "3457cb50"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "504f755"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "504f755"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "504f755"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "504f755"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "duanluqi_wx"
    ],
    description: "开关-断路器"
  },
  {
    id: "9e0dfb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999964,
    height: 0.9999999999999997,
    children: [
      "df01e5d",
      "59bf8d4f",
      "43c3c40",
      "2b0e0ff3",
      "f59771f"
    ],
    anchors: [
      {
        id: "0",
        penId: "9e0dfb",
        x: 0.8375913784007838,
        y: 0.0015698587127158557
      },
      {
        id: "1",
        penId: "9e0dfb",
        x: 0.8375913784007838,
        y: 1.001569858712716
      }
    ],
    description: "开关-断路器-断开",
    parentId: "504f755",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999964,
    ey: 0.9999999999999997
  },
  {
    id: "df01e5d",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.8375913784007838,
    y: 0.0015698587127158557,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.29645635263612796,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "c02ac53",
        penId: "df01e5d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "cf211b7",
        penId: "df01e5d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "59bf8d4f",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.8375913784007838,
    y: 0.6682306457587357,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3333392129539804,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5c6982bf",
        penId: "59bf8d4f"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "a4f9d2c",
        penId: "59bf8d4f"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "43c3c40",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.6749566659130304,
    y: 0.2968267687368812,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "4c10c83b",
    width: 0.3252694249755068,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "43c3c40"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "43c3c40"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "43c3c40"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "43c3c40"
      }
    ]
  },
  {
    id: "2b0e0ff3",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.057125631170397165,
    y: 0.30289453724445703,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.7804657472303866,
    height: 0.36533610851427867,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "16ed797d",
        penId: "2b0e0ff3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2197e1a8",
        penId: "2b0e0ff3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f59771f",
    locked: 10,
    parentId: "9e0dfb",
    x: 0.06556635767578566,
    y: 0.42514948935494684,
    rotate: -27.52,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "rectangle",
    width: 0.31253297158791166,
    height: 0.07314836046778263,
    borderRadius: 0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f59771f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f59771f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f59771f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f59771f"
      }
    ]
  },
  {
    id: "3457cb50",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999964,
    height: 0.9999999999999997,
    children: [
      "6b7d5b",
      "6332554e",
      "f5b393c",
      "df444e3",
      "7d9ae722"
    ],
    anchors: [
      {
        id: "0",
        penId: "3457cb50",
        x: 0.8375913784007838,
        y: 0.0015698587127158557
      },
      {
        id: "1",
        penId: "3457cb50",
        x: 0.8375913784007838,
        y: 1.001569858712716
      }
    ],
    description: "开关-断路器-闭合",
    parentId: "504f755",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999964,
    ey: 0.9999999999999997
  },
  {
    id: "6b7d5b",
    locked: 10,
    parentId: "3457cb50",
    x: 0.8375913784007838,
    y: 0.0015698587127158557,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.29645635263612796,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "885dfcc",
        penId: "6b7d5b"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1ade8799",
        penId: "6b7d5b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6332554e",
    locked: 10,
    parentId: "3457cb50",
    x: 0.8375913784007838,
    y: 0.6682306457587357,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3333392129539804,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "71e1ba",
        penId: "6332554e"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1908ce43",
        penId: "6332554e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "f5b393c",
    locked: 10,
    parentId: "3457cb50",
    x: 0.6749566659130304,
    y: 0.2968267687368812,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.08466653731501243,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "6b0139a9",
    width: 0.3252694249755068,
    height: 0.07612932813574863,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "f5b393c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "f5b393c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "f5b393c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "f5b393c"
      }
    ]
  },
  {
    id: "df444e3",
    locked: 10,
    parentId: "3457cb50",
    x: 0.6413444871505012,
    y: 0.2623604325048948,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.19624689125028266,
    height: 0.4058702132538408,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3e3d1df",
        penId: "df444e3"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "44bf6ff",
        penId: "df444e3"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7d9ae722",
    locked: 10,
    parentId: "3457cb50",
    x: 0.40643605396035876,
    y: 0.3881784347273914,
    rotate: -7.41,
    color: "#231815",
    lineWidth: 0.014111089552502074,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "rectangle",
    width: 0.31253297158791166,
    height: 0.07314836046778263,
    borderRadius: 0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7d9ae722"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7d9ae722"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7d9ae722"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7d9ae722"
      }
    ]
  },
  {
    id: "d5c2232",
    name: "combine",
    x: -1216.8859793252482,
    y: 2787.336883583446,
    ex: -1178.6033829237772,
    ey: 2879.188297016047,
    width: 38.28259640147095,
    height: 91.85141343260112,
    center: {
      x: -1197.7446811245127,
      y: 2833.2625902997465
    },
    children: [
      "1851cab6",
      "348aed8"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d5c2232"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d5c2232"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d5c2232"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d5c2232"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "Btn_SelfReset"
    ],
    description: "开关-按钮"
  },
  {
    id: "1851cab6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000009,
    height: 0.9999999999999997,
    children: [
      "5415ea3",
      "8235341",
      "3b9f6e93",
      "7caade40",
      "2545ae",
      "6289c32",
      "da14c63"
    ],
    anchors: [
      {
        id: "0",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.3354014598540146
      },
      {
        id: "1",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.594160583941606
      },
      {
        id: "2",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.6653284671532848
      },
      {
        id: "3",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.9963503649635037
      },
      {
        id: "4",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.6653284671532846
      },
      {
        id: "5",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.0036496350364963507
      },
      {
        id: "6",
        penId: "1851cab6",
        x: 0.9912434325744308,
        y: 0.33467153284671536
      },
      {
        id: "7",
        penId: "1851cab6",
        x: 0.008756567425569177,
        y: 0.46459854014598545
      }
    ],
    description: "开关-按钮-断开",
    parentId: "d5c2232",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000009,
    ey: 0.9999999999999997
  },
  {
    id: "5415ea3",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "52368382"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5415ea3"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5415ea3"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5415ea3"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5415ea3"
      }
    ],
    rotate: 0
  },
  {
    id: "52368382",
    locked: 10,
    parentId: "5415ea3",
    x: 0.013134851138353765,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3ee233b",
        penId: "52368382"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "db5796d",
        penId: "52368382"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "8235341",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "9a59be"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "8235341"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "8235341"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "8235341"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "8235341"
      }
    ],
    rotate: 0
  },
  {
    id: "9a59be",
    locked: 10,
    parentId: "8235341",
    x: 0.013134851138353765,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.1987740805604203,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "2ed99f6d",
        penId: "9a59be"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "38603fe",
        penId: "9a59be"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "3b9f6e93",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "58b79b2d"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3b9f6e93"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3b9f6e93"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3b9f6e93"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3b9f6e93"
      }
    ],
    rotate: 0
  },
  {
    id: "58b79b2d",
    locked: 10,
    parentId: "3b9f6e93",
    x: 0.008756567425569177,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "578a5708",
        penId: "58b79b2d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "2dd6465f",
        penId: "58b79b2d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7caade40",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d01d2f2"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "7caade40"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "7caade40"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "7caade40"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "7caade40"
      }
    ],
    rotate: 0
  },
  {
    id: "d01d2f2",
    locked: 10,
    parentId: "7caade40",
    x: 0.9912434325744308,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5407908d",
        penId: "d01d2f2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "25fcf84",
        penId: "d01d2f2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2545ae",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7e9aa4"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2545ae"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2545ae"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2545ae"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2545ae"
      }
    ],
    rotate: 0
  },
  {
    id: "7e9aa4",
    locked: 10,
    parentId: "2545ae",
    x: 0.43607705779334505,
    y: 0.26423357664233577,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5551663747810858,
    height: 0.40109489051094893,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "63f47920",
        penId: "7e9aa4"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2d761783",
        penId: "7e9aa4"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6289c32",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "abdd075"
    ],
    parentId: "1851cab6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "6289c32"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "6289c32"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "6289c32"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "6289c32"
      }
    ],
    rotate: 0
  },
  {
    id: "abdd075",
    locked: 10,
    parentId: "6289c32",
    x: 0.9912434325744308,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "4cd41f",
        penId: "abdd075"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ae23a9d",
        penId: "abdd075"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "da14c63",
    locked: 10,
    parentId: "1851cab6",
    x: 0.008756567425569177,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.7049036777583189,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "7e2187bc",
        penId: "da14c63"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "3c848649",
        penId: "da14c63"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "348aed8",
    name: "combine",
    x: 0.09063047285464522,
    y: 0,
    locked: 0,
    width: 0.8187390542907186,
    height: 0.9999999999999997,
    children: [
      "5709b5cb",
      "bb6f8a2",
      "c6a04a4",
      "23ae3733",
      "72f3febc",
      "1ed8fdd",
      "c02a701",
      "2748deb"
    ],
    anchors: [
      {
        id: "0",
        penId: "348aed8",
        x: 0.9893048128342247,
        y: 0.9963503649635037
      },
      {
        id: "1",
        penId: "348aed8",
        x: 0.9893048128342247,
        y: 0.0036496350364963507
      }
    ],
    description: "开关-按钮-闭合",
    parentId: "d5c2232",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9093695271453638,
    ey: 0.9999999999999997
  },
  {
    id: "5709b5cb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7da3394d"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "5709b5cb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "5709b5cb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "5709b5cb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "5709b5cb"
      }
    ],
    rotate: 0
  },
  {
    id: "7da3394d",
    locked: 10,
    parentId: "5709b5cb",
    x: 0.7283422459893047,
    y: 0.33467153284671536,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.26096256684491986,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "47978557",
        penId: "7da3394d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "184dd9a",
        penId: "7da3394d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "bb6f8a2",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "5918d98"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bb6f8a2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bb6f8a2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bb6f8a2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bb6f8a2"
      }
    ],
    rotate: 0
  },
  {
    id: "5918d98",
    locked: 10,
    parentId: "bb6f8a2",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.25875912408759133,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "2238e17",
        penId: "5918d98"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "85108ed",
        penId: "5918d98"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "c6a04a4",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "59148ae2"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "c6a04a4"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "c6a04a4"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "c6a04a4"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "c6a04a4"
      }
    ],
    rotate: 0
  },
  {
    id: "59148ae2",
    locked: 10,
    parentId: "c6a04a4",
    x: 0.9893048128342247,
    y: 0.6653284671532848,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "34caf87",
        penId: "59148ae2"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "20782110",
        penId: "59148ae2"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "23ae3733",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "ca4e4ed"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "23ae3733"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "23ae3733"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "23ae3733"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "23ae3733"
      }
    ],
    rotate: 0
  },
  {
    id: "ca4e4ed",
    locked: 10,
    parentId: "23ae3733",
    x: 0.7540106951871658,
    y: 0.2091240875912409,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.23529411764705885,
    height: 0.4562043795620438,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "64667d",
        penId: "ca4e4ed"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "dc379db",
        penId: "ca4e4ed"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "72f3febc",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "29c6c39"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "72f3febc"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "72f3febc"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "72f3febc"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "72f3febc"
      }
    ],
    rotate: 0
  },
  {
    id: "29c6c39",
    locked: 10,
    parentId: "72f3febc",
    x: 0.9893048128342247,
    y: 0.0036496350364963507,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.331021897810219,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "642da3a",
        penId: "29c6c39"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e8c9ba3",
        penId: "29c6c39"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1ed8fdd",
    locked: 10,
    parentId: "348aed8",
    x: 0.010695187165775402,
    y: 0.46459854014598545,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8545454545454546,
    height: 0,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "2b297c",
        penId: "1ed8fdd"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "e921f1c",
        penId: "1ed8fdd"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "c02a701",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "2400598d"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "c02a701"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "c02a701"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "c02a701"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "c02a701"
      }
    ],
    rotate: 0
  },
  {
    id: "2400598d",
    locked: 10,
    parentId: "c02a701",
    x: 0.010695187165775402,
    y: 0.5941605839416059,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "d2b80bc",
        penId: "2400598d"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "ce72d63",
        penId: "2400598d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2748deb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7aa759c"
    ],
    parentId: "348aed8",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2748deb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2748deb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2748deb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2748deb"
      }
    ],
    rotate: 0
  },
  {
    id: "7aa759c",
    locked: 10,
    parentId: "2748deb",
    x: 0.010695187165775402,
    y: 0.3354014598540146,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.29197080291970806,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.24278074866310162,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "21e1e38b",
        penId: "7aa759c"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "3eb788df",
        penId: "7aa759c"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d0677b7",
    name: "combine",
    x: -1086.0292836927256,
    y: 2787.67210772006,
    ex: -1059.3897937013883,
    ey: 2879.523521152661,
    width: 26.639489991337413,
    height: 91.85141343260112,
    center: {
      x: -1072.7095386970568,
      y: 2833.5978144363607
    },
    children: [
      "172592a",
      "cc7f3b6"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d0677b7"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d0677b7"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d0677b7"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d0677b7"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch"
    ],
    description: "开关-惯性开关"
  },
  {
    id: "172592a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 0.9999999999999954,
    height: 0.9999999999999997,
    children: [
      "fa76b81",
      "bcaf08b",
      "2f7165df",
      "ca46ae8",
      "dac4035",
      "4a1b17bd"
    ],
    anchors: [
      {
        id: "0",
        penId: "172592a",
        x: 0.9887005649717514,
        y: 0.9976591760299625
      },
      {
        id: "1",
        penId: "172592a",
        x: 0.9887005649717514,
        y: 0.0023408239700374533
      }
    ],
    description: "开关-惯性开关-断开",
    parentId: "d0677b7",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.9999999999999954,
    ey: 0.9999999999999997
  },
  {
    id: "fa76b81",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1ec9c5e"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fa76b81"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fa76b81"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fa76b81"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fa76b81"
      }
    ],
    rotate: 0
  },
  {
    id: "1ec9c5e",
    locked: 10,
    parentId: "fa76b81",
    x: 0.011299435028248588,
    y: 0.5063202247191011,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2857142857142857,
    height: 0.14372659176029964,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ab43420",
        penId: "1ec9c5e"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "398143e1",
        penId: "1ec9c5e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "bcaf08b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "1455e2fd"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "bcaf08b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "bcaf08b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "bcaf08b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "bcaf08b"
      }
    ],
    rotate: 0
  },
  {
    id: "1455e2fd",
    locked: 10,
    parentId: "bcaf08b",
    x: 0.011299435028248588,
    y: 0.4234550561797753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.49475383373688453,
    height: 0.08286516853932582,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "832da14",
        penId: "1455e2fd"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "cbe28eb",
        penId: "1455e2fd"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2f7165df",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "7b5447a"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2f7165df"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2f7165df"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2f7165df"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2f7165df"
      }
    ],
    rotate: 0
  },
  {
    id: "7b5447a",
    locked: 10,
    parentId: "2f7165df",
    x: 0.9887005649717514,
    y: 0.6659644194756554,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3316947565543071,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1fed1dd5",
        penId: "7b5447a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "62e1ccba",
        penId: "7b5447a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ca46ae8",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "b0bf3df"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ca46ae8"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ca46ae8"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ca46ae8"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ca46ae8"
      }
    ],
    rotate: 0
  },
  {
    id: "b0bf3df",
    locked: 10,
    parentId: "ca46ae8",
    x: 0.9887005649717514,
    y: 0.0023408239700374533,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33169475655430714,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "142820bb",
        penId: "b0bf3df"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "37fc1daa",
        penId: "b0bf3df"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "dac4035",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "651dbbe"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dac4035"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dac4035"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dac4035"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dac4035"
      }
    ],
    rotate: 0
  },
  {
    id: "651dbbe",
    locked: 10,
    parentId: "dac4035",
    x: 0.1880548829701372,
    y: 0.26357677902621723,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8006456820016141,
    height: 0.40238764044943814,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "f13b315",
        penId: "651dbbe"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2188a6f",
        penId: "651dbbe"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "4a1b17bd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "d7cf5da"
    ],
    parentId: "172592a",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4a1b17bd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4a1b17bd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4a1b17bd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4a1b17bd"
      }
    ],
    rotate: 0
  },
  {
    id: "d7cf5da",
    locked: 10,
    parentId: "4a1b17bd",
    x: 0.2397094430992736,
    y: 0.6334269662921348,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "circle",
    width: 0.11460855528652138,
    height: 0.03323970037453183,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d7cf5da"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d7cf5da"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d7cf5da"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d7cf5da"
      }
    ]
  },
  {
    id: "cc7f3b6",
    name: "combine",
    x: 0.16101694915254353,
    y: 0,
    locked: 0,
    width: 0.6779661016949121,
    height: 0.9999999999999997,
    children: [
      "9c5994f",
      "85f3ee",
      "a69020c",
      "76e6bcb",
      "cdf33e",
      "63b03a4",
      "3e70cd"
    ],
    anchors: [
      {
        id: "0",
        penId: "cc7f3b6",
        x: 0.9857142857142855,
        y: 0.9976591760299625
      },
      {
        id: "1",
        penId: "cc7f3b6",
        x: 0.9857142857142855,
        y: 0.0023408239700374533
      }
    ],
    description: "开关-惯性开关-闭合",
    parentId: "d0677b7",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 0.8389830508474556,
    ey: 0.9999999999999997
  },
  {
    id: "9c5994f",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "12829e70"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "9c5994f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "9c5994f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "9c5994f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "9c5994f"
      }
    ],
    rotate: 0
  },
  {
    id: "12829e70",
    locked: 10,
    parentId: "9c5994f",
    x: 0.02261904761904762,
    y: 0.4014513108614232,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.07380952380952382,
    height: 0.16526217228464427,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "5df6aefc",
        penId: "12829e70"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "5eae3db5",
        penId: "12829e70"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "85f3ee",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f957342"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "85f3ee"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "85f3ee"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "85f3ee"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "85f3ee"
      }
    ],
    rotate: 0
  },
  {
    id: "f957342",
    locked: 10,
    parentId: "85f3ee",
    x: 0.02261904761904762,
    y: 0.38693820224719105,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.8404761904761904,
    height: 0.01451310861423215,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6678d636",
        penId: "f957342"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7cfd80c",
        penId: "f957342"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "a69020c",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "2763b646"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "a69020c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "a69020c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "a69020c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "a69020c"
      }
    ],
    rotate: 0
  },
  {
    id: "2763b646",
    locked: 10,
    parentId: "a69020c",
    x: 0.9857142857142855,
    y: 0.6659644194756554,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3316947565543071,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "6970420",
        penId: "2763b646"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "70a7ada5",
        penId: "2763b646"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "76e6bcb",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "103ff180"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "76e6bcb"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "76e6bcb"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "76e6bcb"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "76e6bcb"
      }
    ],
    rotate: 0
  },
  {
    id: "103ff180",
    locked: 10,
    parentId: "76e6bcb",
    x: 0.9857142857142855,
    y: 0.0023408239700374533,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.33169475655430714,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8d4d71f",
        penId: "103ff180"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "53cda15",
        penId: "103ff180"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "cdf33e",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "4c490749"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "cdf33e"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "cdf33e"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "cdf33e"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "cdf33e"
      }
    ],
    rotate: 0
  },
  {
    id: "4c490749",
    locked: 10,
    parentId: "cdf33e",
    x: 0.7809523809523808,
    y: 0.20318352059925093,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2059523809523809,
    height: 0.4627808988764045,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "3f497cd2",
        penId: "4c490749"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "4e390436",
        penId: "4c490749"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "63b03a4",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "dae1a6"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "63b03a4"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "63b03a4"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "63b03a4"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "63b03a4"
      }
    ],
    rotate: 0
  },
  {
    id: "dae1a6",
    locked: 10,
    parentId: "63b03a4",
    x: 0.011904761904761915,
    y: 0.5500936329588015,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "circle",
    width: 0.16904761904761903,
    height: 0.03323970037453183,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "dae1a6"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "dae1a6"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "dae1a6"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "dae1a6"
      }
    ]
  },
  {
    id: "3e70cd",
    name: "combine",
    x: 0,
    y: 0,
    locked: 10,
    width: 1,
    height: 1,
    children: [
      "f157420"
    ],
    parentId: "cc7f3b6",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3e70cd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3e70cd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3e70cd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3e70cd"
      }
    ],
    rotate: 0
  },
  {
    id: "f157420",
    locked: 10,
    parentId: "3e70cd",
    x: 0.6952380952380952,
    y: 0.33403558052434457,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.18726591760299627,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.2904761904761904,
    height: 0,
    anchors: [
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "538c0f5",
        penId: "f157420"
      },
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d70609a",
        penId: "f157420"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ab399f5",
    name: "combine",
    x: -948.9944812432741,
    y: 2783.591358014707,
    ex: -890.9724616253116,
    ey: 2875.442771447308,
    width: 58.02201961796249,
    height: 91.85141343260112,
    center: {
      x: -919.9834714342928,
      y: 2829.517064731008
    },
    children: [
      "57971e6",
      "85cc95b",
      "43468a30"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "ab399f5"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "ab399f5"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "ab399f5"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "ab399f5"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "MultipleContact",
      "MultipleContact-2"
    ],
    description: "开关-单刀双掷"
  },
  {
    id: "57971e6",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "4307c73",
      "98d918e",
      "949a86a",
      "ccfd4d",
      "7ad5a4c"
    ],
    anchors: [
      {
        id: "0",
        penId: "57971e6",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "57971e6",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "57971e6",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-中间位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "4307c73",
    locked: 10,
    parentId: "57971e6",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "7c4f510",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4307c73"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4307c73"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4307c73"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4307c73"
      }
    ]
  },
  {
    id: "98d918e",
    locked: 10,
    parentId: "57971e6",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "6e6fa01",
        penId: "98d918e"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "3c8e069",
        penId: "98d918e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "949a86a",
    locked: 10,
    parentId: "57971e6",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7d46f63f",
        penId: "949a86a"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "500c5ac",
        penId: "949a86a"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ccfd4d",
    locked: 10,
    parentId: "57971e6",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "3fb8d837",
        penId: "ccfd4d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "ec176e",
        penId: "ccfd4d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "7ad5a4c",
    locked: 10,
    parentId: "57971e6",
    x: 0.5,
    y: 0.19261195918023108,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.4063085097410812,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "0930080",
        penId: "7ad5a4c"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "589a943d",
        penId: "7ad5a4c"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "85cc95b",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "4b53bbd",
      "fa52a46",
      "02e1616",
      "d7e2c46",
      "955cd37"
    ],
    anchors: [
      {
        id: "0",
        penId: "85cc95b",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "85cc95b",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "85cc95b",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-右位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "4b53bbd",
    locked: 10,
    parentId: "85cc95b",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "86524f3",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4b53bbd"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4b53bbd"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4b53bbd"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4b53bbd"
      }
    ]
  },
  {
    id: "fa52a46",
    locked: 10,
    parentId: "85cc95b",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "fe24266",
        penId: "fa52a46"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "862ece6",
        penId: "fa52a46"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "02e1616",
    locked: 10,
    parentId: "85cc95b",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "18932e09",
        penId: "02e1616"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "3be85b31",
        penId: "02e1616"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "d7e2c46",
    locked: 10,
    parentId: "85cc95b",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "bdb07a5",
        penId: "d7e2c46"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "60b42e",
        penId: "d7e2c46"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "955cd37",
    locked: 10,
    parentId: "85cc95b",
    x: 0.5,
    y: 0.27870456270557475,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.4018958611481976,
    height: 0.3172303280762419,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "7a11b2b",
        penId: "955cd37"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "1d8894f0",
        penId: "955cd37"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "43468a30",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "916f56a",
      "439ca78d",
      "23b4ff4e",
      "2af47a96",
      "2f6018"
    ],
    anchors: [
      {
        id: "0",
        penId: "43468a30",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "43468a30",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "43468a30",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-单刀双掷-左位",
    parentId: "ab399f5",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "916f56a",
    locked: 10,
    parentId: "43468a30",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3580bcf4",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "916f56a"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "916f56a"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "916f56a"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "916f56a"
      }
    ]
  },
  {
    id: "439ca78d",
    locked: 10,
    parentId: "43468a30",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "13990b7",
        penId: "439ca78d"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "0fadb82",
        penId: "439ca78d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "23b4ff4e",
    locked: 10,
    parentId: "43468a30",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "dbcbf67",
        penId: "23b4ff4e"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "5d684b3",
        penId: "23b4ff4e"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2af47a96",
    locked: 10,
    parentId: "43468a30",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1f2fe4b0",
        penId: "2af47a96"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "41b4553",
        penId: "2af47a96"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2f6018",
    locked: 10,
    parentId: "43468a30",
    x: 0.09810413885180241,
    y: 0.27870456270557475,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.4018958611481976,
    height: 0.3172303280762419,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "43b054a",
        penId: "2f6018"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "0b73ba3",
        penId: "2f6018"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "0eca90c",
    name: "combine",
    x: -811.1132453099428,
    y: 2785.70796615796,
    ex: -753.0912256919803,
    ey: 2877.559379590561,
    width: 58.02201961796249,
    height: 91.85141343260112,
    center: {
      x: -782.1022355009616,
      y: 2831.633672874261
    },
    children: [
      "a50a9d",
      "107ef2a",
      "9aadb9a"
    ],
    showChild: 0,
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "0eca90c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "0eca90c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "0eca90c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "0eca90c"
      }
    ],
    rotate: 0,
    globalAlpha: 1,
    tags: [
      "Switch",
      "MultipleContact",
      "MultipleContact-3"
    ],
    description: "开关-三位置"
  },
  {
    id: "a50a9d",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "d6af092",
      "3467a0e2",
      "4ad10d99",
      "f741643",
      "5d94b170",
      "2a8895f",
      "5a704f56",
      "115c7ac",
      "20d57ad"
    ],
    anchors: [
      {
        id: "0",
        penId: "a50a9d",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "a50a9d",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "a50a9d",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "a50a9d",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      },
      {
        id: "4",
        penId: "a50a9d",
        x: 0,
        y: 0.343324618368896
      }
    ],
    description: "开关-三位置-1位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "d6af092",
    locked: 10,
    parentId: "a50a9d",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "65bdccc",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "d6af092"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "d6af092"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "d6af092"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "d6af092"
      }
    ]
  },
  {
    id: "3467a0e2",
    locked: 10,
    parentId: "a50a9d",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "c781765",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3467a0e2"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3467a0e2"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3467a0e2"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3467a0e2"
      }
    ]
  },
  {
    id: "4ad10d99",
    locked: 10,
    parentId: "a50a9d",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "fb19b70",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4ad10d99"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4ad10d99"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4ad10d99"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4ad10d99"
      }
    ]
  },
  {
    id: "f741643",
    locked: 10,
    parentId: "a50a9d",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "8e35710",
        penId: "f741643"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "2e21b8a",
        penId: "f741643"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5d94b170",
    locked: 10,
    parentId: "a50a9d",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "8122d9",
        penId: "5d94b170"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7c17ab3",
        penId: "5d94b170"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "2a8895f",
    locked: 10,
    parentId: "a50a9d",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "f51068",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "2a8895f"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "2a8895f"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "2a8895f"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "2a8895f"
      }
    ]
  },
  {
    id: "5a704f56",
    locked: 10,
    parentId: "a50a9d",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "33773e33",
        penId: "5a704f56"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "59c0fe1",
        penId: "5a704f56"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "115c7ac",
    locked: 10,
    parentId: "a50a9d",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "1f84dc0f",
        penId: "115c7ac"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "4db08d42",
        penId: "115c7ac"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "20d57ad",
    locked: 10,
    parentId: "a50a9d",
    x: 0,
    y: 0.343324618368896,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5,
    height: 0.2555958505524163,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "ae696ae",
        penId: "20d57ad"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "8e1bd1",
        penId: "20d57ad"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "107ef2a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "a25934b",
      "3b89ef1",
      "fa3bc2c",
      "f7642c6",
      "645786d",
      "1051430",
      "54cf7428",
      "6d80bb9",
      "db08d80"
    ],
    anchors: [
      {
        id: "0",
        penId: "107ef2a",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "107ef2a",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "107ef2a",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "107ef2a",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      }
    ],
    description: "开关-三位置-2位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "a25934b",
    locked: 10,
    parentId: "107ef2a",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "a0ecd01",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "a25934b"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "a25934b"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "a25934b"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "a25934b"
      }
    ]
  },
  {
    id: "3b89ef1",
    locked: 10,
    parentId: "107ef2a",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "f5f5e77",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "3b89ef1"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "3b89ef1"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "3b89ef1"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "3b89ef1"
      }
    ]
  },
  {
    id: "fa3bc2c",
    locked: 10,
    parentId: "107ef2a",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "5f71e1f6",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "fa3bc2c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "fa3bc2c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "fa3bc2c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "fa3bc2c"
      }
    ]
  },
  {
    id: "f7642c6",
    locked: 10,
    parentId: "107ef2a",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "67a13704",
        penId: "f7642c6"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "47d950be",
        penId: "f7642c6"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "645786d",
    locked: 10,
    parentId: "107ef2a",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "e6fea73",
        penId: "645786d"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "8f3f0e",
        penId: "645786d"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "1051430",
    locked: 10,
    parentId: "107ef2a",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3ae6546f",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1051430"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1051430"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1051430"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1051430"
      }
    ]
  },
  {
    id: "54cf7428",
    locked: 10,
    parentId: "107ef2a",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "40d8499d",
        penId: "54cf7428"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "76314f06",
        penId: "54cf7428"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "6d80bb9",
    locked: 10,
    parentId: "107ef2a",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "41f5bfb1",
        penId: "6d80bb9"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "463311d1",
        penId: "6d80bb9"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "db08d80",
    locked: 10,
    parentId: "107ef2a",
    x: 0.36443257676902535,
    y: 0.19919035169098423,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.13556742323097465,
    height: 0.39718309859154927,
    anchors: [
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "af5e575",
        penId: "db08d80"
      },
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "612cb4c5",
        penId: "db08d80"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "9aadb9a",
    name: "combine",
    x: 0,
    y: 0,
    locked: 0,
    width: 1.0000000000000018,
    height: 0.9999999999999997,
    children: [
      "74570835",
      "1275566",
      "4a0de302",
      "49f9637b",
      "5eb9b2bb",
      "122626c",
      "2595364",
      "68978eb",
      "ffe92b7"
    ],
    anchors: [
      {
        id: "0",
        penId: "9aadb9a",
        x: 0.5,
        y: 1
      },
      {
        id: "1",
        penId: "9aadb9a",
        x: 0.8573297730307076,
        y: 0.0012650754828371425
      },
      {
        id: "2",
        penId: "9aadb9a",
        x: 0.5,
        y: 0.0012650754828371425
      },
      {
        id: "3",
        penId: "9aadb9a",
        x: 0.14267022696929238,
        y: 0.0012650754828371425
      },
      {
        id: "4",
        penId: "9aadb9a",
        x: 1,
        y: 0.343324618368896
      }
    ],
    description: "开关-三位置-3位",
    parentId: "0eca90c",
    lineWidth: 1,
    fontSize: 12,
    lineHeight: 1.5,
    rotate: 0,
    globalAlpha: 1,
    tags: [],
    ex: 1.0000000000000018,
    ey: 0.9999999999999997
  },
  {
    id: "74570835",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.4218691588785047,
    y: 0.5947035506451884,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "3fd48a86",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "74570835"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "74570835"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "74570835"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "74570835"
      }
    ]
  },
  {
    id: "1275566",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.06453938584779706,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "9efe400",
    width: 0.15626168224299064,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "1275566"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "1275566"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "1275566"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "1275566"
      }
    ]
  },
  {
    id: "4a0de302",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.7791989319092123,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "2208226c",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "4a0de302"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "4a0de302"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "4a0de302"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "4a0de302"
      }
    ]
  },
  {
    id: "49f9637b",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.6892131230496753,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 1,
        hidden: !0,
        id: "0fc9b23",
        penId: "49f9637b"
      },
      {
        x: 0,
        y: 0,
        hidden: !0,
        id: "44b1230",
        penId: "49f9637b"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "5eb9b2bb",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.8573297730307076,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "093fb83",
        penId: "5eb9b2bb"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "177adc9",
        penId: "5eb9b2bb"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "122626c",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.4218691588785047,
    y: 0.307835034157038,
    rotate: 0,
    background: "#231815",
    lineWidth: 0,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "svgPath",
    pathId: "387b959b",
    width: 0.1562616822429906,
    height: 0.09870962300750608,
    disableAnchor: !0,
    children: [],
    lineHeight: 1.5,
    anchors: [
      {
        x: 0.5,
        y: 0,
        id: "0",
        penId: "122626c"
      },
      {
        x: 1,
        y: 0.5,
        id: "1",
        penId: "122626c"
      },
      {
        x: 0.5,
        y: 1,
        id: "2",
        penId: "122626c"
      },
      {
        x: 0,
        y: 0.5,
        id: "3",
        penId: "122626c"
      }
    ]
  },
  {
    id: "2595364",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "db4123e",
        penId: "2595364"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "778193f",
        penId: "2595364"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "68978eb",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.14267022696929238,
    y: 0.0012650754828371425,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0,
    height: 0.3107868769503247,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "66888a0",
        penId: "68978eb"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "e4d3552",
        penId: "68978eb"
      }
    ],
    children: [],
    lineHeight: 1.5
  },
  {
    id: "ffe92b7",
    locked: 10,
    parentId: "9aadb9a",
    x: 0.5,
    y: 0.343324618368896,
    rotate: 0,
    color: "#231815",
    lineWidth: 0.013494138483596188,
    globalAlpha: null,
    fontSize: 16,
    matrix: null,
    name: "line",
    lineName: "line",
    type: 0,
    width: 0.5,
    height: 0.2555958505524163,
    anchors: [
      {
        x: 1,
        y: 0,
        hidden: !0,
        id: "5cf32734",
        penId: "ffe92b7"
      },
      {
        x: 0,
        y: 1,
        hidden: !0,
        id: "7e3545f",
        penId: "ffe92b7"
      }
    ],
    children: [],
    lineHeight: 1.5
  }
], Dh = {
  x: -1913.574579695493,
  y: 2785.717495189335
}, Bh = {
  x: -933,
  y: 3085
}, zh = {
  "818f759": "M180,188.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "64c23b2": "M0,268.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58S0,280.34,0,268.98h0Z",
  fb0b262: "M180,188.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "607a597": "M44,268.98c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "4c10c83b": "M90.56,189.86c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "6b0139a9": "M90.56,189.86c0-11.37,9.21-20.58,20.58-20.58s20.58,9.21,20.58,20.58-9.21,20.58-20.58,20.58-20.58-9.21-20.58-20.58h0Z",
  "7c4f510": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "86524f3": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3580bcf4": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "65bdccc": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  c781765: "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  fb19b70: "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  f51068: "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  a0ecd01: "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  f5f5e77: "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "5f71e1f6": "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3ae6546f": "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "3fd48a86": "M187.25,355.07c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,353.57c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "9efe400": "M53.43,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M53.43,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "2208226c": "M321.07,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M321.07,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z",
  "387b959b": "M187.25,185c14.78,0,26.76,11.98,26.76,26.76s-11.98,26.76-26.76,26.76-26.76-11.98-26.76-26.76,11.98-26.76,26.76-26.76M187.25,183.5c-15.59,0-28.26,12.68-28.26,28.26s12.68,28.26,28.26,28.26,28.26-12.68,28.26-28.26-12.68-28.26-28.26-28.26h0Z"
}, Hh = "dc171b5", Fh = "light", Wh = !0, jh = "1.0.42", Vh = [], Uh = 0, qh = "", Yh = [], $h = !0, Xh = [], Kh = [], de = {
  x: Lh,
  y: Mh,
  scale: Nh,
  pens: Oh,
  origin: Dh,
  center: Bh,
  paths: zh,
  template: Hh,
  theme: Fh,
  rule: Wh,
  version: jh,
  dataPoints: Vh,
  locked: Uh,
  name: qh,
  msgTypes: Yh,
  grid: $h,
  wsMsgFields: Xh,
  wsMsgHandlers: Kh
}, pa = {
  0: 0,
  1: 90,
  2: 180,
  3: 270
}, Gh = [
  "Vdc",
  "MultipleContact",
  "Coil",
  "Lamp",
  "Diode",
  "TerminalsXT",
  "CoilOnDelay",
  "R",
  "VProbe",
  "IProbe",
  "CoilOffDelay",
  "CoilOnDelay",
  "DoubleCoil",
  "TransformerNew"
], Jh = [
  "Btn_SelfReset",
  "Btn_SelfLock",
  "Knob_SelfReset",
  "Knob_SelfLock"
];
function Hi(e, t, i) {
  let s = pa[i.rotateAngel] || 0;
  if (["Switch", "MultipleContact"].includes(i.type)) {
    if (e.width > e.height) {
      const a = e.height;
      e.height = e.width, e.width = a;
    }
    s -= 90;
  }
  s && setTimeout(() => {
    meta2d.setValue({
      id: e.id,
      rotate: -s
      // 电路编辑器默认是逆时针旋转
    });
  }, 100);
  const o = (t == null ? void 0 : t.元件类型) || i.type;
  if (Gh.includes(o)) {
    e.y -= e.height / 2, e.x -= e.width / 2;
    return;
  } else if (Jh.includes(o)) {
    s ? i.rotateAngel == "1" ? (e.y -= e.height / 2 - 10, e.x -= e.width / 2) : i.rotateAngel == "2" ? (e.y -= e.height / 2, e.x -= e.width / 2 - 10) : i.rotateAngel == "3" && (e.x -= e.width / 2, e.y -= e.height / 2 + 10) : (e.x -= e.width / 1.5, e.y -= e.height / 2);
    return;
  }
  switch (o) {
    case "Input":
      s ? s === 90 ? (e.x -= e.width / 2, e.y += 5) : s === 180 ? e.y -= e.height / 2 : s === 270 && (e.y -= e.height + 5, e.x -= e.width / 2) : (e.x -= e.width, e.y -= e.height / 2);
      break;
    case "Output":
      s ? s === 90 ? (e.x -= e.width / 2, e.y += 5) : s === 180 ? e.y -= e.height / 2 : s === 270 && (e.y -= e.height + 5, e.x -= e.width / 2) : (e.y -= e.height / 2, e.x -= e.width);
      break;
    case "GND":
      s ? s === 90 ? e.y -= e.height / 2 : s === 180 ? (e.x -= e.width / 2, e.y -= e.height) : s === 270 && (e.y -= e.height / 2, e.x -= e.width) : e.x -= e.width / 2;
      break;
    case "ElectromagneticValve":
      s ? (i.rotateAngel == "1" || i.rotateAngel == "2" || i.rotateAngel == "3") && (e.x -= e.width / 2, e.y -= e.height / 2) : (e.y -= e.height / 2, e.x -= e.width / 2);
      break;
    case "duanluqi_wx":
      s ? i.rotateAngel == "1" ? (e.y -= e.height / 2 + 10, e.x -= e.width / 2) : i.rotateAngel == "2" ? (e.x -= e.width / 2 + 10, e.y -= e.height / 2) : i.rotateAngel == "3" && (e.y -= e.width - 6, e.x -= e.width / 2) : (e.x -= e.width / 4, e.y -= e.height / 2);
      break;
    case "Switch":
      i.rotateAngel == "0" ? (e.x -= e.width / 2, e.y -= e.height / 1.5) : i.rotateAngel == "1" ? (e.x -= e.width, e.y -= e.height / 2) : i.rotateAngel == "2" ? (e.x -= e.width / 2, e.y -= e.height / 3) : i.rotateAngel == "3" && (e.y -= e.height / 2);
      break;
    case "Contact":
      i.rotateAngel == "0" ? (e.x -= e.width - 3, e.y -= e.height / 2) : i.rotateAngel == "1" ? (e.x -= e.width / 2, e.y -= e.height / 4 + 2) : i.rotateAngel == "2" ? (e.y -= e.height / 2, e.x -= 2) : i.rotateAngel == "3" && (e.y -= e.height / 1.5 + 2, e.x -= e.width / 2);
      break;
    case "Contactk":
      i.rotateAngel == "0" ? (e.x -= e.width - 3, e.y -= e.height / 2) : i.rotateAngel == "1" ? (e.x -= e.width / 2, e.y -= e.height / 4 + 2) : i.rotateAngel == "2" ? (e.y -= e.height / 2, e.x -= 2) : i.rotateAngel == "3" && (e.y -= e.height / 1.5 + 2, e.x -= e.width / 2);
      break;
  }
}
const Qh = [
  "Btn_SelfLock",
  "Knob_SelfReset",
  "Switch",
  "Knob_SelfLock",
  "duanluqi_wx",
  "MultipleContact",
  "Btn_SelfReset"
];
function Zh(e) {
  if (e.type == "MultipleContact") {
    if (e.v10 > "3")
      return 0;
    if (e.v10 == "2")
      return e.v16 == "0" ? 1 : 2;
    if (e.v10 == "3")
      return Number(e.v18);
  } else {
    if (e.v10 == "off")
      return 0;
    if (e.v10 == "on")
      return 1;
  }
}
function td(e, t) {
  if (!e || !t) return;
  const i = [], s = [e];
  for (; s.length; ) {
    const o = s.shift();
    i.push(o);
    for (const a of t)
      a.parentId == o.id && s.push(a);
  }
  return i;
}
function ed(e) {
  const t = "-" + nt(), i = G(e);
  return i.forEach((s) => {
    s.id = s.id + t, s.children && (s.children = s.children.map((o) => o + t)), s.parentId && (s.parentId = s.parentId + t), s.anchors && s.anchors.forEach((o) => {
      o.penId = o.penId + t;
    });
  }), i;
}
const xf = (e) => {
  sd((t) => {
    if (console.log("readJSONFile: ", t, de), t != null && t.data) {
      if (meta2d.clear(), de.paths) {
        const r = meta2d.data().paths || {};
        Object.assign(r, de.paths), Object.assign(meta2d.store.data, {
          paths: r
        });
      }
      const { Components: i, Paintings: s, Wires: o } = t.data, a = [];
      i && i.forEach((r) => {
        var c;
        const l = Kl.find((d) => {
          var u, f;
          return ((u = d.元件类型) == null ? void 0 : u.toLocaleLowerCase()) == ((f = r.type) == null ? void 0 : f.toLocaleLowerCase());
        });
        if (meta2d.findOne(r.uuid))
          return;
        if (Qh.includes(r.type)) {
          let d = G(
            de.pens.find((f) => {
              var g, y;
              if (r.type == "MultipleContact" && r.v10 >= "3")
                return ((g = f.tags) == null ? void 0 : g.includes("MultipleContact-3")) && !f.parentId;
              if ((y = f.tags) != null && y.includes(r.type) && !f.parentId)
                return !0;
            })
          );
          const u = ed(
            td(d, de.pens)
          );
          if (u) {
            d = u[0];
            const f = meta2d.getPenRect(d), g = f.width / de.scale, y = f.height / de.scale, v = Number((l == null ? void 0 : l["宽度(X向)"]) || g), b = Number((l == null ? void 0 : l["高度(Y向)"]) || y);
            Object.assign(d, {
              text: r.name,
              x: Number(r.posX),
              y: Number(r.posY),
              width: v,
              height: b
            }), d.tags && !((c = d.tags) != null && c.includes(r.name)) && d.tags.push(r.name), Hi(d, l, r), d.showChild = Zh(r), meta2d.addPens(u);
            return;
          }
        }
        const h = Gl.find((d) => {
          var u;
          return d.data.electricTypeCode == r.type || ((u = d.data.tags) == null ? void 0 : u.includes(r.type));
        });
        if (h) {
          const d = Number(l == null ? void 0 : l["宽度(X向)"]), u = Number(l == null ? void 0 : l["高度(Y向)"]);
          _h(h.data.image, h, !1).then((f) => {
            const g = f.find(
              (y) => y.name == "combine" && !y.parentId
            );
            Object.assign(g, {
              text: r.name,
              x: Number(r.posX),
              y: Number(r.posY),
              //rotate: rotateAngelMap[item.rotateAngel] || 0, // 跟预期不一致
              tags: [r.type, r.name],
              width: d || g.width,
              height: u || g.height
            }), console.log(
              "单一 svg: ",
              h.name,
              h,
              g,
              d,
              u
            ), Hi(g, l, r), h.data.anchors && (g.anchors = h.data.anchors), meta2d.addPens(f);
          });
        } else {
          const d = {
            id: r.uuid,
            name: "rectangle",
            text: r.name,
            //   title: item.name,
            x: Number(r.posX),
            y: Number(r.posY),
            width: Number((l == null ? void 0 : l["宽度(X向)"]) || 100),
            height: Number((l == null ? void 0 : l["高度(Y向)"]) || 100),
            rotate: pa[r.rotateAngel] || 0,
            tags: [r.type, r.name]
            // fontSize: 10,
          };
          Hi(d, l, r), a.push(d);
        }
      }), o && o.forEach((r) => {
        if (meta2d.findOne(r.uuid))
          return;
        const { length: n = 0, anchors: h = [] } = id(r), c = {
          type: 1,
          id: r.uuid,
          name: "line",
          lineName: "curve",
          text: r.name,
          //   title: item.name,
          x: Number(r.startX),
          y: Number(r.startY),
          width: n,
          height: n,
          anchors: h,
          tags: [r.name]
          // fontSize: 10,
        };
        a.push(c);
      }), s && s.forEach((r) => {
        if (meta2d.findOne(r.uuid))
          return;
        const n = {
          id: r.uuid,
          name: "rectangle",
          text: r.text,
          //   title: item.name,
          x: Number(r.posX),
          y: Number(r.posY),
          width: 200,
          height: 50,
          color: r.color,
          textAutoAdjust: !0,
          borderWidth: 0
        };
        a.push(n);
      }), meta2d.addPens(a);
    }
  });
};
function id(e) {
  const { startX: t, startY: i, endX: s, endY: o } = e, a = Math.sqrt(
    Math.pow(s - t, 2) + Math.pow(o - i, 2)
  ), r = [
    { x: 0, y: 0 },
    { x: 1, y: 1 }
  ];
  return t === s ? r[1].x = 0 : r[1].y = 0, { length: a, anchors: r };
}
const sd = (e = null) => {
  const t = document.createElement("input");
  t.type = "file", t.accept = ".json", t.onchange = async () => {
    if (!t.files || !t.files.length) return;
    const i = t.files[0], { name: s, size: o, type: a } = i, r = new FileReader();
    r.onload = () => {
      try {
        const l = JSON.parse(r.result);
        e && e({ fileName: s, data: l });
      } catch (l) {
        console.error(l);
      }
    }, r.readAsText(i);
  }, t.click();
}, kf = (e = null) => {
  const t = document.createElement("input");
  t.type = "file", t.accept = ".svg", t.onchange = async () => {
    if (!t.files || !t.files.length) return;
    const i = t.files[0], { name: s } = i, o = new FileReader();
    o.onload = () => {
      try {
        const a = o.result;
        e && e({ fileName: s, data: a });
      } catch (a) {
        console.error(a);
      }
    }, o.readAsText(i);
  }, t.click();
};
function If(e) {
  if (navigator.clipboard && window.isSecureContext)
    return navigator.clipboard.writeText(e).then(() => !0).catch((t) => {
      console.error("复制失败：", t);
    });
  {
    const t = document.createElement("textarea");
    t.value = e, document.body.appendChild(t), t.select();
    const i = document.execCommand("copy");
    return document.body.removeChild(t), new Promise((s, o) => {
      i ? s(!0) : o(!1);
    });
  }
}
const Af = () => {
  !document.fullscreenElement && // 没有处于全屏模式
  !document.mozFullScreenElement && // Firefox
  !document.webkitFullscreenElement && // Chrome, Safari, Opera
  !document.msFullscreenElement ? document.documentElement.requestFullscreen ? document.documentElement.requestFullscreen() : document.documentElement.mozRequestFullScreen ? document.documentElement.mozRequestFullScreen() : document.documentElement.webkitRequestFullscreen ? document.documentElement.webkitRequestFullscreen() : document.documentElement.msRequestFullscreen && document.documentElement.msRequestFullscreen() : document.exitFullscreen ? document.exitFullscreen() : document.mozCancelFullScreen ? document.mozCancelFullScreen() : document.webkitExitFullscreen ? document.webkitExitFullscreen() : document.msExitFullscreen && document.msExitFullscreen();
}, od = () => {
  const e = ee([]), t = {
    limit: 1024 * 1,
    unit: "KB"
  }, i = Ma(), s = {
    Authorization: i.token
  };
  return {
    uploadValue: e,
    sizeLimit: t,
    headers: s,
    handleFail: (r) => {
      console.log("upload fail: ", r);
    },
    uploadFileFn: (r) => {
      if (!i.uploadUrl) return Promise.reject("文件上传地址不存在！");
      const l = new FormData();
      return l.append("object", r), fetch(i.uploadUrl, {
        method: "POST",
        headers: s,
        body: l
      }).then((n) => n.json()).then((n) => n).catch((n) => {
        console.log(n);
      });
    }
  };
};
let Fi = null;
function ad(e, t) {
  var l;
  let i = e.split(","), s = ((l = i[0].match(/:(.*\/*?);/)) == null ? void 0 : l[1]) || "image/png", o = atob(i[1]), a = o.length, r = new Uint8Array(a);
  for (; a--; )
    r[a] = o.charCodeAt(a);
  return new File([r], t, { type: s });
}
function rd(e, t) {
  const i = t ? meta2d.toPng() : meta2d.activeToPng();
  if (e != null && e.endsWith(".png") || (e += ".png"), i)
    return ad(i, e);
}
function nd(e) {
  var s;
  if (console.log("getJsonString: ", e), !e) return;
  let t;
  if (e.mode == 1)
    e.pen.name == "combine" ? t = [...e.pen.children.map((a) => meta2d.findOne(a)), e.pen] : t = e.pen;
  else if (e.mode == 2) {
    const o = e.pens;
    meta2d.combine(o);
    const a = (s = meta2d.store.active) == null ? void 0 : s[0];
    t = [...o, a];
  }
  let i = "";
  try {
    const o = G(t);
    Array.isArray(o) ? o.forEach((a) => {
      a.calculative = void 0;
    }) : o.calculative = void 0, i = JSON.stringify(o);
  } catch (o) {
    console.log("error: ", o);
  }
  return i;
}
const ld = (e) => {
  const t = ee([]), i = ee([]), s = ee(!1), o = ee(""), a = ee(!1), r = ee(""), l = qa(), n = ee("");
  let h = null, c = "";
  const d = (C) => {
    a.value = !1, s.value = !0, c = C;
  }, { uploadFileFn: u } = od(), f = () => {
    if (console.log("confirm: ", o.value, h), s.value = !1, !!o.value)
      if (a.value) {
        let C;
        c != "paper" ? C = nd(h) : C = JSON.stringify(h);
        const R = rd(
          n.value || "image.png",
          c == "paper"
        ), P = (E) => l.saveComponent({
          nodeId: o.value,
          data: C,
          type: c,
          // image, component, paper,
          name: n.value,
          label: c == "paper" ? "paper" : "component",
          cover: E
        }).then((H) => {
          (H == null ? void 0 : H.code) == 200 && k(c);
        });
        if (console.log("png file: ", R), R) {
          u(R).then((E) => {
            if (console.log("upload file: ", E), (E == null ? void 0 : E.code) == 200) {
              const H = E.data.fileurl;
              P(H);
            }
          });
          return;
        }
        P();
      } else
        l.createFolder({
          dictName: o.value,
          type: c
        }).then((C) => {
          (C == null ? void 0 : C.code) == 200 && k(c);
        });
  }, g = (C, R) => {
    l.saveComponent({
      nodeId: C.id,
      data: JSON.stringify(R),
      type: "component",
      name: R.fileName,
      cover: R.image,
      label: "iamge"
    }).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k("component");
    });
  }, y = () => {
    o.value = "", n.value = "";
  }, v = (C, R) => {
    l.deleteComponent(C.id).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k(R);
    });
  }, b = (C) => {
    a.value = !0, s.value = !0, h = C, c = "component", r.value = c;
  }, x = () => {
    a.value = !0, s.value = !0, h = meta2d.data(), c = "paper", r.value = c;
  }, p = (C, R) => {
    l.deleteFolder(C.id).then((P) => {
      (P == null ? void 0 : P.code) == 200 && k(R);
    });
  }, k = (C) => l.getTree(C).then((R) => {
    Array.isArray(R.data) && (C == "paper" ? t.value = R.data : i.value = R.data);
  });
  return e && Fi ? Fi : Fi = {
    blueprintList: t,
    componentList: i,
    saveComponentShow: b,
    showAddFolder: d,
    deleteMyPen: v,
    visible: s,
    folderName: o,
    confirm: f,
    close: y,
    selectMode: a,
    selectType: r,
    deleteFolder: p,
    getTree: k,
    fileName: n,
    saveImageComponent: g,
    saveBlueprintShow: x
  };
}, ba = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [s, o] of t)
    i[s] = o;
  return i;
};
function cd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ey: r } = e.calculative.worldRect, l = a / 4;
  if (i.moveTo(s + l, o), i.lineTo(s, o), i.lineTo(s, r), i.lineTo(s + l, r), i instanceof Path2D) return i;
}
function hd(e) {
  const t = [
    {
      x: 0.25,
      y: 0
    },
    {
      x: 0.25,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: o + "",
    x: i,
    y: s,
    penId: e.id
  }));
}
function dd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect, n = e.offsetX;
  let h = a / 7;
  if (n > 1 ? h = n : n > 0 && (h = a * n), i.moveTo(s + h, o), i.lineTo(r, o), i.lineTo(s + a - h, l), i.lineTo(s, l), i.closePath(), i instanceof Path2D) return i;
}
function ud(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.9285714285714286,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.07142857142857142,
      y: 0.5
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function fd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l, ey: n } = e.calculative.worldRect, h = a / 8;
  if (i.moveTo(s + h, o), i.lineTo(l - h, o), i.bezierCurveTo(
    l + h / 3,
    o,
    l + h / 3,
    n,
    l - h,
    n
  ), i.lineTo(s + h, n), i.lineTo(s, o + r / 2), i.closePath(), i instanceof Path2D) return i;
}
function gd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l, center: n } = e.calculative.worldRect, h = n.x, c = o + r * 6 / 7, d = r / 6;
  if (i.moveTo(s, o), i.lineTo(l, o), i.lineTo(l, c), i.bezierCurveTo(
    l - 20,
    c - d,
    h + a / 5,
    c - d,
    h,
    c
  ), i.bezierCurveTo(
    h - a / 5,
    c + d,
    s,
    c + d,
    s,
    c
  ), i.closePath(), i instanceof Path2D) return i;
}
function vd(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 0.8571428571428571
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function yd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 10;
  if (i.moveTo(s + n * 2, o), i.bezierCurveTo(
    s - n * 2 / 3,
    o,
    s - n * 2 / 3,
    l,
    s + n * 2,
    l
  ), i.lineTo(r, l), i.bezierCurveTo(r - n, l, r - n, o, r, o), i.closePath(), i instanceof Path2D) return i;
}
function md(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect;
  i.moveTo(s, o), i.lineTo(r, o), i.lineTo(r, l), i.lineTo(s, l), i.closePath();
  const n = a / 7;
  if (i.moveTo(s, o + n), i.lineTo(r, o + n), i.moveTo(s + n, o), i.lineTo(s + n, l), i instanceof Path2D) return i;
}
function pd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, height: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 4;
  if (i.moveTo(s, o + n), i.lineTo(r, o), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i instanceof Path2D) return i;
}
function bd(e) {
  const t = [
    {
      x: 0.5,
      y: 0.125
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.5
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function wd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, ex: a, ey: r } = e.calculative.worldRect;
  if (i.moveTo(s, o), i.lineTo(a, o), i.moveTo(s, r), i.lineTo(a, r), i instanceof Path2D) return i;
}
function xd(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: o + "",
    x: i,
    y: s,
    penId: e.id
  }));
}
function kd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l, ey: n } = e.calculative.worldRect;
  if (i.ellipse(
    s + a / 2,
    o + r / 2,
    a / 2,
    r / 2,
    0,
    0,
    Math.PI * 2
  ), i.moveTo(s + a / 2, n), i.lineTo(l, n), i.closePath(), i instanceof Path2D) return i;
}
function Id(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 7;
  if (i.moveTo(s, o), i.lineTo(r, o), i.lineTo(r, l), i.lineTo(s, l), i.closePath(), i.moveTo(s + n, o), i.lineTo(s + n, l), i.moveTo(r - n, o), i.lineTo(r - n, l), i instanceof Path2D) return i;
}
function Ad(e, t) {
  const i = t || new Path2D(), { x: s, y: o, height: a, ex: r, ey: l } = e.calculative.worldRect, n = a / 7;
  if (i.moveTo(s, o + n), i.bezierCurveTo(
    s,
    o - n / 2 | 0,
    r,
    o - n / 2 | 0,
    r,
    o + n
  ), i.lineTo(r, l - n), i.bezierCurveTo(
    r,
    l + n / 2 | 0,
    s,
    l + n / 2 | 0,
    s,
    l - n
  ), i.closePath(), i.moveTo(s, l - n), i.bezierCurveTo(
    s,
    l - n * 2 | 0,
    r,
    l - n * 2 | 0,
    r,
    l - n
  ), i instanceof Path2D) return i;
}
function Sd() {
  return {
    flowComment: cd,
    flowData: dd,
    flowDb: Ad,
    flowDisplay: fd,
    flowDocument: gd,
    flowExternStorage: yd,
    flowInternalStorage: md,
    flowManually: pd,
    flowParallel: wd,
    flowQueue: kd,
    flowSubprocess: Id
  };
}
function Td() {
  return {
    flowDocument: vd,
    flowManually: bd,
    flowParallel: xd,
    flowComment: hd,
    flowData: ud
  };
}
function Cd(e, t) {
  const { x: i, y: s, width: o, height: a } = t.calculative.worldRect;
  e.beginPath(), e.ellipse(
    i + o / 2,
    s + a / 2,
    o / 2,
    a / 2,
    0,
    0,
    Math.PI * 2
  ), e.stroke(), e.beginPath(), e.fillStyle = e.strokeStyle, e.ellipse(
    i + o / 2,
    s + a / 2,
    o / 4,
    a / 4,
    0,
    0,
    Math.PI * 2
  ), e.fill();
}
function Rd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ey: l } = e.calculative.worldRect, n = e.calculative.lineLeft || 0.08;
  let h = e.calculative.borderRadius || 0, c = h;
  h < 1 && (h = a * h, c = r * h);
  let d = h < c ? h : c;
  if (a < 2 * d && (d = a / 2), r < 2 * d && (d = r / 2), i.moveTo(s + d, o), i.arcTo(s + a, o, s + a, o + r, d), i.arcTo(s + a, o + r, s, o + r, d), i.arcTo(s, o + r, s, o, d), i.arcTo(s, o, s + a, o, d), i.closePath(), i.moveTo(s + n * a, o), i.lineTo(s + n * a, l), i instanceof Path2D) return i;
}
function Pd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l } = e.calculative.worldRect, n = e.calculative.lineTop || 0.08;
  let h = e.calculative.borderRadius || 0, c = h;
  h < 1 && (h = a * h, c = r * c);
  let d = h < c ? h : c;
  if (a < 2 * d && (d = a / 2), r < 2 * d && (d = r / 2), i.moveTo(s + d, o), i.arcTo(s + a, o, s + a, o + r, d), i.arcTo(s + a, o + r, s, o + r, d), i.arcTo(s, o + r, s, o, d), i.arcTo(s, o, s + a, o, d), i.closePath(), i.moveTo(s, o + n * r), i.lineTo(l, o + n * r), i instanceof Path2D) return i;
}
function Ed() {
  return {
    forkV: ke,
    forkH: ke,
    swimlaneH: Rd,
    swimlaneV: Pd
  };
}
function _d() {
  return {
    activityFinal: Cd
  };
}
function Ld(e, t) {
  e.onDestroy || (e.onDestroy = Nd, e.onAdd = Md);
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l } = e.calculative.worldRect;
  let n = e.calculative.borderRadius || 0, h = n;
  n < 1 && (n *= a, h *= r);
  let c = n < h ? n : h;
  a < 2 * c && (c = a / 2), r < 2 * c && (c = r / 2), i.moveTo(s + c, o), i.arcTo(s + a, o, s + a, o + r, c), i.arcTo(s + a, o + r, s, o + r, c), i.arcTo(s, o + r, s, o, c), i.arcTo(s, o, s + a, o, c);
  const d = 0.2 * r;
  i.moveTo(s, o + d), i.lineTo(l, o + d);
  const u = o + d + (r - d) / 2;
  if (i.moveTo(s, u), i.lineTo(l, u), i.closePath(), i instanceof Path2D) return i;
}
function Md(e) {
  const { x: t, y: i, width: s, height: o } = e.calculative.worldRect, a = e.list, r = {
    name: "text",
    x: t,
    y: i + 0.2 * o,
    width: s,
    height: 0.4 * o,
    // text: list[0].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  }, l = {
    name: "text",
    x: t,
    y: i + 0.6 * o,
    width: s,
    height: 0.4 * o,
    // text: list[1].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  };
  Object.assign(r, a[0]), Object.assign(l, a[1]), e.calculative.canvas.makePen(r), e.calculative.canvas.makePen(l), e.calculative.canvas.parent.pushChildren(e, [r]), e.calculative.canvas.parent.pushChildren(e, [l]);
}
function Nd(e) {
  const t = e.calculative.canvas.store;
  e.children.forEach((i) => {
    const s = t.data.pens.findIndex((o) => o.id === i);
    s > -1 && (t.data.pens.splice(s, 1), t.pens[i] = void 0);
  }), e.children = void 0;
}
function Od(e, t) {
  e.onDestroy || (e.onDestroy = Bd, e.onAdd = Dd);
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r, ex: l } = e.calculative.worldRect;
  let n = e.calculative.borderRadius || 0, h = n;
  n < 1 && (n = a * n, h = r * h);
  let c = n < h ? n : h;
  a < 2 * c && (c = a / 2), r < 2 * c && (c = r / 2), i.moveTo(s + c, o), i.arcTo(s + a, o, s + a, o + r, c), i.lineTo(s + a, o + r - c), i.arcTo(s + a, o + r, s, o + r, c), i.arcTo(s, o + r, s, o, c), i.arcTo(s, o, s + a, o, c);
  const d = 0.2 * r;
  if (i.moveTo(s, o + d), i.lineTo(l, o + d), i.closePath(), i instanceof Path2D) return i;
}
function Dd(e) {
  const { x: t, y: i, width: s, height: o } = e.calculative.worldRect, a = e.list;
  let r = {
    name: "text",
    x: t,
    y: i + 0.2 * o,
    width: s,
    height: 0.8 * o,
    // text: list[0].text,
    textAlign: "left",
    textBaseline: "top",
    textLeft: 10,
    textTop: 10
  };
  Object.assign(r, a[0]), e.calculative.canvas.makePen(r), e.calculative.canvas.parent.pushChildren(e, [r]);
}
function Bd(e) {
  const t = e.calculative.canvas.store;
  e.children.forEach((i) => {
    const s = t.data.pens.findIndex((o) => o.id === i);
    s > -1 && (t.data.pens.splice(s, 1), t.pens[i] = void 0);
  }), e.children = [];
}
function zd() {
  return {
    interfaceClass: Ld,
    simpleClass: Od
  };
}
function Hd(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  if (i.rect(s, o, a, r), i.closePath(), i instanceof Path2D) return i;
}
function Fd(e, t) {
  const i = t.headHeight ?? 50, { x: s, y: o, width: a, height: r, ey: l } = t.calculative.worldRect;
  let n = t.calculative.borderRadius || 0, h = n;
  t.calculative.borderRadius < 1 && (n *= a, h *= r);
  let c = n < h ? n : h;
  a < 2 * c && (c = a / 2), i < 2 * c && (c = i / 2), e.beginPath(), e.moveTo(s + c, o), e.arcTo(s + a, o, s + a, o + i, c), e.arcTo(s + a, o + i, s, o + i, c), e.arcTo(s, o + i, s, o, c), e.arcTo(s, o, s + a, o, c), e.closePath(), e.stroke(), e.save(), e.beginPath(), e.lineWidth = 1, e.setLineDash([7, 7]);
  const d = s + a / 2;
  e.moveTo(d, o + i + 1), e.lineTo(d, l), e.stroke(), e.restore();
}
function Wd() {
  return {
    sequenceFocus: Hd
  };
}
function jd() {
  return {
    lifeline: Fd
  };
}
let ls = [
  "fontSize",
  "nameGap",
  "margin",
  "width",
  "symbolSize",
  "itemWidth",
  // 图例宽度
  "itemHeight",
  // 图例高度
  "fontWeight",
  "top",
  "left",
  "right",
  "bottom",
  "zoom",
  "edgeSymbolSize",
  "nodeWidth",
  "nodeGap",
  "distance",
  "length",
  "length2",
  "offsetCenter",
  "size",
  "symbolOffset",
  "padding",
  "barWidth",
  "symbolOffset",
  "shadowOffsetY",
  "shadowOffsetX"
];
function Vd(e) {
  var o, a;
  let t = globalThis.echarts;
  if (!e.echarts || !t)
    return;
  if (typeof e.echarts == "string")
    try {
      e.echarts = JSON.parse(e.echarts);
    } catch {
    }
  ls = ((o = e.calculative.canvas.store.options.diagramOptions.chart) == null ? void 0 : o.keyWords) || ls, e.onDestroy || (e.onDestroy = qd, e.onMove = Wi, e.onResize = Yd, e.onRotate = Wi, e.onValue = $d, e.onBeforeValue = Xd, e.onBinds = Kd, e.onMouseEnter = Wi, e.onRenderPenRaw = ji), e.calculative.singleton || (e.calculative.singleton = {});
  const i = new Path2D(), s = e.calculative.worldRect;
  if (!e.calculative.singleton.div) {
    const r = document.createElement("div");
    r.style.position = "absolute", r.style.outline = "none", r.style.left = "-9999px", r.style.top = "-9999px", r.style.width = s.width + "px", r.style.height = s.height + "px", document.body.appendChild(r), (a = e.calculative.canvas.externalElements) == null || a.parentElement.appendChild(r), Ct(e, r), e.calculative.singleton.div = r, e.calculative.singleton.echart = t.init(r, e.echarts.theme), Ud(e), e.calculative.singleton.echartsReady = !0, e.echarts.geoName && !t.getMap(e.echarts.geoName) && (e.echarts.geoJson ? t.registerMap(e.echarts.geoName, e.echarts.geoJson) : e.echarts.geoUrl && (e.calculative.singleton.echartsReady = !1, fetch(e.echarts.geoUrl).then((l) => {
      l.text().then((n) => {
        if (typeof n == "string")
          try {
            n = JSON.parse(n);
          } catch {
          }
        if (n.constructor !== Object && n.constructor !== Array) {
          console.warn("Invalid data:", n);
          return;
        }
        t.registerMap(e.echarts.geoName, n), e.calculative.singleton.echartsReady = !0, e.calculative.singleton.echart.setOption(
          Ti(
            e.echarts.option,
            e.calculative.canvas.store.data.scale
          ),
          !0
        ), e.calculative.singleton.echart.resize(), setTimeout(() => {
          ji(e);
        }, 300);
      });
    }))), e.calculative.singleton.echartsReady && setTimeout(() => {
      e.calculative.singleton.echart.setOption(
        Ti(
          e.echarts.option,
          e.calculative.canvas.store.data.scale
        ),
        !0
      ), setTimeout(() => ji(e), 300);
    });
  }
  return i;
}
function Ud(e) {
  var s;
  const t = e.calculative.singleton.echart, i = ["click", "dblclick", "mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "globalout", "contextmenu"];
  i.forEach((o) => {
    t.off(o);
  }), (s = e.events) == null || s.forEach((o) => {
    o.actions && o.actions.length && i.includes(o.name) && t.on(o.name, (a) => {
      let r = !1;
      o.conditions && o.conditions.length ? o.conditionType === "and" ? r = o.conditions.every((l) => e.calculative.canvas.parent.judgeCondition(e, l.key, l)) : o.conditionType === "or" && (r = o.conditions.some((l) => e.calculative.canvas.parent.judgeCondition(e, l.key, l))) : r = !0, r && o.actions.forEach((l) => {
        if (l.timeout) {
          let n = setTimeout(() => {
            e.calculative.canvas.parent.events[l.action] && (e.calculative.canvas.parent.events[l.action](e, l, a), clearTimeout(n), n = null);
          }, l.timeout);
        } else
          e.calculative.canvas.parent.events[l.action] && e.calculative.canvas.parent.events[l.action](e, l, a);
      });
    });
  });
}
function qd(e) {
  if (e.calculative.singleton && e.calculative.singleton.div) {
    e.calculative.singleton.div.remove();
    let t = globalThis.echarts;
    t && t.dispose(e.calculative.singleton.echart), delete e.calculative.singleton.div, delete e.calculative.singleton.echart;
  }
}
function Wi(e) {
  e.calculative.singleton.div && Ct(e, e.calculative.singleton.div);
}
function Yd(e) {
  if (!e.calculative.singleton.echart)
    return;
  let t = globalThis.echarts;
  Ct(e, e.calculative.singleton.div), !(e.echarts.geoName && !t.getMap(e.echarts.geoName)) && (e.calculative.singleton.echart.setOption(
    Ti(e.echarts.option, e.calculative.canvas.store.data.scale),
    !0
  ), e.calculative.singleton.echart.resize());
}
function $d(e) {
  if (e.calculative.singleton.echart && (Ct(e, e.calculative.singleton.div), e.calculative.singleton.echartsReady))
    if (e.calculative.partialOption) {
      const t = e.calculative.partialOption.echarts.option;
      e.calculative.singleton.echart.setOption(G(t));
    } else
      e.calculative.singleton.echart.setOption(
        Ti(
          e.echarts.option,
          e.calculative.canvas.store.data.scale
        ),
        !0
      );
}
function Xd(e, t) {
  if (e.calculative.partialOption = null, t.echarts) {
    let g = globalThis.echarts;
    return t.echarts.geoName && !g.getMap(t.echarts.geoName) && (t.echarts.geoJson ? g.registerMap(t.echarts.geoName, t.echarts.geoJson) : t.echarts.geoUrl && (e.calculative.singleton.echartsReady = !1, fetch(t.echarts.geoUrl).then((y) => {
      y.text().then((v) => {
        if (typeof v == "string")
          try {
            v = JSON.parse(v);
          } catch {
          }
        if (v.constructor !== Object && v.constructor !== Array) {
          console.warn("Invalid data:", v);
          return;
        }
        return g.registerMap(t.echarts.geoName, v), e.calculative.singleton.echartsReady = !0, e.onValue(e), !1;
      });
    }))), t;
  }
  if (e.realTimes && e.realTimes.length) {
    let g = Object.keys(t);
    const { xAxis: y, yAxis: v } = e.echarts.option, { max: b, replaceMode: x, timeFormat: p } = e.echarts;
    let k = [], C = !1;
    for (let R in t)
      if (R.includes("echarts.option")) {
        C = !0;
        let P = Me(e, R);
        if (Array.isArray(P) && x === 0 && (P.push(t[R]), b && P.splice(0, P.length - b), t[R] = P, !g.includes("echarts.option.xAxis.data"))) {
          let E = "echarts.option.xAxis.data";
          Array.isArray(y) && y.length && (E = "echarts.option.xAxis.0.data");
          let H = Me(e, E), $ = Er(
            p || "`${hours}:${minutes}:${seconds}`"
          );
          H.push($), b && H.splice(0, H.length - b), t[E] = H;
        }
        if (R.includes(".data.")) {
          let E = R.substring(0, R.indexOf(".data.") + 5);
          k.includes(E) || k.push(E);
        }
      }
    if (C) {
      const R = G(t);
      e.calculative.partialOption = Gd(R), k.forEach((P) => {
        let E = Me(e, P);
        Ki(e.calculative.partialOption, P, E);
      });
    }
    return t;
  }
  if (!t.dataX && !t.dataY)
    return t;
  const i = e.echarts, { max: s, replaceMode: o } = i;
  let a = t.dataX, r = t.dataY, l = [];
  r && l.push("echarts.option.series");
  const n = i.option.series, h = n.length, { xAxis: c, yAxis: d } = i.option;
  Array.isArray(c) && c.length > 1 && console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  const u = Array.isArray(c) ? c[0] : c, f = Array.isArray(d) ? d[0] : d;
  if (o)
    if (o === 1) {
      if (!u && !f)
        r && (h === 1 ? (!Array.isArray(r) && (r = [r]), r.forEach((g, y) => {
          const v = n[0].data.find((b) => b.name === g.name);
          v && (v.value = g.value);
        })) : n.forEach((g, y) => {
          Array.isArray(r[y]) || (r[y] = [r[y]]), r[y].forEach((v, b) => {
            const x = g.data.find((p) => p.name === v.name);
            x && (x.value = v.value);
          });
        }));
      else if ((u.type === "category" || f.type === "category") && a && r) {
        const g = u.type === "category" ? u.data : f.data;
        !Array.isArray(a) && (a = [a]), !Array.isArray(r) && (r = [r]), u.type === "category" ? l.push("echarts.option.xAxis") : l.push("echarts.option.yAxis"), h === 1 ? r.forEach((y, v) => {
          const b = g.indexOf(a[v]);
          n[0].data[b] = y;
        }) : n.forEach((y, v) => {
          r[v].forEach((b, x) => {
            const p = g.indexOf(a[x]);
            y.data[p] = b;
          });
        });
      }
    } else o === 2 && (a && (u.data = a, u.data.splice(0, u.data.length - s), l.push("echarts.option.xAxis")), r && (h === 1 ? (n[0].data = r, n[0].data.splice(0, n[0].data.length - s)) : n.forEach((g, y) => {
      g.data = r[y], g.data.splice(0, g.data.length - s);
    })));
  else {
    if (a) {
      !Array.isArray(a) && (a = [a]);
      const g = u.data;
      g.push(...a), g.splice(0, g.length - s), l.push("echarts.option.xAxis");
    }
    if (r)
      if (h === 1) {
        !Array.isArray(r) && (r = [r]);
        const g = n[0].data;
        g.push(...r), g.splice(0, g.length - s);
      } else
        n.forEach((g, y) => {
          Array.isArray(r[y]) || (r[y] = [r[y]]);
          const v = g.data;
          v.push(...r[y]), v.splice(0, v.length - s);
        });
  }
  return e.calculative.partialOption = {}, l.forEach((g) => {
    let y = Me(e, g);
    Ki(e.calculative.partialOption, g, y);
  }), delete t.dataX, delete t.dataY, Object.assign(t, { echarts: i });
}
function Kd(e, t, i) {
  if (i.key !== "dataY")
    return;
  const s = e.echarts, { xAxis: o, yAxis: a } = s.option;
  Array.isArray(o) && o.length > 1 && console.warn("echarts 只支持单 x 轴，多 x 轴将被忽略");
  const r = Array.isArray(o) ? o[0] : o, l = Array.isArray(a) ? a[0] : a, n = s.option.series;
  if (!r && !l) {
    const h = [];
    if (Array.isArray(n) && n.length === 1)
      return n[0].data.forEach((c) => {
        const { dataId: d } = i.dataIds.find(
          (u) => u.name === c.name
        );
        if (d) {
          const u = t.find((f) => f.dataId === d);
          u && h.push({
            name: c.name,
            value: u.value
          });
        }
      }), {
        id: e.id,
        dataY: h
      };
  } else if (r.type === "category" || l.type === "category") {
    const h = [], c = [], d = r.type === "category" ? r.data : l.data;
    return d == null || d.forEach((u) => {
      const { dataId: f } = i.dataIds.find(
        (g) => g.name === u
      );
      if (f) {
        const g = t.find((y) => y.dataId === f);
        g && (c.push(u), h.push(g.value));
      }
    }), {
      id: e.id,
      dataY: h,
      dataX: c
    };
  } else if (r.type === "time") {
    const h = [], c = +/* @__PURE__ */ new Date();
    let d = !1;
    if (n.forEach((u, f) => {
      const g = [], { dataId: y } = i.dataIds.find(
        (v) => v.name === u.name
      );
      if (y) {
        const v = t.find((b) => b.dataId === y);
        v && (g.push([c, v.value]), d = !0);
      }
      h[f] = g;
    }), d)
      h.forEach((u, f) => {
        if (!u || u.length === 0) {
          const g = n[f].data[n[f].data.length - 1];
          h[f] = [[c, g[1]]];
        }
      });
    else
      return;
    return {
      id: e.id,
      dataY: h.length === 1 ? h[0] : h
    };
  }
}
function ji(e) {
  var i, s;
  const t = new Image();
  t.src = (s = (i = e.calculative.singleton) == null ? void 0 : i.echart) == null ? void 0 : s.getDataURL({
    pixelRatio: 2
  }), e.calculative.img = t;
}
function Ti(e, t) {
  const i = G(e);
  if (i.dataZoom) {
    let s = ["right", "top", "width", "height", "left", "bottom"];
    for (let o = 0; o < s.length; o++)
      i.dataZoom.forEach((a) => {
        isNaN(a[s[o]]) || (a[s[o]] *= t);
      });
  }
  return $i(i, ls, t), i;
}
function Gd(e) {
  const t = {};
  return Object.keys(e).forEach((i) => {
    const s = i.split(".");
    let o = t;
    s.forEach((a, r) => {
      const l = !isNaN(parseInt(a));
      if (r === s.length - 1)
        l ? (Array.isArray(o) || (o = []), o[parseInt(a)] = e[i]) : o[a] = e[i];
      else if (l) {
        const n = parseInt(a);
        if (Array.isArray(o) || o[s[r - 1]], o[n] || (o[n] = {}), Array.isArray(o))
          for (let h = 0; h < parseInt(a); h++)
            o[h] || (o[h] = {});
        o = o[n];
      } else
        o[a] || (a === "series" ? o[a] = [] : o[a] = {}), o = o[a];
    });
  }), t;
}
function Jd(e) {
  me({ echarts: Vd });
}
var cs = /* @__PURE__ */ ((e) => (e[e.Add = 0] = "Add", e[e.Replace = 1] = "Replace", e[e.ReplaceAll = 2] = "ReplaceAll", e))(cs || {});
function wa(e, t) {
  const i = t.calculative.worldRect.height * 14 / 16, o = (e.match(/[\u4e00-\u9fa5]/g) || "").length;
  return (e.length - o) * i * 0.6 + o * i;
}
function xa(e) {
  if (e.direction == "horizontal") {
    const t = [];
    let i = 0;
    const s = e.height;
    e.checkboxHeight = s, e.options.forEach((a, r) => {
      t.push(r * (40 + s) + i), i += wa(a.text, e);
    }), e.optionPos = t;
    const o = t.length * (40 + s) + i;
    e.checkboxWidth = o, e.width = o, e.calculative.width = o, e.calculative.worldRect = {
      x: e.x,
      y: e.y,
      height: e.height,
      width: e.width,
      center: {
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
      }
    }, wt(e.calculative.worldRect);
  } else if (e.direction == "vertical") {
    e.optionInterval == null && (e.optionInterval = 20), e.optionHeight || (e.optionHeight = 20);
    const t = [];
    e.options.forEach((s, o) => {
      t.push(o * (e.optionInterval + e.optionHeight));
    }), e.optionPos = t;
    const i = t[t.length - 1] + e.optionHeight;
    e.checkboxHeight = i, e.width || (e.height = i, e.calculative.height = i, e.calculative.worldRect = {
      x: e.x,
      y: e.y,
      height: e.height,
      width: e.width,
      center: {
        x: e.x + e.width / 2,
        y: e.y + e.height / 2
      }
    }, wt(e.calculative.worldRect));
  }
}
function ho(e, t) {
  t.onAdd || (t.onAdd = ka, (!t.rowPos || !t.colPos || !t.calculative.maxOffsetY) && t.onAdd(t), t.onMouseMove = ou, t.onMouseLeave = au, t.onMouseDown = ru, t.onShowInput = iu, t.onInput = su, t.onValue = cu, t.onBeforeValue = hu, t.onMouseEnter = vu, t.onWheel = du, t.onDestroy = fu), t.data.length !== t.rowPos.length && (t.initWorldRect = null, t.calculative.isUpdateData = !0, t.onValue(t)), t.data[0].length !== t.colPos.length && (t.initWorldRect = null, t.calculative.isUpdateData = !0, t.onValue(t));
  const i = t.calculative.canvas.store.data, s = t.calculative.canvas.store.options;
  if (t.color = t.color || i.color || s.color, t.textColor = t.textColor || t.color || i.textColor || s.textColor, t.activeColor = t.activeColor || s.activeColor, t.hoverColor = t.hoverColor || s.hoverColor, t.activeBackground = t.activeBackground || s.activeBackground, t.hoverBackground = t.hoverBackground || s.hoverBackground, !t.hasHeader) {
    e.save(), e.beginPath();
    const { x: o, y: a, width: r, height: l } = t.calculative.worldRect;
    e.fillStyle = "#fff0", e.rect(o - 1, a - 1, r + 2, l + 2), e.fill(), e.clip();
  }
  tu(e, t), eu(e, t), Qd(e, t), e.restore(), t.isFirstTime = !1;
}
function Qd(e, t) {
  if (!t.calculative.hover || !t.calculative.hoverCell || t.calculative.isInput || !t.calculative.isHover)
    return;
  let i = t.calculative.worldRect, s = t.calculative.canvas.mousePos;
  if (!(s.x > i.x && s.x < i.x + i.width && s.y > i.y && s.y < i.y + i.height)) {
    t.calculative.hover = !1, t.calculative.isHover = !1, t.calculative.hoverCell = void 0;
    return;
  }
  const { row: o, col: a } = t.calculative.hoverCell, { x: r, y: l } = t.calculative.canvas.mousePos;
  if (!t.data[o])
    return;
  let n = t.data[o][a];
  if (typeof n == "object" || !n)
    return;
  e.save(), e.beginPath(), e.textAlign = "start", e.textBaseline = "middle", e.font = e.font = (t.calculative.fontStyle || "") + " normal " + (t.calculative.fontWeight || "") + " " + (t.calculative.fontSize || 12) + "px " + t.calculative.fontFamily;
  const h = e.measureText(n).width;
  e.beginPath(), e.fillStyle = "#fff", e.strokeStyle = "#000", e.moveTo(r, l), e.rect(r - 10, l, h + 20, 20), e.fill(), e.stroke(), e.beginPath(), e.fillStyle = "#000", e.fillText(n, r, l + 10), e.restore();
}
function Zd(e) {
  const t = [], i = [], s = {};
  e.rowHeight || (e.rowHeight = 40), e.colWidth || (e.colWidth = 150);
  let o = 0;
  const a = e.styles && e.styles.filter((f) => f.col !== void 0 && f.row === void 0 && f.width);
  let r = {};
  a && a.forEach((f) => {
    r[f.col] = f.width;
  });
  for (let f = 0; f < e.data[0].length; f++) {
    o += (r[f] || e.colWidth) * e.calculative.canvas.store.data.scale, t.push(o);
    let g = e.styles && e.styles.filter((y) => y.col === f && y.row === void 0);
    g && (s[f] = g[0]);
  }
  let l = 0;
  const n = e.styles && e.styles.filter((f) => f.col === void 0 && f.row !== void 0 && f.height);
  let h = {};
  n && n.forEach((f) => {
    h[f.row] = f.height;
  });
  let c = l;
  for (let f = 0; f < e.data.length; f++)
    l += (h[f] || e.rowHeight) * e.calculative.canvas.store.data.scale, i.push(l), f < e.maxNum && (c = l);
  if (e.calculative.maxOffsetY = (l - c) / e.calculative.canvas.store.data.scale, e.initWorldRect)
    return;
  e.colPos = t, e.rowPos = i, e.colStyle = s, e.initScale = e.calculative.canvas.store.data.scale, e.tableWidth = o, e.tableHeight = c || l, e.calculative.width = o, e.calculative.height = c || l, e.calculative.width = o, e.calculative.height = c || l, e.height || (e.height = e.calculative.height), e.width || (e.width = e.calculative.width);
  let d = e.x, u = e.y;
  if (e.parentId) {
    let f = e.calculative.canvas.store.pens[e.parentId];
    d = f.calculative.worldRect.x + f.calculative.worldRect.width * e.x, u = f.calculative.worldRect.y + f.calculative.worldRect.height * e.y;
  }
  e.calculative.worldRect = {
    x: d,
    y: u,
    height: e.calculative.height,
    width: e.calculative.width,
    center: {
      x: e.x + e.calculative.width / 2,
      y: e.y + e.calculative.height / 2
    }
  }, e.width = e.calculative.width, e.height = e.calculative.height, e.initWorldRect || (e.initWorldRect = {
    width: e.calculative.worldRect.width,
    height: e.calculative.worldRect.height
  }), wt(e.calculative.worldRect);
}
function tu(e, t) {
  if (!t.colPos)
    return;
  const { x: i, y: s, width: o, height: a, ex: r, ey: l } = t.calculative.worldRect;
  e.save(), e.beginPath(), e.strokeStyle = t.color;
  let n = t.calculative.borderRadius || 0, h = n;
  n < 1 && (n = o * n, h = a * h);
  let c = n < h ? n : h;
  if (o < 2 * c && (c = o / 2), a < 2 * c && (c = a / 2), e.moveTo(i + c, s), e.arcTo(r, s, r, l, c), e.arcTo(r, l, i, l, c), e.arcTo(i, l, i, s, c), e.arcTo(i, s, r, s, c), t.background && (e.fillStyle = t.background, e.fill()), t.bordered !== !1 && (e.strokeStyle = t.borderColor || "#424B61", e.stroke()), t.hLine !== !1) {
    let d = t.rowPos[t.rowPos.length - 1];
    t.hasHeader && (e.beginPath(), e.moveTo(
      t.calculative.worldRect.x,
      t.calculative.worldRect.y + t.rowPos[0] * t.calculative.worldRect.height / t.tableHeight
    ), e.lineTo(
      t.calculative.worldRect.ex,
      t.calculative.worldRect.y + t.rowPos[0] * t.calculative.worldRect.height / t.tableHeight
    ), e.strokeStyle = t.borderColor || "#424B61", e.stroke());
    for (const u of t.rowPos) {
      if (u === d)
        continue;
      const f = u * t.calculative.worldRect.height / t.tableHeight - t.offsetY * t.calculative.canvas.store.data.scale;
      if (t.hasHeader) {
        if (f < 0 + t.rowPos[0] || f > t.calculative.worldRect.height)
          continue;
      } else if (f < 0 || f > t.calculative.worldRect.height)
        continue;
      e.beginPath(), e.moveTo(t.calculative.worldRect.x, t.calculative.worldRect.y + f), e.lineTo(t.calculative.worldRect.ex, t.calculative.worldRect.y + f), e.strokeStyle = t.borderColor || "#424B61", e.stroke();
    }
  }
  if (t.vLine !== !1) {
    let d = t.colPos[t.colPos.length - 1];
    t.colPos.forEach((u, f) => {
      if (u === d)
        return;
      const g = u * t.calculative.worldRect.width / t.tableWidth;
      e.beginPath(), e.moveTo(t.calculative.worldRect.x + g, t.calculative.worldRect.y), e.lineTo(t.calculative.worldRect.x + g, t.calculative.worldRect.ey), e.strokeStyle = t.borderColor || "#424B61", e.stroke();
    });
  }
  e.restore();
}
function eu(e, t) {
  var s, o, a, r, l;
  if (!t.colPos)
    return;
  t.calculative.texts || (t.calculative.texts = []);
  const i = 1;
  for (let n = 0; n < t.rowPos.length; n++) {
    if (t.hasHeader && n === 1) {
      e.save(), e.beginPath();
      const { x: c, y: d, width: u, height: f } = t.calculative.worldRect;
      e.fillStyle = "#fff0", e.rect(
        c - 1,
        d + t.rowPos[0] * t.calculative.worldRect.height / t.tableHeight - 1,
        u + 2,
        f - t.rowPos[0] * t.calculative.worldRect.height / t.tableHeight + 2
      ), e.fill(), e.clip();
    }
    let { style: h } = nu(t, n);
    for (let c = 0; c < t.colPos.length; c++) {
      let { value: d, style: u } = Aa(t, n, c), f = !0;
      if (Array.isArray(u) && u.length > 0) {
        let E = 0;
        u.forEach((H, $) => {
          H.wheres && H.wheres.every((I) => new Function(
            "attr",
            `return attr ${I.comparison} ${I.value}`
          )(d)) && (E = $);
        }), u = u[E];
      } else
        u.wheres && Array.isArray(u.wheres) && (f = !1, f = u.wheres.every(function(E) {
          return new Function(
            "attr",
            `return attr ${E.comparison} ${E.value}`
          )(d);
        }));
      let g = t.color, y = t.textColor || t.color, v = null, b = null, x = null, p = null;
      f && (g = u.color || h.color || t.color, y = u.textColor || h.textColor || t.textColor, v = u.background || h.background, b = (u.fontSize || h.fontSize || 0) * t.calculative.canvas.store.data.scale, x = u.fontWeight || h.fontWeight, p = u.fontStyle || h.fontStyle);
      let k;
      t.stripe && (t.hasHeader !== !1 ? n % 2 === 1 && (v = v || t.stripeColor || "#407FFF1F") : n % 2 === 0 && (v = v || t.stripeColor || "#407FFF1F")), t.calculative.active && ((s = t.calculative.activeCell) == null ? void 0 : s.row) === n && ((o = t.calculative.activeCell) == null ? void 0 : o.col) === c && (g = t.activeColor, v = t.activeBackground, k = g, y = t.activeTextColor || t.activeColor), t.calculative.hover && ((a = t.calculative.hoverCell) == null ? void 0 : a.row) === n && ((r = t.calculative.hoverCell) == null ? void 0 : r.col) === c && (g = t.hoverColor, v = t.hoverBackground, y = t.hoverTextColor || t.hoverColor, k = g);
      const C = Ta(t, n, c);
      if (C.y + C.height < t.calculative.worldRect.y || C.y > t.calculative.worldRect.height + t.calculative.worldRect.y)
        continue;
      v && (e.save(), e.beginPath(), e.fillStyle = v, e.fillRect(
        C.x,
        C.y,
        C.width + 0.25 * t.calculative.canvas.store.data.scale,
        C.height
      ), e.restore()), k && (e.save(), e.beginPath(), e.strokeStyle = k, e.strokeRect(C.x, C.y, C.width, C.height), e.restore()), t.calculative.worldTextRect = C;
      let R = t.calculative.texts[n];
      if (t.calculative.texts[n] || (R = [], t.calculative.texts.push(R)), R[c] == null) {
        if (typeof d == "object") {
          const E = t.styles && t.styles.filter((H) => H.col === c && H.row === void 0 && H.pens);
          if (E.length > 0) {
            if (R[c] = "", t.isFirstTime) {
              t.maxNum && t.hasHeader && n >= t.maxNum && (d.visible = !1);
              let H = JSON.parse(JSON.stringify(E[0].pens));
              H.forEach(($) => {
                Object.assign($, { row: n, col: c }, d), $.activeBackground = $.background, $.hoverBackground = $.background, $.activeColor = $.color, $.hoverColor = $.color, $.activeTextColor = $.textColor, $.hoverTextColor = $.textColor, $.height *= t.calculative.canvas.store.data.scale, $.width *= t.calculative.canvas.store.data.scale;
              }), lu(t, C, H), t.calculative.canvas.parent.pushChildren(t, H);
            }
            continue;
          }
        } else d === void 0 ? R[c] = "" : R[c] = d.text || d + "";
        if (!R[c])
          continue;
        R[c] = ii(t, R[c]);
      }
      if (!R[c])
        continue;
      e.save(), e.beginPath(), e.fillStyle = y, e.textAlign = "center", e.textBaseline = "middle", e.font = (p || t.calculative.fontStyle || "") + " normal " + (x || t.calculative.fontWeight || "") + " " + (b || t.calculative.fontSize || 12) * i + "px " + t.calculative.fontFamily;
      let P = t.colStyle && ((l = t.colStyle[c]) == null ? void 0 : l.textAlign);
      if (P && (e.textAlign = P), R[c].length === 1)
        P === "left" ? e.fillText(R[c][0], C.x, C.y + C.height / 2) : P === "right" ? e.fillText(
          R[c][0],
          C.x + C.width,
          C.y + C.height / 2
        ) : e.fillText(
          R[c][0],
          C.x + C.width / 2,
          C.y + C.height / 2
        );
      else {
        const H = (b || t.calculative.fontSize) * t.calculative.lineHeight * i, $ = R[c].length * H;
        let A = (C.height - $) / 2;
        P === "left" ? R[c].forEach((I, S) => {
          e.fillText(I, C.x, C.y + A + (S + 0.55) * H);
        }) : P === "right" ? R[c].forEach((I, S) => {
          e.fillText(
            I,
            C.x + C.width,
            C.y + A + (S + 0.55) * H
          );
        }) : R[c].forEach((I, S) => {
          e.fillText(
            I,
            C.x + C.width / 2,
            C.y + A + (S + 0.55) * H
          );
        });
      }
      e.restore();
    }
  }
}
function ka(e) {
  var t;
  Is(e), (t = e.children) != null && t.length || (e.isFirstTime = !0), e.offsetY || (e.offsetY = 0), Zd(e);
}
function iu(e, t) {
  if (!e.calculative.hoverCell)
    return;
  const { value: i } = Aa(
    e,
    e.calculative.hoverCell.row,
    e.calculative.hoverCell.col
  );
  if (typeof i == "object")
    return;
  e.calculative.isHover = !1, e.calculative.isInput = !0, e.calculative.canvas.render(), e.calculative.inputCell = e.calculative.hoverCell;
  const s = Ta(
    e,
    e.calculative.hoverCell.row,
    e.calculative.hoverCell.col
  );
  e.calculative.tempText = i.text || i + "", e.calculative.canvas.showInput(e, s, "#ffffff");
}
function su(e, t) {
  e.calculative.inputCell && (Sa(
    e,
    e.calculative.inputCell.row,
    e.calculative.inputCell.col,
    t
  ), e.calculative.isInput = !1, e.calculative.isHover = !0, e.calculative.canvas.render());
}
function ou(e, t) {
  e.timer && (e.calculative.isHover = !1, clearTimeout(e.timer)), e.timer = setTimeout(() => {
    e.calculative.isHover = !0, e.calculative.canvas.render();
  }, 500), e.calculative.hoverCell = Ia(e, t), e.calculative.canvas.render();
}
function au(e, t) {
  Is(e), e.calculative.hoverCell = void 0, e.calculative.canvas.render();
}
function ru(e, t) {
  e.calculative.activeCell = Ia(e, t), e.calculative.canvas.render();
}
function Ia(e, t) {
  const i = e.calculative.worldRect.width / e.tableWidth, s = e.calculative.worldRect.height / e.tableHeight, o = { row: 0, col: 0 };
  for (let a = 0; a < e.colPos.length; a++)
    t.x > e.calculative.worldRect.x + e.colPos[a] * i && (o.col = a + 1);
  for (let a = 0; a < e.rowPos.length; a++)
    t.y > e.calculative.worldRect.y + e.rowPos[a] * s - e.offsetY * e.calculative.canvas.store.data.scale && (o.row = a + 1);
  return o;
}
function Aa(e, t, i) {
  if (!e.data || !Array.isArray(e.data))
    return;
  const s = e.data[t], o = e.styles && e.styles.filter((a) => a.row === t && a.col === i);
  if (Array.isArray(s))
    return { value: s[i], style: (o == null ? void 0 : o.length) > 0 ? o.length > 1 ? o : o[0] : {} };
  if (!s.data || !Array.isArray(s.data))
    return;
}
function nu(e, t) {
  if (!e.data || !Array.isArray(e.data))
    return;
  const i = e.data[t], s = e.styles && e.styles.filter((o) => o.row === t && o.col === void 0);
  if (Array.isArray(i))
    return { value: i, style: (s == null ? void 0 : s.length) > 0 ? s[0] : {} };
  if (!i.data || !Array.isArray(i.data))
    return;
}
function Sa(e, t, i, s) {
  if (!e.data || !Array.isArray(e.data))
    return;
  e.isFirstTime = !1, e.calculative.texts = void 0;
  let o = e.data[t];
  o && (o[i] instanceof Object || (o[i] = s), e.calculative.canvas.store.emitter.emit("valueUpdate", e));
}
function Ta(e, t, i) {
  const s = e.calculative.worldRect.width / e.tableWidth, o = e.calculative.worldRect.height / e.tableHeight;
  let a = 0, r = e.colPos[i] * s;
  i > 0 && (a = e.colPos[i - 1] * s);
  let l = 0, n = e.rowPos[t] * o;
  t > 0 && (l = e.rowPos[t - 1] * o);
  let h = e.offsetY * e.calculative.canvas.store.data.scale;
  return t === 0 && e.hasHeader && (h = 0), {
    x: e.calculative.worldRect.x + a,
    y: e.calculative.worldRect.y + l - h,
    ex: e.calculative.worldRect.x + r,
    ey: e.calculative.worldRect.y + n - h,
    width: r - a,
    height: n - l
  };
}
function lu(e, t, i) {
  if (!(i && i.length))
    return;
  const s = e.calculative.worldRect.width / e.tableWidth, o = e.calculative.worldRect.height / e.tableHeight;
  let a = 1, r = 1;
  e.initWorldRect && (e.calculative.worldRect.width !== e.initWorldRect.width && (a = e.calculative.worldRect.width / e.initWorldRect.width), e.calculative.worldRect.height !== e.initWorldRect.height && (r = e.calculative.worldRect.height / e.initWorldRect.height));
  let l = 0, n = 0, h = 0;
  const c = e.calculative.canvas.store.data.scale;
  if (i.length > 1) {
    for (const d of i)
      n + d.width * s + 20 * c * s < t.width ? (d.x = t.x + n + 10 * c * s, d.y = t.y + h + 10 * c * o, n += (d.width + 10 * c) * s, l = Math.max(l, h + (d.height + 10 * c) * o)) : (n = 0, h = l, d.x = t.x + n + 10 * c * s, d.y = t.y + h + 10 * c * o, l += (d.height + 10 * c) * o);
    if (l + 20 * c * o < t.height) {
      const d = (t.height - l - 10 * c * o) / 2;
      for (const u of i)
        u.y += d;
    }
  } else
    i[0].x = t.x + (t.width - i[0].width) / 2, i[0].y = t.y + (t.height - i[0].height) / 2;
  i.forEach((d) => {
    d.width = d.width * a, d.height = d.height * r;
  });
}
function cu(e) {
  if (e.calculative.isUpdateData) {
    delete e.calculative.isUpdateData;
    let t = G(e.children);
    e.children = [], ka(e), t && t.forEach((i) => {
      e.calculative.canvas.delForce(e.calculative.canvas.findOne(i));
    }), e.calculative.texts = void 0;
  }
}
function hu(e, t) {
  if (e.calculative.isUpdateData = !1, e.swiper !== void 0 && (e.swiper ? Is(e) : ks(e)), t.styles && (e.initWorldRect = void 0), t.table || t.col == null && t.row == null) {
    if (t.dataY) {
      const s = e.replaceMode;
      let o = [];
      return s ? s === cs.Replace ? (o = e.data, t.dataX && t.dataX.forEach((a, r) => {
        o[a] = t.dataY[r];
      })) : s === cs.ReplaceAll && (t.dataX ? o[0] = t.dataX : o[0] = e.data[0], o = o.concat(t.dataY)) : o = e.data.concat(t.dataY), delete t.dataX, delete t.dataY, e.calculative.isUpdateData = !0, Object.assign(t, { data: o });
    }
    (t.data || t.styles || t.maxNum || t.rowHeight || t.colWidth) && (e.calculative.isUpdateData = !0, e.initWorldRect = null);
    for (let s of Object.keys(t))
      s.includes("data.") && (e.calculative.isUpdateData = !0);
    return t;
  }
  let i = e.data[t.row];
  return i && (i[t.col] instanceof Object || (i[t.col] = t.value), Sa(e, t.row, t.col, t.value), e.calculative.canvas.render(), delete t.col, delete t.row), t;
}
function du(e, t) {
  if (!e.locked && !e.calculative.canvas.store.data.locked || !e.maxNum)
    return;
  let i = 0;
  t.deltaY > 0 ? i = 4 : i = -4, hs(e, i);
}
function hs(e, t) {
  var i;
  e.offsetY || (e.offsetY = 0), e.offsetY += t, e.offsetY > e.calculative.maxOffsetY && (e.offsetY = e.calculative.maxOffsetY), e.offsetY < 0 && (e.offsetY = 0), (i = e.children) == null || i.forEach((s) => {
    const o = e.calculative.canvas.store.pens[s];
    uu(e, o);
  }), e.calculative.canvas.render();
}
function uu(e, t) {
  if (!t)
    return;
  t.oldY || (t.oldY = t.y), t.calculative.worldRect, e.calculative.worldRect;
  const i = e.calculative.canvas.store.data.scale;
  e.calculative.worldRect.height / e.tableHeight;
  const s = e.rowHeight;
  t.y = t.oldY - e.offsetY * i / e.calculative.worldRect.height;
  const o = s * (e.initScale || 1) / e.tableHeight * e.maxNum;
  if (e.calculative.canvas.updatePenRect(t), e.hasHeader)
    if (t.y < e.rowPos[0] / e.tableHeight) {
      if (t.calculative.visible = !1, t.visible = !1, t.y < e.rowPos[0] / e.tableHeight / 2) {
        t.oldY += o;
        let a = t.row + e.maxNum;
        if (!e.data[a])
          return;
        let r = G(e.data[a][t.col]);
        r.background && (r.activeBackground = r.background, r.hoverBackground = r.background), r.color && (r.hoverColor = r.color, r.activeColor = r.color), r.textColor && (r.activeTextColor = r.textColor, r.hoverTextColor = r.textColor), Object.assign(t, r, { row: a }), Object.assign(t.calculative, r, { row: a });
      }
    } else if (t.y + t.height > 1) {
      if (t.calculative.visible = !1, t.visible = !1, t.y + t.height / 2 > 1) {
        t.oldY -= o;
        let a = t.row - e.maxNum;
        if (!e.data[a])
          return;
        let r = G(e.data[a][t.col]);
        r.background && (r.activeBackground = r.background, r.hoverBackground = r.background), r.color && (r.hoverColor = r.color, r.activeColor = r.color), r.textColor && (r.activeTextColor = r.textColor, r.hoverTextColor = r.textColor), Object.assign(t, r, { row: a }), Object.assign(t.calculative, r, { row: a });
      }
    } else
      t.visible = !0, t.calculative.visible = !0;
  else if (t.y < 0) {
    if (t.calculative.visible = !1, t.visible = !1, t.y < -s / e.tableHeight / 2) {
      t.oldY += o;
      let a = t.row + e.maxNum;
      if (!e.data[a])
        return;
      let r = G(e.data[a][t.col]);
      r.background && (r.activeBackground = r.background, r.hoverBackground = r.background), r.color && (r.hoverColor = r.color, r.activeColor = r.color), r.textColor && (r.activeTextColor = r.textColor, r.hoverTextColor = r.textColor), Object.assign(t, r, { row: a }), Object.assign(t.calculative, r, { row: a });
    }
  } else if (t.y + t.height > 1) {
    if (t.calculative.visible = !1, t.visible = !1, t.y + t.height / 2 > 1) {
      t.oldY -= o;
      let a = t.row - e.maxNum;
      if (!e.data[a])
        return;
      let r = G(e.data[a][t.col]);
      r.background && (r.activeBackground = r.background, r.hoverBackground = r.background), r.color && (r.hoverColor = r.color, r.activeColor = r.color), r.textColor && (r.activeTextColor = r.textColor, r.hoverTextColor = r.textColor), Object.assign(t, r, { row: a }), Object.assign(t.calculative, r, { row: a });
    }
  } else
    t.calculative.visible = !0, t.visible = !0;
}
function fu(e) {
  ks(e);
}
function ks(e) {
  e.interval && (globalThis.clearInterval(e.interval), e.interval = null);
}
function Is(e) {
  if (e.maxNum && e.swiper) {
    if (e.interval)
      return;
    e.interval = globalThis.setInterval(() => {
      e.offsetY >= e.calculative.maxOffsetY ? (e.offsetY = 0, gu(e)) : e.offsetY % e.rowHeight ? hs(e, 1) : (e.calculative.stap || (e.calculative.stap = 0), e.calculative.stap += 1, e.calculative.stap == 12 && (e.calculative.stap = 0, hs(e, 1)));
    }, 50);
  }
}
function gu(e) {
  var t;
  (t = e.children) == null || t.forEach((i) => {
    const s = e.rowHeight, o = e.calculative.canvas.store.pens[i];
    if (!o)
      return;
    const a = s * (e.initScale || 1) / e.tableHeight * e.maxNum;
    o.oldY -= a;
    const r = o.row - e.maxNum;
    if (!e.data[r])
      return;
    let l = G(e.data[r][o.col]);
    l.background && (l.activeBackground = l.background, l.hoverBackground = l.background), l.color && (l.hoverColor = l.color, l.activeColor = l.color), l.textColor && (l.activeTextColor = l.textColor, l.hoverTextColor = l.textColor), o.calculative.visible = !0, o.visible = !0, Object.assign(o, l, { row: r }), Object.assign(o.calculative, l, { row: r });
  }), e.calculative.canvas.render();
}
function vu(e) {
  ks(e);
}
function yu(e, t) {
  t.onClick || (t.onClick = mu);
  let i = t.calculative.worldRect.x, s = t.calculative.worldRect.y, o = t.calculative.worldRect.width, a = t.calculative.worldRect.height;
  o < a * 1.5 && (o = 1.5 * a), e.beginPath(), e.arc(i + a / 2, s + a / 2, a / 2, Math.PI / 2, Math.PI * 3 / 2), e.lineTo(i + o - a / 2, s), e.arc(i + o - a / 2, s + a / 2, a / 2, -Math.PI / 2, Math.PI / 2), e.lineTo(i + a / 2, s + a), t.checked ? (e.fillStyle = t.onColor, (t.disabled || t.disable) && (e.fillStyle = t.disableOnColor || Tt(0.6, t.onColor)), t.lineWidth && (e.strokeStyle = t.onStrokeColor, e.stroke()), e.fill(), e.closePath(), e.beginPath(), e.fillStyle = "#ffffff", e.moveTo(i + a * 2, s + a / 2), e.arc(
    i + o - a / 2,
    s + a / 2,
    a / 2 > 2 ? a / 2 - 2 : 1,
    0,
    Math.PI * 2
  ), e.fill()) : (e.fillStyle = t.offColor, (t.disabled || t.disable) && (e.fillStyle = t.disableOffColor || Tt(0.6, t.offColor)), t.lineWidth && (e.strokeStyle = t.offStrokeColor, e.stroke()), e.fill(), e.closePath(), e.beginPath(), e.fillStyle = "#ffffff", e.moveTo(i + a, s + a / 2), e.arc(i + a / 2, s + a / 2, a / 2 > 2 ? a / 2 - 2 : 1, 0, Math.PI * 2), e.fill()), e.closePath();
}
function mu(e) {
  e.disabled || e.disable || (e.checked = !e.checked, e.calculative.canvas.store.emitter.emit("valueUpdate", e), e.calculative.canvas.render());
}
function pu(e, t) {
  t.onAdd || (t.onAdd = Ye, t.onResize = Ye, t.onMove = Ye, t.onMouseMove = bu, t.onMouseDown = Ca, t.onValue = wu, t.onBeforeValue = xu), t.calculative.barRect || Ye(t), t.calculative.canvas.store.data;
  const i = t.calculative.canvas.store.options;
  let s = t.background;
  t.disabled && (s = t.disabledBackground || Tt(0.6, s)), e.fillStyle = s, e.beginPath();
  let o = t.calculative.worldRect.x + t.calculative.barRect.x, a = t.calculative.worldRect.y + t.calculative.barRect.y, r = t.calculative.barRect.width, l = t.calculative.barRect.height, n = l / 2;
  e.moveTo(o + n, a), e.arcTo(o + r, a, o + r, a + l, n), e.arcTo(o + r, a + l, o, a + l, n), e.arcTo(o, a + l, t.x, t.y, n), e.arcTo(o, a, o + r, a, n), e.fill();
  let h = t.activeColor || i.activeColor;
  t.disabled && (h = t.disabledColor || Tt(0.6, h)), e.fillStyle = h, e.beginPath(), r = t.calculative.ballRect.x, e.moveTo(o + n, a), e.arcTo(o + r, a, o + r, a + l, n), e.arcTo(o + r, a + l, o, a + l, n), e.arcTo(o, a + l, t.x, t.y, n), e.arcTo(o, a, o + r, a, n), e.fill(), e.fillStyle = t.btnBackground || "#fff", e.strokeStyle = h, e.lineWidth = 2, e.beginPath(), o = t.calculative.worldRect.x + t.calculative.ballRect.x, a = t.calculative.worldRect.y + t.calculative.ballRect.y + t.calculative.ballRect.height / 2, e.lineWidth = t.calculative.ballRect.width / 10, e.arc(o, a, t.calculative.ballRect.width / 2, 0, Math.PI * 2), e.fill(), e.stroke();
}
function Ye(e) {
  if (e._textWidth || (e._textWidth = e.textWidth || 50, e._fontSize = e.fontSize || 12), e.textWidth = e.calculative.worldRect.width, e.calculative.textWidth = e.textWidth, e.unit || (e.unit = "%"), e.sliderWidth || (e.sliderWidth = e.width), e.sliderHeight || (e.sliderHeight = e.height), !e.calculative.worldRect)
    return;
  const t = e.calculative.worldRect.width / e.sliderWidth, i = e.calculative.worldRect.height / e.sliderHeight, s = Math.min(t, i);
  e.fontSize = e._fontSize * s;
  const o = e.calculative.worldRect.width - e._textWidth * s;
  e.textLeft = o + 10 * s, e.calculative.textLeft = e.textLeft, e.calculative.barRect = {
    x: 0,
    y: (e.calculative.worldRect.height - e.barHeight * i) / 2,
    width: o,
    height: e.barHeight * i
  }, wt(e.calculative.barRect), As(e);
}
function As(e) {
  const t = e.calculative.barRect.height * 3.5, i = e.calculative.barRect.width * e.value / 100;
  e.calculative.ballRect = {
    x: i,
    y: (e.calculative.worldRect.height - t) / 2,
    width: t,
    height: t
  }, wt(e.calculative.ballRect), e.calculative.text = e.value + e.unit, qt(e);
}
function Ca(e, t) {
  if (e.disabled)
    return;
  const i = t.x - e.calculative.worldRect.x;
  if (i > e.calculative.barRect.width)
    return;
  let s = Math.round(i / e.calculative.barRect.width * 100);
  s < e.min || s > e.max || s < 0 || s > 100 || (e.value = s, As(e), e.calculative.text = e.value + e.unit, qt(e), e.calculative.canvas.store.emitter.emit("valueUpdate", e), e.calculative.canvas.render());
}
function bu(e, t) {
  e.calculative.canvas.mouseDown && Ca(e, t);
}
function wu(e) {
  e.calculative.isUpdateData && (delete e.calculative.isUpdateData, Ye(e)), As(e);
}
function xu(e, t) {
  return e.calculative.isUpdateData = !1, (t.textWidth || t.barHeight) && (t.textWidth && (e._textWidth = 0), e.calculative.isUpdateData = !0), t;
}
function ku(e, t) {
  t.onMouseDown || (t.onMouseDown = Iu), t.options || (t.options = t.data);
  let i = t.calculative.worldRect.x, s = t.calculative.worldRect.y, o = t.calculative.worldRect.height;
  t.calculative.worldRect.width;
  const { fontStyle: a, fontWeight: r, fontSize: l, fontFamily: n, lineHeight: h } = t.calculative;
  let c = 2;
  e.beginPath(), e.moveTo(i, s), e.arcTo(i + o, s, i + o, s + o, c), e.arcTo(i + o, s + o, i, s + o, c), e.arcTo(i, s + o, i, s, c), e.arcTo(i, s, i + o, s, c), e.strokeStyle = "#d9d9d9", e.fillStyle = "#ffffff00", t.checked && (e.fillStyle = t.background || "#1890ff", e.strokeStyle = t.background || "#1890ff"), (t.isForbidden || t.disabled) && (e.fillStyle = t.disabledBackground || Tt(0.6, t.background) || "#ebebeb", e.strokeStyle = t.disabledColor || Tt(0.6, t.color) || "#d9d9d9"), e.closePath(), e.fill(), e.stroke(), e.save(), t.checked && (e.beginPath(), e.lineWidth = o / 10, e.strokeStyle = "#ffffff", e.moveTo(i + 102 / 506 * o, s + o / 2), e.lineTo(i + 220 / 506 * o, s + 346 / 460 * o), e.lineTo(i + 404 / 506 * o, s + 142 / 460 * o), e.stroke()), e.restore(), e.save(), e.fillStyle = t.disabled || t.isForbidden ? t.disabledTextColor || Tt(0.6, t.textColor || t.color) || "#00000040" : ce(t, t.calculative.canvas.parent.store) || "#000000d9", e.textAlign = "start", e.textBaseline = "middle", e.font = Dt({
    fontStyle: a,
    fontWeight: r,
    fontFamily: n || t.calculative.canvas.parent.store.options.fontFamily,
    fontSize: l,
    lineHeight: h
  }), e.fillText(t.value + "", i + o + 10, s + o / 2), e.restore();
}
function Iu(e, t) {
  e.isForbidden || (e.checked = !e.checked, e.calculative.canvas.store.emitter.emit("valueUpdate", e), e.calculative.canvas.render());
}
function Au(e, t) {
  t.options || (t.options = t.data), t.onAdd || (t.onAdd = Su, t.optionPos || (t.onAdd(t), t.calculative.canvas.parent.active([t])), t.onMouseDown = Tu, t.onValue = Cu);
  let i = t.calculative.worldRect.x, s = t.calculative.worldRect.y, o = t.calculative.worldRect.height, a = t.calculative.worldRect.width;
  if (!t.optionPos)
    return;
  const { fontStyle: r, fontWeight: l, fontSize: n, fontFamily: h, lineHeight: c } = t.calculative;
  if (t.direction == "horizontal")
    for (let d = 0; d < t.optionPos.length; d++) {
      const u = t.optionPos[d] * a / t.checkboxWidth, f = t.options[d].isForbidden || t.disabled;
      e.beginPath(), e.arc(i + u + o / 2, s + o / 2, o / 2, 0, Math.PI * 2), e.strokeStyle = "#d9d9d9", e.fillStyle = "#ffffff00", t.options[d].text === t.checked && (e.strokeStyle = t.options[d].background || t.background || "#1890ff"), f && (e.fillStyle = t.disabledBackground || Tt(0.6, t.background) || "#ebebeb", e.strokeStyle = t.disabledColor || Tt(0.6, t.color) || "#d9d9d9", t.options[d].text === t.checked && (e.fillStyle = "#ffffff00")), e.closePath(), e.fill(), e.stroke(), e.save(), t.options[d].text === t.checked && (e.beginPath(), e.strokeStyle = t.options[d].background ? t.options[d].background + "20" : t.background || "#1890ff20", f && (e.strokeStyle = t.disabledBackground || Tt(0.6, t.background) || "#ebebeb"), e.arc(i + o / 2 + u, s + o / 2, o / 2 + 1.5, 0, Math.PI * 2), e.stroke(), e.closePath(), e.beginPath(), e.fillStyle = t.options[d].background || t.background || "#1890ff", f && (e.fillStyle = t.disabledBackground || Tt(0.6, t.background) || "#ebebeb"), e.arc(i + o / 2 + u, s + o / 2, o / 4, 0, Math.PI * 2), e.fill(), e.closePath()), e.restore(), e.save(), e.fillStyle = f ? t.disabledTextColor || "#00000040" : ce(t, t.calculative.canvas.parent.store) || "#000000d9";
      const g = t.calculative.worldRect.height * 14 / 16;
      e.textAlign = "start", e.textBaseline = "middle", e.font = Dt({
        fontStyle: r,
        fontWeight: l,
        fontFamily: h || t.calculative.canvas.parent.store.options.fontFamily,
        fontSize: g,
        lineHeight: c
      }), e.fillText(
        t.options[d].text,
        i + o + u + 10 / t.checkboxWidth * a,
        s + o / 2
      ), e.restore();
    }
  else if (t.direction == "vertical") {
    const d = t.optionHeight * o / t.checkboxHeight;
    for (let u = 0; u < t.optionPos.length; u++) {
      const f = t.optionPos[u] * o / t.checkboxHeight, g = t.options[u].isForbidden;
      e.beginPath(), e.arc(
        i + d / 2,
        s + d / 2 + f,
        d / 2,
        0,
        Math.PI * 2
      ), e.strokeStyle = "#d9d9d9", e.fillStyle = "#ffffff00", t.options[u].text === t.checked && (e.strokeStyle = t.options[u].background || "#1890ff"), g && (e.fillStyle = "#ebebeb", e.strokeStyle = "#d9d9d9"), e.closePath(), e.fill(), e.stroke(), e.save(), !g && t.options[u].text === t.checked && (e.beginPath(), e.strokeStyle = t.options[u].background ? t.options[u].background + "20" : "#1890ff20", e.arc(
        i + d / 2,
        s + d / 2 + f,
        d / 2 + 1.5,
        0,
        Math.PI * 2
      ), e.stroke(), e.closePath(), e.beginPath(), e.fillStyle = t.options[u].background || "#1890ff", e.arc(
        i + d / 2,
        s + d / 2 + f,
        d / 4,
        0,
        Math.PI * 2
      ), e.fill(), e.closePath()), e.restore(), e.save(), e.fillStyle = g ? "#00000040" : ce(t, t.calculative.canvas.parent.store) || "#000000d9";
      const y = 14 * t.calculative.worldRect.height / t.checkboxHeight;
      e.textAlign = "start", e.textBaseline = "middle", e.font = Dt({
        fontStyle: r,
        fontWeight: l,
        fontFamily: h || t.calculative.canvas.parent.store.options.fontFamily,
        fontSize: y,
        lineHeight: c
      }), e.fillText(
        t.options[u].text,
        i + d + 10,
        s + d / 2 + f
      ), e.restore();
    }
  }
}
function Su(e) {
  xa(e);
}
function Tu(e, t) {
  if (e.direction == "horizontal")
    for (let i = 0; i < e.optionPos.length; i++)
      !e.options[i].isForbidden && t.x > e.calculative.worldRect.x + e.optionPos[i] * e.calculative.worldRect.width / e.checkboxWidth && t.x < e.calculative.worldRect.x + (e.optionPos[i] + e.height) / e.checkboxWidth * e.calculative.worldRect.width + wa(e.options[i].text, e) + 10 / e.checkboxWidth * e.calculative.worldRect.width && (e.checked = e.options[i].text, e.calculative.canvas.store.emitter.emit("valueUpdate", e));
  else if (e.direction == "vertical") {
    const i = e.calculative.worldRect.height / e.checkboxHeight;
    for (let s = 0; s < e.optionPos.length; s++)
      !e.options[s].isForbidden && t.y > e.calculative.worldRect.y + e.optionPos[s] * i && t.y < e.calculative.worldRect.y + (e.optionPos[s] + e.optionHeight) * i && (e.checked = e.options[s].text, e.calculative.canvas.store.emitter.emit("valueUpdate", e));
  }
  e.calculative.canvas.render();
}
function Cu(e) {
  xa(e);
}
function Ru() {
  return {
    radio: Au,
    switch: yu,
    slider: pu,
    checkbox: ku,
    table: ho,
    table2: ho
  };
}
const Pu = 15;
function ue(e, t = Pu) {
  let i = "" + e;
  return i.indexOf(".") >= 0 && (i = Number.parseFloat(i).toFixed(t)), Number.parseFloat(i);
}
function Vi(e) {
  return typeof e == "number" && Number.isFinite(e);
}
function Eu(e) {
  e = {
    max: null,
    min: null,
    splitNumber: 4,
    // splitNumber建议取4或者5等这种容易被整除的数字
    symmetrical: !1,
    deviation: !1,
    preferZero: !1,
    ...e
  };
  const t = [
    10,
    15,
    20,
    25,
    30,
    40,
    50,
    60,
    70,
    80,
    90,
    100,
    150
  ];
  let {
    max: i,
    min: s,
    splitNumber: o,
    symmetrical: a,
    deviation: r,
    preferZero: l
  } = e;
  if (!Vi(i) || !Vi(s) || i < s)
    return { splitNumber: o };
  if (i === s && i === 0)
    return {
      max: ue(t[0] * o),
      min: s,
      interval: t[0],
      splitNumber: o
    };
  i === s && (l = !0), (!Vi(o) || o <= 0) && (o = 4), l && i * s > 0 && (i < 0 ? i = 0 : s = 0);
  const n = (i - s) / o;
  let h = Math.floor(Math.log10(n) - 1);
  h = Math.pow(10, h);
  const c = n / h;
  let d = t[0] * h, u = -1, f;
  for (f = 0; f < t.length; f++)
    if (t[f] > c) {
      d = t[f] * h;
      break;
    }
  let g = i, y = s;
  function v(x) {
    if (g = parseInt("" + (i / x + 1)) * x, y = parseInt("" + (s / x - 1)) * x, i === 0 && (g = 0), s === 0 && (y = 0), a && g * y < 0) {
      const p = Math.max(Math.abs(g), Math.abs(y));
      g = p, y = -p;
    }
  }
  if (v(d), r)
    return {
      max: ue(g),
      min: ue(y),
      interval: ue(d),
      splitNumber: Math.round((g - y) / d)
    };
  if (!a || g * y > 0) {
    let x;
    t: do {
      if (x = Math.round((g - y) / d), (f - u) * (x - o) < 0) {
        for (; x < o; )
          if (y - s <= g - i && y !== 0 || g === 0 ? y -= d : g += d, x++, x === o) break t;
      }
      if (f >= t.length - 1 || f <= 0 || x === o)
        break;
      u = f, x > o ? d = t[++f] * h : d = t[--f] * h, v(d);
    } while (x !== o);
  }
  g = ue(g), y = ue(y);
  const b = ue((g - y) / o);
  return {
    max: g,
    min: y,
    interval: b,
    splitNumber: o
  };
}
function Ra(e, t) {
  var v, b, x, p, k, C, R, P, E, H, $, A, I, S, _, B, j, X, z, M, D, W, N, U, q, Y, Z, Q;
  const i = t.calculative.worldRect.x, s = t.calculative.worldRect.y, o = t.calculative.worldRect.width, a = t.calculative.worldRect.height;
  let r = t.calculative.canvas.store.data.scale, l = [];
  if (t.echarts)
    for (let J = 0; J < t.echarts.option.series.length; J++)
      l.push(t.echarts.option.series[J].data);
  else
    l = t.data;
  let n = [];
  for (let J = 0; J < l.length; J++)
    n = n.concat(l[J]);
  let h = {
    max: Math.max.apply(null, n),
    min: Math.min.apply(null, n),
    splitNumber: 5
  }, c = Eu(h), d = t.echarts ? t.echarts.option.xAxis.data.length : t.xAxisData.length;
  e.beginPath(), e.strokeStyle = "#BFBFBF", e.lineWidth = 6 * r, e.lineCap = "butt";
  let u = (o - 1 * (d + 1)) / d;
  e.setLineDash([1, u]), e.moveTo(i, s + a + 3 * r), e.lineTo(i + o, s + a + 3 * r), e.stroke(), e.closePath(), e.beginPath(), e.lineWidth = 1 * r, e.setLineDash([]), e.moveTo(i, s + a), e.lineTo(i + o, s + a), e.stroke(), e.closePath(), e.beginPath(), e.fillStyle = "#BFBFBF", e.strokeStyle = "#E9E9E9", e.setLineDash([2, 2]);
  let f = {
    fontStyle: ((b = (v = t.yAxis) == null ? void 0 : v.axisLabel) == null ? void 0 : b.fontStyle) || t.fontStyle,
    textDecoration: (p = (x = t.yAxis) == null ? void 0 : x.axisLabel) == null ? void 0 : p.textDecoration,
    fontWeight: ((C = (k = t.yAxis) == null ? void 0 : k.axisLabel) == null ? void 0 : C.fontWeight) || t.fontWeight,
    fontFamily: ((P = (R = t.yAxis) == null ? void 0 : R.axisLabel) == null ? void 0 : P.fontFamily) || t.fontFamily,
    fontSize: ((H = (E = t.yAxis) == null ? void 0 : E.axisLabel) == null ? void 0 : H.fontSize) || t.fontSize,
    lineHeight: ((A = ($ = t.yAxis) == null ? void 0 : $.axisLabel) == null ? void 0 : A.lineHeight) || t.lineHeight
  };
  e.fillStyle = ((S = (I = t.yAxis) == null ? void 0 : I.axisLabel) == null ? void 0 : S.fontColor) || t.color;
  for (let J = 0; J < c.splitNumber + 1; J++) {
    let m = J * a / c.splitNumber;
    e.textAlign = "right", e.textBaseline = "middle", e.font = Dt(f), e.fillText(
      c.max - J * c.interval + "",
      i - 10 * r,
      s + m
    ), e.fill(), J < c.splitNumber && (e.beginPath(), e.moveTo(i, s + m), e.lineTo(i + o, s + m), e.stroke());
  }
  e.closePath(), e.beginPath(), e.strokeStyle = "#BFBFBF";
  let g = t.echarts ? t.echarts.option.xAxis.data : t.xAxisData, y = 0;
  for (let J = 0; J < g.length; J++) {
    y = i + (1 + u / 2) + (u + 1) * J, e.textAlign = "center", e.textBaseline = "top";
    let m = {
      fontStyle: ((B = (_ = t.xAxis) == null ? void 0 : _.axisLabel) == null ? void 0 : B.fontStyle) || t.calculative.fontStyle,
      textDecoration: (X = (j = t.xAxis) == null ? void 0 : j.axisLabel) == null ? void 0 : X.textDecoration,
      fontWeight: ((M = (z = t.xAxis) == null ? void 0 : z.axisLabel) == null ? void 0 : M.fontWeight) || t.calculative.fontWeight,
      fontFamily: ((W = (D = t.xAxis) == null ? void 0 : D.axisLabel) == null ? void 0 : W.fontFamily) || t.calculative.fontFamily,
      fontSize: ((U = (N = t.xAxis) == null ? void 0 : N.axisLabel) == null ? void 0 : U.fontSize) || t.calculative.fontSize,
      lineHeight: ((Y = (q = t.xAxis) == null ? void 0 : q.axisLabel) == null ? void 0 : Y.lineHeight) || t.calculative.lineHeight
    };
    e.font = Dt(m), e.fillStyle = ((Q = (Z = t.xAxis) == null ? void 0 : Z.axisLabel) == null ? void 0 : Q.fontColor) || t.calculative.color, e.fillText(g[J], y, s + a + 10 * r), e.fill();
  }
  return e.closePath(), e.setLineDash([]), { dash: u, normalizedOption: c };
}
function _u(e, t) {
  if (!isNaN(e))
    return Math.round(Number(e) * 1e3) / 1e3;
}
var ei = /* @__PURE__ */ ((e) => (e[e.Add = 0] = "Add", e[e.Replace = 1] = "Replace", e[e.ReplaceAll = 2] = "ReplaceAll", e))(ei || {});
function Lu(e, t) {
  t.onBeforeValue || (t.onBeforeValue = Pa);
  const i = t.calculative.worldRect.x, s = t.calculative.worldRect.y;
  t.calculative.worldRect.width;
  const o = t.calculative.worldRect.height;
  let a = t.calculative.canvas.store.data.scale, r = [];
  t.echarts && !t.echarts.option.color && (t.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]);
  let l = Ra(e, t), n = l.dash, h = l.normalizedOption;
  const c = !!(t.echarts ? t.echarts.option.series[0].smooth : t.smooth);
  let d = [];
  if (t.echarts)
    for (let u = 0; u < t.echarts.option.series.length; u++)
      r.push(t.echarts.option.series[u].data);
  else
    r = t.data;
  for (let u = 0; u < r.length; u++) {
    e.beginPath();
    let f = r[u];
    e.strokeStyle = t.echarts ? t.echarts.option.color[u] : t.chartsColor[u], e.fillStyle = t.echarts ? t.echarts.option.color[u] : t.chartsColor[u];
    let g = i + (1 + n / 2), y = s + o - (f[0] - h.min) / (h.max - h.min) * o;
    if (e.moveTo(g, y), d.push({ x: g, y }), c)
      if (f.length <= 2)
        for (let v = 1; v < f.length; v++)
          g = i + (1 + n / 2) + (n + 1) * v, y = s + o - (f[v] - h.min) / (h.max - h.min) * o, e.lineTo(g, y), d.push({ x: g, y });
      else {
        let v, b, x, p;
        f.forEach((k, C) => {
          g = i + (1 + n / 2) + (n + 1) * C, y = s + o - (f[C] - h.min) / (h.max - h.min) * o;
          let R = i + (1 + n / 2) + (n + 1) * (C + 1), P = s + o - (f[C + 1] - h.min) / (h.max - h.min) * o, E = i + (1 + n / 2) + (n + 1) * (C - 1), H = s + o - (f[C - 1] - h.min) / (h.max - h.min) * o, $ = i + (1 + n / 2) + (n + 1) * (C + 2), A = s + o - (f[C + 2] - h.min) / (h.max - h.min) * o;
          C === 0 ? (E = i + (1 + n / 2) + (n + 1) * C, H = s + o - (f[C] - h.min) / (h.max - h.min) * o) : C === f.length - 2 && ($ = i + (1 + n / 2) + (n + 1) * (C + 1), A = s + o - (f[C + 1] - h.min) / (h.max - h.min) * o), d.push({ x: g, y }), v = g + (R - E) / 4, b = y + (P - H) / 4, x = R - ($ - g) / 4, p = P - (A - y) / 4, e.bezierCurveTo(v, b, x, p, R, P);
        });
      }
    else
      for (let v = 1; v < f.length; v++)
        g = i + (1 + n / 2) + (n + 1) * v, y = s + o - (f[v] - h.min) / (h.max - h.min) * o, e.lineTo(g, y), d.push({ x: g, y });
    e.stroke(), e.closePath(), e.save(), d.forEach((v, b) => {
      e.beginPath(), e.strokeStyle = "#fff", e.lineWidth = 2 * a, e.arc(v.x, v.y, 4 * a, 0, Math.PI * 2), e.stroke(), e.fill(), e.closePath();
    }), e.restore(), d = [];
  }
}
function Pa(e, t) {
  if (t.xAxisData || t.data || !t.dataX && !t.dataY)
    return t;
  const i = e.xAxisData, s = e.data, o = e.replaceMode;
  let a = [], r = [];
  return o ? o === ei.Replace ? (t.dataX.forEach((l, n) => {
    let h = i.indexOf(l);
    s.forEach((c, d) => {
      c[h] = t.dataY[d][n];
    });
  }), a = i, r = s) : o === ei.ReplaceAll && (a = t.dataX, r = t.dataY) : (a = [...i, ...t.dataX], s.forEach((l, n) => {
    let h = [...l, ...t.dataY[n]];
    r.push(h);
  })), delete t.dataX, delete t.dataY, Object.assign(t, { xAxisData: a, data: r });
}
function Mu(e, t) {
  var c, d;
  t.onBeforeValue || (t.onBeforeValue = Nu);
  let i = t.calculative.canvas.store.data.scale;
  const s = t.calculative.worldRect.x, o = t.calculative.worldRect.y, a = t.calculative.worldRect.width, r = t.calculative.worldRect.height, l = !!t.echarts;
  t.echarts ? (t.echarts.option.color || (t.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]), t.chartsColor = t.echarts.option.color) : t.chartsColor || (t.chartsColor = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]);
  const n = l ? t.echarts.option.series : t.data;
  let h = 0;
  for (let u = 0; u < n.length; u++) {
    let f = n[u], g = a / 2;
    r < a && (g = r / 2);
    const y = s + a / 2, v = o + r / 2;
    let b = 0;
    l ? b = f.data.reduce((P, E) => P + E.value, 0) : b = f.reduce((P, E) => P + E.value, 0);
    const x = g * parseFloat(l ? f.radius[0] : t.chartsRadius[u][0]) / 100, p = g * parseFloat(l ? f.radius[1] : t.chartsRadius[u][1]) / 100;
    if (x > p)
      return;
    let k = 0, C = 0;
    e.strokeStyle = l && ((c = f.itemStyle) == null ? void 0 : c.borderColor) || "#fff", e.lineWidth = (l && ((d = f.itemStyle) == null ? void 0 : d.borderWidth) || 2) * i;
    const R = l ? f.data : f;
    R.forEach((P, E) => {
      var B, j, X, z, M, D, W, N, U, q;
      C += Math.PI * 2 * P.value / b, e.beginPath();
      let H = h + E;
      H >= t.chartsColor.length && (H = H % t.chartsColor.length), e.fillStyle = l ? t.echarts.option.color[H] : t.chartsColor[H], e.moveTo(
        y + x * Math.sin(C),
        v - x * Math.cos(C)
      ), e.arc(
        y,
        v,
        x,
        -Math.PI / 2 + C,
        -Math.PI / 2 + k,
        !0
      ), e.lineTo(
        y + p * Math.sin(k),
        v - p * Math.cos(k)
      ), e.arc(
        y,
        v,
        p,
        -Math.PI / 2 + k,
        -Math.PI / 2 + C
      ), e.lineTo(
        y + x * Math.sin(C),
        v - x * Math.cos(C)
      ), e.stroke(), e.fill(), e.closePath();
      let $ = (k + C) / 2, A = y + (p + 10 * i) * Math.sin($), I = v - (p + 10 * i) * Math.cos($), S = e.fillStyle;
      f.label || (f.label = { position: "outside", show: !0 }), l && ["inner", "inside"].includes(f.label.position) ? (e.fillStyle = "#ffffff", A = y + (p - x) / 2 * Math.sin($), I = v - (p - x) / 2 * Math.cos($)) : l && f.label.position == "outside", f.labelLine || (f.labelLine = { show: !0 }), (l && f.labelLine.show !== !1 || !l) && (e.beginPath(), e.strokeStyle = l ? t.echarts.option.color[h + E] : t.chartsColor[h + E], e.moveTo(
        y + p * Math.sin($),
        v - p * Math.cos($)
      ), e.lineTo(A, I));
      let _ = {
        fontStyle: ((B = t.tickLabel) == null ? void 0 : B.fontStyle) || t.calculative.fontStyle,
        fontWeight: ((j = t.tickLabel) == null ? void 0 : j.fontWeight) || t.calculative.fontWeight,
        fontFamily: ((X = t.tickLabel) == null ? void 0 : X.fontFamily) || t.calculative.fontFamily,
        lineHeight: ((z = t.tickLabel) == null ? void 0 : z.lineHeight) || t.calculative.lineHeight,
        fontSize: (((M = t.tickLabel) == null ? void 0 : M.fontSize) || t.calculative.fontSize) * i
      };
      e.font = Dt(_), e.textBaseline = "middle", e.textAlign = "center", $ > Math.PI ? ((l && f.label.position === "outside" || !l) && (e.textAlign = "end"), (l && f.labelLine.show !== !1 || !l && (((W = (D = t.tickLabel) == null ? void 0 : D.labelLine) == null ? void 0 : W.show) ?? !0)) && e.lineTo(A - 5 * i, I), (l && f.label.show !== !1 || !l && (((N = t.tickLabel) == null ? void 0 : N.show) ?? !0)) && e.fillText(P.name, A - 5 * i, I)) : ((l && f.label.position === "outside" || !l) && (e.textAlign = "start"), (l && f.labelLine.show !== !1 || !l) && e.lineTo(A + 5 * i, I), (l && f.label.show !== !1 || !l && (((U = t.tickLabel) == null ? void 0 : U.show) ?? !0)) && e.fillText(P.name, A + 5 * i, I)), e.stroke(), e.closePath(), e.fillStyle = S, e.strokeStyle = l && ((q = f.itemStyle) == null ? void 0 : q.borderColor) || "#fff", k = C;
    }), h += R.length;
  }
}
function Nu(e, t) {
  if (t.data || !t.dataX && !t.dataY)
    return t;
  const i = e.data, s = e.replaceMode;
  let o = [];
  return s ? s === ei.Replace ? (t.dataY.forEach((a, r) => {
    a.forEach((l, n) => {
      let h = i[r].filter(
        (c) => c.name === l.name
      );
      h.length > 0 && (h[0].value = l.value);
    });
  }), o = i) : s === ei.ReplaceAll && (o = t.dataY) : i.forEach((a, r) => {
    let l = [...a, ...t.dataY[r]];
    o.push(l);
  }), delete t.dataX, delete t.dataY, Object.assign(t, { data: o });
}
function Ou(e, t) {
  t.onBeforeValue || (t.onBeforeValue = Pa);
  let i = t.calculative.canvas.store.data.scale;
  const s = t.calculative.worldRect.x, o = t.calculative.worldRect.y;
  t.calculative.worldRect.width;
  const a = t.calculative.worldRect.height;
  let r = [];
  if (t.echarts && !t.echarts.option.color && (t.echarts.option.color = [
    "#1890ff",
    "#2FC25B",
    "#FACC14",
    "#c23531",
    "#2f4554",
    "#61a0a8",
    "#d48265"
  ]), t.echarts)
    for (let d = 0; d < t.echarts.option.series.length; d++)
      r.push(t.echarts.option.series[d].data);
  else
    r = t.data;
  let l = Ra(e, t), n = l.dash, h = l.normalizedOption, c = n * 4 / 5 / r.length;
  for (let d = 0; d < r.length; d++) {
    e.beginPath();
    let u = r[d];
    e.fillStyle = t.echarts ? t.echarts.option.color[d] : t.chartsColor[d], e.strokeStyle = "#ffffff", e.lineWidth = 1 * i;
    let f = 0, g = 0, y = 0;
    for (let v = 0; v < u.length; v++)
      f = s + (1 + 0.1 * n) + (n + 1) * v + c * d, y = (u[v] - h.min) / (h.max - h.min) * a, g = o + a - y, e.rect(f, g, c - 1, y - 1), e.stroke(), e.fill();
    e.closePath();
  }
}
function Du(e, t) {
  var z, M, D, W, N, U, q, Y, Z, Q, J, m, w, T;
  t.onAdd || (t.onAdd = Bu, t.onDestroy = zu, t.onClick = Hu, t.clockInterval && (t.onDestroy(t), t.onAdd(t)));
  const i = t.calculative.worldRect.x, s = t.calculative.worldRect.y, o = t.calculative.worldRect.width, a = t.calculative.worldRect.height;
  let r = t.calculative.canvas.store.data.scale, l = {
    startAngle: 225,
    endAngle: -45,
    min: 0,
    max: 100,
    splitNumber: 10
  };
  if (t.echarts && t.echarts.option) {
    let L = t.echarts.option.series[0];
    t.startAngle = L.startAngle || l.startAngle, t.endAngle = L.endAngle || l.endAngle, t.min = L.min || l.min, t.max = L.max || l.max, t.axisLine = L.axisLine.lineStyle.color, t.unit = L.detail.formatter.replace("{value}", ""), t.value = L.data[0].value, t.splitNumber = L.splitNumber || l.splitNumber;
  }
  t = { ...l, ...t };
  let n = o > a ? a / 2 * 9 / 10 : o / 2 * 9 / 10, h = i + o / 2, c = s + a / 2, d = t.echarts ? t.echarts.option.series[0].data[0].value : t.value, u, f = t.startAngle - t.endAngle, g = t.background || "#E6EBF8";
  e.strokeStyle = g;
  let y = n / 10;
  e.lineWidth = y, e.beginPath(), e.lineCap = "round", e.arc(
    h,
    c,
    n,
    -t.startAngle / 180 * Math.PI,
    -t.endAngle / 180 * Math.PI
  ), e.stroke(), e.closePath();
  let v = 0;
  if (t.axisLine && !t.isClock)
    for (let L = t.axisLine.length - 1; L >= 0; L--)
      t.axisLine[L][0] * (t.max - t.min) < d ? v = t.axisLine[L][0] : (v = (d - t.min) / (t.max - t.min), u = t.axisLine[L][1]), e.beginPath(), e.strokeStyle = t.axisLine[L][1], e.arc(
        h,
        c,
        n,
        -t.startAngle / 180 * Math.PI,
        (-t.startAngle + v * f) / 180 * Math.PI
      ), e.stroke(), e.closePath();
  e.lineCap = "butt";
  let b = 2 * r, x = n - y;
  x < 0 && (x = 0);
  let p = f / 180 * Math.PI * x, k = (p - b * t.splitNumber) / t.splitNumber, C = f / 180 * Math.PI * b / 2 / p;
  e.beginPath(), e.strokeStyle = t.color || "#999999", e.lineWidth = n / 20, e.setLineDash([b, k]), e.arc(
    h,
    c,
    x,
    -t.startAngle / 180 * Math.PI - C,
    -t.endAngle / 180 * Math.PI + C
  ), e.stroke(), e.closePath();
  let R = 1 * r, P = n - y;
  P < 0 && (P = 0);
  let E = f / 180 * Math.PI * P, H = (E - R * 5 * t.splitNumber) / 5 / t.splitNumber, $ = f / 180 * Math.PI * R / 2 / E;
  e.beginPath(), e.strokeStyle = t.color || "#999999", e.lineWidth = n / 40, e.setLineDash([R, H]), e.arc(
    h,
    c,
    P,
    -t.startAngle / 180 * Math.PI - $,
    -t.endAngle / 180 * Math.PI + $
  ), e.stroke(), e.closePath(), e.beginPath();
  let A = t.max - t.min, I = A / t.splitNumber, S = {
    fontStyle: ((z = t.tickLabel) == null ? void 0 : z.fontStyle) || t.calculative.fontStyle,
    textDecoration: ((M = t.tickLabel) == null ? void 0 : M.textDecoration) || t.textDecoration,
    fontWeight: ((D = t.tickLabel) == null ? void 0 : D.fontWeight) || t.calculative.fontWeight,
    fontFamily: ((W = t.tickLabel) == null ? void 0 : W.fontFamily) || t.calculative.fontFamily,
    fontSize: (((N = t.tickLabel) == null ? void 0 : N.fontSize) || t.calculative.fontSize) * r,
    lineHeight: ((U = t.tickLabel) == null ? void 0 : U.lineHeight) || t.calculative.lineHeight
  };
  e.font = Dt(S);
  let _ = n - y - n / 20;
  for (let L = 0; L <= t.splitNumber; L++) {
    if (Math.abs(t.startAngle) + Math.abs(t.endAngle) === 360 && L == 0)
      continue;
    let F = t.startAngle - I * L / A * f, V = Math.cos(F / 180 * Math.PI), K = Math.sin(F / 180 * Math.PI);
    e.fillStyle = ((q = t.tickLabel) == null ? void 0 : q.color) || "#999999", V > 0.02 ? e.textAlign = "end" : V < -0.02 ? e.textAlign = "start" : e.textAlign = "center", K > 0.02 ? e.textBaseline = "top" : K < -0.02 ? e.textBaseline = "bottom" : e.textBaseline = "middle", e.fillText(
      _u(I * L + t.min),
      h + _ * V,
      c - _ * K
    ), e.fill();
  }
  e.closePath();
  let B = 1, j = ["value"];
  if (t.isClock && (B = 3, j = ["hourvalue", "minutevalue", "secondvalue"]), t.isClock)
    for (let L = 0; L < B; L++) {
      let F = (t.startAngle - (t[j[L]] - t.min) / (t.max - t.min) * f) / 180 * Math.PI;
      L > 0 && (F = (t.startAngle - (t[j[L]] - t.min) / (t.max * 5 - t.min) * f) / 180 * Math.PI);
      let V = 4 / 5 * n;
      j[L] === "hourvalue" && (V = 3 / 5 * n), j[L] === "minutevalue" && (V = 3.5 / 5 * n);
      let K = n * 1 / 40;
      e.beginPath(), e.setLineDash([]), e.lineWidth = n / (L + 1) / 20, e.strokeStyle = t.color || "#999999", e.moveTo(
        h - K * 3 * Math.cos(F),
        c + K * 3 * Math.sin(F)
      ), e.lineTo(
        h + V * Math.cos(F),
        c - V * Math.sin(F)
      ), e.stroke();
    }
  else {
    let L = (t.startAngle - (d - t.min) / (t.max - t.min) * f) / 180 * Math.PI, F = 4 / 5 * n, V = n * 1 / 40;
    e.beginPath(), e.setLineDash([]), e.lineWidth = 2, e.fillStyle = u, e.moveTo(
      h - V * 3 * Math.cos(L),
      c + V * 3 * Math.sin(L)
    ), e.lineTo(
      h + V * Math.cos(L - Math.PI / 2),
      c - V * Math.sin(L - Math.PI / 2)
    ), e.lineTo(
      h + F * Math.cos(L),
      c - F * Math.sin(L)
    ), e.lineTo(
      h + V * Math.cos(L + Math.PI / 2),
      c - V * Math.sin(L + Math.PI / 2)
    ), e.lineTo(
      h - V * 3 * Math.cos(L),
      c + V * 3 * Math.sin(L)
    ), e.fill();
  }
  e.beginPath(), e.textAlign = "center", e.textBaseline = "middle";
  let X = {
    fontStyle: ((Y = t.titleLabel) == null ? void 0 : Y.fontStyle) || t.calculative.fontStyle,
    textDecoration: ((Z = t.titleLabel) == null ? void 0 : Z.textDecoration) || t.textDecoration,
    fontWeight: ((Q = t.titleLabel) == null ? void 0 : Q.fontWeight) || t.calculative.fontWeight,
    fontFamily: ((J = t.titleLabel) == null ? void 0 : J.fontFamily) || t.calculative.fontFamily,
    fontSize: (((m = t.titleLabel) == null ? void 0 : m.fontSize) || t.calculative.fontSize) * r,
    lineHeight: ((w = t.titleLabel) == null ? void 0 : w.lineHeight) || t.calculative.lineHeight
  };
  e.font = Dt(X), e.fillStyle = ((T = t.titleLabel) == null ? void 0 : T.color) || u, t.isClock ? e.fillText(
    ("0" + parseInt(t.hourvalue)).slice(-2) + ":" + ("0" + parseInt(t.minutevalue)).slice(-2) + ":" + ("0" + parseInt(t.secondvalue)).slice(-2),
    h,
    c + n / 2
  ) : e.fillText(d + " " + (t.unit || ""), h, c + n / 2), e.fill(), t.isClock && (e.beginPath(), e.fillStyle = t.color || "#999999", e.strokeStyle = "#ffffff", e.arc(h, c, n / 20, 0, Math.PI * 2), e.stroke(), e.fill(), e.closePath());
}
function Bu(e) {
  if (e.isClock)
    e.clockInterval = setInterval(() => {
      let t = /* @__PURE__ */ new Date(), i = t.getSeconds(), s = t.getMinutes() + i / 60, o = t.getHours() % 12 + s / 60;
      e.calculative.canvas.parent.setValue(
        {
          id: e.id,
          hourvalue: o,
          minutevalue: s,
          secondvalue: i
        },
        {
          render: !0,
          doEvent: !1
        }
      );
    }, 1e3);
  else {
    const t = e.value;
    e.value = 0, e.frames = [
      {
        duration: 2e3,
        value: t
      }
    ], e.calculative.canvas.parent.startAnimate(e.id), setTimeout(() => {
      e.value = t;
    }, 1e3);
  }
}
function zu(e) {
  e.clockInterval && (clearInterval(e.clockInterval), e.clockInterval = void 0);
}
function Hu(e) {
  e.isClock && (e.onDestroy(e), e.onAdd(e));
}
function Fu() {
  return {
    lineChart: Lu,
    histogram: Ou,
    pieChart: Mu,
    gauge: Du
  };
}
function Wu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 6, n = a / 4;
  if (i.moveTo(s + n * 2, o + 0), i.lineTo(s + n * 2, o + l), i.moveTo(s, o + l + n * 2), i.arc(
    s + n * 2,
    o + l + n * 2,
    n * 2,
    Math.PI * 1,
    Math.PI * 2,
    !1
  ), i.lineTo(s + n * 4, o + l * 5), i.lineTo(s, o + l * 5), i.lineTo(s, o + l + n * 2), i.moveTo(s + n, o + l * 5), i.lineTo(s + n, o + l * 6), i.moveTo(s + n * 2, o + l * 5), i.lineTo(s + n * 2, o + l * 6), i.moveTo(s + n * 3, o + l * 5), i.lineTo(s + n * 3, o + l * 6), i.closePath(), i instanceof Path2D) return i;
}
function uo(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.25,
      y: 1
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.75,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function ju(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r - a, n = 0.5 * a;
  if (i.moveTo(s + a / 2, o), i.lineTo(s + a / 2, o + l), i.moveTo(s + a, o + n + l), i.arc(s + a / 2, o + n + l, n, 0, Math.PI * 2, !1), i.closePath(), i instanceof Path2D) return i;
}
function fo(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function Vu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 2, n = a / 5;
  if (i.moveTo(s, o + l), i.lineTo(s + n, o + l), i.moveTo(s + n * 5, o + l), i.ellipse(s + n * 3, o + l, 2 * n, l, 0, 0, Math.PI * 2), i.closePath(), i instanceof Path2D) return i;
}
function Uu(e) {
  const t = [
    {
      x: 0.6,
      y: 0
    },
    { x: 1, y: 0.5 },
    { x: 0.6, y: 1 },
    { x: 0, y: 0.5 }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function qu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 4, n = 0.5 * a;
  if (i.moveTo(s + n, o), i.lineTo(s + n, o + l), i.moveTo(s, o + l), i.rect(s, o + l, n * 2, l * 2), i.moveTo(s + n, o + 3 * l), i.lineTo(s + n, o + 4 * l), i.closePath(), i instanceof Path2D) return i;
}
function Yu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 8, n = 0.25 * a;
  if (i.moveTo(s + n * 2, o), i.lineTo(s + n * 2, o + l * 2), i.lineTo(s + n * 3, o + l * 3), i.lineTo(s + n * 3, o + l * 5), i.lineTo(s + n * 2, o + l * 6), i.lineTo(s + n * 1, o + l * 5), i.lineTo(s + n * 1, o + l * 3), i.lineTo(s + n * 2, o + l * 2), i.moveTo(s + n * 3, o + l * 4), i.lineTo(s + n * 4, o + l * 4), i.moveTo(s + n * 2, o + l * 6), i.lineTo(s + n * 2, o + l * 8), i.closePath(), i instanceof Path2D) return i;
}
function $u(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.5
    },
    {
      x: 0.5,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function Xu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = a / 2, n = r / 10;
  if (i.moveTo(s + l, o), i.lineTo(s + l, o + n), i.moveTo(s + l, o + n), i.quadraticCurveTo(s + l * 2, o + n, s + l * 2, o + n * 9), i.moveTo(s + l, o + n), i.quadraticCurveTo(s, o + n, s, o + n * 9), i.quadraticCurveTo(s + l, o + n * 6, s + l * 2, o + n * 9), i.moveTo(s + l, o + r * 3 / 4), i.lineTo(s + l, o + r), i.moveTo(s + l * 2 / 5, o + r * 201 / 250), i.lineTo(s + l * 2 / 5, o + r), i.moveTo(s + l * 8 / 5, o + r * 201 / 250), i.lineTo(s + l * 8 / 5, o + r), i.closePath(), i instanceof Path2D) return i;
}
function go(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0.8,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function Ku(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 6, n = a / 4;
  if (i.moveTo(s + n * 2, o + 0), i.lineTo(s + n * 2, o + l), i.moveTo(s, o + l + n * 2), i.arc(
    s + n * 2,
    o + l + n * 2,
    n * 2,
    Math.PI * 1,
    Math.PI * 2,
    !1
  ), i.lineTo(s + n * 4, o + l * 5), i.lineTo(s, o + l * 5), i.lineTo(s, o + l + n * 2), i.moveTo(s, o + l * 5 - l / 3), i.lineTo(s + n * 4, o + l * 5 - l / 3), i.moveTo(s + n, o + l * 5), i.lineTo(s + n, o + l * 6), i.moveTo(s + n * 2, o + l * 5), i.lineTo(s + n * 2, o + l * 6), i.moveTo(s + n * 3, o + l * 5), i.lineTo(s + n * 3, o + l * 6), i.closePath(), i instanceof Path2D) return i;
}
function Gu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 4, n = 0.5 * a;
  if (i.moveTo(s + n, o), i.lineTo(s + n, o + l), i.lineTo(s + n * 2, o + l * 2), i.lineTo(s + n * 2, o + l * 4), i.lineTo(s, o + l * 4), i.lineTo(s, o + l * 2), i.lineTo(s + n, o + l), i.closePath(), i instanceof Path2D) return i;
}
function Ju(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 4, n = a / 2;
  if (i.moveTo(s + n, o), i.lineTo(s + n, o + l), i.lineTo(s + n * 2, o + l * 4), i.lineTo(s, o + l * 4), i.lineTo(s + n, o + l), i.closePath(), i instanceof Path2D) return i;
}
function Qu(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect, l = r / 3, n = 0.5 * a;
  if (i.moveTo(s + n, o), i.lineTo(s + n, o + l), i.lineTo(s + a, o + 2 * l), i.lineTo(s + n, o + r), i.lineTo(s, o + 2 * l), i.lineTo(s + n, o + l), i.closePath(), i instanceof Path2D) return i;
}
function Zu(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 1,
      y: 0.6666666666666666
    },
    {
      x: 0.5,
      y: 1
    },
    {
      x: 0,
      y: 0.6666666666666666
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function tf(e, t) {
  const i = t || new Path2D(), { x: s, y: o, width: a, height: r } = e.calculative.worldRect;
  let l = a / 2, n = r / 10;
  if (i.moveTo(s + l, o), i.lineTo(s + l, o + n), i.moveTo(s + l, o + n), i.quadraticCurveTo(s + l * 2, o + n, s + l * 2, o + n * 9), i.moveTo(s + l, o + n), i.quadraticCurveTo(s, o + n, s, o + n * 9), i.quadraticCurveTo(s + l, o + n * 6, s + l * 2, o + n * 9), i.moveTo(s, o + n * 10), i.quadraticCurveTo(s + l, o + n * 7, s + l * 2, o + n * 10), i.moveTo(s + l * 2 / 5, o + r * 201 / 250 + n), i.lineTo(s + l * 2 / 5, o + r), i.moveTo(s + l * 8 / 5, o + r * 201 / 250 + n), i.lineTo(s + l * 8 / 5, o + r), i.closePath(), i instanceof Path2D) return i;
}
function ef(e) {
  const t = [
    {
      x: 0.5,
      y: 0
    },
    {
      x: 0.2,
      y: 1
    },
    {
      x: 0.8,
      y: 1
    }
  ];
  e.anchors = t.map(({ x: i, y: s }, o) => ({
    id: `${o}`,
    penId: e.id,
    x: i,
    y: s
  }));
}
function sf(e, t) {
  const { x: i, y: s, width: o, height: a } = t.calculative.worldRect, r = o / 2, l = a / 10;
  e.beginPath(), e.moveTo(i + r, s), e.lineTo(i + r, s + l), e.moveTo(i + r, s + l), e.quadraticCurveTo(i + r * 2, s + l, i + r * 2, s + l * 9), e.moveTo(i + r, s + l), e.quadraticCurveTo(i, s + l, i, s + l * 9), e.quadraticCurveTo(i + r, s + l * 6, i + r * 2, s + l * 9), e.moveTo(i + r, s + a * 3 / 4), e.lineTo(i + r, s + a * 9 / 10), e.moveTo(i + r * 2 / 5, s + a * 201 / 250), e.lineTo(i + r * 2 / 5, s + a * 9 / 10), e.moveTo(i + r * 8 / 5, s + a * 201 / 250), e.lineTo(i + r * 8 / 5, s + a * 9 / 10), e.stroke(), e.closePath(), e.beginPath();
  const n = r * 2 > l * 10 ? l : r / 5;
  e.fillStyle = "#333333", e.font = n + "px Arial", e.textBaseline = "bottom", e.textAlign = "center", e.fillText("o", i + r, s + a), e.fillText("m", i + r * 2 / 5, s + a), e.fillText("o", i + r * 8 / 5, s + a), e.closePath();
}
function of() {
  return {
    andGate: Wu,
    basicEvent: ju,
    conditionalEvent: Vu,
    event: qu,
    forbiddenGate: Yu,
    orGate: Xu,
    priorityAndGate: Ku,
    switchEvent: Gu,
    transferSymbol: Ju,
    unexpandedEvent: Qu,
    xorGate: tf
  };
}
function af() {
  return {
    votingGate: sf
  };
}
function rf() {
  return {
    andGate: uo,
    orGate: go,
    priorityAndGate: uo,
    votingGate: go,
    xorGate: ef,
    forbiddenGate: $u,
    basicEvent: fo,
    unexpandedEvent: Zu,
    conditionalEvent: Uu,
    transferSymbol: fo
  };
}
var nf = /* @__PURE__ */ ((e) => (e[e.File = 0] = "File", e[e.Pen = 1] = "Pen", e[e.Pens = 2] = "Pens", e))(nf || {});
const fe = yo({
  // 选中对象类型：0 - 画布；1 - 单个图元
  mode: 0,
  pen: void 0
}), Ea = () => ({
  selections: fe,
  select: (t) => {
    if (!t || t.length < 1) {
      fe.mode = 0, fe.pen = void 0;
      return;
    }
    if (console.log("select pens: ", t), t.length === 1) {
      fe.mode = 1, fe.pen = t[0];
      return;
    }
    fe.mode = 2, fe.pens = [...t];
  }
}), lf = /* @__PURE__ */ mo({
  __name: "ContextMenu",
  props: {
    x: {
      type: Number,
      default: 0
    },
    y: {
      type: Number,
      default: 0
    },
    visible: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["hide"],
  setup(e, { emit: t }) {
    const i = e, s = Na(() => ({
      left: i.x + "px",
      top: i.y + "px"
    })), o = t, { selections: a } = Ea(), { saveComponentShow: r } = ld(!0), l = [
      {
        label: "锁定",
        icon: "lock",
        action: () => {
          if (console.log("lock", a), a.pen) {
            const n = { id: a.pen.id, locked: 2 };
            meta2d.setValue(n, { render: !0 });
          } else a.pens && a.pens.forEach((n) => {
            const h = { id: n.id, locked: 2 };
            meta2d.setValue(h, { render: !0 });
          });
          o("hide", !1);
        },
        show: () => {
          if (a.pen)
            return !a.pen.locked;
          if (a.pens)
            return !a.pens.some((n) => n.locked > 0);
        }
      },
      {
        label: "解锁",
        icon: "lock",
        action: () => {
          if (console.log("unlock", a), a.pen) {
            const n = { id: a.pen.id, locked: 0 };
            meta2d.setValue(n, { render: !0 });
          } else a.pens && a.pens.forEach((n) => {
            const h = { id: n.id, locked: 0 };
            meta2d.setValue(h, { render: !0 });
          });
          o("hide", !1);
        },
        show: () => {
          if (a.pen)
            return a.pen.locked;
          if (a.pens)
            return a.pens.some((n) => n.locked > 0);
        }
      },
      {
        label: "删除",
        icon: "delete",
        action: () => {
          a.pen ? meta2d.delete([a.pen]) : a.pens && meta2d.delete(a.pens), o("hide", !1);
        }
      },
      // 组合
      {
        label: "组合为状态",
        icon: "group",
        action: () => {
          console.log("group", a), a.pens && meta2d.combine(a.pens, 0), o("hide", !1);
        },
        show: () => a.mode == 2
      },
      // 取消组合
      {
        label: "取消组合",
        icon: "group",
        action: () => {
          console.log("ungroup", a), meta2d.uncombine(a.pen), o("hide", !1);
        },
        show: () => {
          var n;
          return a.mode == 1 && ((n = a.pen) == null ? void 0 : n.name) == "combine";
        }
      },
      {
        label: "保存为组件",
        icon: "save",
        action: () => {
          r(a), o("hide", !1);
        }
      }
    ];
    return (n, h) => {
      const c = oi("t-button"), d = oi("t-list-item"), u = oi("t-list"), f = oi("t-card");
      return Ss((qi(), Oa(f, {
        bordered: "",
        hoverShadow: "",
        class: "context-menu",
        style: Da(s.value)
      }, {
        default: ai(() => [
          yi(u, null, {
            default: ai(() => [
              (qi(), po(bo, null, Ba(l, (g) => Ss(yi(d, null, {
                default: ai(() => [
                  yi(c, {
                    theme: "default",
                    block: "",
                    variant: "outline",
                    onClick: (y) => g.action()
                  }, {
                    default: ai(() => [
                      za(Ha(g.label), 1)
                    ]),
                    _: 2
                  }, 1032, ["onClick"])
                ]),
                _: 2
              }, 1536), [
                [Ts, g.show ? g.show() : !0]
              ])), 64))
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["style"])), [
        [Ts, e.visible]
      ]);
    };
  }
}), cf = /* @__PURE__ */ ba(lf, [["__scopeId", "data-v-7b70639e"]]);
var re = /* @__PURE__ */ ((e) => (e[e.MSG_FAMILY_SUBSCRIBE = 1] = "MSG_FAMILY_SUBSCRIBE", e[e.MSG_FAMILY_UNSUBSCRIBE = 2] = "MSG_FAMILY_UNSUBSCRIBE", e[e.MSG_FAMILY_TRANSMIT = 3] = "MSG_FAMILY_TRANSMIT", e[e.MSG_FAMILY_HEARTBEAT = 4] = "MSG_FAMILY_HEARTBEAT", e[e.MSG_FAMILY_HEARTBEAT_FEEDBACK = 5] = "MSG_FAMILY_HEARTBEAT_FEEDBACK", e[e.MSG_FAMILY_REGISTER = 6] = "MSG_FAMILY_REGISTER", e))(re || {});
function vo(e, t, i) {
  return {
    interMsgType: e,
    data: {
      busName: t,
      msgTypes: i
    }
  };
}
const pe = class pe {
  constructor(t, i = {}) {
    O(this, "ws", null);
    O(this, "url");
    O(this, "messageHandlers", /* @__PURE__ */ new Map());
    O(this, "cache", /* @__PURE__ */ new Map());
    // 消息缓存
    O(this, "heartbeatInterval");
    O(this, "heartbeatTimer", null);
    // 客户端主动发送心跳
    O(this, "enableHeartbeat", !1);
    O(this, "reconnectTimer", null);
    O(this, "isConnected", !1);
    // 最大重连次数
    O(this, "maxReconnectTimes", 30);
    // 重连间隔
    O(this, "reconnectInterval", 3e3);
    O(this, "wsOptions", null);
    O(this, "enableLog", !0);
    O(this, "_subscribeTasks", []);
    const { heartbeatInterval: s = 3e4 } = i;
    this.url = t, this.heartbeatInterval = s, this.maxReconnectTimes = i.maxReconnectTimes || 30, this.reconnectInterval = i.reconnectInterval || 3e3, this.wsOptions = i, this.enableLog = i.enableLog, this.enableHeartbeat = i.enableHeartbeat;
  }
  // 获取 WebSocketClient 单例实例
  static getInstance(t, i) {
    !t.startsWith("ws://") && !t.startsWith("wss://") && (t = "ws://" + t), console.log("getInstance: ", t, i);
    let s = pe.InstanceMap.get(t);
    return s ? console.log("Using existing WebSocketClient instance.") : (s = new pe(t, i), pe.InstanceMap.set(t, s)), s.connect(), s;
  }
  // 1. 初始化 WebSocket 连接并处理事件
  connect() {
    if (!this.url) {
      console.error("ws url is required");
      return;
    }
    if (this.isConnected) {
      this.wsOptions.onReady && this.wsOptions.onReady();
      return;
    }
    this.ws ? this.ws.readyState === WebSocket.OPEN ? this.wsOptions.onReady && this.wsOptions.onReady() : (console.error("连接已断开：", this.url), this.ws = new WebSocket(this.url), this.ws.onopen = () => {
      this.isConnected = !0, this.register(), this.startHeartbeat(), this.subscribe(this.wsOptions.busName, this.wsOptions.msgTypes), console.log("========= WebSocket connection established. ========="), this._subscribeTasks.forEach((t) => {
        t();
      }), this._subscribeTasks = [], this.wsOptions.onReady && this.wsOptions.onReady();
    }, this.ws.onmessage = (t) => {
      this.handleMessage(t.data);
    }, this.ws.onclose = () => {
      this.isConnected = !1, this.stopHeartbeat(), this.reconnect(), console.log("WebSocket connection closed.");
    }, this.ws.onerror = (t) => {
      console.error("WebSocket error:", t), this.isConnected = !1, this.stopHeartbeat(), this.reconnect();
    }) : (this.ws = new WebSocket(this.url), this.ws.onopen = () => {
      this.isConnected = !0, this.register(), this.startHeartbeat(), this.subscribe(this.wsOptions.busName, this.wsOptions.msgTypes), console.log("========= WebSocket connection established. ========="), this._subscribeTasks.forEach((t) => {
        t();
      }), this._subscribeTasks = [], this.wsOptions.onReady && this.wsOptions.onReady();
    }, this.ws.onmessage = (t) => {
      this.handleMessage(t.data);
    }, this.ws.onclose = () => {
      this.isConnected = !1, this.stopHeartbeat(), this.reconnect(), console.log("WebSocket connection closed.");
    }, this.ws.onerror = (t) => {
      console.error("WebSocket error:", t), this.isConnected = !1, this.stopHeartbeat(), this.reconnect();
    });
  }
  /**
   * @description websocket通信建立后，应立刻发送此消息进行注册
   * @param appName 应用名称
   */
  register(t) {
    const i = {
      interMsgType: re.MSG_FAMILY_REGISTER,
      data: {
        name: t || this.wsOptions.appName || "WebSocket Client"
      }
    };
    this.ws.send(JSON.stringify(i));
  }
  /**
   * @description TODO
   * @param appName
   */
  unRegister(t) {
  }
  // 2. 处理 WebSocket 消息
  handleMessage(t) {
    const i = JSON.parse(t);
    this.enableLog && console.log("Received message:", i);
    const { interMsgType: s, data: o } = i;
    if (s === re.MSG_FAMILY_HEARTBEAT) {
      const l = {
        interMsgType: re.MSG_FAMILY_HEARTBEAT_FEEDBACK,
        data: o
      };
      this.ws.send(JSON.stringify(l));
      return;
    }
    const a = o == null ? void 0 : o.busName;
    a && this.cache.set(a, o), (this.messageHandlers.get(a) || []).forEach((l) => l && l(o));
  }
  /**
   * @description 客户端如果需要收到消息，需先订阅消息，订阅后BusServer会将对应的消息转发给对应的连接
   *  当websocket通信断开了，当重新连接成功后，SDK中应再重新自动发送订阅消息。
   * @param busName
   * @param msgTypes
   * @param callback
   */
  subscribe(t, i, s) {
    var l;
    const o = t || this.wsOptions.busName, a = i || this.wsOptions.msgTypes;
    o || console.error("订阅消息需要指定 [busName] 参数！");
    const r = vo(
      re.MSG_FAMILY_SUBSCRIBE,
      o,
      a
    );
    if (((l = this.ws) == null ? void 0 : l.readyState) !== WebSocket.OPEN ? (console.log("WebSocket 连接尚未建立，订阅任务加入队列"), this._subscribeTasks.push(() => {
      this.ws.send(JSON.stringify(r));
    })) : this.ws.send(JSON.stringify(r)), this.cache.has(o) && s && s(this.cache.get(o)), !s) {
      console.error(`请使用 subscribe() 方法订阅消息： ${o} `);
      return;
    }
    this.messageHandlers.has(o) || this.messageHandlers.set(o, []), this.messageHandlers.get(o).push(s);
  }
  /**
   * @description 取消订阅后，BusServer 不再将对应消息转发给对应的连接
   * @param busName
   * @param msgTypes
   * @param callback
   */
  unSubscribe(t, i, s) {
    const o = t || this.wsOptions.busName, a = i || this.wsOptions.msgTypes, r = vo(
      re.MSG_FAMILY_UNSUBSCRIBE,
      o,
      a
    );
    this.ws.send(JSON.stringify(r));
    const l = this.messageHandlers.get(o);
    l && this.messageHandlers.set(
      o,
      l.filter((n) => n !== s)
    );
  }
  /**
   * @description 针对客户端订阅的消息，如果某个客户端发送了对应的消息，则会转发给其他所有订阅此消息的客户端
   * @param busName
   * @param data
   */
  sendMessage(t, i, s) {
    var r, l;
    const o = t || this.wsOptions.busName, a = {
      interMsgType: re.MSG_FAMILY_TRANSMIT,
      data: {
        busName: o,
        msgType: i,
        msg: s
      }
    };
    ((r = this.ws) == null ? void 0 : r.readyState) !== WebSocket.OPEN ? (console.warn("WebSocket 连接尚未建立，sendMessage 任务加入队列"), this._subscribeTasks.push(() => {
      this.ws.send(JSON.stringify(a));
    })) : (l = this.ws) == null || l.send(JSON.stringify(a));
  }
  /**
   * @description BusServer会定时1秒对所有连接发送心跳消息，客户端收到后立刻返回心跳反馈消息
   * 当websocket通信处于连接状态时，客户端超过设定时间没有接收到心跳消息，主动断开websocket通信，然后重新连接，设定时间默认为30s。
   * BusServer内部的机制为：如果超过设定时间没有接收到连接反馈，亦会主动断开websocket连接。
   * @returns
   */
  startHeartbeat() {
    this.enableHeartbeat && (this.heartbeatTimer || (this.heartbeatTimer = setInterval(() => {
      this.ws && this.ws.readyState === WebSocket.OPEN && this.ws.send(
        JSON.stringify({
          interMsgType: re.MSG_FAMILY_HEARTBEAT,
          data: {
            version: "1.0",
            ackId: Date.now()
          }
        })
      );
    }, this.heartbeatInterval)));
  }
  // 停止心跳
  stopHeartbeat() {
    this.heartbeatTimer && (clearInterval(this.heartbeatTimer), this.heartbeatTimer = null);
  }
  // 7. 尝试重新连接
  reconnect() {
    if (!this.reconnectTimer) {
      if (this.maxReconnectTimes <= 0) {
        console.log("Max reconnect times reached.");
        return;
      }
      this.reconnectTimer = setTimeout(() => {
        console.log("Reconnecting...", this.maxReconnectTimes), this.maxReconnectTimes--, this.connect(), this.reconnectTimer = null;
      }, this.reconnectInterval);
    }
  }
  // 8. 清除缓存
  clearCache(t) {
    t ? this.cache.delete(t) : this.cache.clear();
  }
  // 9. 关闭 WebSocket 连接并清除单例
  close() {
    var t;
    this.stopHeartbeat(), (t = this.ws) == null || t.close(), this.ws = null, pe.InstanceMap.delete(this.url), this.isConnected = !1, console.log("WebSocketClient instance closed and cleared.");
  }
};
O(pe, "InstanceMap", /* @__PURE__ */ new Map());
let ds = pe;
var $e = /* @__PURE__ */ ((e) => (e[e.Link = 0] = "Link", e[e.SetProps = 1] = "SetProps", e[e.StartAnimate = 2] = "StartAnimate", e[e.PauseAnimate = 3] = "PauseAnimate", e[e.StopAnimate = 4] = "StopAnimate", e[e.JS = 5] = "JS", e[e.GlobalFn = 6] = "GlobalFn", e[e.Emit = 7] = "Emit", e[e.StartVideo = 8] = "StartVideo", e[e.PauseVideo = 9] = "PauseVideo", e[e.StopVideo = 10] = "StopVideo", e[e.SendPropData = 11] = "SendPropData", e[e.SendVarData = 12] = "SendVarData", e))($e || {});
function hf(e, t) {
  if (!e) return !0;
  const { key: i, value: s, comparison: o } = e;
  if (!i || !o) return !0;
  const a = s;
  switch (o) {
    case "==":
      return t[i] == s;
    case "!=":
      return t[i] != s;
    case ">":
      return t[i] > a;
    case "<":
      return t[i] < a;
    case ">=":
      return t[i] >= a;
    case "<=":
      return t[i] <= a;
    default:
      return !0;
  }
}
function Ui(e, t, i) {
  const s = {
    0: "startAnimate",
    1: "pauseAnimate",
    2: "stopAnimate"
  }, o = [];
  t != null && t.length ? t.forEach((r) => {
    o.push(meta2d.findOne(r));
  }) : i != null && i.length && i.forEach((r) => {
    o.push(...meta2d.find(r));
  });
  const a = s[e];
  a && meta2d[a](o);
}
const df = (e) => ({
  resolver: (i) => {
    if (i != null && i.msg) {
      const s = e.wsMsgHandlers || [], o = i.msg;
      s.forEach((a) => {
        const { action: r, params: l, value: n, where: h } = a;
        if (!hf(h, o)) return;
        const { tags: c, ids: d } = l;
        switch (r) {
          case $e.SetProps:
            d != null && d.length ? (d.forEach((u) => {
              meta2d.setValue(
                {
                  id: u,
                  ...n
                },
                {
                  render: !1
                }
              );
            }), meta2d.render()) : c != null && c.length && (c.forEach((u) => {
              meta2d.setValue(
                {
                  tag: u,
                  ...n
                },
                {
                  render: !1
                }
              );
            }), meta2d.render());
            break;
          case $e.StartAnimate:
            Ui("0", d, c);
            break;
          case $e.PauseAnimate:
            Ui("1", d, c);
            break;
          case $e.StopAnimate:
            Ui("2", d, c);
            break;
        }
      });
    }
  }
}), uf = /* @__PURE__ */ mo({
  __name: "View",
  props: {
    preview: {
      type: Boolean,
      default: !1
    },
    data: {
      type: Object
    }
  },
  emits: ["ready"],
  setup(e, { emit: t }) {
    const i = e, { select: s, selections: o } = Ea(), a = {
      rule: !1,
      drawingLineName: "line",
      rotateCursor: "rotate.cur"
    }, r = yo({
      x: 0,
      y: 0,
      visible: !1
    }), l = (u) => {
      i.preview || o.mode !== 0 && (r.x = u.e.clientX, r.y = u.e.clientY, r.visible = !0);
    }, n = () => {
      r.visible = !1;
    }, h = t;
    Fa(() => {
      new Xl("meta2d", a), me(Sd()), Yi(Td()), me(Ed()), _e(_d()), me(zd()), me(Wd()), _e(jd()), Jd(), _e(Ru()), _e(Fu()), me(of()), _e(af()), Yi(rf()), h("ready", meta2d);
      let u = localStorage.getItem("meta2d");
      if (i.data || u) {
        u = i.data || JSON.parse(u);
        const { resolver: f } = df(u);
        if (location.pathname === "/preview" || i.preview) {
          u.locked = 1;
          const g = (u.msgTypes || []).map((v) => Number(v)).filter((v) => !isNaN(v)), y = u.onMessageJsCode;
          if (u.wsUrl) {
            const v = ds.getInstance(u.wsUrl, {
              busName: u.busName,
              msgTypes: g,
              enableLog: !1,
              onReady: () => {
                console.log("%c连接成功！", "color: green; font-weight: bold;"), v.subscribe("", [1], (b) => {
                  console.log(
                    "%c收到消息: ",
                    "color: green; font-weight: bold;",
                    u
                  );
                  try {
                    y ? new Function("data", y)(b) : f(b);
                  } catch (x) {
                    console.log("error: ", x);
                  }
                });
              }
            });
            v.connect();
          }
        } else
          u.locked = 0;
        meta2d.open(u);
      }
      meta2d.on("active", c), meta2d.on("inactive", d), meta2d.on("contextmenu", l), meta2d.on("click", n);
    });
    const c = (u) => {
      s(u);
    }, d = () => {
      s();
    };
    return Wa(() => {
      meta2d.destroy();
    }), (u, f) => (qi(), po(bo, null, [
      ja("div", {
        id: "meta2d",
        class: Va({ "is--preview": e.preview })
      }, null, 2),
      yi(cf, Ua(r, { onHide: n }), null, 16)
    ], 64));
  }
}), Sf = /* @__PURE__ */ ba(uf, [["__scopeId", "data-v-1ceb342c"]]);
export {
  Kl as C,
  $e as E,
  ft as P,
  nf as S,
  Sf as V,
  ds as W,
  ba as _,
  yf as a,
  od as b,
  Vt as c,
  G as d,
  df as e,
  Ea as f,
  mf as g,
  If as h,
  Gl as i,
  pf as j,
  de as k,
  xf as l,
  _h as m,
  Eh as p,
  kf as r,
  nt as s,
  Af as t,
  ld as u
};
//# sourceMappingURL=View-x8nqHB5y.mjs.map
